var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_stdin = __commonJS({
  "<stdin>"(exports, module) {
    (async () => {
      (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const n of document.querySelectorAll('link[rel="modulepreload"]')) i(n);
        new MutationObserver((n) => {
          for (const r of n) if (r.type === "childList") for (const a of r.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function t(n) {
          const r = {};
          return n.integrity && (r.integrity = n.integrity), n.referrerPolicy && (r.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? r.credentials = "include" : n.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
        }
        function i(n) {
          if (n.ep) return;
          n.ep = true;
          const r = t(n);
          fetch(n.href, r);
        }
      })();
      var tS = {
        exports: {}
      }, ud = {};
      var RA = Symbol.for("react.transitional.element"), CA = Symbol.for("react.fragment");
      function iS(s, e, t) {
        var i = null;
        if (t !== void 0 && (i = "" + t), e.key !== void 0 && (i = "" + e.key), "key" in e) {
          t = {};
          for (var n in e) n !== "key" && (t[n] = e[n]);
        } else t = e;
        return e = t.ref, {
          $$typeof: RA,
          type: s,
          key: i,
          ref: e !== void 0 ? e : null,
          props: t
        };
      }
      ud.Fragment = CA;
      ud.jsx = iS;
      ud.jsxs = iS;
      tS.exports = ud;
      var V = tS.exports, sS = {
        exports: {}
      }, se = {};
      var Ng = Symbol.for("react.transitional.element"), BA = Symbol.for("react.portal"), DA = Symbol.for("react.fragment"), UA = Symbol.for("react.strict_mode"), FA = Symbol.for("react.profiler"), OA = Symbol.for("react.consumer"), zA = Symbol.for("react.context"), LA = Symbol.for("react.forward_ref"), GA = Symbol.for("react.suspense"), PA = Symbol.for("react.memo"), nS = Symbol.for("react.lazy"), b0 = Symbol.iterator;
      function kA(s) {
        return s === null || typeof s != "object" ? null : (s = b0 && s[b0] || s["@@iterator"], typeof s == "function" ? s : null);
      }
      var rS = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      }, aS = Object.assign, oS = {};
      function No(s, e, t) {
        this.props = s, this.context = e, this.refs = oS, this.updater = t || rS;
      }
      No.prototype.isReactComponent = {};
      No.prototype.setState = function(s, e) {
        if (typeof s != "object" && typeof s != "function" && s != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, s, e, "setState");
      };
      No.prototype.forceUpdate = function(s) {
        this.updater.enqueueForceUpdate(this, s, "forceUpdate");
      };
      function lS() {
      }
      lS.prototype = No.prototype;
      function wg(s, e, t) {
        this.props = s, this.context = e, this.refs = oS, this.updater = t || rS;
      }
      var Eg = wg.prototype = new lS();
      Eg.constructor = wg;
      aS(Eg, No.prototype);
      Eg.isPureReactComponent = true;
      var S0 = Array.isArray, Pe = {
        H: null,
        A: null,
        T: null,
        S: null
      }, uS = Object.prototype.hasOwnProperty;
      function Rg(s, e, t, i, n, r) {
        return t = r.ref, {
          $$typeof: Ng,
          type: s,
          key: e,
          ref: t !== void 0 ? t : null,
          props: r
        };
      }
      function IA(s, e) {
        return Rg(s.type, e, void 0, void 0, void 0, s.props);
      }
      function Cg(s) {
        return typeof s == "object" && s !== null && s.$$typeof === Ng;
      }
      function VA(s) {
        var e = {
          "=": "=0",
          ":": "=2"
        };
        return "$" + s.replace(/[=:]/g, function(t) {
          return e[t];
        });
      }
      var T0 = /\/+/g;
      function Qd(s, e) {
        return typeof s == "object" && s !== null && s.key != null ? VA("" + s.key) : e.toString(36);
      }
      function v0() {
      }
      function HA(s) {
        switch (s.status) {
          case "fulfilled":
            return s.value;
          case "rejected":
            throw s.reason;
          default:
            switch (typeof s.status == "string" ? s.then(v0, v0) : (s.status = "pending", s.then(function(e) {
              s.status === "pending" && (s.status = "fulfilled", s.value = e);
            }, function(e) {
              s.status === "pending" && (s.status = "rejected", s.reason = e);
            })), s.status) {
              case "fulfilled":
                return s.value;
              case "rejected":
                throw s.reason;
            }
        }
        throw s;
      }
      function ba(s, e, t, i, n) {
        var r = typeof s;
        (r === "undefined" || r === "boolean") && (s = null);
        var a = false;
        if (s === null) a = true;
        else switch (r) {
          case "bigint":
          case "string":
          case "number":
            a = true;
            break;
          case "object":
            switch (s.$$typeof) {
              case Ng:
              case BA:
                a = true;
                break;
              case nS:
                return a = s._init, ba(a(s._payload), e, t, i, n);
            }
        }
        if (a) return n = n(s), a = i === "" ? "." + Qd(s, 0) : i, S0(n) ? (t = "", a != null && (t = a.replace(T0, "$&/") + "/"), ba(n, e, t, "", function(u) {
          return u;
        })) : n != null && (Cg(n) && (n = IA(n, t + (n.key == null || s && s.key === n.key ? "" : ("" + n.key).replace(T0, "$&/") + "/") + a)), e.push(n)), 1;
        a = 0;
        var l = i === "" ? "." : i + ":";
        if (S0(s)) for (var o = 0; o < s.length; o++) i = s[o], r = l + Qd(i, o), a += ba(i, e, t, r, n);
        else if (o = kA(s), typeof o == "function") for (s = o.call(s), o = 0; !(i = s.next()).done; ) i = i.value, r = l + Qd(i, o++), a += ba(i, e, t, r, n);
        else if (r === "object") {
          if (typeof s.then == "function") return ba(HA(s), e, t, i, n);
          throw e = String(s), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
        }
        return a;
      }
      function ku(s, e, t) {
        if (s == null) return s;
        var i = [], n = 0;
        return ba(s, i, "", "", function(r) {
          return e.call(t, r, n++);
        }), i;
      }
      function qA(s) {
        if (s._status === -1) {
          var e = s._result;
          e = e(), e.then(function(t) {
            (s._status === 0 || s._status === -1) && (s._status = 1, s._result = t);
          }, function(t) {
            (s._status === 0 || s._status === -1) && (s._status = 2, s._result = t);
          }), s._status === -1 && (s._status = 0, s._result = e);
        }
        if (s._status === 1) return s._result.default;
        throw s._result;
      }
      var M0 = typeof reportError == "function" ? reportError : function(s) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var e = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: typeof s == "object" && s !== null && typeof s.message == "string" ? String(s.message) : String(s),
            error: s
          });
          if (!window.dispatchEvent(e)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", s);
          return;
        }
        console.error(s);
      };
      function YA() {
      }
      se.Children = {
        map: ku,
        forEach: function(s, e, t) {
          ku(s, function() {
            e.apply(this, arguments);
          }, t);
        },
        count: function(s) {
          var e = 0;
          return ku(s, function() {
            e++;
          }), e;
        },
        toArray: function(s) {
          return ku(s, function(e) {
            return e;
          }) || [];
        },
        only: function(s) {
          if (!Cg(s)) throw Error("React.Children.only expected to receive a single React element child.");
          return s;
        }
      };
      se.Component = No;
      se.Fragment = DA;
      se.Profiler = FA;
      se.PureComponent = wg;
      se.StrictMode = UA;
      se.Suspense = GA;
      se.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Pe;
      se.act = function() {
        throw Error("act(...) is not supported in production builds of React.");
      };
      se.cache = function(s) {
        return function() {
          return s.apply(null, arguments);
        };
      };
      se.cloneElement = function(s, e, t) {
        if (s == null) throw Error("The argument must be a React element, but you passed " + s + ".");
        var i = aS({}, s.props), n = s.key, r = void 0;
        if (e != null) for (a in e.ref !== void 0 && (r = void 0), e.key !== void 0 && (n = "" + e.key), e) !uS.call(e, a) || a === "key" || a === "__self" || a === "__source" || a === "ref" && e.ref === void 0 || (i[a] = e[a]);
        var a = arguments.length - 2;
        if (a === 1) i.children = t;
        else if (1 < a) {
          for (var l = Array(a), o = 0; o < a; o++) l[o] = arguments[o + 2];
          i.children = l;
        }
        return Rg(s.type, n, void 0, void 0, r, i);
      };
      se.createContext = function(s) {
        return s = {
          $$typeof: zA,
          _currentValue: s,
          _currentValue2: s,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }, s.Provider = s, s.Consumer = {
          $$typeof: OA,
          _context: s
        }, s;
      };
      se.createElement = function(s, e, t) {
        var i, n = {}, r = null;
        if (e != null) for (i in e.key !== void 0 && (r = "" + e.key), e) uS.call(e, i) && i !== "key" && i !== "__self" && i !== "__source" && (n[i] = e[i]);
        var a = arguments.length - 2;
        if (a === 1) n.children = t;
        else if (1 < a) {
          for (var l = Array(a), o = 0; o < a; o++) l[o] = arguments[o + 2];
          n.children = l;
        }
        if (s && s.defaultProps) for (i in a = s.defaultProps, a) n[i] === void 0 && (n[i] = a[i]);
        return Rg(s, r, void 0, void 0, null, n);
      };
      se.createRef = function() {
        return {
          current: null
        };
      };
      se.forwardRef = function(s) {
        return {
          $$typeof: LA,
          render: s
        };
      };
      se.isValidElement = Cg;
      se.lazy = function(s) {
        return {
          $$typeof: nS,
          _payload: {
            _status: -1,
            _result: s
          },
          _init: qA
        };
      };
      se.memo = function(s, e) {
        return {
          $$typeof: PA,
          type: s,
          compare: e === void 0 ? null : e
        };
      };
      se.startTransition = function(s) {
        var e = Pe.T, t = {};
        Pe.T = t;
        try {
          var i = s(), n = Pe.S;
          n !== null && n(t, i), typeof i == "object" && i !== null && typeof i.then == "function" && i.then(YA, M0);
        } catch (r) {
          M0(r);
        } finally {
          Pe.T = e;
        }
      };
      se.unstable_useCacheRefresh = function() {
        return Pe.H.useCacheRefresh();
      };
      se.use = function(s) {
        return Pe.H.use(s);
      };
      se.useActionState = function(s, e, t) {
        return Pe.H.useActionState(s, e, t);
      };
      se.useCallback = function(s, e) {
        return Pe.H.useCallback(s, e);
      };
      se.useContext = function(s) {
        return Pe.H.useContext(s);
      };
      se.useDebugValue = function() {
      };
      se.useDeferredValue = function(s, e) {
        return Pe.H.useDeferredValue(s, e);
      };
      se.useEffect = function(s, e) {
        return Pe.H.useEffect(s, e);
      };
      se.useId = function() {
        return Pe.H.useId();
      };
      se.useImperativeHandle = function(s, e, t) {
        return Pe.H.useImperativeHandle(s, e, t);
      };
      se.useInsertionEffect = function(s, e) {
        return Pe.H.useInsertionEffect(s, e);
      };
      se.useLayoutEffect = function(s, e) {
        return Pe.H.useLayoutEffect(s, e);
      };
      se.useMemo = function(s, e) {
        return Pe.H.useMemo(s, e);
      };
      se.useOptimistic = function(s, e) {
        return Pe.H.useOptimistic(s, e);
      };
      se.useReducer = function(s, e, t) {
        return Pe.H.useReducer(s, e, t);
      };
      se.useRef = function(s) {
        return Pe.H.useRef(s);
      };
      se.useState = function(s) {
        return Pe.H.useState(s);
      };
      se.useSyncExternalStore = function(s, e, t) {
        return Pe.H.useSyncExternalStore(s, e, t);
      };
      se.useTransition = function() {
        return Pe.H.useTransition();
      };
      se.version = "19.0.0";
      sS.exports = se;
      var Ne = sS.exports, cS = {
        exports: {}
      }, cd = {}, hS = {
        exports: {}
      }, dS = {};
      (function(s) {
        function e(P, W) {
          var Y = P.length;
          P.push(W);
          e: for (; 0 < Y; ) {
            var ne = Y - 1 >>> 1, le = P[ne];
            if (0 < n(le, W)) P[ne] = W, P[Y] = le, Y = ne;
            else break e;
          }
        }
        function t(P) {
          return P.length === 0 ? null : P[0];
        }
        function i(P) {
          if (P.length === 0) return null;
          var W = P[0], Y = P.pop();
          if (Y !== W) {
            P[0] = Y;
            e: for (var ne = 0, le = P.length, ht = le >>> 1; ne < ht; ) {
              var Oi = 2 * (ne + 1) - 1, rn = P[Oi], fs = Oi + 1, tr = P[fs];
              if (0 > n(rn, Y)) fs < le && 0 > n(tr, rn) ? (P[ne] = tr, P[fs] = Y, ne = fs) : (P[ne] = rn, P[Oi] = Y, ne = Oi);
              else if (fs < le && 0 > n(tr, Y)) P[ne] = tr, P[fs] = Y, ne = fs;
              else break e;
            }
          }
          return W;
        }
        function n(P, W) {
          var Y = P.sortIndex - W.sortIndex;
          return Y !== 0 ? Y : P.id - W.id;
        }
        if (s.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
          var r = performance;
          s.unstable_now = function() {
            return r.now();
          };
        } else {
          var a = Date, l = a.now();
          s.unstable_now = function() {
            return a.now() - l;
          };
        }
        var o = [], u = [], c = 1, h = null, d = 3, f = false, p = false, g = false, _ = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, y = typeof setImmediate < "u" ? setImmediate : null;
        function x(P) {
          for (var W = t(u); W !== null; ) {
            if (W.callback === null) i(u);
            else if (W.startTime <= P) i(u), W.sortIndex = W.expirationTime, e(o, W);
            else break;
            W = t(u);
          }
        }
        function b(P) {
          if (g = false, x(P), !p) if (t(o) !== null) p = true, Fe();
          else {
            var W = t(u);
            W !== null && qe(b, W.startTime - P);
          }
        }
        var T = false, N = -1, A = 5, w = -1;
        function k() {
          return !(s.unstable_now() - w < A);
        }
        function G() {
          if (T) {
            var P = s.unstable_now();
            w = P;
            var W = true;
            try {
              e: {
                p = false, g && (g = false, m(N), N = -1), f = true;
                var Y = d;
                try {
                  t: {
                    for (x(P), h = t(o); h !== null && !(h.expirationTime > P && k()); ) {
                      var ne = h.callback;
                      if (typeof ne == "function") {
                        h.callback = null, d = h.priorityLevel;
                        var le = ne(h.expirationTime <= P);
                        if (P = s.unstable_now(), typeof le == "function") {
                          h.callback = le, x(P), W = true;
                          break t;
                        }
                        h === t(o) && i(o), x(P);
                      } else i(o);
                      h = t(o);
                    }
                    if (h !== null) W = true;
                    else {
                      var ht = t(u);
                      ht !== null && qe(b, ht.startTime - P), W = false;
                    }
                  }
                  break e;
                } finally {
                  h = null, d = Y, f = false;
                }
                W = void 0;
              }
            } finally {
              W ? I() : T = false;
            }
          }
        }
        var I;
        if (typeof y == "function") I = function() {
          y(G);
        };
        else if (typeof MessageChannel < "u") {
          var be = new MessageChannel(), ce = be.port2;
          be.port1.onmessage = G, I = function() {
            ce.postMessage(null);
          };
        } else I = function() {
          _(G, 0);
        };
        function Fe() {
          T || (T = true, I());
        }
        function qe(P, W) {
          N = _(function() {
            P(s.unstable_now());
          }, W);
        }
        s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(P) {
          P.callback = null;
        }, s.unstable_continueExecution = function() {
          p || f || (p = true, Fe());
        }, s.unstable_forceFrameRate = function(P) {
          0 > P || 125 < P ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : A = 0 < P ? Math.floor(1e3 / P) : 5;
        }, s.unstable_getCurrentPriorityLevel = function() {
          return d;
        }, s.unstable_getFirstCallbackNode = function() {
          return t(o);
        }, s.unstable_next = function(P) {
          switch (d) {
            case 1:
            case 2:
            case 3:
              var W = 3;
              break;
            default:
              W = d;
          }
          var Y = d;
          d = W;
          try {
            return P();
          } finally {
            d = Y;
          }
        }, s.unstable_pauseExecution = function() {
        }, s.unstable_requestPaint = function() {
        }, s.unstable_runWithPriority = function(P, W) {
          switch (P) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              P = 3;
          }
          var Y = d;
          d = P;
          try {
            return W();
          } finally {
            d = Y;
          }
        }, s.unstable_scheduleCallback = function(P, W, Y) {
          var ne = s.unstable_now();
          switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? ne + Y : ne) : Y = ne, P) {
            case 1:
              var le = -1;
              break;
            case 2:
              le = 250;
              break;
            case 5:
              le = 1073741823;
              break;
            case 4:
              le = 1e4;
              break;
            default:
              le = 5e3;
          }
          return le = Y + le, P = {
            id: c++,
            callback: W,
            priorityLevel: P,
            startTime: Y,
            expirationTime: le,
            sortIndex: -1
          }, Y > ne ? (P.sortIndex = Y, e(u, P), t(o) === null && P === t(u) && (g ? (m(N), N = -1) : g = true, qe(b, Y - ne))) : (P.sortIndex = le, e(o, P), p || f || (p = true, Fe())), P;
        }, s.unstable_shouldYield = k, s.unstable_wrapCallback = function(P) {
          var W = d;
          return function() {
            var Y = d;
            d = W;
            try {
              return P.apply(this, arguments);
            } finally {
              d = Y;
            }
          };
        };
      })(dS);
      hS.exports = dS;
      var WA = hS.exports, fS = {
        exports: {}
      }, kt = {};
      var jA = Ne;
      function pS(s) {
        var e = "https://react.dev/errors/" + s;
        if (1 < arguments.length) {
          e += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var t = 2; t < arguments.length; t++) e += "&args[]=" + encodeURIComponent(arguments[t]);
        }
        return "Minified React error #" + s + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function an() {
      }
      var Ot = {
        d: {
          f: an,
          r: function() {
            throw Error(pS(522));
          },
          D: an,
          C: an,
          L: an,
          m: an,
          X: an,
          S: an,
          M: an
        },
        p: 0,
        findDOMNode: null
      }, $A = Symbol.for("react.portal");
      function XA(s, e, t) {
        var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
          $$typeof: $A,
          key: i == null ? null : "" + i,
          children: s,
          containerInfo: e,
          implementation: t
        };
      }
      var yl = jA.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function hd(s, e) {
        if (s === "font") return "";
        if (typeof e == "string") return e === "use-credentials" ? e : "";
      }
      kt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Ot;
      kt.createPortal = function(s, e) {
        var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) throw Error(pS(299));
        return XA(s, e, null, t);
      };
      kt.flushSync = function(s) {
        var e = yl.T, t = Ot.p;
        try {
          if (yl.T = null, Ot.p = 2, s) return s();
        } finally {
          yl.T = e, Ot.p = t, Ot.d.f();
        }
      };
      kt.preconnect = function(s, e) {
        typeof s == "string" && (e ? (e = e.crossOrigin, e = typeof e == "string" ? e === "use-credentials" ? e : "" : void 0) : e = null, Ot.d.C(s, e));
      };
      kt.prefetchDNS = function(s) {
        typeof s == "string" && Ot.d.D(s);
      };
      kt.preinit = function(s, e) {
        if (typeof s == "string" && e && typeof e.as == "string") {
          var t = e.as, i = hd(t, e.crossOrigin), n = typeof e.integrity == "string" ? e.integrity : void 0, r = typeof e.fetchPriority == "string" ? e.fetchPriority : void 0;
          t === "style" ? Ot.d.S(s, typeof e.precedence == "string" ? e.precedence : void 0, {
            crossOrigin: i,
            integrity: n,
            fetchPriority: r
          }) : t === "script" && Ot.d.X(s, {
            crossOrigin: i,
            integrity: n,
            fetchPriority: r,
            nonce: typeof e.nonce == "string" ? e.nonce : void 0
          });
        }
      };
      kt.preinitModule = function(s, e) {
        if (typeof s == "string") if (typeof e == "object" && e !== null) {
          if (e.as == null || e.as === "script") {
            var t = hd(e.as, e.crossOrigin);
            Ot.d.M(s, {
              crossOrigin: t,
              integrity: typeof e.integrity == "string" ? e.integrity : void 0,
              nonce: typeof e.nonce == "string" ? e.nonce : void 0
            });
          }
        } else e == null && Ot.d.M(s);
      };
      kt.preload = function(s, e) {
        if (typeof s == "string" && typeof e == "object" && e !== null && typeof e.as == "string") {
          var t = e.as, i = hd(t, e.crossOrigin);
          Ot.d.L(s, t, {
            crossOrigin: i,
            integrity: typeof e.integrity == "string" ? e.integrity : void 0,
            nonce: typeof e.nonce == "string" ? e.nonce : void 0,
            type: typeof e.type == "string" ? e.type : void 0,
            fetchPriority: typeof e.fetchPriority == "string" ? e.fetchPriority : void 0,
            referrerPolicy: typeof e.referrerPolicy == "string" ? e.referrerPolicy : void 0,
            imageSrcSet: typeof e.imageSrcSet == "string" ? e.imageSrcSet : void 0,
            imageSizes: typeof e.imageSizes == "string" ? e.imageSizes : void 0,
            media: typeof e.media == "string" ? e.media : void 0
          });
        }
      };
      kt.preloadModule = function(s, e) {
        if (typeof s == "string") if (e) {
          var t = hd(e.as, e.crossOrigin);
          Ot.d.m(s, {
            as: typeof e.as == "string" && e.as !== "script" ? e.as : void 0,
            crossOrigin: t,
            integrity: typeof e.integrity == "string" ? e.integrity : void 0
          });
        } else Ot.d.m(s);
      };
      kt.requestFormReset = function(s) {
        Ot.d.r(s);
      };
      kt.unstable_batchedUpdates = function(s, e) {
        return s(e);
      };
      kt.useFormState = function(s, e, t) {
        return yl.H.useFormState(s, e, t);
      };
      kt.useFormStatus = function() {
        return yl.H.useHostTransitionStatus();
      };
      kt.version = "19.0.0";
      function mS() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(mS);
        } catch (s) {
          console.error(s);
        }
      }
      mS(), fS.exports = kt;
      var ZA = fS.exports;
      var ut = WA, gS = Ne, QA = ZA;
      function D(s) {
        var e = "https://react.dev/errors/" + s;
        if (1 < arguments.length) {
          e += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var t = 2; t < arguments.length; t++) e += "&args[]=" + encodeURIComponent(arguments[t]);
        }
        return "Minified React error #" + s + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function yS(s) {
        return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11);
      }
      var KA = Symbol.for("react.element"), Iu = Symbol.for("react.transitional.element"), ul = Symbol.for("react.portal"), Aa = Symbol.for("react.fragment"), xS = Symbol.for("react.strict_mode"), Vp = Symbol.for("react.profiler"), JA = Symbol.for("react.provider"), _S = Symbol.for("react.consumer"), Ds = Symbol.for("react.context"), Bg = Symbol.for("react.forward_ref"), Hp = Symbol.for("react.suspense"), qp = Symbol.for("react.suspense_list"), Dg = Symbol.for("react.memo"), yn = Symbol.for("react.lazy"), bS = Symbol.for("react.offscreen"), eN = Symbol.for("react.memo_cache_sentinel"), A0 = Symbol.iterator;
      function Po(s) {
        return s === null || typeof s != "object" ? null : (s = A0 && s[A0] || s["@@iterator"], typeof s == "function" ? s : null);
      }
      var tN = Symbol.for("react.client.reference");
      function Yp(s) {
        if (s == null) return null;
        if (typeof s == "function") return s.$$typeof === tN ? null : s.displayName || s.name || null;
        if (typeof s == "string") return s;
        switch (s) {
          case Aa:
            return "Fragment";
          case ul:
            return "Portal";
          case Vp:
            return "Profiler";
          case xS:
            return "StrictMode";
          case Hp:
            return "Suspense";
          case qp:
            return "SuspenseList";
        }
        if (typeof s == "object") switch (s.$$typeof) {
          case Ds:
            return (s.displayName || "Context") + ".Provider";
          case _S:
            return (s._context.displayName || "Context") + ".Consumer";
          case Bg:
            var e = s.render;
            return s = s.displayName, s || (s = e.displayName || e.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
          case Dg:
            return e = s.displayName || null, e !== null ? e : Yp(s.type) || "Memo";
          case yn:
            e = s._payload, s = s._init;
            try {
              return Yp(s(e));
            } catch {
            }
        }
        return null;
      }
      var J = gS.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Ue = Object.assign, Kd, N0;
      function cl(s) {
        if (Kd === void 0) try {
          throw Error();
        } catch (t) {
          var e = t.stack.trim().match(/\n( *(at )?)/);
          Kd = e && e[1] || "", N0 = -1 < t.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < t.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return `
` + Kd + s + N0;
      }
      var Jd = false;
      function ef(s, e) {
        if (!s || Jd) return "";
        Jd = true;
        var t = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var i = {
            DetermineComponentFrameRoot: function() {
              try {
                if (e) {
                  var h = function() {
                    throw Error();
                  };
                  if (Object.defineProperty(h.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                      Reflect.construct(h, []);
                    } catch (f) {
                      var d = f;
                    }
                    Reflect.construct(s, [], h);
                  } else {
                    try {
                      h.call();
                    } catch (f) {
                      d = f;
                    }
                    s.call(h.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (f) {
                    d = f;
                  }
                  (h = s()) && typeof h.catch == "function" && h.catch(function() {
                  });
                }
              } catch (f) {
                if (f && d && typeof f.stack == "string") return [
                  f.stack,
                  d.stack
                ];
              }
              return [
                null,
                null
              ];
            }
          };
          i.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var n = Object.getOwnPropertyDescriptor(i.DetermineComponentFrameRoot, "name");
          n && n.configurable && Object.defineProperty(i.DetermineComponentFrameRoot, "name", {
            value: "DetermineComponentFrameRoot"
          });
          var r = i.DetermineComponentFrameRoot(), a = r[0], l = r[1];
          if (a && l) {
            var o = a.split(`
`), u = l.split(`
`);
            for (n = i = 0; i < o.length && !o[i].includes("DetermineComponentFrameRoot"); ) i++;
            for (; n < u.length && !u[n].includes("DetermineComponentFrameRoot"); ) n++;
            if (i === o.length || n === u.length) for (i = o.length - 1, n = u.length - 1; 1 <= i && 0 <= n && o[i] !== u[n]; ) n--;
            for (; 1 <= i && 0 <= n; i--, n--) if (o[i] !== u[n]) {
              if (i !== 1 || n !== 1) do
                if (i--, n--, 0 > n || o[i] !== u[n]) {
                  var c = `
` + o[i].replace(" at new ", " at ");
                  return s.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", s.displayName)), c;
                }
              while (1 <= i && 0 <= n);
              break;
            }
          }
        } finally {
          Jd = false, Error.prepareStackTrace = t;
        }
        return (t = s ? s.displayName || s.name : "") ? cl(t) : "";
      }
      function iN(s) {
        switch (s.tag) {
          case 26:
          case 27:
          case 5:
            return cl(s.type);
          case 16:
            return cl("Lazy");
          case 13:
            return cl("Suspense");
          case 19:
            return cl("SuspenseList");
          case 0:
          case 15:
            return s = ef(s.type, false), s;
          case 11:
            return s = ef(s.type.render, false), s;
          case 1:
            return s = ef(s.type, true), s;
          default:
            return "";
        }
      }
      function w0(s) {
        try {
          var e = "";
          do
            e += iN(s), s = s.return;
          while (s);
          return e;
        } catch (t) {
          return `
Error generating stack: ` + t.message + `
` + t.stack;
        }
      }
      function wo(s) {
        var e = s, t = s;
        if (s.alternate) for (; e.return; ) e = e.return;
        else {
          s = e;
          do
            e = s, e.flags & 4098 && (t = e.return), s = e.return;
          while (s);
        }
        return e.tag === 3 ? t : null;
      }
      function SS(s) {
        if (s.tag === 13) {
          var e = s.memoizedState;
          if (e === null && (s = s.alternate, s !== null && (e = s.memoizedState)), e !== null) return e.dehydrated;
        }
        return null;
      }
      function E0(s) {
        if (wo(s) !== s) throw Error(D(188));
      }
      function sN(s) {
        var e = s.alternate;
        if (!e) {
          if (e = wo(s), e === null) throw Error(D(188));
          return e !== s ? null : s;
        }
        for (var t = s, i = e; ; ) {
          var n = t.return;
          if (n === null) break;
          var r = n.alternate;
          if (r === null) {
            if (i = n.return, i !== null) {
              t = i;
              continue;
            }
            break;
          }
          if (n.child === r.child) {
            for (r = n.child; r; ) {
              if (r === t) return E0(n), s;
              if (r === i) return E0(n), e;
              r = r.sibling;
            }
            throw Error(D(188));
          }
          if (t.return !== i.return) t = n, i = r;
          else {
            for (var a = false, l = n.child; l; ) {
              if (l === t) {
                a = true, t = n, i = r;
                break;
              }
              if (l === i) {
                a = true, i = n, t = r;
                break;
              }
              l = l.sibling;
            }
            if (!a) {
              for (l = r.child; l; ) {
                if (l === t) {
                  a = true, t = r, i = n;
                  break;
                }
                if (l === i) {
                  a = true, i = r, t = n;
                  break;
                }
                l = l.sibling;
              }
              if (!a) throw Error(D(189));
            }
          }
          if (t.alternate !== i) throw Error(D(190));
        }
        if (t.tag !== 3) throw Error(D(188));
        return t.stateNode.current === t ? s : e;
      }
      function TS(s) {
        var e = s.tag;
        if (e === 5 || e === 26 || e === 27 || e === 6) return s;
        for (s = s.child; s !== null; ) {
          if (e = TS(s), e !== null) return e;
          s = s.sibling;
        }
        return null;
      }
      var hl = Array.isArray, De = QA.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, br = {
        pending: false,
        data: null,
        method: null,
        action: null
      }, Wp = [], Na = -1;
      function cs(s) {
        return {
          current: s
        };
      }
      function xt(s) {
        0 > Na || (s.current = Wp[Na], Wp[Na] = null, Na--);
      }
      function Oe(s, e) {
        Na++, Wp[Na] = s.current, s.current = e;
      }
      var is = cs(null), Il = cs(null), Dn = cs(null), hh = cs(null);
      function dh(s, e) {
        switch (Oe(Dn, e), Oe(Il, s), Oe(is, null), s = e.nodeType, s) {
          case 9:
          case 11:
            e = (e = e.documentElement) && (e = e.namespaceURI) ? Rx(e) : 0;
            break;
          default:
            if (s = s === 8 ? e.parentNode : e, e = s.tagName, s = s.namespaceURI) s = Rx(s), e = F1(s, e);
            else switch (e) {
              case "svg":
                e = 1;
                break;
              case "math":
                e = 2;
                break;
              default:
                e = 0;
            }
        }
        xt(is), Oe(is, e);
      }
      function ro() {
        xt(is), xt(Il), xt(Dn);
      }
      function jp(s) {
        s.memoizedState !== null && Oe(hh, s);
        var e = is.current, t = F1(e, s.type);
        e !== t && (Oe(Il, s), Oe(is, t));
      }
      function fh(s) {
        Il.current === s && (xt(is), xt(Il)), hh.current === s && (xt(hh), Kl._currentValue = br);
      }
      var $p = Object.prototype.hasOwnProperty, Ug = ut.unstable_scheduleCallback, tf = ut.unstable_cancelCallback, nN = ut.unstable_shouldYield, rN = ut.unstable_requestPaint, ss = ut.unstable_now, aN = ut.unstable_getCurrentPriorityLevel, vS = ut.unstable_ImmediatePriority, MS = ut.unstable_UserBlockingPriority, ph = ut.unstable_NormalPriority, oN = ut.unstable_LowPriority, AS = ut.unstable_IdlePriority, lN = ut.log, uN = ut.unstable_setDisableYieldValue, _u = null, ui = null;
      function cN(s) {
        if (ui && typeof ui.onCommitFiberRoot == "function") try {
          ui.onCommitFiberRoot(_u, s, void 0, (s.current.flags & 128) === 128);
        } catch {
        }
      }
      function En(s) {
        if (typeof lN == "function" && uN(s), ui && typeof ui.setStrictMode == "function") try {
          ui.setStrictMode(_u, s);
        } catch {
        }
      }
      var ci = Math.clz32 ? Math.clz32 : fN, hN = Math.log, dN = Math.LN2;
      function fN(s) {
        return s >>>= 0, s === 0 ? 32 : 31 - (hN(s) / dN | 0) | 0;
      }
      var Vu = 128, Hu = 4194304;
      function lr(s) {
        var e = s & 42;
        if (e !== 0) return e;
        switch (s & -s) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return s & 4194176;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return s & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return s;
        }
      }
      function dd(s, e) {
        var t = s.pendingLanes;
        if (t === 0) return 0;
        var i = 0, n = s.suspendedLanes, r = s.pingedLanes, a = s.warmLanes;
        s = s.finishedLanes !== 0;
        var l = t & 134217727;
        return l !== 0 ? (t = l & ~n, t !== 0 ? i = lr(t) : (r &= l, r !== 0 ? i = lr(r) : s || (a = l & ~a, a !== 0 && (i = lr(a))))) : (l = t & ~n, l !== 0 ? i = lr(l) : r !== 0 ? i = lr(r) : s || (a = t & ~a, a !== 0 && (i = lr(a)))), i === 0 ? 0 : e !== 0 && e !== i && !(e & n) && (n = i & -i, a = e & -e, n >= a || n === 32 && (a & 4194176) !== 0) ? e : i;
      }
      function bu(s, e) {
        return (s.pendingLanes & ~(s.suspendedLanes & ~s.pingedLanes) & e) === 0;
      }
      function pN(s, e) {
        switch (s) {
          case 1:
          case 2:
          case 4:
          case 8:
            return e + 250;
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return e + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function NS() {
        var s = Vu;
        return Vu <<= 1, !(Vu & 4194176) && (Vu = 128), s;
      }
      function wS() {
        var s = Hu;
        return Hu <<= 1, !(Hu & 62914560) && (Hu = 4194304), s;
      }
      function sf(s) {
        for (var e = [], t = 0; 31 > t; t++) e.push(s);
        return e;
      }
      function Su(s, e) {
        s.pendingLanes |= e, e !== 268435456 && (s.suspendedLanes = 0, s.pingedLanes = 0, s.warmLanes = 0);
      }
      function mN(s, e, t, i, n, r) {
        var a = s.pendingLanes;
        s.pendingLanes = t, s.suspendedLanes = 0, s.pingedLanes = 0, s.warmLanes = 0, s.expiredLanes &= t, s.entangledLanes &= t, s.errorRecoveryDisabledLanes &= t, s.shellSuspendCounter = 0;
        var l = s.entanglements, o = s.expirationTimes, u = s.hiddenUpdates;
        for (t = a & ~t; 0 < t; ) {
          var c = 31 - ci(t), h = 1 << c;
          l[c] = 0, o[c] = -1;
          var d = u[c];
          if (d !== null) for (u[c] = null, c = 0; c < d.length; c++) {
            var f = d[c];
            f !== null && (f.lane &= -536870913);
          }
          t &= ~h;
        }
        i !== 0 && ES(s, i, 0), r !== 0 && n === 0 && s.tag !== 0 && (s.suspendedLanes |= r & ~(a & ~e));
      }
      function ES(s, e, t) {
        s.pendingLanes |= e, s.suspendedLanes &= ~e;
        var i = 31 - ci(e);
        s.entangledLanes |= e, s.entanglements[i] = s.entanglements[i] | 1073741824 | t & 4194218;
      }
      function RS(s, e) {
        var t = s.entangledLanes |= e;
        for (s = s.entanglements; t; ) {
          var i = 31 - ci(t), n = 1 << i;
          n & e | s[i] & e && (s[i] |= e), t &= ~n;
        }
      }
      function CS(s) {
        return s &= -s, 2 < s ? 8 < s ? s & 134217727 ? 32 : 268435456 : 8 : 2;
      }
      function BS() {
        var s = De.p;
        return s !== 0 ? s : (s = window.event, s === void 0 ? 32 : q1(s.type));
      }
      function gN(s, e) {
        var t = De.p;
        try {
          return De.p = s, e();
        } finally {
          De.p = t;
        }
      }
      var Qn = Math.random().toString(36).slice(2), Rt = "__reactFiber$" + Qn, Xt = "__reactProps$" + Qn, Eo = "__reactContainer$" + Qn, Xp = "__reactEvents$" + Qn, yN = "__reactListeners$" + Qn, xN = "__reactHandles$" + Qn, R0 = "__reactResources$" + Qn, Vl = "__reactMarker$" + Qn;
      function Fg(s) {
        delete s[Rt], delete s[Xt], delete s[Xp], delete s[yN], delete s[xN];
      }
      function xr(s) {
        var e = s[Rt];
        if (e) return e;
        for (var t = s.parentNode; t; ) {
          if (e = t[Eo] || t[Rt]) {
            if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (s = Bx(s); s !== null; ) {
              if (t = s[Rt]) return t;
              s = Bx(s);
            }
            return e;
          }
          s = t, t = s.parentNode;
        }
        return null;
      }
      function Ro(s) {
        if (s = s[Rt] || s[Eo]) {
          var e = s.tag;
          if (e === 5 || e === 6 || e === 13 || e === 26 || e === 27 || e === 3) return s;
        }
        return null;
      }
      function dl(s) {
        var e = s.tag;
        if (e === 5 || e === 26 || e === 27 || e === 6) return s.stateNode;
        throw Error(D(33));
      }
      function Ha(s) {
        var e = s[R0];
        return e || (e = s[R0] = {
          hoistableStyles: /* @__PURE__ */ new Map(),
          hoistableScripts: /* @__PURE__ */ new Map()
        }), e;
      }
      function mt(s) {
        s[Vl] = true;
      }
      var DS = /* @__PURE__ */ new Set(), US = {};
      function Ir(s, e) {
        ao(s, e), ao(s + "Capture", e);
      }
      function ao(s, e) {
        for (US[s] = e, s = 0; s < e.length; s++) DS.add(e[s]);
      }
      var qs = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), _N = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), C0 = {}, B0 = {};
      function bN(s) {
        return $p.call(B0, s) ? true : $p.call(C0, s) ? false : _N.test(s) ? B0[s] = true : (C0[s] = true, false);
      }
      function Ic(s, e, t) {
        if (bN(e)) if (t === null) s.removeAttribute(e);
        else {
          switch (typeof t) {
            case "undefined":
            case "function":
            case "symbol":
              s.removeAttribute(e);
              return;
            case "boolean":
              var i = e.toLowerCase().slice(0, 5);
              if (i !== "data-" && i !== "aria-") {
                s.removeAttribute(e);
                return;
              }
          }
          s.setAttribute(e, "" + t);
        }
      }
      function qu(s, e, t) {
        if (t === null) s.removeAttribute(e);
        else {
          switch (typeof t) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              s.removeAttribute(e);
              return;
          }
          s.setAttribute(e, "" + t);
        }
      }
      function ps(s, e, t, i) {
        if (i === null) s.removeAttribute(t);
        else {
          switch (typeof i) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              s.removeAttribute(t);
              return;
          }
          s.setAttributeNS(e, t, "" + i);
        }
      }
      function Si(s) {
        switch (typeof s) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return s;
          case "object":
            return s;
          default:
            return "";
        }
      }
      function FS(s) {
        var e = s.type;
        return (s = s.nodeName) && s.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
      }
      function SN(s) {
        var e = FS(s) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(s.constructor.prototype, e), i = "" + s[e];
        if (!s.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
          var n = t.get, r = t.set;
          return Object.defineProperty(s, e, {
            configurable: true,
            get: function() {
              return n.call(this);
            },
            set: function(a) {
              i = "" + a, r.call(this, a);
            }
          }), Object.defineProperty(s, e, {
            enumerable: t.enumerable
          }), {
            getValue: function() {
              return i;
            },
            setValue: function(a) {
              i = "" + a;
            },
            stopTracking: function() {
              s._valueTracker = null, delete s[e];
            }
          };
        }
      }
      function mh(s) {
        s._valueTracker || (s._valueTracker = SN(s));
      }
      function OS(s) {
        if (!s) return false;
        var e = s._valueTracker;
        if (!e) return true;
        var t = e.getValue(), i = "";
        return s && (i = FS(s) ? s.checked ? "true" : "false" : s.value), s = i, s !== t ? (e.setValue(s), true) : false;
      }
      function gh(s) {
        if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
        try {
          return s.activeElement || s.body;
        } catch {
          return s.body;
        }
      }
      var TN = /[\n"\\]/g;
      function Ai(s) {
        return s.replace(TN, function(e) {
          return "\\" + e.charCodeAt(0).toString(16) + " ";
        });
      }
      function Zp(s, e, t, i, n, r, a, l) {
        s.name = "", a != null && typeof a != "function" && typeof a != "symbol" && typeof a != "boolean" ? s.type = a : s.removeAttribute("type"), e != null ? a === "number" ? (e === 0 && s.value === "" || s.value != e) && (s.value = "" + Si(e)) : s.value !== "" + Si(e) && (s.value = "" + Si(e)) : a !== "submit" && a !== "reset" || s.removeAttribute("value"), e != null ? Qp(s, a, Si(e)) : t != null ? Qp(s, a, Si(t)) : i != null && s.removeAttribute("value"), n == null && r != null && (s.defaultChecked = !!r), n != null && (s.checked = n && typeof n != "function" && typeof n != "symbol"), l != null && typeof l != "function" && typeof l != "symbol" && typeof l != "boolean" ? s.name = "" + Si(l) : s.removeAttribute("name");
      }
      function zS(s, e, t, i, n, r, a, l) {
        if (r != null && typeof r != "function" && typeof r != "symbol" && typeof r != "boolean" && (s.type = r), e != null || t != null) {
          if (!(r !== "submit" && r !== "reset" || e != null)) return;
          t = t != null ? "" + Si(t) : "", e = e != null ? "" + Si(e) : t, l || e === s.value || (s.value = e), s.defaultValue = e;
        }
        i = i ?? n, i = typeof i != "function" && typeof i != "symbol" && !!i, s.checked = l ? s.checked : !!i, s.defaultChecked = !!i, a != null && typeof a != "function" && typeof a != "symbol" && typeof a != "boolean" && (s.name = a);
      }
      function Qp(s, e, t) {
        e === "number" && gh(s.ownerDocument) === s || s.defaultValue === "" + t || (s.defaultValue = "" + t);
      }
      function qa(s, e, t, i) {
        if (s = s.options, e) {
          e = {};
          for (var n = 0; n < t.length; n++) e["$" + t[n]] = true;
          for (t = 0; t < s.length; t++) n = e.hasOwnProperty("$" + s[t].value), s[t].selected !== n && (s[t].selected = n), n && i && (s[t].defaultSelected = true);
        } else {
          for (t = "" + Si(t), e = null, n = 0; n < s.length; n++) {
            if (s[n].value === t) {
              s[n].selected = true, i && (s[n].defaultSelected = true);
              return;
            }
            e !== null || s[n].disabled || (e = s[n]);
          }
          e !== null && (e.selected = true);
        }
      }
      function LS(s, e, t) {
        if (e != null && (e = "" + Si(e), e !== s.value && (s.value = e), t == null)) {
          s.defaultValue !== e && (s.defaultValue = e);
          return;
        }
        s.defaultValue = t != null ? "" + Si(t) : "";
      }
      function GS(s, e, t, i) {
        if (e == null) {
          if (i != null) {
            if (t != null) throw Error(D(92));
            if (hl(i)) {
              if (1 < i.length) throw Error(D(93));
              i = i[0];
            }
            t = i;
          }
          t == null && (t = ""), e = t;
        }
        t = Si(e), s.defaultValue = t, i = s.textContent, i === t && i !== "" && i !== null && (s.value = i);
      }
      function oo(s, e) {
        if (e) {
          var t = s.firstChild;
          if (t && t === s.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return;
          }
        }
        s.textContent = e;
      }
      var vN = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
      function D0(s, e, t) {
        var i = e.indexOf("--") === 0;
        t == null || typeof t == "boolean" || t === "" ? i ? s.setProperty(e, "") : e === "float" ? s.cssFloat = "" : s[e] = "" : i ? s.setProperty(e, t) : typeof t != "number" || t === 0 || vN.has(e) ? e === "float" ? s.cssFloat = t : s[e] = ("" + t).trim() : s[e] = t + "px";
      }
      function PS(s, e, t) {
        if (e != null && typeof e != "object") throw Error(D(62));
        if (s = s.style, t != null) {
          for (var i in t) !t.hasOwnProperty(i) || e != null && e.hasOwnProperty(i) || (i.indexOf("--") === 0 ? s.setProperty(i, "") : i === "float" ? s.cssFloat = "" : s[i] = "");
          for (var n in e) i = e[n], e.hasOwnProperty(n) && t[n] !== i && D0(s, n, i);
        } else for (var r in e) e.hasOwnProperty(r) && D0(s, r, e[r]);
      }
      function Og(s) {
        if (s.indexOf("-") === -1) return false;
        switch (s) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var MN = /* @__PURE__ */ new Map([
        [
          "acceptCharset",
          "accept-charset"
        ],
        [
          "htmlFor",
          "for"
        ],
        [
          "httpEquiv",
          "http-equiv"
        ],
        [
          "crossOrigin",
          "crossorigin"
        ],
        [
          "accentHeight",
          "accent-height"
        ],
        [
          "alignmentBaseline",
          "alignment-baseline"
        ],
        [
          "arabicForm",
          "arabic-form"
        ],
        [
          "baselineShift",
          "baseline-shift"
        ],
        [
          "capHeight",
          "cap-height"
        ],
        [
          "clipPath",
          "clip-path"
        ],
        [
          "clipRule",
          "clip-rule"
        ],
        [
          "colorInterpolation",
          "color-interpolation"
        ],
        [
          "colorInterpolationFilters",
          "color-interpolation-filters"
        ],
        [
          "colorProfile",
          "color-profile"
        ],
        [
          "colorRendering",
          "color-rendering"
        ],
        [
          "dominantBaseline",
          "dominant-baseline"
        ],
        [
          "enableBackground",
          "enable-background"
        ],
        [
          "fillOpacity",
          "fill-opacity"
        ],
        [
          "fillRule",
          "fill-rule"
        ],
        [
          "floodColor",
          "flood-color"
        ],
        [
          "floodOpacity",
          "flood-opacity"
        ],
        [
          "fontFamily",
          "font-family"
        ],
        [
          "fontSize",
          "font-size"
        ],
        [
          "fontSizeAdjust",
          "font-size-adjust"
        ],
        [
          "fontStretch",
          "font-stretch"
        ],
        [
          "fontStyle",
          "font-style"
        ],
        [
          "fontVariant",
          "font-variant"
        ],
        [
          "fontWeight",
          "font-weight"
        ],
        [
          "glyphName",
          "glyph-name"
        ],
        [
          "glyphOrientationHorizontal",
          "glyph-orientation-horizontal"
        ],
        [
          "glyphOrientationVertical",
          "glyph-orientation-vertical"
        ],
        [
          "horizAdvX",
          "horiz-adv-x"
        ],
        [
          "horizOriginX",
          "horiz-origin-x"
        ],
        [
          "imageRendering",
          "image-rendering"
        ],
        [
          "letterSpacing",
          "letter-spacing"
        ],
        [
          "lightingColor",
          "lighting-color"
        ],
        [
          "markerEnd",
          "marker-end"
        ],
        [
          "markerMid",
          "marker-mid"
        ],
        [
          "markerStart",
          "marker-start"
        ],
        [
          "overlinePosition",
          "overline-position"
        ],
        [
          "overlineThickness",
          "overline-thickness"
        ],
        [
          "paintOrder",
          "paint-order"
        ],
        [
          "panose-1",
          "panose-1"
        ],
        [
          "pointerEvents",
          "pointer-events"
        ],
        [
          "renderingIntent",
          "rendering-intent"
        ],
        [
          "shapeRendering",
          "shape-rendering"
        ],
        [
          "stopColor",
          "stop-color"
        ],
        [
          "stopOpacity",
          "stop-opacity"
        ],
        [
          "strikethroughPosition",
          "strikethrough-position"
        ],
        [
          "strikethroughThickness",
          "strikethrough-thickness"
        ],
        [
          "strokeDasharray",
          "stroke-dasharray"
        ],
        [
          "strokeDashoffset",
          "stroke-dashoffset"
        ],
        [
          "strokeLinecap",
          "stroke-linecap"
        ],
        [
          "strokeLinejoin",
          "stroke-linejoin"
        ],
        [
          "strokeMiterlimit",
          "stroke-miterlimit"
        ],
        [
          "strokeOpacity",
          "stroke-opacity"
        ],
        [
          "strokeWidth",
          "stroke-width"
        ],
        [
          "textAnchor",
          "text-anchor"
        ],
        [
          "textDecoration",
          "text-decoration"
        ],
        [
          "textRendering",
          "text-rendering"
        ],
        [
          "transformOrigin",
          "transform-origin"
        ],
        [
          "underlinePosition",
          "underline-position"
        ],
        [
          "underlineThickness",
          "underline-thickness"
        ],
        [
          "unicodeBidi",
          "unicode-bidi"
        ],
        [
          "unicodeRange",
          "unicode-range"
        ],
        [
          "unitsPerEm",
          "units-per-em"
        ],
        [
          "vAlphabetic",
          "v-alphabetic"
        ],
        [
          "vHanging",
          "v-hanging"
        ],
        [
          "vIdeographic",
          "v-ideographic"
        ],
        [
          "vMathematical",
          "v-mathematical"
        ],
        [
          "vectorEffect",
          "vector-effect"
        ],
        [
          "vertAdvY",
          "vert-adv-y"
        ],
        [
          "vertOriginX",
          "vert-origin-x"
        ],
        [
          "vertOriginY",
          "vert-origin-y"
        ],
        [
          "wordSpacing",
          "word-spacing"
        ],
        [
          "writingMode",
          "writing-mode"
        ],
        [
          "xmlnsXlink",
          "xmlns:xlink"
        ],
        [
          "xHeight",
          "x-height"
        ]
      ]), AN = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function Vc(s) {
        return AN.test("" + s) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : s;
      }
      var Kp = null;
      function zg(s) {
        return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s;
      }
      var wa = null, Ya = null;
      function U0(s) {
        var e = Ro(s);
        if (e && (s = e.stateNode)) {
          var t = s[Xt] || null;
          e: switch (s = e.stateNode, e.type) {
            case "input":
              if (Zp(s, t.value, t.defaultValue, t.defaultValue, t.checked, t.defaultChecked, t.type, t.name), e = t.name, t.type === "radio" && e != null) {
                for (t = s; t.parentNode; ) t = t.parentNode;
                for (t = t.querySelectorAll('input[name="' + Ai("" + e) + '"][type="radio"]'), e = 0; e < t.length; e++) {
                  var i = t[e];
                  if (i !== s && i.form === s.form) {
                    var n = i[Xt] || null;
                    if (!n) throw Error(D(90));
                    Zp(i, n.value, n.defaultValue, n.defaultValue, n.checked, n.defaultChecked, n.type, n.name);
                  }
                }
                for (e = 0; e < t.length; e++) i = t[e], i.form === s.form && OS(i);
              }
              break e;
            case "textarea":
              LS(s, t.value, t.defaultValue);
              break e;
            case "select":
              e = t.value, e != null && qa(s, !!t.multiple, e, false);
          }
        }
      }
      var nf = false;
      function kS(s, e, t) {
        if (nf) return s(e, t);
        nf = true;
        try {
          var i = s(e);
          return i;
        } finally {
          if (nf = false, (wa !== null || Ya !== null) && (Td(), wa && (e = wa, s = Ya, Ya = wa = null, U0(e), s))) for (e = 0; e < s.length; e++) U0(s[e]);
        }
      }
      function Hl(s, e) {
        var t = s.stateNode;
        if (t === null) return null;
        var i = t[Xt] || null;
        if (i === null) return null;
        t = i[e];
        e: switch (e) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (i = !i.disabled) || (s = s.type, i = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !i;
            break e;
          default:
            s = false;
        }
        if (s) return null;
        if (t && typeof t != "function") throw Error(D(231, e, typeof t));
        return t;
      }
      var Jp = false;
      if (qs) try {
        var ko = {};
        Object.defineProperty(ko, "passive", {
          get: function() {
            Jp = true;
          }
        }), window.addEventListener("test", ko, ko), window.removeEventListener("test", ko, ko);
      } catch {
        Jp = false;
      }
      var Rn = null, Lg = null, Hc = null;
      function IS() {
        if (Hc) return Hc;
        var s, e = Lg, t = e.length, i, n = "value" in Rn ? Rn.value : Rn.textContent, r = n.length;
        for (s = 0; s < t && e[s] === n[s]; s++) ;
        var a = t - s;
        for (i = 1; i <= a && e[t - i] === n[r - i]; i++) ;
        return Hc = n.slice(s, 1 < i ? 1 - i : void 0);
      }
      function qc(s) {
        var e = s.keyCode;
        return "charCode" in s ? (s = s.charCode, s === 0 && e === 13 && (s = 13)) : s = e, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0;
      }
      function Yu() {
        return true;
      }
      function F0() {
        return false;
      }
      function Kt(s) {
        function e(t, i, n, r, a) {
          this._reactName = t, this._targetInst = n, this.type = i, this.nativeEvent = r, this.target = a, this.currentTarget = null;
          for (var l in s) s.hasOwnProperty(l) && (t = s[l], this[l] = t ? t(r) : r[l]);
          return this.isDefaultPrevented = (r.defaultPrevented != null ? r.defaultPrevented : r.returnValue === false) ? Yu : F0, this.isPropagationStopped = F0, this;
        }
        return Ue(e.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = false), this.isDefaultPrevented = Yu);
          },
          stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = true), this.isPropagationStopped = Yu);
          },
          persist: function() {
          },
          isPersistent: Yu
        }), e;
      }
      var Vr = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(s) {
          return s.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, fd = Kt(Vr), Tu = Ue({}, Vr, {
        view: 0,
        detail: 0
      }), NN = Kt(Tu), rf, af, Io, pd = Ue({}, Tu, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Gg,
        button: 0,
        buttons: 0,
        relatedTarget: function(s) {
          return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget;
        },
        movementX: function(s) {
          return "movementX" in s ? s.movementX : (s !== Io && (Io && s.type === "mousemove" ? (rf = s.screenX - Io.screenX, af = s.screenY - Io.screenY) : af = rf = 0, Io = s), rf);
        },
        movementY: function(s) {
          return "movementY" in s ? s.movementY : af;
        }
      }), O0 = Kt(pd), wN = Ue({}, pd, {
        dataTransfer: 0
      }), EN = Kt(wN), RN = Ue({}, Tu, {
        relatedTarget: 0
      }), of = Kt(RN), CN = Ue({}, Vr, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), BN = Kt(CN), DN = Ue({}, Vr, {
        clipboardData: function(s) {
          return "clipboardData" in s ? s.clipboardData : window.clipboardData;
        }
      }), UN = Kt(DN), FN = Ue({}, Vr, {
        data: 0
      }), z0 = Kt(FN), ON = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, zN = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, LN = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function GN(s) {
        var e = this.nativeEvent;
        return e.getModifierState ? e.getModifierState(s) : (s = LN[s]) ? !!e[s] : false;
      }
      function Gg() {
        return GN;
      }
      var PN = Ue({}, Tu, {
        key: function(s) {
          if (s.key) {
            var e = ON[s.key] || s.key;
            if (e !== "Unidentified") return e;
          }
          return s.type === "keypress" ? (s = qc(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? zN[s.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Gg,
        charCode: function(s) {
          return s.type === "keypress" ? qc(s) : 0;
        },
        keyCode: function(s) {
          return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
        },
        which: function(s) {
          return s.type === "keypress" ? qc(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
        }
      }), kN = Kt(PN), IN = Ue({}, pd, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), L0 = Kt(IN), VN = Ue({}, Tu, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Gg
      }), HN = Kt(VN), qN = Ue({}, Vr, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), YN = Kt(qN), WN = Ue({}, pd, {
        deltaX: function(s) {
          return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
        },
        deltaY: function(s) {
          return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), jN = Kt(WN), $N = Ue({}, Vr, {
        newState: 0,
        oldState: 0
      }), XN = Kt($N), ZN = [
        9,
        13,
        27,
        32
      ], Pg = qs && "CompositionEvent" in window, xl = null;
      qs && "documentMode" in document && (xl = document.documentMode);
      var QN = qs && "TextEvent" in window && !xl, VS = qs && (!Pg || xl && 8 < xl && 11 >= xl), G0 = " ", P0 = false;
      function HS(s, e) {
        switch (s) {
          case "keyup":
            return ZN.indexOf(e.keyCode) !== -1;
          case "keydown":
            return e.keyCode !== 229;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function qS(s) {
        return s = s.detail, typeof s == "object" && "data" in s ? s.data : null;
      }
      var Ea = false;
      function KN(s, e) {
        switch (s) {
          case "compositionend":
            return qS(e);
          case "keypress":
            return e.which !== 32 ? null : (P0 = true, G0);
          case "textInput":
            return s = e.data, s === G0 && P0 ? null : s;
          default:
            return null;
        }
      }
      function JN(s, e) {
        if (Ea) return s === "compositionend" || !Pg && HS(s, e) ? (s = IS(), Hc = Lg = Rn = null, Ea = false, s) : null;
        switch (s) {
          case "paste":
            return null;
          case "keypress":
            if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
              if (e.char && 1 < e.char.length) return e.char;
              if (e.which) return String.fromCharCode(e.which);
            }
            return null;
          case "compositionend":
            return VS && e.locale !== "ko" ? null : e.data;
          default:
            return null;
        }
      }
      var ew = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function k0(s) {
        var e = s && s.nodeName && s.nodeName.toLowerCase();
        return e === "input" ? !!ew[s.type] : e === "textarea";
      }
      function YS(s, e, t, i) {
        wa ? Ya ? Ya.push(i) : Ya = [
          i
        ] : wa = i, e = Dh(e, "onChange"), 0 < e.length && (t = new fd("onChange", "change", null, t, i), s.push({
          event: t,
          listeners: e
        }));
      }
      var _l = null, ql = null;
      function tw(s) {
        B1(s, 0);
      }
      function md(s) {
        var e = dl(s);
        if (OS(e)) return s;
      }
      function I0(s, e) {
        if (s === "change") return e;
      }
      var WS = false;
      if (qs) {
        var lf;
        if (qs) {
          var uf = "oninput" in document;
          if (!uf) {
            var V0 = document.createElement("div");
            V0.setAttribute("oninput", "return;"), uf = typeof V0.oninput == "function";
          }
          lf = uf;
        } else lf = false;
        WS = lf && (!document.documentMode || 9 < document.documentMode);
      }
      function H0() {
        _l && (_l.detachEvent("onpropertychange", jS), ql = _l = null);
      }
      function jS(s) {
        if (s.propertyName === "value" && md(ql)) {
          var e = [];
          YS(e, ql, s, zg(s)), kS(tw, e);
        }
      }
      function iw(s, e, t) {
        s === "focusin" ? (H0(), _l = e, ql = t, _l.attachEvent("onpropertychange", jS)) : s === "focusout" && H0();
      }
      function sw(s) {
        if (s === "selectionchange" || s === "keyup" || s === "keydown") return md(ql);
      }
      function nw(s, e) {
        if (s === "click") return md(e);
      }
      function rw(s, e) {
        if (s === "input" || s === "change") return md(e);
      }
      function aw(s, e) {
        return s === e && (s !== 0 || 1 / s === 1 / e) || s !== s && e !== e;
      }
      var di = typeof Object.is == "function" ? Object.is : aw;
      function Yl(s, e) {
        if (di(s, e)) return true;
        if (typeof s != "object" || s === null || typeof e != "object" || e === null) return false;
        var t = Object.keys(s), i = Object.keys(e);
        if (t.length !== i.length) return false;
        for (i = 0; i < t.length; i++) {
          var n = t[i];
          if (!$p.call(e, n) || !di(s[n], e[n])) return false;
        }
        return true;
      }
      function q0(s) {
        for (; s && s.firstChild; ) s = s.firstChild;
        return s;
      }
      function Y0(s, e) {
        var t = q0(s);
        s = 0;
        for (var i; t; ) {
          if (t.nodeType === 3) {
            if (i = s + t.textContent.length, s <= e && i >= e) return {
              node: t,
              offset: e - s
            };
            s = i;
          }
          e: {
            for (; t; ) {
              if (t.nextSibling) {
                t = t.nextSibling;
                break e;
              }
              t = t.parentNode;
            }
            t = void 0;
          }
          t = q0(t);
        }
      }
      function $S(s, e) {
        return s && e ? s === e ? true : s && s.nodeType === 3 ? false : e && e.nodeType === 3 ? $S(s, e.parentNode) : "contains" in s ? s.contains(e) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(e) & 16) : false : false;
      }
      function XS(s) {
        s = s != null && s.ownerDocument != null && s.ownerDocument.defaultView != null ? s.ownerDocument.defaultView : window;
        for (var e = gh(s.document); e instanceof s.HTMLIFrameElement; ) {
          try {
            var t = typeof e.contentWindow.location.href == "string";
          } catch {
            t = false;
          }
          if (t) s = e.contentWindow;
          else break;
          e = gh(s.document);
        }
        return e;
      }
      function kg(s) {
        var e = s && s.nodeName && s.nodeName.toLowerCase();
        return e && (e === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || e === "textarea" || s.contentEditable === "true");
      }
      function ow(s, e) {
        var t = XS(e);
        e = s.focusedElem;
        var i = s.selectionRange;
        if (t !== e && e && e.ownerDocument && $S(e.ownerDocument.documentElement, e)) {
          if (i !== null && kg(e)) {
            if (s = i.start, t = i.end, t === void 0 && (t = s), "selectionStart" in e) e.selectionStart = s, e.selectionEnd = Math.min(t, e.value.length);
            else if (t = (s = e.ownerDocument || document) && s.defaultView || window, t.getSelection) {
              t = t.getSelection();
              var n = e.textContent.length, r = Math.min(i.start, n);
              i = i.end === void 0 ? r : Math.min(i.end, n), !t.extend && r > i && (n = i, i = r, r = n), n = Y0(e, r);
              var a = Y0(e, i);
              n && a && (t.rangeCount !== 1 || t.anchorNode !== n.node || t.anchorOffset !== n.offset || t.focusNode !== a.node || t.focusOffset !== a.offset) && (s = s.createRange(), s.setStart(n.node, n.offset), t.removeAllRanges(), r > i ? (t.addRange(s), t.extend(a.node, a.offset)) : (s.setEnd(a.node, a.offset), t.addRange(s)));
            }
          }
          for (s = [], t = e; t = t.parentNode; ) t.nodeType === 1 && s.push({
            element: t,
            left: t.scrollLeft,
            top: t.scrollTop
          });
          for (typeof e.focus == "function" && e.focus(), e = 0; e < s.length; e++) t = s[e], t.element.scrollLeft = t.left, t.element.scrollTop = t.top;
        }
      }
      var lw = qs && "documentMode" in document && 11 >= document.documentMode, Ra = null, em = null, bl = null, tm = false;
      function W0(s, e, t) {
        var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
        tm || Ra == null || Ra !== gh(i) || (i = Ra, "selectionStart" in i && kg(i) ? i = {
          start: i.selectionStart,
          end: i.selectionEnd
        } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset
        }), bl && Yl(bl, i) || (bl = i, i = Dh(em, "onSelect"), 0 < i.length && (e = new fd("onSelect", "select", null, e, t), s.push({
          event: e,
          listeners: i
        }), e.target = Ra)));
      }
      function ir(s, e) {
        var t = {};
        return t[s.toLowerCase()] = e.toLowerCase(), t["Webkit" + s] = "webkit" + e, t["Moz" + s] = "moz" + e, t;
      }
      var Ca = {
        animationend: ir("Animation", "AnimationEnd"),
        animationiteration: ir("Animation", "AnimationIteration"),
        animationstart: ir("Animation", "AnimationStart"),
        transitionrun: ir("Transition", "TransitionRun"),
        transitionstart: ir("Transition", "TransitionStart"),
        transitioncancel: ir("Transition", "TransitionCancel"),
        transitionend: ir("Transition", "TransitionEnd")
      }, cf = {}, ZS = {};
      qs && (ZS = document.createElement("div").style, "AnimationEvent" in window || (delete Ca.animationend.animation, delete Ca.animationiteration.animation, delete Ca.animationstart.animation), "TransitionEvent" in window || delete Ca.transitionend.transition);
      function Hr(s) {
        if (cf[s]) return cf[s];
        if (!Ca[s]) return s;
        var e = Ca[s], t;
        for (t in e) if (e.hasOwnProperty(t) && t in ZS) return cf[s] = e[t];
        return s;
      }
      var QS = Hr("animationend"), KS = Hr("animationiteration"), JS = Hr("animationstart"), uw = Hr("transitionrun"), cw = Hr("transitionstart"), hw = Hr("transitioncancel"), eT = Hr("transitionend"), tT = /* @__PURE__ */ new Map(), j0 = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" ");
      function Zi(s, e) {
        tT.set(s, e), Ir(e, [
          s
        ]);
      }
      var _i = [], Ba = 0, Ig = 0;
      function gd() {
        for (var s = Ba, e = Ig = Ba = 0; e < s; ) {
          var t = _i[e];
          _i[e++] = null;
          var i = _i[e];
          _i[e++] = null;
          var n = _i[e];
          _i[e++] = null;
          var r = _i[e];
          if (_i[e++] = null, i !== null && n !== null) {
            var a = i.pending;
            a === null ? n.next = n : (n.next = a.next, a.next = n), i.pending = n;
          }
          r !== 0 && iT(t, n, r);
        }
      }
      function yd(s, e, t, i) {
        _i[Ba++] = s, _i[Ba++] = e, _i[Ba++] = t, _i[Ba++] = i, Ig |= i, s.lanes |= i, s = s.alternate, s !== null && (s.lanes |= i);
      }
      function Vg(s, e, t, i) {
        return yd(s, e, t, i), yh(s);
      }
      function qn(s, e) {
        return yd(s, null, null, e), yh(s);
      }
      function iT(s, e, t) {
        s.lanes |= t;
        var i = s.alternate;
        i !== null && (i.lanes |= t);
        for (var n = false, r = s.return; r !== null; ) r.childLanes |= t, i = r.alternate, i !== null && (i.childLanes |= t), r.tag === 22 && (s = r.stateNode, s === null || s._visibility & 1 || (n = true)), s = r, r = r.return;
        n && e !== null && s.tag === 3 && (r = s.stateNode, n = 31 - ci(t), r = r.hiddenUpdates, s = r[n], s === null ? r[n] = [
          e
        ] : s.push(e), e.lane = t | 536870912);
      }
      function yh(s) {
        if (50 < Dl) throw Dl = 0, vm = null, Error(D(185));
        for (var e = s.return; e !== null; ) s = e, e = s.return;
        return s.tag === 3 ? s.stateNode : null;
      }
      var Da = {}, $0 = /* @__PURE__ */ new WeakMap();
      function Ni(s, e) {
        if (typeof s == "object" && s !== null) {
          var t = $0.get(s);
          return t !== void 0 ? t : (e = {
            value: s,
            source: e,
            stack: w0(e)
          }, $0.set(s, e), e);
        }
        return {
          value: s,
          source: e,
          stack: w0(e)
        };
      }
      var Ua = [], Fa = 0, xh = null, _h = 0, Ti = [], vi = 0, Sr = null, Us = 1, Fs = "";
      function ur(s, e) {
        Ua[Fa++] = _h, Ua[Fa++] = xh, xh = s, _h = e;
      }
      function sT(s, e, t) {
        Ti[vi++] = Us, Ti[vi++] = Fs, Ti[vi++] = Sr, Sr = s;
        var i = Us;
        s = Fs;
        var n = 32 - ci(i) - 1;
        i &= ~(1 << n), t += 1;
        var r = 32 - ci(e) + n;
        if (30 < r) {
          var a = n - n % 5;
          r = (i & (1 << a) - 1).toString(32), i >>= a, n -= a, Us = 1 << 32 - ci(e) + n | t << n | i, Fs = r + s;
        } else Us = 1 << r | t << n | i, Fs = s;
      }
      function Hg(s) {
        s.return !== null && (ur(s, 1), sT(s, 1, 0));
      }
      function qg(s) {
        for (; s === xh; ) xh = Ua[--Fa], Ua[Fa] = null, _h = Ua[--Fa], Ua[Fa] = null;
        for (; s === Sr; ) Sr = Ti[--vi], Ti[vi] = null, Fs = Ti[--vi], Ti[vi] = null, Us = Ti[--vi], Ti[vi] = null;
      }
      var Ut = null, vt = null, ge = false, Ii = null, Ji = false, im = Error(D(519));
      function Er(s) {
        var e = Error(D(418, ""));
        throw Wl(Ni(e, s)), im;
      }
      function X0(s) {
        var e = s.stateNode, t = s.type, i = s.memoizedProps;
        switch (e[Rt] = s, e[Xt] = i, t) {
          case "dialog":
            ue("cancel", e), ue("close", e);
            break;
          case "iframe":
          case "object":
          case "embed":
            ue("load", e);
            break;
          case "video":
          case "audio":
            for (t = 0; t < Xl.length; t++) ue(Xl[t], e);
            break;
          case "source":
            ue("error", e);
            break;
          case "img":
          case "image":
          case "link":
            ue("error", e), ue("load", e);
            break;
          case "details":
            ue("toggle", e);
            break;
          case "input":
            ue("invalid", e), zS(e, i.value, i.defaultValue, i.checked, i.defaultChecked, i.type, i.name, true), mh(e);
            break;
          case "select":
            ue("invalid", e);
            break;
          case "textarea":
            ue("invalid", e), GS(e, i.value, i.defaultValue, i.children), mh(e);
        }
        t = i.children, typeof t != "string" && typeof t != "number" && typeof t != "bigint" || e.textContent === "" + t || i.suppressHydrationWarning === true || U1(e.textContent, t) ? (i.popover != null && (ue("beforetoggle", e), ue("toggle", e)), i.onScroll != null && ue("scroll", e), i.onScrollEnd != null && ue("scrollend", e), i.onClick != null && (e.onclick = Md), e = true) : e = false, e || Er(s);
      }
      function Z0(s) {
        for (Ut = s.return; Ut; ) switch (Ut.tag) {
          case 3:
          case 27:
            Ji = true;
            return;
          case 5:
          case 13:
            Ji = false;
            return;
          default:
            Ut = Ut.return;
        }
      }
      function Vo(s) {
        if (s !== Ut) return false;
        if (!ge) return Z0(s), ge = true, false;
        var e = false, t;
        if ((t = s.tag !== 3 && s.tag !== 27) && ((t = s.tag === 5) && (t = s.type, t = !(t !== "form" && t !== "button") || Cm(s.type, s.memoizedProps)), t = !t), t && (e = true), e && vt && Er(s), Z0(s), s.tag === 13) {
          if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(D(317));
          e: {
            for (s = s.nextSibling, e = 0; s; ) {
              if (s.nodeType === 8) if (t = s.data, t === "/$") {
                if (e === 0) {
                  vt = Yi(s.nextSibling);
                  break e;
                }
                e--;
              } else t !== "$" && t !== "$!" && t !== "$?" || e++;
              s = s.nextSibling;
            }
            vt = null;
          }
        } else vt = Ut ? Yi(s.stateNode.nextSibling) : null;
        return true;
      }
      function vu() {
        vt = Ut = null, ge = false;
      }
      function Wl(s) {
        Ii === null ? Ii = [
          s
        ] : Ii.push(s);
      }
      var Sl = Error(D(460)), nT = Error(D(474)), sm = {
        then: function() {
        }
      };
      function Q0(s) {
        return s = s.status, s === "fulfilled" || s === "rejected";
      }
      function Wu() {
      }
      function rT(s, e, t) {
        switch (t = s[t], t === void 0 ? s.push(e) : t !== e && (e.then(Wu, Wu), e = t), e.status) {
          case "fulfilled":
            return e.value;
          case "rejected":
            throw s = e.reason, s === Sl ? Error(D(483)) : s;
          default:
            if (typeof e.status == "string") e.then(Wu, Wu);
            else {
              if (s = Re, s !== null && 100 < s.shellSuspendCounter) throw Error(D(482));
              s = e, s.status = "pending", s.then(function(i) {
                if (e.status === "pending") {
                  var n = e;
                  n.status = "fulfilled", n.value = i;
                }
              }, function(i) {
                if (e.status === "pending") {
                  var n = e;
                  n.status = "rejected", n.reason = i;
                }
              });
            }
            switch (e.status) {
              case "fulfilled":
                return e.value;
              case "rejected":
                throw s = e.reason, s === Sl ? Error(D(483)) : s;
            }
            throw Tl = e, Sl;
        }
      }
      var Tl = null;
      function K0() {
        if (Tl === null) throw Error(D(459));
        var s = Tl;
        return Tl = null, s;
      }
      var Wa = null, jl = 0;
      function ju(s) {
        var e = jl;
        return jl += 1, Wa === null && (Wa = []), rT(Wa, s, e);
      }
      function Ho(s, e) {
        e = e.props.ref, s.ref = e !== void 0 ? e : null;
      }
      function $u(s, e) {
        throw e.$$typeof === KA ? Error(D(525)) : (s = Object.prototype.toString.call(e), Error(D(31, s === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : s)));
      }
      function J0(s) {
        var e = s._init;
        return e(s._payload);
      }
      function aT(s) {
        function e(m, y) {
          if (s) {
            var x = m.deletions;
            x === null ? (m.deletions = [
              y
            ], m.flags |= 16) : x.push(y);
          }
        }
        function t(m, y) {
          if (!s) return null;
          for (; y !== null; ) e(m, y), y = y.sibling;
          return null;
        }
        function i(m) {
          for (var y = /* @__PURE__ */ new Map(); m !== null; ) m.key !== null ? y.set(m.key, m) : y.set(m.index, m), m = m.sibling;
          return y;
        }
        function n(m, y) {
          return m = On(m, y), m.index = 0, m.sibling = null, m;
        }
        function r(m, y, x) {
          return m.index = x, s ? (x = m.alternate, x !== null ? (x = x.index, x < y ? (m.flags |= 33554434, y) : x) : (m.flags |= 33554434, y)) : (m.flags |= 1048576, y);
        }
        function a(m) {
          return s && m.alternate === null && (m.flags |= 33554434), m;
        }
        function l(m, y, x, b) {
          return y === null || y.tag !== 6 ? (y = Tf(x, m.mode, b), y.return = m, y) : (y = n(y, x), y.return = m, y);
        }
        function o(m, y, x, b) {
          var T = x.type;
          return T === Aa ? c(m, y, x.props.children, b, x.key) : y !== null && (y.elementType === T || typeof T == "object" && T !== null && T.$$typeof === yn && J0(T) === y.type) ? (y = n(y, x.props), Ho(y, x), y.return = m, y) : (y = Xc(x.type, x.key, x.props, null, m.mode, b), Ho(y, x), y.return = m, y);
        }
        function u(m, y, x, b) {
          return y === null || y.tag !== 4 || y.stateNode.containerInfo !== x.containerInfo || y.stateNode.implementation !== x.implementation ? (y = vf(x, m.mode, b), y.return = m, y) : (y = n(y, x.children || []), y.return = m, y);
        }
        function c(m, y, x, b, T) {
          return y === null || y.tag !== 7 ? (y = vr(x, m.mode, b, T), y.return = m, y) : (y = n(y, x), y.return = m, y);
        }
        function h(m, y, x) {
          if (typeof y == "string" && y !== "" || typeof y == "number" || typeof y == "bigint") return y = Tf("" + y, m.mode, x), y.return = m, y;
          if (typeof y == "object" && y !== null) {
            switch (y.$$typeof) {
              case Iu:
                return x = Xc(y.type, y.key, y.props, null, m.mode, x), Ho(x, y), x.return = m, x;
              case ul:
                return y = vf(y, m.mode, x), y.return = m, y;
              case yn:
                var b = y._init;
                return y = b(y._payload), h(m, y, x);
            }
            if (hl(y) || Po(y)) return y = vr(y, m.mode, x, null), y.return = m, y;
            if (typeof y.then == "function") return h(m, ju(y), x);
            if (y.$$typeof === Ds) return h(m, Xu(m, y), x);
            $u(m, y);
          }
          return null;
        }
        function d(m, y, x, b) {
          var T = y !== null ? y.key : null;
          if (typeof x == "string" && x !== "" || typeof x == "number" || typeof x == "bigint") return T !== null ? null : l(m, y, "" + x, b);
          if (typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
              case Iu:
                return x.key === T ? o(m, y, x, b) : null;
              case ul:
                return x.key === T ? u(m, y, x, b) : null;
              case yn:
                return T = x._init, x = T(x._payload), d(m, y, x, b);
            }
            if (hl(x) || Po(x)) return T !== null ? null : c(m, y, x, b, null);
            if (typeof x.then == "function") return d(m, y, ju(x), b);
            if (x.$$typeof === Ds) return d(m, y, Xu(m, x), b);
            $u(m, x);
          }
          return null;
        }
        function f(m, y, x, b, T) {
          if (typeof b == "string" && b !== "" || typeof b == "number" || typeof b == "bigint") return m = m.get(x) || null, l(y, m, "" + b, T);
          if (typeof b == "object" && b !== null) {
            switch (b.$$typeof) {
              case Iu:
                return m = m.get(b.key === null ? x : b.key) || null, o(y, m, b, T);
              case ul:
                return m = m.get(b.key === null ? x : b.key) || null, u(y, m, b, T);
              case yn:
                var N = b._init;
                return b = N(b._payload), f(m, y, x, b, T);
            }
            if (hl(b) || Po(b)) return m = m.get(x) || null, c(y, m, b, T, null);
            if (typeof b.then == "function") return f(m, y, x, ju(b), T);
            if (b.$$typeof === Ds) return f(m, y, x, Xu(y, b), T);
            $u(y, b);
          }
          return null;
        }
        function p(m, y, x, b) {
          for (var T = null, N = null, A = y, w = y = 0, k = null; A !== null && w < x.length; w++) {
            A.index > w ? (k = A, A = null) : k = A.sibling;
            var G = d(m, A, x[w], b);
            if (G === null) {
              A === null && (A = k);
              break;
            }
            s && A && G.alternate === null && e(m, A), y = r(G, y, w), N === null ? T = G : N.sibling = G, N = G, A = k;
          }
          if (w === x.length) return t(m, A), ge && ur(m, w), T;
          if (A === null) {
            for (; w < x.length; w++) A = h(m, x[w], b), A !== null && (y = r(A, y, w), N === null ? T = A : N.sibling = A, N = A);
            return ge && ur(m, w), T;
          }
          for (A = i(A); w < x.length; w++) k = f(A, m, w, x[w], b), k !== null && (s && k.alternate !== null && A.delete(k.key === null ? w : k.key), y = r(k, y, w), N === null ? T = k : N.sibling = k, N = k);
          return s && A.forEach(function(I) {
            return e(m, I);
          }), ge && ur(m, w), T;
        }
        function g(m, y, x, b) {
          if (x == null) throw Error(D(151));
          for (var T = null, N = null, A = y, w = y = 0, k = null, G = x.next(); A !== null && !G.done; w++, G = x.next()) {
            A.index > w ? (k = A, A = null) : k = A.sibling;
            var I = d(m, A, G.value, b);
            if (I === null) {
              A === null && (A = k);
              break;
            }
            s && A && I.alternate === null && e(m, A), y = r(I, y, w), N === null ? T = I : N.sibling = I, N = I, A = k;
          }
          if (G.done) return t(m, A), ge && ur(m, w), T;
          if (A === null) {
            for (; !G.done; w++, G = x.next()) G = h(m, G.value, b), G !== null && (y = r(G, y, w), N === null ? T = G : N.sibling = G, N = G);
            return ge && ur(m, w), T;
          }
          for (A = i(A); !G.done; w++, G = x.next()) G = f(A, m, w, G.value, b), G !== null && (s && G.alternate !== null && A.delete(G.key === null ? w : G.key), y = r(G, y, w), N === null ? T = G : N.sibling = G, N = G);
          return s && A.forEach(function(be) {
            return e(m, be);
          }), ge && ur(m, w), T;
        }
        function _(m, y, x, b) {
          if (typeof x == "object" && x !== null && x.type === Aa && x.key === null && (x = x.props.children), typeof x == "object" && x !== null) {
            switch (x.$$typeof) {
              case Iu:
                e: {
                  for (var T = x.key; y !== null; ) {
                    if (y.key === T) {
                      if (T = x.type, T === Aa) {
                        if (y.tag === 7) {
                          t(m, y.sibling), b = n(y, x.props.children), b.return = m, m = b;
                          break e;
                        }
                      } else if (y.elementType === T || typeof T == "object" && T !== null && T.$$typeof === yn && J0(T) === y.type) {
                        t(m, y.sibling), b = n(y, x.props), Ho(b, x), b.return = m, m = b;
                        break e;
                      }
                      t(m, y);
                      break;
                    } else e(m, y);
                    y = y.sibling;
                  }
                  x.type === Aa ? (b = vr(x.props.children, m.mode, b, x.key), b.return = m, m = b) : (b = Xc(x.type, x.key, x.props, null, m.mode, b), Ho(b, x), b.return = m, m = b);
                }
                return a(m);
              case ul:
                e: {
                  for (T = x.key; y !== null; ) {
                    if (y.key === T) if (y.tag === 4 && y.stateNode.containerInfo === x.containerInfo && y.stateNode.implementation === x.implementation) {
                      t(m, y.sibling), b = n(y, x.children || []), b.return = m, m = b;
                      break e;
                    } else {
                      t(m, y);
                      break;
                    }
                    else e(m, y);
                    y = y.sibling;
                  }
                  b = vf(x, m.mode, b), b.return = m, m = b;
                }
                return a(m);
              case yn:
                return T = x._init, x = T(x._payload), _(m, y, x, b);
            }
            if (hl(x)) return p(m, y, x, b);
            if (Po(x)) {
              if (T = Po(x), typeof T != "function") throw Error(D(150));
              return x = T.call(x), g(m, y, x, b);
            }
            if (typeof x.then == "function") return _(m, y, ju(x), b);
            if (x.$$typeof === Ds) return _(m, y, Xu(m, x), b);
            $u(m, x);
          }
          return typeof x == "string" && x !== "" || typeof x == "number" || typeof x == "bigint" ? (x = "" + x, y !== null && y.tag === 6 ? (t(m, y.sibling), b = n(y, x), b.return = m, m = b) : (t(m, y), b = Tf(x, m.mode, b), b.return = m, m = b), a(m)) : t(m, y);
        }
        return function(m, y, x, b) {
          try {
            jl = 0;
            var T = _(m, y, x, b);
            return Wa = null, T;
          } catch (A) {
            if (A === Sl) throw A;
            var N = Ei(29, A, null, m.mode);
            return N.lanes = b, N.return = m, N;
          } finally {
          }
        };
      }
      var Rr = aT(true), oT = aT(false), lo = cs(null), bh = cs(0);
      function ex(s, e) {
        s = js, Oe(bh, s), Oe(lo, e), js = s | e.baseLanes;
      }
      function nm() {
        Oe(bh, js), Oe(lo, lo.current);
      }
      function Yg() {
        js = bh.current, xt(lo), xt(bh);
      }
      var Di = cs(null), ns = null;
      function bn(s) {
        var e = s.alternate;
        Oe(ot, ot.current & 1), Oe(Di, s), ns === null && (e === null || lo.current !== null || e.memoizedState !== null) && (ns = s);
      }
      function lT(s) {
        if (s.tag === 22) {
          if (Oe(ot, ot.current), Oe(Di, s), ns === null) {
            var e = s.alternate;
            e !== null && e.memoizedState !== null && (ns = s);
          }
        } else Sn();
      }
      function Sn() {
        Oe(ot, ot.current), Oe(Di, Di.current);
      }
      function Os(s) {
        xt(Di), ns === s && (ns = null), xt(ot);
      }
      var ot = cs(0);
      function Sh(s) {
        for (var e = s; e !== null; ) {
          if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e;
          } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128) return e;
          } else if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue;
          }
          if (e === s) break;
          for (; e.sibling === null; ) {
            if (e.return === null || e.return === s) return null;
            e = e.return;
          }
          e.sibling.return = e.return, e = e.sibling;
        }
        return null;
      }
      var dw = typeof AbortController < "u" ? AbortController : function() {
        var s = [], e = this.signal = {
          aborted: false,
          addEventListener: function(t, i) {
            s.push(i);
          }
        };
        this.abort = function() {
          e.aborted = true, s.forEach(function(t) {
            return t();
          });
        };
      }, fw = ut.unstable_scheduleCallback, pw = ut.unstable_NormalPriority, at = {
        $$typeof: Ds,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function Wg() {
        return {
          controller: new dw(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function Mu(s) {
        s.refCount--, s.refCount === 0 && fw(pw, function() {
          s.controller.abort();
        });
      }
      var vl = null, rm = 0, uo = 0, ja = null;
      function mw(s, e) {
        if (vl === null) {
          var t = vl = [];
          rm = 0, uo = my(), ja = {
            status: "pending",
            value: void 0,
            then: function(i) {
              t.push(i);
            }
          };
        }
        return rm++, e.then(tx, tx), e;
      }
      function tx() {
        if (--rm === 0 && vl !== null) {
          ja !== null && (ja.status = "fulfilled");
          var s = vl;
          vl = null, uo = 0, ja = null;
          for (var e = 0; e < s.length; e++) (0, s[e])();
        }
      }
      function gw(s, e) {
        var t = [], i = {
          status: "pending",
          value: null,
          reason: null,
          then: function(n) {
            t.push(n);
          }
        };
        return s.then(function() {
          i.status = "fulfilled", i.value = e;
          for (var n = 0; n < t.length; n++) (0, t[n])(e);
        }, function(n) {
          for (i.status = "rejected", i.reason = n, n = 0; n < t.length; n++) (0, t[n])(void 0);
        }), i;
      }
      var ix = J.S;
      J.S = function(s, e) {
        typeof e == "object" && e !== null && typeof e.then == "function" && mw(s, e), ix !== null && ix(s, e);
      };
      var Tr = cs(null);
      function jg() {
        var s = Tr.current;
        return s !== null ? s : Re.pooledCache;
      }
      function Yc(s, e) {
        e === null ? Oe(Tr, Tr.current) : Oe(Tr, e.pool);
      }
      function uT() {
        var s = jg();
        return s === null ? null : {
          parent: at._currentValue,
          pool: s
        };
      }
      var Yn = 0, re = null, Me = null, Xe = null, Th = false, $a = false, Cr = false, vh = 0, $l = 0, Xa = null, yw = 0;
      function We() {
        throw Error(D(321));
      }
      function $g(s, e) {
        if (e === null) return false;
        for (var t = 0; t < e.length && t < s.length; t++) if (!di(s[t], e[t])) return false;
        return true;
      }
      function Xg(s, e, t, i, n, r) {
        return Yn = r, re = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, J.H = s === null || s.memoizedState === null ? qr : Kn, Cr = false, r = t(i, n), Cr = false, $a && (r = hT(e, t, i, n)), cT(s), r;
      }
      function cT(s) {
        J.H = rs;
        var e = Me !== null && Me.next !== null;
        if (Yn = 0, Xe = Me = re = null, Th = false, $l = 0, Xa = null, e) throw Error(D(300));
        s === null || yt || (s = s.dependencies, s !== null && Nh(s) && (yt = true));
      }
      function hT(s, e, t, i) {
        re = s;
        var n = 0;
        do {
          if ($a && (Xa = null), $l = 0, $a = false, 25 <= n) throw Error(D(301));
          if (n += 1, Xe = Me = null, s.updateQueue != null) {
            var r = s.updateQueue;
            r.lastEffect = null, r.events = null, r.stores = null, r.memoCache != null && (r.memoCache.index = 0);
          }
          J.H = Yr, r = e(t, i);
        } while ($a);
        return r;
      }
      function xw() {
        var s = J.H, e = s.useState()[0];
        return e = typeof e.then == "function" ? Au(e) : e, s = s.useState()[0], (Me !== null ? Me.memoizedState : null) !== s && (re.flags |= 1024), e;
      }
      function Zg() {
        var s = vh !== 0;
        return vh = 0, s;
      }
      function Qg(s, e, t) {
        e.updateQueue = s.updateQueue, e.flags &= -2053, s.lanes &= ~t;
      }
      function Kg(s) {
        if (Th) {
          for (s = s.memoizedState; s !== null; ) {
            var e = s.queue;
            e !== null && (e.pending = null), s = s.next;
          }
          Th = false;
        }
        Yn = 0, Xe = Me = re = null, $a = false, $l = vh = 0, Xa = null;
      }
      function Vt() {
        var s = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return Xe === null ? re.memoizedState = Xe = s : Xe = Xe.next = s, Xe;
      }
      function Je() {
        if (Me === null) {
          var s = re.alternate;
          s = s !== null ? s.memoizedState : null;
        } else s = Me.next;
        var e = Xe === null ? re.memoizedState : Xe.next;
        if (e !== null) Xe = e, Me = s;
        else {
          if (s === null) throw re.alternate === null ? Error(D(467)) : Error(D(310));
          Me = s, s = {
            memoizedState: Me.memoizedState,
            baseState: Me.baseState,
            baseQueue: Me.baseQueue,
            queue: Me.queue,
            next: null
          }, Xe === null ? re.memoizedState = Xe = s : Xe = Xe.next = s;
        }
        return Xe;
      }
      var xd;
      xd = function() {
        return {
          lastEffect: null,
          events: null,
          stores: null,
          memoCache: null
        };
      };
      function Au(s) {
        var e = $l;
        return $l += 1, Xa === null && (Xa = []), s = rT(Xa, s, e), e = re, (Xe === null ? e.memoizedState : Xe.next) === null && (e = e.alternate, J.H = e === null || e.memoizedState === null ? qr : Kn), s;
      }
      function _d(s) {
        if (s !== null && typeof s == "object") {
          if (typeof s.then == "function") return Au(s);
          if (s.$$typeof === Ds) return Ct(s);
        }
        throw Error(D(438, String(s)));
      }
      function Jg(s) {
        var e = null, t = re.updateQueue;
        if (t !== null && (e = t.memoCache), e == null) {
          var i = re.alternate;
          i !== null && (i = i.updateQueue, i !== null && (i = i.memoCache, i != null && (e = {
            data: i.data.map(function(n) {
              return n.slice();
            }),
            index: 0
          })));
        }
        if (e == null && (e = {
          data: [],
          index: 0
        }), t === null && (t = xd(), re.updateQueue = t), t.memoCache = e, t = e.data[e.index], t === void 0) for (t = e.data[e.index] = Array(s), i = 0; i < s; i++) t[i] = eN;
        return e.index++, t;
      }
      function Ys(s, e) {
        return typeof e == "function" ? e(s) : e;
      }
      function Wc(s) {
        var e = Je();
        return ey(e, Me, s);
      }
      function ey(s, e, t) {
        var i = s.queue;
        if (i === null) throw Error(D(311));
        i.lastRenderedReducer = t;
        var n = s.baseQueue, r = i.pending;
        if (r !== null) {
          if (n !== null) {
            var a = n.next;
            n.next = r.next, r.next = a;
          }
          e.baseQueue = n = r, i.pending = null;
        }
        if (r = s.baseState, n === null) s.memoizedState = r;
        else {
          e = n.next;
          var l = a = null, o = null, u = e, c = false;
          do {
            var h = u.lane & -536870913;
            if (h !== u.lane ? (he & h) === h : (Yn & h) === h) {
              var d = u.revertLane;
              if (d === 0) o !== null && (o = o.next = {
                lane: 0,
                revertLane: 0,
                action: u.action,
                hasEagerState: u.hasEagerState,
                eagerState: u.eagerState,
                next: null
              }), h === uo && (c = true);
              else if ((Yn & d) === d) {
                u = u.next, d === uo && (c = true);
                continue;
              } else h = {
                lane: 0,
                revertLane: u.revertLane,
                action: u.action,
                hasEagerState: u.hasEagerState,
                eagerState: u.eagerState,
                next: null
              }, o === null ? (l = o = h, a = r) : o = o.next = h, re.lanes |= d, jn |= d;
              h = u.action, Cr && t(r, h), r = u.hasEagerState ? u.eagerState : t(r, h);
            } else d = {
              lane: h,
              revertLane: u.revertLane,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null
            }, o === null ? (l = o = d, a = r) : o = o.next = d, re.lanes |= h, jn |= h;
            u = u.next;
          } while (u !== null && u !== e);
          if (o === null ? a = r : o.next = l, !di(r, s.memoizedState) && (yt = true, c && (t = ja, t !== null))) throw t;
          s.memoizedState = r, s.baseState = a, s.baseQueue = o, i.lastRenderedState = r;
        }
        return n === null && (i.lanes = 0), [
          s.memoizedState,
          i.dispatch
        ];
      }
      function hf(s) {
        var e = Je(), t = e.queue;
        if (t === null) throw Error(D(311));
        t.lastRenderedReducer = s;
        var i = t.dispatch, n = t.pending, r = e.memoizedState;
        if (n !== null) {
          t.pending = null;
          var a = n = n.next;
          do
            r = s(r, a.action), a = a.next;
          while (a !== n);
          di(r, e.memoizedState) || (yt = true), e.memoizedState = r, e.baseQueue === null && (e.baseState = r), t.lastRenderedState = r;
        }
        return [
          r,
          i
        ];
      }
      function dT(s, e, t) {
        var i = re, n = Je(), r = ge;
        if (r) {
          if (t === void 0) throw Error(D(407));
          t = t();
        } else t = e();
        var a = !di((Me || n).memoizedState, t);
        if (a && (n.memoizedState = t, yt = true), n = n.queue, ty(mT.bind(null, i, n, s), [
          s
        ]), n.getSnapshot !== e || a || Xe !== null && Xe.memoizedState.tag & 1) {
          if (i.flags |= 2048, co(9, pT.bind(null, i, n, t, e), {
            destroy: void 0
          }, null), Re === null) throw Error(D(349));
          r || Yn & 60 || fT(i, e, t);
        }
        return t;
      }
      function fT(s, e, t) {
        s.flags |= 16384, s = {
          getSnapshot: e,
          value: t
        }, e = re.updateQueue, e === null ? (e = xd(), re.updateQueue = e, e.stores = [
          s
        ]) : (t = e.stores, t === null ? e.stores = [
          s
        ] : t.push(s));
      }
      function pT(s, e, t, i) {
        e.value = t, e.getSnapshot = i, gT(e) && yT(s);
      }
      function mT(s, e, t) {
        return t(function() {
          gT(e) && yT(s);
        });
      }
      function gT(s) {
        var e = s.getSnapshot;
        s = s.value;
        try {
          var t = e();
          return !di(s, t);
        } catch {
          return true;
        }
      }
      function yT(s) {
        var e = qn(s, 2);
        e !== null && zt(e, s, 2);
      }
      function am(s) {
        var e = Vt();
        if (typeof s == "function") {
          var t = s;
          if (s = t(), Cr) {
            En(true);
            try {
              t();
            } finally {
              En(false);
            }
          }
        }
        return e.memoizedState = e.baseState = s, e.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Ys,
          lastRenderedState: s
        }, e;
      }
      function xT(s, e, t, i) {
        return s.baseState = t, ey(s, Me, typeof i == "function" ? i : Ys);
      }
      function _w(s, e, t, i, n) {
        if (Sd(s)) throw Error(D(485));
        if (s = e.action, s !== null) {
          var r = {
            payload: n,
            action: s,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(a) {
              r.listeners.push(a);
            }
          };
          J.T !== null ? t(true) : r.isTransition = false, i(r), t = e.pending, t === null ? (r.next = e.pending = r, _T(e, r)) : (r.next = t.next, e.pending = t.next = r);
        }
      }
      function _T(s, e) {
        var t = e.action, i = e.payload, n = s.state;
        if (e.isTransition) {
          var r = J.T, a = {};
          J.T = a;
          try {
            var l = t(n, i), o = J.S;
            o !== null && o(a, l), sx(s, e, l);
          } catch (u) {
            om(s, e, u);
          } finally {
            J.T = r;
          }
        } else try {
          r = t(n, i), sx(s, e, r);
        } catch (u) {
          om(s, e, u);
        }
      }
      function sx(s, e, t) {
        t !== null && typeof t == "object" && typeof t.then == "function" ? t.then(function(i) {
          nx(s, e, i);
        }, function(i) {
          return om(s, e, i);
        }) : nx(s, e, t);
      }
      function nx(s, e, t) {
        e.status = "fulfilled", e.value = t, bT(e), s.state = t, e = s.pending, e !== null && (t = e.next, t === e ? s.pending = null : (t = t.next, e.next = t, _T(s, t)));
      }
      function om(s, e, t) {
        var i = s.pending;
        if (s.pending = null, i !== null) {
          i = i.next;
          do
            e.status = "rejected", e.reason = t, bT(e), e = e.next;
          while (e !== i);
        }
        s.action = null;
      }
      function bT(s) {
        s = s.listeners;
        for (var e = 0; e < s.length; e++) (0, s[e])();
      }
      function ST(s, e) {
        return e;
      }
      function TT(s, e) {
        if (ge) {
          var t = Re.formState;
          if (t !== null) {
            e: {
              var i = re;
              if (ge) {
                if (vt) {
                  t: {
                    for (var n = vt, r = Ji; n.nodeType !== 8; ) {
                      if (!r) {
                        n = null;
                        break t;
                      }
                      if (n = Yi(n.nextSibling), n === null) {
                        n = null;
                        break t;
                      }
                    }
                    r = n.data, n = r === "F!" || r === "F" ? n : null;
                  }
                  if (n) {
                    vt = Yi(n.nextSibling), i = n.data === "F!";
                    break e;
                  }
                }
                Er(i);
              }
              i = false;
            }
            i && (e = t[0]);
          }
        }
        return t = Vt(), t.memoizedState = t.baseState = e, i = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ST,
          lastRenderedState: e
        }, t.queue = i, t = PT.bind(null, re, i), i.dispatch = t, i = am(false), r = ry.bind(null, re, false, i.queue), i = Vt(), n = {
          state: e,
          dispatch: null,
          action: s,
          pending: null
        }, i.queue = n, t = _w.bind(null, re, n, r, t), n.dispatch = t, i.memoizedState = s, [
          e,
          t,
          false
        ];
      }
      function vT(s) {
        var e = Je();
        return MT(e, Me, s);
      }
      function MT(s, e, t) {
        e = ey(s, e, ST)[0], s = Wc(Ys)[0], e = typeof e == "object" && e !== null && typeof e.then == "function" ? Au(e) : e;
        var i = Je(), n = i.queue, r = n.dispatch;
        return t !== i.memoizedState && (re.flags |= 2048, co(9, bw.bind(null, n, t), {
          destroy: void 0
        }, null)), [
          e,
          r,
          s
        ];
      }
      function bw(s, e) {
        s.action = e;
      }
      function AT(s) {
        var e = Je(), t = Me;
        if (t !== null) return MT(e, t, s);
        Je(), e = e.memoizedState, t = Je();
        var i = t.queue.dispatch;
        return t.memoizedState = s, [
          e,
          i,
          false
        ];
      }
      function co(s, e, t, i) {
        return s = {
          tag: s,
          create: e,
          inst: t,
          deps: i,
          next: null
        }, e = re.updateQueue, e === null && (e = xd(), re.updateQueue = e), t = e.lastEffect, t === null ? e.lastEffect = s.next = s : (i = t.next, t.next = s, s.next = i, e.lastEffect = s), s;
      }
      function NT() {
        return Je().memoizedState;
      }
      function jc(s, e, t, i) {
        var n = Vt();
        re.flags |= s, n.memoizedState = co(1 | e, t, {
          destroy: void 0
        }, i === void 0 ? null : i);
      }
      function bd(s, e, t, i) {
        var n = Je();
        i = i === void 0 ? null : i;
        var r = n.memoizedState.inst;
        Me !== null && i !== null && $g(i, Me.memoizedState.deps) ? n.memoizedState = co(e, t, r, i) : (re.flags |= s, n.memoizedState = co(1 | e, t, r, i));
      }
      function rx(s, e) {
        jc(8390656, 8, s, e);
      }
      function ty(s, e) {
        bd(2048, 8, s, e);
      }
      function wT(s, e) {
        return bd(4, 2, s, e);
      }
      function ET(s, e) {
        return bd(4, 4, s, e);
      }
      function RT(s, e) {
        if (typeof e == "function") {
          s = s();
          var t = e(s);
          return function() {
            typeof t == "function" ? t() : e(null);
          };
        }
        if (e != null) return s = s(), e.current = s, function() {
          e.current = null;
        };
      }
      function CT(s, e, t) {
        t = t != null ? t.concat([
          s
        ]) : null, bd(4, 4, RT.bind(null, e, s), t);
      }
      function iy() {
      }
      function BT(s, e) {
        var t = Je();
        e = e === void 0 ? null : e;
        var i = t.memoizedState;
        return e !== null && $g(e, i[1]) ? i[0] : (t.memoizedState = [
          s,
          e
        ], s);
      }
      function DT(s, e) {
        var t = Je();
        e = e === void 0 ? null : e;
        var i = t.memoizedState;
        if (e !== null && $g(e, i[1])) return i[0];
        if (i = s(), Cr) {
          En(true);
          try {
            s();
          } finally {
            En(false);
          }
        }
        return t.memoizedState = [
          i,
          e
        ], i;
      }
      function sy(s, e, t) {
        return t === void 0 || Yn & 1073741824 ? s.memoizedState = e : (s.memoizedState = t, s = b1(), re.lanes |= s, jn |= s, t);
      }
      function UT(s, e, t, i) {
        return di(t, e) ? t : lo.current !== null ? (s = sy(s, t, i), di(s, e) || (yt = true), s) : Yn & 42 ? (s = b1(), re.lanes |= s, jn |= s, e) : (yt = true, s.memoizedState = t);
      }
      function FT(s, e, t, i, n) {
        var r = De.p;
        De.p = r !== 0 && 8 > r ? r : 8;
        var a = J.T, l = {};
        J.T = l, ry(s, false, e, t);
        try {
          var o = n(), u = J.S;
          if (u !== null && u(l, o), o !== null && typeof o == "object" && typeof o.then == "function") {
            var c = gw(o, i);
            Ml(s, e, c, hi(s));
          } else Ml(s, e, i, hi(s));
        } catch (h) {
          Ml(s, e, {
            then: function() {
            },
            status: "rejected",
            reason: h
          }, hi());
        } finally {
          De.p = r, J.T = a;
        }
      }
      function Sw() {
      }
      function lm(s, e, t, i) {
        if (s.tag !== 5) throw Error(D(476));
        var n = OT(s).queue;
        FT(s, n, e, br, t === null ? Sw : function() {
          return zT(s), t(i);
        });
      }
      function OT(s) {
        var e = s.memoizedState;
        if (e !== null) return e;
        e = {
          memoizedState: br,
          baseState: br,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ys,
            lastRenderedState: br
          },
          next: null
        };
        var t = {};
        return e.next = {
          memoizedState: t,
          baseState: t,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Ys,
            lastRenderedState: t
          },
          next: null
        }, s.memoizedState = e, s = s.alternate, s !== null && (s.memoizedState = e), e;
      }
      function zT(s) {
        var e = OT(s).next.queue;
        Ml(s, e, {}, hi());
      }
      function ny() {
        return Ct(Kl);
      }
      function LT() {
        return Je().memoizedState;
      }
      function GT() {
        return Je().memoizedState;
      }
      function Tw(s) {
        for (var e = s.return; e !== null; ) {
          switch (e.tag) {
            case 24:
            case 3:
              var t = hi();
              s = Un(t);
              var i = Fn(e, s, t);
              i !== null && (zt(i, e, t), Nl(i, e, t)), e = {
                cache: Wg()
              }, s.payload = e;
              return;
          }
          e = e.return;
        }
      }
      function vw(s, e, t) {
        var i = hi();
        t = {
          lane: i,
          revertLane: 0,
          action: t,
          hasEagerState: false,
          eagerState: null,
          next: null
        }, Sd(s) ? kT(e, t) : (t = Vg(s, e, t, i), t !== null && (zt(t, s, i), IT(t, e, i)));
      }
      function PT(s, e, t) {
        var i = hi();
        Ml(s, e, t, i);
      }
      function Ml(s, e, t, i) {
        var n = {
          lane: i,
          revertLane: 0,
          action: t,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (Sd(s)) kT(e, n);
        else {
          var r = s.alternate;
          if (s.lanes === 0 && (r === null || r.lanes === 0) && (r = e.lastRenderedReducer, r !== null)) try {
            var a = e.lastRenderedState, l = r(a, t);
            if (n.hasEagerState = true, n.eagerState = l, di(l, a)) return yd(s, e, n, 0), Re === null && gd(), false;
          } catch {
          } finally {
          }
          if (t = Vg(s, e, n, i), t !== null) return zt(t, s, i), IT(t, e, i), true;
        }
        return false;
      }
      function ry(s, e, t, i) {
        if (i = {
          lane: 2,
          revertLane: my(),
          action: i,
          hasEagerState: false,
          eagerState: null,
          next: null
        }, Sd(s)) {
          if (e) throw Error(D(479));
        } else e = Vg(s, t, i, 2), e !== null && zt(e, s, 2);
      }
      function Sd(s) {
        var e = s.alternate;
        return s === re || e !== null && e === re;
      }
      function kT(s, e) {
        $a = Th = true;
        var t = s.pending;
        t === null ? e.next = e : (e.next = t.next, t.next = e), s.pending = e;
      }
      function IT(s, e, t) {
        if (t & 4194176) {
          var i = e.lanes;
          i &= s.pendingLanes, t |= i, e.lanes = t, RS(s, t);
        }
      }
      var rs = {
        readContext: Ct,
        use: _d,
        useCallback: We,
        useContext: We,
        useEffect: We,
        useImperativeHandle: We,
        useLayoutEffect: We,
        useInsertionEffect: We,
        useMemo: We,
        useReducer: We,
        useRef: We,
        useState: We,
        useDebugValue: We,
        useDeferredValue: We,
        useTransition: We,
        useSyncExternalStore: We,
        useId: We
      };
      rs.useCacheRefresh = We;
      rs.useMemoCache = We;
      rs.useHostTransitionStatus = We;
      rs.useFormState = We;
      rs.useActionState = We;
      rs.useOptimistic = We;
      var qr = {
        readContext: Ct,
        use: _d,
        useCallback: function(s, e) {
          return Vt().memoizedState = [
            s,
            e === void 0 ? null : e
          ], s;
        },
        useContext: Ct,
        useEffect: rx,
        useImperativeHandle: function(s, e, t) {
          t = t != null ? t.concat([
            s
          ]) : null, jc(4194308, 4, RT.bind(null, e, s), t);
        },
        useLayoutEffect: function(s, e) {
          return jc(4194308, 4, s, e);
        },
        useInsertionEffect: function(s, e) {
          jc(4, 2, s, e);
        },
        useMemo: function(s, e) {
          var t = Vt();
          e = e === void 0 ? null : e;
          var i = s();
          if (Cr) {
            En(true);
            try {
              s();
            } finally {
              En(false);
            }
          }
          return t.memoizedState = [
            i,
            e
          ], i;
        },
        useReducer: function(s, e, t) {
          var i = Vt();
          if (t !== void 0) {
            var n = t(e);
            if (Cr) {
              En(true);
              try {
                t(e);
              } finally {
                En(false);
              }
            }
          } else n = e;
          return i.memoizedState = i.baseState = n, s = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: s,
            lastRenderedState: n
          }, i.queue = s, s = s.dispatch = vw.bind(null, re, s), [
            i.memoizedState,
            s
          ];
        },
        useRef: function(s) {
          var e = Vt();
          return s = {
            current: s
          }, e.memoizedState = s;
        },
        useState: function(s) {
          s = am(s);
          var e = s.queue, t = PT.bind(null, re, e);
          return e.dispatch = t, [
            s.memoizedState,
            t
          ];
        },
        useDebugValue: iy,
        useDeferredValue: function(s, e) {
          var t = Vt();
          return sy(t, s, e);
        },
        useTransition: function() {
          var s = am(false);
          return s = FT.bind(null, re, s.queue, true, false), Vt().memoizedState = s, [
            false,
            s
          ];
        },
        useSyncExternalStore: function(s, e, t) {
          var i = re, n = Vt();
          if (ge) {
            if (t === void 0) throw Error(D(407));
            t = t();
          } else {
            if (t = e(), Re === null) throw Error(D(349));
            he & 60 || fT(i, e, t);
          }
          n.memoizedState = t;
          var r = {
            value: t,
            getSnapshot: e
          };
          return n.queue = r, rx(mT.bind(null, i, r, s), [
            s
          ]), i.flags |= 2048, co(9, pT.bind(null, i, r, t, e), {
            destroy: void 0
          }, null), t;
        },
        useId: function() {
          var s = Vt(), e = Re.identifierPrefix;
          if (ge) {
            var t = Fs, i = Us;
            t = (i & ~(1 << 32 - ci(i) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = vh++, 0 < t && (e += "H" + t.toString(32)), e += ":";
          } else t = yw++, e = ":" + e + "r" + t.toString(32) + ":";
          return s.memoizedState = e;
        },
        useCacheRefresh: function() {
          return Vt().memoizedState = Tw.bind(null, re);
        }
      };
      qr.useMemoCache = Jg;
      qr.useHostTransitionStatus = ny;
      qr.useFormState = TT;
      qr.useActionState = TT;
      qr.useOptimistic = function(s) {
        var e = Vt();
        e.memoizedState = e.baseState = s;
        var t = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return e.queue = t, e = ry.bind(null, re, true, t), t.dispatch = e, [
          s,
          e
        ];
      };
      var Kn = {
        readContext: Ct,
        use: _d,
        useCallback: BT,
        useContext: Ct,
        useEffect: ty,
        useImperativeHandle: CT,
        useInsertionEffect: wT,
        useLayoutEffect: ET,
        useMemo: DT,
        useReducer: Wc,
        useRef: NT,
        useState: function() {
          return Wc(Ys);
        },
        useDebugValue: iy,
        useDeferredValue: function(s, e) {
          var t = Je();
          return UT(t, Me.memoizedState, s, e);
        },
        useTransition: function() {
          var s = Wc(Ys)[0], e = Je().memoizedState;
          return [
            typeof s == "boolean" ? s : Au(s),
            e
          ];
        },
        useSyncExternalStore: dT,
        useId: LT
      };
      Kn.useCacheRefresh = GT;
      Kn.useMemoCache = Jg;
      Kn.useHostTransitionStatus = ny;
      Kn.useFormState = vT;
      Kn.useActionState = vT;
      Kn.useOptimistic = function(s, e) {
        var t = Je();
        return xT(t, Me, s, e);
      };
      var Yr = {
        readContext: Ct,
        use: _d,
        useCallback: BT,
        useContext: Ct,
        useEffect: ty,
        useImperativeHandle: CT,
        useInsertionEffect: wT,
        useLayoutEffect: ET,
        useMemo: DT,
        useReducer: hf,
        useRef: NT,
        useState: function() {
          return hf(Ys);
        },
        useDebugValue: iy,
        useDeferredValue: function(s, e) {
          var t = Je();
          return Me === null ? sy(t, s, e) : UT(t, Me.memoizedState, s, e);
        },
        useTransition: function() {
          var s = hf(Ys)[0], e = Je().memoizedState;
          return [
            typeof s == "boolean" ? s : Au(s),
            e
          ];
        },
        useSyncExternalStore: dT,
        useId: LT
      };
      Yr.useCacheRefresh = GT;
      Yr.useMemoCache = Jg;
      Yr.useHostTransitionStatus = ny;
      Yr.useFormState = AT;
      Yr.useActionState = AT;
      Yr.useOptimistic = function(s, e) {
        var t = Je();
        return Me !== null ? xT(t, Me, s, e) : (t.baseState = s, [
          s,
          t.queue.dispatch
        ]);
      };
      function df(s, e, t, i) {
        e = s.memoizedState, t = t(i, e), t = t == null ? e : Ue({}, e, t), s.memoizedState = t, s.lanes === 0 && (s.updateQueue.baseState = t);
      }
      var um = {
        isMounted: function(s) {
          return (s = s._reactInternals) ? wo(s) === s : false;
        },
        enqueueSetState: function(s, e, t) {
          s = s._reactInternals;
          var i = hi(), n = Un(i);
          n.payload = e, t != null && (n.callback = t), e = Fn(s, n, i), e !== null && (zt(e, s, i), Nl(e, s, i));
        },
        enqueueReplaceState: function(s, e, t) {
          s = s._reactInternals;
          var i = hi(), n = Un(i);
          n.tag = 1, n.payload = e, t != null && (n.callback = t), e = Fn(s, n, i), e !== null && (zt(e, s, i), Nl(e, s, i));
        },
        enqueueForceUpdate: function(s, e) {
          s = s._reactInternals;
          var t = hi(), i = Un(t);
          i.tag = 2, e != null && (i.callback = e), e = Fn(s, i, t), e !== null && (zt(e, s, t), Nl(e, s, t));
        }
      };
      function ax(s, e, t, i, n, r, a) {
        return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(i, r, a) : e.prototype && e.prototype.isPureReactComponent ? !Yl(t, i) || !Yl(n, r) : true;
      }
      function ox(s, e, t, i) {
        s = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i), e.state !== s && um.enqueueReplaceState(e, e.state, null);
      }
      function Br(s, e) {
        var t = e;
        if ("ref" in e) {
          t = {};
          for (var i in e) i !== "ref" && (t[i] = e[i]);
        }
        if (s = s.defaultProps) {
          t === e && (t = Ue({}, t));
          for (var n in s) t[n] === void 0 && (t[n] = s[n]);
        }
        return t;
      }
      var Mh = typeof reportError == "function" ? reportError : function(s) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var e = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: typeof s == "object" && s !== null && typeof s.message == "string" ? String(s.message) : String(s),
            error: s
          });
          if (!window.dispatchEvent(e)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", s);
          return;
        }
        console.error(s);
      };
      function VT(s) {
        Mh(s);
      }
      function HT(s) {
        console.error(s);
      }
      function qT(s) {
        Mh(s);
      }
      function Ah(s, e) {
        try {
          var t = s.onUncaughtError;
          t(e.value, {
            componentStack: e.stack
          });
        } catch (i) {
          setTimeout(function() {
            throw i;
          });
        }
      }
      function lx(s, e, t) {
        try {
          var i = s.onCaughtError;
          i(t.value, {
            componentStack: t.stack,
            errorBoundary: e.tag === 1 ? e.stateNode : null
          });
        } catch (n) {
          setTimeout(function() {
            throw n;
          });
        }
      }
      function cm(s, e, t) {
        return t = Un(t), t.tag = 3, t.payload = {
          element: null
        }, t.callback = function() {
          Ah(s, e);
        }, t;
      }
      function YT(s) {
        return s = Un(s), s.tag = 3, s;
      }
      function WT(s, e, t, i) {
        var n = t.type.getDerivedStateFromError;
        if (typeof n == "function") {
          var r = i.value;
          s.payload = function() {
            return n(r);
          }, s.callback = function() {
            lx(e, t, i);
          };
        }
        var a = t.stateNode;
        a !== null && typeof a.componentDidCatch == "function" && (s.callback = function() {
          lx(e, t, i), typeof n != "function" && (zn === null ? zn = /* @__PURE__ */ new Set([
            this
          ]) : zn.add(this));
          var l = i.stack;
          this.componentDidCatch(i.value, {
            componentStack: l !== null ? l : ""
          });
        });
      }
      function Mw(s, e, t, i, n) {
        if (t.flags |= 32768, i !== null && typeof i == "object" && typeof i.then == "function") {
          if (e = t.alternate, e !== null && Nu(e, t, n, true), t = Di.current, t !== null) {
            switch (t.tag) {
              case 13:
                return ns === null ? Am() : t.alternate === null && Ve === 0 && (Ve = 3), t.flags &= -257, t.flags |= 65536, t.lanes = n, i === sm ? t.flags |= 16384 : (e = t.updateQueue, e === null ? t.updateQueue = /* @__PURE__ */ new Set([
                  i
                ]) : e.add(i), Af(s, i, n)), false;
              case 22:
                return t.flags |= 65536, i === sm ? t.flags |= 16384 : (e = t.updateQueue, e === null ? (e = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([
                    i
                  ])
                }, t.updateQueue = e) : (t = e.retryQueue, t === null ? e.retryQueue = /* @__PURE__ */ new Set([
                  i
                ]) : t.add(i)), Af(s, i, n)), false;
            }
            throw Error(D(435, t.tag));
          }
          return Af(s, i, n), Am(), false;
        }
        if (ge) return e = Di.current, e !== null ? (!(e.flags & 65536) && (e.flags |= 256), e.flags |= 65536, e.lanes = n, i !== im && (s = Error(D(422), {
          cause: i
        }), Wl(Ni(s, t)))) : (i !== im && (e = Error(D(423), {
          cause: i
        }), Wl(Ni(e, t))), s = s.current.alternate, s.flags |= 65536, n &= -n, s.lanes |= n, i = Ni(i, t), n = cm(s.stateNode, i, n), xf(s, n), Ve !== 4 && (Ve = 2)), false;
        var r = Error(D(520), {
          cause: i
        });
        if (r = Ni(r, t), Cl === null ? Cl = [
          r
        ] : Cl.push(r), Ve !== 4 && (Ve = 2), e === null) return true;
        i = Ni(i, t), t = e;
        do {
          switch (t.tag) {
            case 3:
              return t.flags |= 65536, s = n & -n, t.lanes |= s, s = cm(t.stateNode, i, s), xf(t, s), false;
            case 1:
              if (e = t.type, r = t.stateNode, (t.flags & 128) === 0 && (typeof e.getDerivedStateFromError == "function" || r !== null && typeof r.componentDidCatch == "function" && (zn === null || !zn.has(r)))) return t.flags |= 65536, n &= -n, t.lanes |= n, n = YT(n), WT(n, s, t, i), xf(t, n), false;
          }
          t = t.return;
        } while (t !== null);
        return false;
      }
      var jT = Error(D(461)), yt = false;
      function St(s, e, t, i) {
        e.child = s === null ? oT(e, null, t, i) : Rr(e, s.child, t, i);
      }
      function ux(s, e, t, i, n) {
        t = t.render;
        var r = e.ref;
        if ("ref" in i) {
          var a = {};
          for (var l in i) l !== "ref" && (a[l] = i[l]);
        } else a = i;
        return Dr(e), i = Xg(s, e, t, a, r, n), l = Zg(), s !== null && !yt ? (Qg(s, e, n), Ws(s, e, n)) : (ge && l && Hg(e), e.flags |= 1, St(s, e, i, n), e.child);
      }
      function cx(s, e, t, i, n) {
        if (s === null) {
          var r = t.type;
          return typeof r == "function" && !cy(r) && r.defaultProps === void 0 && t.compare === null ? (e.tag = 15, e.type = r, $T(s, e, r, i, n)) : (s = Xc(t.type, null, i, e, e.mode, n), s.ref = e.ref, s.return = e, e.child = s);
        }
        if (r = s.child, !ay(s, n)) {
          var a = r.memoizedProps;
          if (t = t.compare, t = t !== null ? t : Yl, t(a, i) && s.ref === e.ref) return Ws(s, e, n);
        }
        return e.flags |= 1, s = On(r, i), s.ref = e.ref, s.return = e, e.child = s;
      }
      function $T(s, e, t, i, n) {
        if (s !== null) {
          var r = s.memoizedProps;
          if (Yl(r, i) && s.ref === e.ref) if (yt = false, e.pendingProps = i = r, ay(s, n)) s.flags & 131072 && (yt = true);
          else return e.lanes = s.lanes, Ws(s, e, n);
        }
        return hm(s, e, t, i, n);
      }
      function XT(s, e, t) {
        var i = e.pendingProps, n = i.children, r = (e.stateNode._pendingVisibility & 2) !== 0, a = s !== null ? s.memoizedState : null;
        if (Al(s, e), i.mode === "hidden" || r) {
          if (e.flags & 128) {
            if (i = a !== null ? a.baseLanes | t : t, s !== null) {
              for (n = e.child = s.child, r = 0; n !== null; ) r = r | n.lanes | n.childLanes, n = n.sibling;
              e.childLanes = r & ~i;
            } else e.childLanes = 0, e.child = null;
            return hx(s, e, i, t);
          }
          if (t & 536870912) e.memoizedState = {
            baseLanes: 0,
            cachePool: null
          }, s !== null && Yc(e, a !== null ? a.cachePool : null), a !== null ? ex(e, a) : nm(), lT(e);
          else return e.lanes = e.childLanes = 536870912, hx(s, e, a !== null ? a.baseLanes | t : t, t);
        } else a !== null ? (Yc(e, a.cachePool), ex(e, a), Sn(), e.memoizedState = null) : (s !== null && Yc(e, null), nm(), Sn());
        return St(s, e, n, t), e.child;
      }
      function hx(s, e, t, i) {
        var n = jg();
        return n = n === null ? null : {
          parent: at._currentValue,
          pool: n
        }, e.memoizedState = {
          baseLanes: t,
          cachePool: n
        }, s !== null && Yc(e, null), nm(), lT(e), s !== null && Nu(s, e, i, true), null;
      }
      function Al(s, e) {
        var t = e.ref;
        if (t === null) s !== null && s.ref !== null && (e.flags |= 2097664);
        else {
          if (typeof t != "function" && typeof t != "object") throw Error(D(284));
          (s === null || s.ref !== t) && (e.flags |= 2097664);
        }
      }
      function hm(s, e, t, i, n) {
        return Dr(e), t = Xg(s, e, t, i, void 0, n), i = Zg(), s !== null && !yt ? (Qg(s, e, n), Ws(s, e, n)) : (ge && i && Hg(e), e.flags |= 1, St(s, e, t, n), e.child);
      }
      function dx(s, e, t, i, n, r) {
        return Dr(e), e.updateQueue = null, t = hT(e, i, t, n), cT(s), i = Zg(), s !== null && !yt ? (Qg(s, e, r), Ws(s, e, r)) : (ge && i && Hg(e), e.flags |= 1, St(s, e, t, r), e.child);
      }
      function fx(s, e, t, i, n) {
        if (Dr(e), e.stateNode === null) {
          var r = Da, a = t.contextType;
          typeof a == "object" && a !== null && (r = Ct(a)), r = new t(i, r), e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, r.updater = um, e.stateNode = r, r._reactInternals = e, r = e.stateNode, r.props = i, r.state = e.memoizedState, r.refs = {}, oy(e), a = t.contextType, r.context = typeof a == "object" && a !== null ? Ct(a) : Da, r.state = e.memoizedState, a = t.getDerivedStateFromProps, typeof a == "function" && (df(e, t, a, i), r.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (a = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), a !== r.state && um.enqueueReplaceState(r, r.state, null), El(e, i, r, n), wl(), r.state = e.memoizedState), typeof r.componentDidMount == "function" && (e.flags |= 4194308), i = true;
        } else if (s === null) {
          r = e.stateNode;
          var l = e.memoizedProps, o = Br(t, l);
          r.props = o;
          var u = r.context, c = t.contextType;
          a = Da, typeof c == "object" && c !== null && (a = Ct(c));
          var h = t.getDerivedStateFromProps;
          c = typeof h == "function" || typeof r.getSnapshotBeforeUpdate == "function", l = e.pendingProps !== l, c || typeof r.UNSAFE_componentWillReceiveProps != "function" && typeof r.componentWillReceiveProps != "function" || (l || u !== a) && ox(e, r, i, a), xn = false;
          var d = e.memoizedState;
          r.state = d, El(e, i, r, n), wl(), u = e.memoizedState, l || d !== u || xn ? (typeof h == "function" && (df(e, t, h, i), u = e.memoizedState), (o = xn || ax(e, t, o, i, d, u, a)) ? (c || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount()), typeof r.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof r.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = u), r.props = i, r.state = u, r.context = a, i = o) : (typeof r.componentDidMount == "function" && (e.flags |= 4194308), i = false);
        } else {
          r = e.stateNode, ym(s, e), a = e.memoizedProps, c = Br(t, a), r.props = c, h = e.pendingProps, d = r.context, u = t.contextType, o = Da, typeof u == "object" && u !== null && (o = Ct(u)), l = t.getDerivedStateFromProps, (u = typeof l == "function" || typeof r.getSnapshotBeforeUpdate == "function") || typeof r.UNSAFE_componentWillReceiveProps != "function" && typeof r.componentWillReceiveProps != "function" || (a !== h || d !== o) && ox(e, r, i, o), xn = false, d = e.memoizedState, r.state = d, El(e, i, r, n), wl();
          var f = e.memoizedState;
          a !== h || d !== f || xn || s !== null && s.dependencies !== null && Nh(s.dependencies) ? (typeof l == "function" && (df(e, t, l, i), f = e.memoizedState), (c = xn || ax(e, t, c, i, d, f, o) || s !== null && s.dependencies !== null && Nh(s.dependencies)) ? (u || typeof r.UNSAFE_componentWillUpdate != "function" && typeof r.componentWillUpdate != "function" || (typeof r.componentWillUpdate == "function" && r.componentWillUpdate(i, f, o), typeof r.UNSAFE_componentWillUpdate == "function" && r.UNSAFE_componentWillUpdate(i, f, o)), typeof r.componentDidUpdate == "function" && (e.flags |= 4), typeof r.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof r.componentDidUpdate != "function" || a === s.memoizedProps && d === s.memoizedState || (e.flags |= 4), typeof r.getSnapshotBeforeUpdate != "function" || a === s.memoizedProps && d === s.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = f), r.props = i, r.state = f, r.context = o, i = c) : (typeof r.componentDidUpdate != "function" || a === s.memoizedProps && d === s.memoizedState || (e.flags |= 4), typeof r.getSnapshotBeforeUpdate != "function" || a === s.memoizedProps && d === s.memoizedState || (e.flags |= 1024), i = false);
        }
        return r = i, Al(s, e), i = (e.flags & 128) !== 0, r || i ? (r = e.stateNode, t = i && typeof t.getDerivedStateFromError != "function" ? null : r.render(), e.flags |= 1, s !== null && i ? (e.child = Rr(e, s.child, null, n), e.child = Rr(e, null, t, n)) : St(s, e, t, n), e.memoizedState = r.state, s = e.child) : s = Ws(s, e, n), s;
      }
      function px(s, e, t, i) {
        return vu(), e.flags |= 256, St(s, e, t, i), e.child;
      }
      var ff = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
      };
      function pf(s) {
        return {
          baseLanes: s,
          cachePool: uT()
        };
      }
      function mf(s, e, t) {
        return s = s !== null ? s.childLanes & ~t : 0, e && (s |= Ri), s;
      }
      function ZT(s, e, t) {
        var i = e.pendingProps, n = false, r = (e.flags & 128) !== 0, a;
        if ((a = r) || (a = s !== null && s.memoizedState === null ? false : (ot.current & 2) !== 0), a && (n = true, e.flags &= -129), a = (e.flags & 32) !== 0, e.flags &= -33, s === null) {
          if (ge) {
            if (n ? bn(e) : Sn(), ge) {
              var l = vt, o;
              if (o = l) {
                e: {
                  for (o = l, l = Ji; o.nodeType !== 8; ) {
                    if (!l) {
                      l = null;
                      break e;
                    }
                    if (o = Yi(o.nextSibling), o === null) {
                      l = null;
                      break e;
                    }
                  }
                  l = o;
                }
                l !== null ? (e.memoizedState = {
                  dehydrated: l,
                  treeContext: Sr !== null ? {
                    id: Us,
                    overflow: Fs
                  } : null,
                  retryLane: 536870912
                }, o = Ei(18, null, null, 0), o.stateNode = l, o.return = e, e.child = o, Ut = e, vt = null, o = true) : o = false;
              }
              o || Er(e);
            }
            if (l = e.memoizedState, l !== null && (l = l.dehydrated, l !== null)) return l.data === "$!" ? e.lanes = 16 : e.lanes = 536870912, null;
            Os(e);
          }
          return l = i.children, i = i.fallback, n ? (Sn(), n = e.mode, l = fm({
            mode: "hidden",
            children: l
          }, n), i = vr(i, n, t, null), l.return = e, i.return = e, l.sibling = i, e.child = l, n = e.child, n.memoizedState = pf(t), n.childLanes = mf(s, a, t), e.memoizedState = ff, i) : (bn(e), dm(e, l));
        }
        if (o = s.memoizedState, o !== null && (l = o.dehydrated, l !== null)) {
          if (r) e.flags & 256 ? (bn(e), e.flags &= -257, e = gf(s, e, t)) : e.memoizedState !== null ? (Sn(), e.child = s.child, e.flags |= 128, e = null) : (Sn(), n = i.fallback, l = e.mode, i = fm({
            mode: "visible",
            children: i.children
          }, l), n = vr(n, l, t, null), n.flags |= 2, i.return = e, n.return = e, i.sibling = n, e.child = i, Rr(e, s.child, null, t), i = e.child, i.memoizedState = pf(t), i.childLanes = mf(s, a, t), e.memoizedState = ff, e = n);
          else if (bn(e), l.data === "$!") {
            if (a = l.nextSibling && l.nextSibling.dataset, a) var u = a.dgst;
            a = u, i = Error(D(419)), i.stack = "", i.digest = a, Wl({
              value: i,
              source: null,
              stack: null
            }), e = gf(s, e, t);
          } else if (yt || Nu(s, e, t, false), a = (t & s.childLanes) !== 0, yt || a) {
            if (a = Re, a !== null) {
              if (i = t & -t, i & 42) i = 1;
              else switch (i) {
                case 2:
                  i = 1;
                  break;
                case 8:
                  i = 4;
                  break;
                case 32:
                  i = 16;
                  break;
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                  i = 64;
                  break;
                case 268435456:
                  i = 134217728;
                  break;
                default:
                  i = 0;
              }
              if (i = i & (a.suspendedLanes | t) ? 0 : i, i !== 0 && i !== o.retryLane) throw o.retryLane = i, qn(s, i), zt(a, s, i), jT;
            }
            l.data === "$?" || Am(), e = gf(s, e, t);
          } else l.data === "$?" ? (e.flags |= 128, e.child = s.child, e = Pw.bind(null, s), l._reactRetry = e, e = null) : (s = o.treeContext, vt = Yi(l.nextSibling), Ut = e, ge = true, Ii = null, Ji = false, s !== null && (Ti[vi++] = Us, Ti[vi++] = Fs, Ti[vi++] = Sr, Us = s.id, Fs = s.overflow, Sr = e), e = dm(e, i.children), e.flags |= 4096);
          return e;
        }
        return n ? (Sn(), n = i.fallback, l = e.mode, o = s.child, u = o.sibling, i = On(o, {
          mode: "hidden",
          children: i.children
        }), i.subtreeFlags = o.subtreeFlags & 31457280, u !== null ? n = On(u, n) : (n = vr(n, l, t, null), n.flags |= 2), n.return = e, i.return = e, i.sibling = n, e.child = i, i = n, n = e.child, l = s.child.memoizedState, l === null ? l = pf(t) : (o = l.cachePool, o !== null ? (u = at._currentValue, o = o.parent !== u ? {
          parent: u,
          pool: u
        } : o) : o = uT(), l = {
          baseLanes: l.baseLanes | t,
          cachePool: o
        }), n.memoizedState = l, n.childLanes = mf(s, a, t), e.memoizedState = ff, i) : (bn(e), t = s.child, s = t.sibling, t = On(t, {
          mode: "visible",
          children: i.children
        }), t.return = e, t.sibling = null, s !== null && (a = e.deletions, a === null ? (e.deletions = [
          s
        ], e.flags |= 16) : a.push(s)), e.child = t, e.memoizedState = null, t);
      }
      function dm(s, e) {
        return e = fm({
          mode: "visible",
          children: e
        }, s.mode), e.return = s, s.child = e;
      }
      function fm(s, e) {
        return x1(s, e, 0, null);
      }
      function gf(s, e, t) {
        return Rr(e, s.child, null, t), s = dm(e, e.pendingProps.children), s.flags |= 2, e.memoizedState = null, s;
      }
      function mx(s, e, t) {
        s.lanes |= e;
        var i = s.alternate;
        i !== null && (i.lanes |= e), mm(s.return, e, t);
      }
      function yf(s, e, t, i, n) {
        var r = s.memoizedState;
        r === null ? s.memoizedState = {
          isBackwards: e,
          rendering: null,
          renderingStartTime: 0,
          last: i,
          tail: t,
          tailMode: n
        } : (r.isBackwards = e, r.rendering = null, r.renderingStartTime = 0, r.last = i, r.tail = t, r.tailMode = n);
      }
      function QT(s, e, t) {
        var i = e.pendingProps, n = i.revealOrder, r = i.tail;
        if (St(s, e, i.children, t), i = ot.current, i & 2) i = i & 1 | 2, e.flags |= 128;
        else {
          if (s !== null && s.flags & 128) e: for (s = e.child; s !== null; ) {
            if (s.tag === 13) s.memoizedState !== null && mx(s, t, e);
            else if (s.tag === 19) mx(s, t, e);
            else if (s.child !== null) {
              s.child.return = s, s = s.child;
              continue;
            }
            if (s === e) break e;
            for (; s.sibling === null; ) {
              if (s.return === null || s.return === e) break e;
              s = s.return;
            }
            s.sibling.return = s.return, s = s.sibling;
          }
          i &= 1;
        }
        switch (Oe(ot, i), n) {
          case "forwards":
            for (t = e.child, n = null; t !== null; ) s = t.alternate, s !== null && Sh(s) === null && (n = t), t = t.sibling;
            t = n, t === null ? (n = e.child, e.child = null) : (n = t.sibling, t.sibling = null), yf(e, false, n, t, r);
            break;
          case "backwards":
            for (t = null, n = e.child, e.child = null; n !== null; ) {
              if (s = n.alternate, s !== null && Sh(s) === null) {
                e.child = n;
                break;
              }
              s = n.sibling, n.sibling = t, t = n, n = s;
            }
            yf(e, true, t, null, r);
            break;
          case "together":
            yf(e, false, null, null, void 0);
            break;
          default:
            e.memoizedState = null;
        }
        return e.child;
      }
      function Ws(s, e, t) {
        if (s !== null && (e.dependencies = s.dependencies), jn |= e.lanes, !(t & e.childLanes)) if (s !== null) {
          if (Nu(s, e, t, false), (t & e.childLanes) === 0) return null;
        } else return null;
        if (s !== null && e.child !== s.child) throw Error(D(153));
        if (e.child !== null) {
          for (s = e.child, t = On(s, s.pendingProps), e.child = t, t.return = e; s.sibling !== null; ) s = s.sibling, t = t.sibling = On(s, s.pendingProps), t.return = e;
          t.sibling = null;
        }
        return e.child;
      }
      function ay(s, e) {
        return s.lanes & e ? true : (s = s.dependencies, !!(s !== null && Nh(s)));
      }
      function Aw(s, e, t) {
        switch (e.tag) {
          case 3:
            dh(e, e.stateNode.containerInfo), Tn(e, at, s.memoizedState.cache), vu();
            break;
          case 27:
          case 5:
            jp(e);
            break;
          case 4:
            dh(e, e.stateNode.containerInfo);
            break;
          case 10:
            Tn(e, e.type, e.memoizedProps.value);
            break;
          case 13:
            var i = e.memoizedState;
            if (i !== null) return i.dehydrated !== null ? (bn(e), e.flags |= 128, null) : t & e.child.childLanes ? ZT(s, e, t) : (bn(e), s = Ws(s, e, t), s !== null ? s.sibling : null);
            bn(e);
            break;
          case 19:
            var n = (s.flags & 128) !== 0;
            if (i = (t & e.childLanes) !== 0, i || (Nu(s, e, t, false), i = (t & e.childLanes) !== 0), n) {
              if (i) return QT(s, e, t);
              e.flags |= 128;
            }
            if (n = e.memoizedState, n !== null && (n.rendering = null, n.tail = null, n.lastEffect = null), Oe(ot, ot.current), i) break;
            return null;
          case 22:
          case 23:
            return e.lanes = 0, XT(s, e, t);
          case 24:
            Tn(e, at, s.memoizedState.cache);
        }
        return Ws(s, e, t);
      }
      function KT(s, e, t) {
        if (s !== null) if (s.memoizedProps !== e.pendingProps) yt = true;
        else {
          if (!ay(s, t) && !(e.flags & 128)) return yt = false, Aw(s, e, t);
          yt = !!(s.flags & 131072);
        }
        else yt = false, ge && e.flags & 1048576 && sT(e, _h, e.index);
        switch (e.lanes = 0, e.tag) {
          case 16:
            e: {
              s = e.pendingProps;
              var i = e.elementType, n = i._init;
              if (i = n(i._payload), e.type = i, typeof i == "function") cy(i) ? (s = Br(i, s), e.tag = 1, e = fx(null, e, i, s, t)) : (e.tag = 0, e = hm(null, e, i, s, t));
              else {
                if (i != null) {
                  if (n = i.$$typeof, n === Bg) {
                    e.tag = 11, e = ux(null, e, i, s, t);
                    break e;
                  } else if (n === Dg) {
                    e.tag = 14, e = cx(null, e, i, s, t);
                    break e;
                  }
                }
                throw e = Yp(i) || i, Error(D(306, e, ""));
              }
            }
            return e;
          case 0:
            return hm(s, e, e.type, e.pendingProps, t);
          case 1:
            return i = e.type, n = Br(i, e.pendingProps), fx(s, e, i, n, t);
          case 3:
            e: {
              if (dh(e, e.stateNode.containerInfo), s === null) throw Error(D(387));
              var r = e.pendingProps;
              n = e.memoizedState, i = n.element, ym(s, e), El(e, r, null, t);
              var a = e.memoizedState;
              if (r = a.cache, Tn(e, at, r), r !== n.cache && gm(e, [
                at
              ], t, true), wl(), r = a.element, n.isDehydrated) if (n = {
                element: r,
                isDehydrated: false,
                cache: a.cache
              }, e.updateQueue.baseState = n, e.memoizedState = n, e.flags & 256) {
                e = px(s, e, r, t);
                break e;
              } else if (r !== i) {
                i = Ni(Error(D(424)), e), Wl(i), e = px(s, e, r, t);
                break e;
              } else for (vt = Yi(e.stateNode.containerInfo.firstChild), Ut = e, ge = true, Ii = null, Ji = true, t = oT(e, null, r, t), e.child = t; t; ) t.flags = t.flags & -3 | 4096, t = t.sibling;
              else {
                if (vu(), r === i) {
                  e = Ws(s, e, t);
                  break e;
                }
                St(s, e, r, t);
              }
              e = e.child;
            }
            return e;
          case 26:
            return Al(s, e), s === null ? (t = Ux(e.type, null, e.pendingProps, null)) ? e.memoizedState = t : ge || (t = e.type, s = e.pendingProps, i = Uh(Dn.current).createElement(t), i[Rt] = e, i[Xt] = s, Mt(i, t, s), mt(i), e.stateNode = i) : e.memoizedState = Ux(e.type, s.memoizedProps, e.pendingProps, s.memoizedState), null;
          case 27:
            return jp(e), s === null && ge && (i = e.stateNode = z1(e.type, e.pendingProps, Dn.current), Ut = e, Ji = true, vt = Yi(i.firstChild)), i = e.pendingProps.children, s !== null || ge ? St(s, e, i, t) : e.child = Rr(e, null, i, t), Al(s, e), e.child;
          case 5:
            return s === null && ge && ((n = i = vt) && (i = tE(i, e.type, e.pendingProps, Ji), i !== null ? (e.stateNode = i, Ut = e, vt = Yi(i.firstChild), Ji = false, n = true) : n = false), n || Er(e)), jp(e), n = e.type, r = e.pendingProps, a = s !== null ? s.memoizedProps : null, i = r.children, Cm(n, r) ? i = null : a !== null && Cm(n, a) && (e.flags |= 32), e.memoizedState !== null && (n = Xg(s, e, xw, null, null, t), Kl._currentValue = n), Al(s, e), St(s, e, i, t), e.child;
          case 6:
            return s === null && ge && ((s = t = vt) && (t = iE(t, e.pendingProps, Ji), t !== null ? (e.stateNode = t, Ut = e, vt = null, s = true) : s = false), s || Er(e)), null;
          case 13:
            return ZT(s, e, t);
          case 4:
            return dh(e, e.stateNode.containerInfo), i = e.pendingProps, s === null ? e.child = Rr(e, null, i, t) : St(s, e, i, t), e.child;
          case 11:
            return ux(s, e, e.type, e.pendingProps, t);
          case 7:
            return St(s, e, e.pendingProps, t), e.child;
          case 8:
            return St(s, e, e.pendingProps.children, t), e.child;
          case 12:
            return St(s, e, e.pendingProps.children, t), e.child;
          case 10:
            return i = e.pendingProps, Tn(e, e.type, i.value), St(s, e, i.children, t), e.child;
          case 9:
            return n = e.type._context, i = e.pendingProps.children, Dr(e), n = Ct(n), i = i(n), e.flags |= 1, St(s, e, i, t), e.child;
          case 14:
            return cx(s, e, e.type, e.pendingProps, t);
          case 15:
            return $T(s, e, e.type, e.pendingProps, t);
          case 19:
            return QT(s, e, t);
          case 22:
            return XT(s, e, t);
          case 24:
            return Dr(e), i = Ct(at), s === null ? (n = jg(), n === null && (n = Re, r = Wg(), n.pooledCache = r, r.refCount++, r !== null && (n.pooledCacheLanes |= t), n = r), e.memoizedState = {
              parent: i,
              cache: n
            }, oy(e), Tn(e, at, n)) : (s.lanes & t && (ym(s, e), El(e, null, null, t), wl()), n = s.memoizedState, r = e.memoizedState, n.parent !== i ? (n = {
              parent: i,
              cache: i
            }, e.memoizedState = n, e.lanes === 0 && (e.memoizedState = e.updateQueue.baseState = n), Tn(e, at, i)) : (i = r.cache, Tn(e, at, i), i !== n.cache && gm(e, [
              at
            ], t, true))), St(s, e, e.pendingProps.children, t), e.child;
          case 29:
            throw e.pendingProps;
        }
        throw Error(D(156, e.tag));
      }
      var pm = cs(null), Wr = null, zs = null;
      function Tn(s, e, t) {
        Oe(pm, e._currentValue), e._currentValue = t;
      }
      function Gs(s) {
        s._currentValue = pm.current, xt(pm);
      }
      function mm(s, e, t) {
        for (; s !== null; ) {
          var i = s.alternate;
          if ((s.childLanes & e) !== e ? (s.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), s === t) break;
          s = s.return;
        }
      }
      function gm(s, e, t, i) {
        var n = s.child;
        for (n !== null && (n.return = s); n !== null; ) {
          var r = n.dependencies;
          if (r !== null) {
            var a = n.child;
            r = r.firstContext;
            e: for (; r !== null; ) {
              var l = r;
              r = n;
              for (var o = 0; o < e.length; o++) if (l.context === e[o]) {
                r.lanes |= t, l = r.alternate, l !== null && (l.lanes |= t), mm(r.return, t, s), i || (a = null);
                break e;
              }
              r = l.next;
            }
          } else if (n.tag === 18) {
            if (a = n.return, a === null) throw Error(D(341));
            a.lanes |= t, r = a.alternate, r !== null && (r.lanes |= t), mm(a, t, s), a = null;
          } else a = n.child;
          if (a !== null) a.return = n;
          else for (a = n; a !== null; ) {
            if (a === s) {
              a = null;
              break;
            }
            if (n = a.sibling, n !== null) {
              n.return = a.return, a = n;
              break;
            }
            a = a.return;
          }
          n = a;
        }
      }
      function Nu(s, e, t, i) {
        s = null;
        for (var n = e, r = false; n !== null; ) {
          if (!r) {
            if (n.flags & 524288) r = true;
            else if (n.flags & 262144) break;
          }
          if (n.tag === 10) {
            var a = n.alternate;
            if (a === null) throw Error(D(387));
            if (a = a.memoizedProps, a !== null) {
              var l = n.type;
              di(n.pendingProps.value, a.value) || (s !== null ? s.push(l) : s = [
                l
              ]);
            }
          } else if (n === hh.current) {
            if (a = n.alternate, a === null) throw Error(D(387));
            a.memoizedState.memoizedState !== n.memoizedState.memoizedState && (s !== null ? s.push(Kl) : s = [
              Kl
            ]);
          }
          n = n.return;
        }
        s !== null && gm(e, s, t, i), e.flags |= 262144;
      }
      function Nh(s) {
        for (s = s.firstContext; s !== null; ) {
          if (!di(s.context._currentValue, s.memoizedValue)) return true;
          s = s.next;
        }
        return false;
      }
      function Dr(s) {
        Wr = s, zs = null, s = s.dependencies, s !== null && (s.firstContext = null);
      }
      function Ct(s) {
        return JT(Wr, s);
      }
      function Xu(s, e) {
        return Wr === null && Dr(s), JT(s, e);
      }
      function JT(s, e) {
        var t = e._currentValue;
        if (e = {
          context: e,
          memoizedValue: t,
          next: null
        }, zs === null) {
          if (s === null) throw Error(D(308));
          zs = e, s.dependencies = {
            lanes: 0,
            firstContext: e
          }, s.flags |= 524288;
        } else zs = zs.next = e;
        return t;
      }
      var xn = false;
      function oy(s) {
        s.updateQueue = {
          baseState: s.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null,
            lanes: 0,
            hiddenCallbacks: null
          },
          callbacks: null
        };
      }
      function ym(s, e) {
        s = s.updateQueue, e.updateQueue === s && (e.updateQueue = {
          baseState: s.baseState,
          firstBaseUpdate: s.firstBaseUpdate,
          lastBaseUpdate: s.lastBaseUpdate,
          shared: s.shared,
          callbacks: null
        });
      }
      function Un(s) {
        return {
          lane: s,
          tag: 0,
          payload: null,
          callback: null,
          next: null
        };
      }
      function Fn(s, e, t) {
        var i = s.updateQueue;
        if (i === null) return null;
        if (i = i.shared, ke & 2) {
          var n = i.pending;
          return n === null ? e.next = e : (e.next = n.next, n.next = e), i.pending = e, e = yh(s), iT(s, null, t), e;
        }
        return yd(s, i, e, t), yh(s);
      }
      function Nl(s, e, t) {
        if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194176) !== 0)) {
          var i = e.lanes;
          i &= s.pendingLanes, t |= i, e.lanes = t, RS(s, t);
        }
      }
      function xf(s, e) {
        var t = s.updateQueue, i = s.alternate;
        if (i !== null && (i = i.updateQueue, t === i)) {
          var n = null, r = null;
          if (t = t.firstBaseUpdate, t !== null) {
            do {
              var a = {
                lane: t.lane,
                tag: t.tag,
                payload: t.payload,
                callback: null,
                next: null
              };
              r === null ? n = r = a : r = r.next = a, t = t.next;
            } while (t !== null);
            r === null ? n = r = e : r = r.next = e;
          } else n = r = e;
          t = {
            baseState: i.baseState,
            firstBaseUpdate: n,
            lastBaseUpdate: r,
            shared: i.shared,
            callbacks: i.callbacks
          }, s.updateQueue = t;
          return;
        }
        s = t.lastBaseUpdate, s === null ? t.firstBaseUpdate = e : s.next = e, t.lastBaseUpdate = e;
      }
      var xm = false;
      function wl() {
        if (xm) {
          var s = ja;
          if (s !== null) throw s;
        }
      }
      function El(s, e, t, i) {
        xm = false;
        var n = s.updateQueue;
        xn = false;
        var r = n.firstBaseUpdate, a = n.lastBaseUpdate, l = n.shared.pending;
        if (l !== null) {
          n.shared.pending = null;
          var o = l, u = o.next;
          o.next = null, a === null ? r = u : a.next = u, a = o;
          var c = s.alternate;
          c !== null && (c = c.updateQueue, l = c.lastBaseUpdate, l !== a && (l === null ? c.firstBaseUpdate = u : l.next = u, c.lastBaseUpdate = o));
        }
        if (r !== null) {
          var h = n.baseState;
          a = 0, c = u = o = null, l = r;
          do {
            var d = l.lane & -536870913, f = d !== l.lane;
            if (f ? (he & d) === d : (i & d) === d) {
              d !== 0 && d === uo && (xm = true), c !== null && (c = c.next = {
                lane: 0,
                tag: l.tag,
                payload: l.payload,
                callback: null,
                next: null
              });
              e: {
                var p = s, g = l;
                d = e;
                var _ = t;
                switch (g.tag) {
                  case 1:
                    if (p = g.payload, typeof p == "function") {
                      h = p.call(_, h, d);
                      break e;
                    }
                    h = p;
                    break e;
                  case 3:
                    p.flags = p.flags & -65537 | 128;
                  case 0:
                    if (p = g.payload, d = typeof p == "function" ? p.call(_, h, d) : p, d == null) break e;
                    h = Ue({}, h, d);
                    break e;
                  case 2:
                    xn = true;
                }
              }
              d = l.callback, d !== null && (s.flags |= 64, f && (s.flags |= 8192), f = n.callbacks, f === null ? n.callbacks = [
                d
              ] : f.push(d));
            } else f = {
              lane: d,
              tag: l.tag,
              payload: l.payload,
              callback: l.callback,
              next: null
            }, c === null ? (u = c = f, o = h) : c = c.next = f, a |= d;
            if (l = l.next, l === null) {
              if (l = n.shared.pending, l === null) break;
              f = l, l = f.next, f.next = null, n.lastBaseUpdate = f, n.shared.pending = null;
            }
          } while (true);
          c === null && (o = h), n.baseState = o, n.firstBaseUpdate = u, n.lastBaseUpdate = c, r === null && (n.shared.lanes = 0), jn |= a, s.lanes = a, s.memoizedState = h;
        }
      }
      function e1(s, e) {
        if (typeof s != "function") throw Error(D(191, s));
        s.call(e);
      }
      function t1(s, e) {
        var t = s.callbacks;
        if (t !== null) for (s.callbacks = null, s = 0; s < t.length; s++) e1(t[s], e);
      }
      function wu(s, e) {
        try {
          var t = e.updateQueue, i = t !== null ? t.lastEffect : null;
          if (i !== null) {
            var n = i.next;
            t = n;
            do {
              if ((t.tag & s) === s) {
                i = void 0;
                var r = t.create, a = t.inst;
                i = r(), a.destroy = i;
              }
              t = t.next;
            } while (t !== n);
          }
        } catch (l) {
          we(e, e.return, l);
        }
      }
      function Wn(s, e, t) {
        try {
          var i = e.updateQueue, n = i !== null ? i.lastEffect : null;
          if (n !== null) {
            var r = n.next;
            i = r;
            do {
              if ((i.tag & s) === s) {
                var a = i.inst, l = a.destroy;
                if (l !== void 0) {
                  a.destroy = void 0, n = e;
                  var o = t;
                  try {
                    l();
                  } catch (u) {
                    we(n, o, u);
                  }
                }
              }
              i = i.next;
            } while (i !== r);
          }
        } catch (u) {
          we(e, e.return, u);
        }
      }
      function i1(s) {
        var e = s.updateQueue;
        if (e !== null) {
          var t = s.stateNode;
          try {
            t1(e, t);
          } catch (i) {
            we(s, s.return, i);
          }
        }
      }
      function s1(s, e, t) {
        t.props = Br(s.type, s.memoizedProps), t.state = s.memoizedState;
        try {
          t.componentWillUnmount();
        } catch (i) {
          we(s, e, i);
        }
      }
      function _r(s, e) {
        try {
          var t = s.ref;
          if (t !== null) {
            var i = s.stateNode;
            switch (s.tag) {
              case 26:
              case 27:
              case 5:
                var n = i;
                break;
              default:
                n = i;
            }
            typeof t == "function" ? s.refCleanup = t(n) : t.current = n;
          }
        } catch (r) {
          we(s, e, r);
        }
      }
      function oi(s, e) {
        var t = s.ref, i = s.refCleanup;
        if (t !== null) if (typeof i == "function") try {
          i();
        } catch (n) {
          we(s, e, n);
        } finally {
          s.refCleanup = null, s = s.alternate, s != null && (s.refCleanup = null);
        }
        else if (typeof t == "function") try {
          t(null);
        } catch (n) {
          we(s, e, n);
        }
        else t.current = null;
      }
      function n1(s) {
        var e = s.type, t = s.memoizedProps, i = s.stateNode;
        try {
          e: switch (e) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              t.autoFocus && i.focus();
              break e;
            case "img":
              t.src ? i.src = t.src : t.srcSet && (i.srcset = t.srcSet);
          }
        } catch (n) {
          we(s, s.return, n);
        }
      }
      function gx(s, e, t) {
        try {
          var i = s.stateNode;
          Zw(i, s.type, t, e), i[Xt] = e;
        } catch (n) {
          we(s, s.return, n);
        }
      }
      function r1(s) {
        return s.tag === 5 || s.tag === 3 || s.tag === 26 || s.tag === 27 || s.tag === 4;
      }
      function _f(s) {
        e: for (; ; ) {
          for (; s.sibling === null; ) {
            if (s.return === null || r1(s.return)) return null;
            s = s.return;
          }
          for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 27 && s.tag !== 18; ) {
            if (s.flags & 2 || s.child === null || s.tag === 4) continue e;
            s.child.return = s, s = s.child;
          }
          if (!(s.flags & 2)) return s.stateNode;
        }
      }
      function _m(s, e, t) {
        var i = s.tag;
        if (i === 5 || i === 6) s = s.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(s, e) : t.insertBefore(s, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(s, t)) : (e = t, e.appendChild(s)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = Md));
        else if (i !== 4 && i !== 27 && (s = s.child, s !== null)) for (_m(s, e, t), s = s.sibling; s !== null; ) _m(s, e, t), s = s.sibling;
      }
      function wh(s, e, t) {
        var i = s.tag;
        if (i === 5 || i === 6) s = s.stateNode, e ? t.insertBefore(s, e) : t.appendChild(s);
        else if (i !== 4 && i !== 27 && (s = s.child, s !== null)) for (wh(s, e, t), s = s.sibling; s !== null; ) wh(s, e, t), s = s.sibling;
      }
      var ws = false, Ie = false, bf = false, yx = typeof WeakSet == "function" ? WeakSet : Set, pt = null, xx = false;
      function Nw(s, e) {
        if (s = s.containerInfo, Em = Lh, s = XS(s), kg(s)) {
          if ("selectionStart" in s) var t = {
            start: s.selectionStart,
            end: s.selectionEnd
          };
          else e: {
            t = (t = s.ownerDocument) && t.defaultView || window;
            var i = t.getSelection && t.getSelection();
            if (i && i.rangeCount !== 0) {
              t = i.anchorNode;
              var n = i.anchorOffset, r = i.focusNode;
              i = i.focusOffset;
              try {
                t.nodeType, r.nodeType;
              } catch {
                t = null;
                break e;
              }
              var a = 0, l = -1, o = -1, u = 0, c = 0, h = s, d = null;
              t: for (; ; ) {
                for (var f; h !== t || n !== 0 && h.nodeType !== 3 || (l = a + n), h !== r || i !== 0 && h.nodeType !== 3 || (o = a + i), h.nodeType === 3 && (a += h.nodeValue.length), (f = h.firstChild) !== null; ) d = h, h = f;
                for (; ; ) {
                  if (h === s) break t;
                  if (d === t && ++u === n && (l = a), d === r && ++c === i && (o = a), (f = h.nextSibling) !== null) break;
                  h = d, d = h.parentNode;
                }
                h = f;
              }
              t = l === -1 || o === -1 ? null : {
                start: l,
                end: o
              };
            } else t = null;
          }
          t = t || {
            start: 0,
            end: 0
          };
        } else t = null;
        for (Rm = {
          focusedElem: s,
          selectionRange: t
        }, Lh = false, pt = e; pt !== null; ) if (e = pt, s = e.child, (e.subtreeFlags & 1028) !== 0 && s !== null) s.return = e, pt = s;
        else for (; pt !== null; ) {
          switch (e = pt, r = e.alternate, s = e.flags, e.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if (s & 1024 && r !== null) {
                s = void 0, t = e, n = r.memoizedProps, r = r.memoizedState, i = t.stateNode;
                try {
                  var p = Br(t.type, n, t.elementType === t.type);
                  s = i.getSnapshotBeforeUpdate(p, r), i.__reactInternalSnapshotBeforeUpdate = s;
                } catch (g) {
                  we(t, t.return, g);
                }
              }
              break;
            case 3:
              if (s & 1024) {
                if (s = e.stateNode.containerInfo, t = s.nodeType, t === 9) Bm(s);
                else if (t === 1) switch (s.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    Bm(s);
                    break;
                  default:
                    s.textContent = "";
                }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if (s & 1024) throw Error(D(163));
          }
          if (s = e.sibling, s !== null) {
            s.return = e.return, pt = s;
            break;
          }
          pt = e.return;
        }
        return p = xx, xx = false, p;
      }
      function a1(s, e, t) {
        var i = t.flags;
        switch (t.tag) {
          case 0:
          case 11:
          case 15:
            gs(s, t), i & 4 && wu(5, t);
            break;
          case 1:
            if (gs(s, t), i & 4) if (s = t.stateNode, e === null) try {
              s.componentDidMount();
            } catch (l) {
              we(t, t.return, l);
            }
            else {
              var n = Br(t.type, e.memoizedProps);
              e = e.memoizedState;
              try {
                s.componentDidUpdate(n, e, s.__reactInternalSnapshotBeforeUpdate);
              } catch (l) {
                we(t, t.return, l);
              }
            }
            i & 64 && i1(t), i & 512 && _r(t, t.return);
            break;
          case 3:
            if (gs(s, t), i & 64 && (i = t.updateQueue, i !== null)) {
              if (s = null, t.child !== null) switch (t.child.tag) {
                case 27:
                case 5:
                  s = t.child.stateNode;
                  break;
                case 1:
                  s = t.child.stateNode;
              }
              try {
                t1(i, s);
              } catch (l) {
                we(t, t.return, l);
              }
            }
            break;
          case 26:
            gs(s, t), i & 512 && _r(t, t.return);
            break;
          case 27:
          case 5:
            gs(s, t), e === null && i & 4 && n1(t), i & 512 && _r(t, t.return);
            break;
          case 12:
            gs(s, t);
            break;
          case 13:
            gs(s, t), i & 4 && u1(s, t);
            break;
          case 22:
            if (n = t.memoizedState !== null || ws, !n) {
              e = e !== null && e.memoizedState !== null || Ie;
              var r = ws, a = Ie;
              ws = n, (Ie = e) && !a ? gn(s, t, (t.subtreeFlags & 8772) !== 0) : gs(s, t), ws = r, Ie = a;
            }
            i & 512 && (t.memoizedProps.mode === "manual" ? _r(t, t.return) : oi(t, t.return));
            break;
          default:
            gs(s, t);
        }
      }
      function o1(s) {
        var e = s.alternate;
        e !== null && (s.alternate = null, o1(e)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (e = s.stateNode, e !== null && Fg(e)), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
      }
      var $e = null, ni = false;
      function ms(s, e, t) {
        for (t = t.child; t !== null; ) l1(s, e, t), t = t.sibling;
      }
      function l1(s, e, t) {
        if (ui && typeof ui.onCommitFiberUnmount == "function") try {
          ui.onCommitFiberUnmount(_u, t);
        } catch {
        }
        switch (t.tag) {
          case 26:
            Ie || oi(t, e), ms(s, e, t), t.memoizedState ? t.memoizedState.count-- : t.stateNode && (t = t.stateNode, t.parentNode.removeChild(t));
            break;
          case 27:
            Ie || oi(t, e);
            var i = $e, n = ni;
            for ($e = t.stateNode, ms(s, e, t), t = t.stateNode, e = t.attributes; e.length; ) t.removeAttributeNode(e[0]);
            Fg(t), $e = i, ni = n;
            break;
          case 5:
            Ie || oi(t, e);
          case 6:
            n = $e;
            var r = ni;
            if ($e = null, ms(s, e, t), $e = n, ni = r, $e !== null) if (ni) try {
              s = $e, i = t.stateNode, s.nodeType === 8 ? s.parentNode.removeChild(i) : s.removeChild(i);
            } catch (a) {
              we(t, e, a);
            }
            else try {
              $e.removeChild(t.stateNode);
            } catch (a) {
              we(t, e, a);
            }
            break;
          case 18:
            $e !== null && (ni ? (e = $e, t = t.stateNode, e.nodeType === 8 ? Df(e.parentNode, t) : e.nodeType === 1 && Df(e, t), tu(e)) : Df($e, t.stateNode));
            break;
          case 4:
            i = $e, n = ni, $e = t.stateNode.containerInfo, ni = true, ms(s, e, t), $e = i, ni = n;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            Ie || Wn(2, t, e), Ie || Wn(4, t, e), ms(s, e, t);
            break;
          case 1:
            Ie || (oi(t, e), i = t.stateNode, typeof i.componentWillUnmount == "function" && s1(t, e, i)), ms(s, e, t);
            break;
          case 21:
            ms(s, e, t);
            break;
          case 22:
            Ie || oi(t, e), Ie = (i = Ie) || t.memoizedState !== null, ms(s, e, t), Ie = i;
            break;
          default:
            ms(s, e, t);
        }
      }
      function u1(s, e) {
        if (e.memoizedState === null && (s = e.alternate, s !== null && (s = s.memoizedState, s !== null && (s = s.dehydrated, s !== null)))) try {
          tu(s);
        } catch (t) {
          we(e, e.return, t);
        }
      }
      function ww(s) {
        switch (s.tag) {
          case 13:
          case 19:
            var e = s.stateNode;
            return e === null && (e = s.stateNode = new yx()), e;
          case 22:
            return s = s.stateNode, e = s._retryCache, e === null && (e = s._retryCache = new yx()), e;
          default:
            throw Error(D(435, s.tag));
        }
      }
      function Sf(s, e) {
        var t = ww(s);
        e.forEach(function(i) {
          var n = kw.bind(null, s, i);
          t.has(i) || (t.add(i), i.then(n, n));
        });
      }
      function mi(s, e) {
        var t = e.deletions;
        if (t !== null) for (var i = 0; i < t.length; i++) {
          var n = t[i], r = s, a = e, l = a;
          e: for (; l !== null; ) {
            switch (l.tag) {
              case 27:
              case 5:
                $e = l.stateNode, ni = false;
                break e;
              case 3:
                $e = l.stateNode.containerInfo, ni = true;
                break e;
              case 4:
                $e = l.stateNode.containerInfo, ni = true;
                break e;
            }
            l = l.return;
          }
          if ($e === null) throw Error(D(160));
          l1(r, a, n), $e = null, ni = false, r = n.alternate, r !== null && (r.return = null), n.return = null;
        }
        if (e.subtreeFlags & 13878) for (e = e.child; e !== null; ) c1(e, s), e = e.sibling;
      }
      var ki = null;
      function c1(s, e) {
        var t = s.alternate, i = s.flags;
        switch (s.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            mi(e, s), gi(s), i & 4 && (Wn(3, s, s.return), wu(3, s), Wn(5, s, s.return));
            break;
          case 1:
            mi(e, s), gi(s), i & 512 && (Ie || t === null || oi(t, t.return)), i & 64 && ws && (s = s.updateQueue, s !== null && (i = s.callbacks, i !== null && (t = s.shared.hiddenCallbacks, s.shared.hiddenCallbacks = t === null ? i : t.concat(i))));
            break;
          case 26:
            var n = ki;
            if (mi(e, s), gi(s), i & 512 && (Ie || t === null || oi(t, t.return)), i & 4) {
              var r = t !== null ? t.memoizedState : null;
              if (i = s.memoizedState, t === null) if (i === null) if (s.stateNode === null) {
                e: {
                  i = s.type, t = s.memoizedProps, n = n.ownerDocument || n;
                  t: switch (i) {
                    case "title":
                      r = n.getElementsByTagName("title")[0], (!r || r[Vl] || r[Rt] || r.namespaceURI === "http://www.w3.org/2000/svg" || r.hasAttribute("itemprop")) && (r = n.createElement(i), n.head.insertBefore(r, n.querySelector("head > title"))), Mt(r, i, t), r[Rt] = s, mt(r), i = r;
                      break e;
                    case "link":
                      var a = Ox("link", "href", n).get(i + (t.href || ""));
                      if (a) {
                        for (var l = 0; l < a.length; l++) if (r = a[l], r.getAttribute("href") === (t.href == null ? null : t.href) && r.getAttribute("rel") === (t.rel == null ? null : t.rel) && r.getAttribute("title") === (t.title == null ? null : t.title) && r.getAttribute("crossorigin") === (t.crossOrigin == null ? null : t.crossOrigin)) {
                          a.splice(l, 1);
                          break t;
                        }
                      }
                      r = n.createElement(i), Mt(r, i, t), n.head.appendChild(r);
                      break;
                    case "meta":
                      if (a = Ox("meta", "content", n).get(i + (t.content || ""))) {
                        for (l = 0; l < a.length; l++) if (r = a[l], r.getAttribute("content") === (t.content == null ? null : "" + t.content) && r.getAttribute("name") === (t.name == null ? null : t.name) && r.getAttribute("property") === (t.property == null ? null : t.property) && r.getAttribute("http-equiv") === (t.httpEquiv == null ? null : t.httpEquiv) && r.getAttribute("charset") === (t.charSet == null ? null : t.charSet)) {
                          a.splice(l, 1);
                          break t;
                        }
                      }
                      r = n.createElement(i), Mt(r, i, t), n.head.appendChild(r);
                      break;
                    default:
                      throw Error(D(468, i));
                  }
                  r[Rt] = s, mt(r), i = r;
                }
                s.stateNode = i;
              } else zx(n, s.type, s.stateNode);
              else s.stateNode = Fx(n, i, s.memoizedProps);
              else r !== i ? (r === null ? t.stateNode !== null && (t = t.stateNode, t.parentNode.removeChild(t)) : r.count--, i === null ? zx(n, s.type, s.stateNode) : Fx(n, i, s.memoizedProps)) : i === null && s.stateNode !== null && gx(s, s.memoizedProps, t.memoizedProps);
            }
            break;
          case 27:
            if (i & 4 && s.alternate === null) {
              n = s.stateNode, r = s.memoizedProps;
              try {
                for (var o = n.firstChild; o; ) {
                  var u = o.nextSibling, c = o.nodeName;
                  o[Vl] || c === "HEAD" || c === "BODY" || c === "SCRIPT" || c === "STYLE" || c === "LINK" && o.rel.toLowerCase() === "stylesheet" || n.removeChild(o), o = u;
                }
                for (var h = s.type, d = n.attributes; d.length; ) n.removeAttributeNode(d[0]);
                Mt(n, h, r), n[Rt] = s, n[Xt] = r;
              } catch (p) {
                we(s, s.return, p);
              }
            }
          case 5:
            if (mi(e, s), gi(s), i & 512 && (Ie || t === null || oi(t, t.return)), s.flags & 32) {
              n = s.stateNode;
              try {
                oo(n, "");
              } catch (p) {
                we(s, s.return, p);
              }
            }
            i & 4 && s.stateNode != null && (n = s.memoizedProps, gx(s, n, t !== null ? t.memoizedProps : n)), i & 1024 && (bf = true);
            break;
          case 6:
            if (mi(e, s), gi(s), i & 4) {
              if (s.stateNode === null) throw Error(D(162));
              i = s.memoizedProps, t = s.stateNode;
              try {
                t.nodeValue = i;
              } catch (p) {
                we(s, s.return, p);
              }
            }
            break;
          case 3:
            if (Qc = null, n = ki, ki = Fh(e.containerInfo), mi(e, s), ki = n, gi(s), i & 4 && t !== null && t.memoizedState.isDehydrated) try {
              tu(e.containerInfo);
            } catch (p) {
              we(s, s.return, p);
            }
            bf && (bf = false, h1(s));
            break;
          case 4:
            i = ki, ki = Fh(s.stateNode.containerInfo), mi(e, s), gi(s), ki = i;
            break;
          case 12:
            mi(e, s), gi(s);
            break;
          case 13:
            mi(e, s), gi(s), s.child.flags & 8192 && s.memoizedState !== null != (t !== null && t.memoizedState !== null) && (fy = ss()), i & 4 && (i = s.updateQueue, i !== null && (s.updateQueue = null, Sf(s, i)));
            break;
          case 22:
            if (i & 512 && (Ie || t === null || oi(t, t.return)), o = s.memoizedState !== null, u = t !== null && t.memoizedState !== null, c = ws, h = Ie, ws = c || o, Ie = h || u, mi(e, s), Ie = h, ws = c, gi(s), e = s.stateNode, e._current = s, e._visibility &= -3, e._visibility |= e._pendingVisibility & 2, i & 8192 && (e._visibility = o ? e._visibility & -2 : e._visibility | 1, o && (e = ws || Ie, t === null || u || e || Sa(s)), s.memoizedProps === null || s.memoizedProps.mode !== "manual")) e: for (t = null, e = s; ; ) {
              if (e.tag === 5 || e.tag === 26 || e.tag === 27) {
                if (t === null) {
                  u = t = e;
                  try {
                    if (n = u.stateNode, o) r = n.style, typeof r.setProperty == "function" ? r.setProperty("display", "none", "important") : r.display = "none";
                    else {
                      a = u.stateNode, l = u.memoizedProps.style;
                      var f = l != null && l.hasOwnProperty("display") ? l.display : null;
                      a.style.display = f == null || typeof f == "boolean" ? "" : ("" + f).trim();
                    }
                  } catch (p) {
                    we(u, u.return, p);
                  }
                }
              } else if (e.tag === 6) {
                if (t === null) {
                  u = e;
                  try {
                    u.stateNode.nodeValue = o ? "" : u.memoizedProps;
                  } catch (p) {
                    we(u, u.return, p);
                  }
                }
              } else if ((e.tag !== 22 && e.tag !== 23 || e.memoizedState === null || e === s) && e.child !== null) {
                e.child.return = e, e = e.child;
                continue;
              }
              if (e === s) break e;
              for (; e.sibling === null; ) {
                if (e.return === null || e.return === s) break e;
                t === e && (t = null), e = e.return;
              }
              t === e && (t = null), e.sibling.return = e.return, e = e.sibling;
            }
            i & 4 && (i = s.updateQueue, i !== null && (t = i.retryQueue, t !== null && (i.retryQueue = null, Sf(s, t))));
            break;
          case 19:
            mi(e, s), gi(s), i & 4 && (i = s.updateQueue, i !== null && (s.updateQueue = null, Sf(s, i)));
            break;
          case 21:
            break;
          default:
            mi(e, s), gi(s);
        }
      }
      function gi(s) {
        var e = s.flags;
        if (e & 2) {
          try {
            if (s.tag !== 27) {
              e: {
                for (var t = s.return; t !== null; ) {
                  if (r1(t)) {
                    var i = t;
                    break e;
                  }
                  t = t.return;
                }
                throw Error(D(160));
              }
              switch (i.tag) {
                case 27:
                  var n = i.stateNode, r = _f(s);
                  wh(s, r, n);
                  break;
                case 5:
                  var a = i.stateNode;
                  i.flags & 32 && (oo(a, ""), i.flags &= -33);
                  var l = _f(s);
                  wh(s, l, a);
                  break;
                case 3:
                case 4:
                  var o = i.stateNode.containerInfo, u = _f(s);
                  _m(s, u, o);
                  break;
                default:
                  throw Error(D(161));
              }
            }
          } catch (c) {
            we(s, s.return, c);
          }
          s.flags &= -3;
        }
        e & 4096 && (s.flags &= -4097);
      }
      function h1(s) {
        if (s.subtreeFlags & 1024) for (s = s.child; s !== null; ) {
          var e = s;
          h1(e), e.tag === 5 && e.flags & 1024 && e.stateNode.reset(), s = s.sibling;
        }
      }
      function gs(s, e) {
        if (e.subtreeFlags & 8772) for (e = e.child; e !== null; ) a1(s, e.alternate, e), e = e.sibling;
      }
      function Sa(s) {
        for (s = s.child; s !== null; ) {
          var e = s;
          switch (e.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              Wn(4, e, e.return), Sa(e);
              break;
            case 1:
              oi(e, e.return);
              var t = e.stateNode;
              typeof t.componentWillUnmount == "function" && s1(e, e.return, t), Sa(e);
              break;
            case 26:
            case 27:
            case 5:
              oi(e, e.return), Sa(e);
              break;
            case 22:
              oi(e, e.return), e.memoizedState === null && Sa(e);
              break;
            default:
              Sa(e);
          }
          s = s.sibling;
        }
      }
      function gn(s, e, t) {
        for (t = t && (e.subtreeFlags & 8772) !== 0, e = e.child; e !== null; ) {
          var i = e.alternate, n = s, r = e, a = r.flags;
          switch (r.tag) {
            case 0:
            case 11:
            case 15:
              gn(n, r, t), wu(4, r);
              break;
            case 1:
              if (gn(n, r, t), i = r, n = i.stateNode, typeof n.componentDidMount == "function") try {
                n.componentDidMount();
              } catch (u) {
                we(i, i.return, u);
              }
              if (i = r, n = i.updateQueue, n !== null) {
                var l = i.stateNode;
                try {
                  var o = n.shared.hiddenCallbacks;
                  if (o !== null) for (n.shared.hiddenCallbacks = null, n = 0; n < o.length; n++) e1(o[n], l);
                } catch (u) {
                  we(i, i.return, u);
                }
              }
              t && a & 64 && i1(r), _r(r, r.return);
              break;
            case 26:
            case 27:
            case 5:
              gn(n, r, t), t && i === null && a & 4 && n1(r), _r(r, r.return);
              break;
            case 12:
              gn(n, r, t);
              break;
            case 13:
              gn(n, r, t), t && a & 4 && u1(n, r);
              break;
            case 22:
              r.memoizedState === null && gn(n, r, t), _r(r, r.return);
              break;
            default:
              gn(n, r, t);
          }
          e = e.sibling;
        }
      }
      function ly(s, e) {
        var t = null;
        s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (t = s.memoizedState.cachePool.pool), s = null, e.memoizedState !== null && e.memoizedState.cachePool !== null && (s = e.memoizedState.cachePool.pool), s !== t && (s != null && s.refCount++, t != null && Mu(t));
      }
      function uy(s, e) {
        s = null, e.alternate !== null && (s = e.alternate.memoizedState.cache), e = e.memoizedState.cache, e !== s && (e.refCount++, s != null && Mu(s));
      }
      function on(s, e, t, i) {
        if (e.subtreeFlags & 10256) for (e = e.child; e !== null; ) d1(s, e, t, i), e = e.sibling;
      }
      function d1(s, e, t, i) {
        var n = e.flags;
        switch (e.tag) {
          case 0:
          case 11:
          case 15:
            on(s, e, t, i), n & 2048 && wu(9, e);
            break;
          case 3:
            on(s, e, t, i), n & 2048 && (s = null, e.alternate !== null && (s = e.alternate.memoizedState.cache), e = e.memoizedState.cache, e !== s && (e.refCount++, s != null && Mu(s)));
            break;
          case 12:
            if (n & 2048) {
              on(s, e, t, i), s = e.stateNode;
              try {
                var r = e.memoizedProps, a = r.id, l = r.onPostCommit;
                typeof l == "function" && l(a, e.alternate === null ? "mount" : "update", s.passiveEffectDuration, -0);
              } catch (o) {
                we(e, e.return, o);
              }
            } else on(s, e, t, i);
            break;
          case 23:
            break;
          case 22:
            r = e.stateNode, e.memoizedState !== null ? r._visibility & 4 ? on(s, e, t, i) : Rl(s, e) : r._visibility & 4 ? on(s, e, t, i) : (r._visibility |= 4, Ta(s, e, t, i, (e.subtreeFlags & 10256) !== 0)), n & 2048 && ly(e.alternate, e);
            break;
          case 24:
            on(s, e, t, i), n & 2048 && uy(e.alternate, e);
            break;
          default:
            on(s, e, t, i);
        }
      }
      function Ta(s, e, t, i, n) {
        for (n = n && (e.subtreeFlags & 10256) !== 0, e = e.child; e !== null; ) {
          var r = s, a = e, l = t, o = i, u = a.flags;
          switch (a.tag) {
            case 0:
            case 11:
            case 15:
              Ta(r, a, l, o, n), wu(8, a);
              break;
            case 23:
              break;
            case 22:
              var c = a.stateNode;
              a.memoizedState !== null ? c._visibility & 4 ? Ta(r, a, l, o, n) : Rl(r, a) : (c._visibility |= 4, Ta(r, a, l, o, n)), n && u & 2048 && ly(a.alternate, a);
              break;
            case 24:
              Ta(r, a, l, o, n), n && u & 2048 && uy(a.alternate, a);
              break;
            default:
              Ta(r, a, l, o, n);
          }
          e = e.sibling;
        }
      }
      function Rl(s, e) {
        if (e.subtreeFlags & 10256) for (e = e.child; e !== null; ) {
          var t = s, i = e, n = i.flags;
          switch (i.tag) {
            case 22:
              Rl(t, i), n & 2048 && ly(i.alternate, i);
              break;
            case 24:
              Rl(t, i), n & 2048 && uy(i.alternate, i);
              break;
            default:
              Rl(t, i);
          }
          e = e.sibling;
        }
      }
      var fl = 8192;
      function Kr(s) {
        if (s.subtreeFlags & fl) for (s = s.child; s !== null; ) f1(s), s = s.sibling;
      }
      function f1(s) {
        switch (s.tag) {
          case 26:
            Kr(s), s.flags & fl && s.memoizedState !== null && mE(ki, s.memoizedState, s.memoizedProps);
            break;
          case 5:
            Kr(s);
            break;
          case 3:
          case 4:
            var e = ki;
            ki = Fh(s.stateNode.containerInfo), Kr(s), ki = e;
            break;
          case 22:
            s.memoizedState === null && (e = s.alternate, e !== null && e.memoizedState !== null ? (e = fl, fl = 16777216, Kr(s), fl = e) : Kr(s));
            break;
          default:
            Kr(s);
        }
      }
      function p1(s) {
        var e = s.alternate;
        if (e !== null && (s = e.child, s !== null)) {
          e.child = null;
          do
            e = s.sibling, s.sibling = null, s = e;
          while (s !== null);
        }
      }
      function qo(s) {
        var e = s.deletions;
        if (s.flags & 16) {
          if (e !== null) for (var t = 0; t < e.length; t++) {
            var i = e[t];
            pt = i, g1(i, s);
          }
          p1(s);
        }
        if (s.subtreeFlags & 10256) for (s = s.child; s !== null; ) m1(s), s = s.sibling;
      }
      function m1(s) {
        switch (s.tag) {
          case 0:
          case 11:
          case 15:
            qo(s), s.flags & 2048 && Wn(9, s, s.return);
            break;
          case 3:
            qo(s);
            break;
          case 12:
            qo(s);
            break;
          case 22:
            var e = s.stateNode;
            s.memoizedState !== null && e._visibility & 4 && (s.return === null || s.return.tag !== 13) ? (e._visibility &= -5, $c(s)) : qo(s);
            break;
          default:
            qo(s);
        }
      }
      function $c(s) {
        var e = s.deletions;
        if (s.flags & 16) {
          if (e !== null) for (var t = 0; t < e.length; t++) {
            var i = e[t];
            pt = i, g1(i, s);
          }
          p1(s);
        }
        for (s = s.child; s !== null; ) {
          switch (e = s, e.tag) {
            case 0:
            case 11:
            case 15:
              Wn(8, e, e.return), $c(e);
              break;
            case 22:
              t = e.stateNode, t._visibility & 4 && (t._visibility &= -5, $c(e));
              break;
            default:
              $c(e);
          }
          s = s.sibling;
        }
      }
      function g1(s, e) {
        for (; pt !== null; ) {
          var t = pt;
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              Wn(8, t, e);
              break;
            case 23:
            case 22:
              if (t.memoizedState !== null && t.memoizedState.cachePool !== null) {
                var i = t.memoizedState.cachePool.pool;
                i != null && i.refCount++;
              }
              break;
            case 24:
              Mu(t.memoizedState.cache);
          }
          if (i = t.child, i !== null) i.return = t, pt = i;
          else e: for (t = s; pt !== null; ) {
            i = pt;
            var n = i.sibling, r = i.return;
            if (o1(i), i === t) {
              pt = null;
              break e;
            }
            if (n !== null) {
              n.return = r, pt = n;
              break e;
            }
            pt = r;
          }
        }
      }
      function Ew(s, e, t, i) {
        this.tag = s, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
      }
      function Ei(s, e, t, i) {
        return new Ew(s, e, t, i);
      }
      function cy(s) {
        return s = s.prototype, !(!s || !s.isReactComponent);
      }
      function On(s, e) {
        var t = s.alternate;
        return t === null ? (t = Ei(s.tag, e, s.key, s.mode), t.elementType = s.elementType, t.type = s.type, t.stateNode = s.stateNode, t.alternate = s, s.alternate = t) : (t.pendingProps = e, t.type = s.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = s.flags & 31457280, t.childLanes = s.childLanes, t.lanes = s.lanes, t.child = s.child, t.memoizedProps = s.memoizedProps, t.memoizedState = s.memoizedState, t.updateQueue = s.updateQueue, e = s.dependencies, t.dependencies = e === null ? null : {
          lanes: e.lanes,
          firstContext: e.firstContext
        }, t.sibling = s.sibling, t.index = s.index, t.ref = s.ref, t.refCleanup = s.refCleanup, t;
      }
      function y1(s, e) {
        s.flags &= 31457282;
        var t = s.alternate;
        return t === null ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = t.childLanes, s.lanes = t.lanes, s.child = t.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = t.memoizedProps, s.memoizedState = t.memoizedState, s.updateQueue = t.updateQueue, s.type = t.type, e = t.dependencies, s.dependencies = e === null ? null : {
          lanes: e.lanes,
          firstContext: e.firstContext
        }), s;
      }
      function Xc(s, e, t, i, n, r) {
        var a = 0;
        if (i = s, typeof s == "function") cy(s) && (a = 1);
        else if (typeof s == "string") a = fE(s, t, is.current) ? 26 : s === "html" || s === "head" || s === "body" ? 27 : 5;
        else e: switch (s) {
          case Aa:
            return vr(t.children, n, r, e);
          case xS:
            a = 8, n |= 24;
            break;
          case Vp:
            return s = Ei(12, t, e, n | 2), s.elementType = Vp, s.lanes = r, s;
          case Hp:
            return s = Ei(13, t, e, n), s.elementType = Hp, s.lanes = r, s;
          case qp:
            return s = Ei(19, t, e, n), s.elementType = qp, s.lanes = r, s;
          case bS:
            return x1(t, n, r, e);
          default:
            if (typeof s == "object" && s !== null) switch (s.$$typeof) {
              case JA:
              case Ds:
                a = 10;
                break e;
              case _S:
                a = 9;
                break e;
              case Bg:
                a = 11;
                break e;
              case Dg:
                a = 14;
                break e;
              case yn:
                a = 16, i = null;
                break e;
            }
            a = 29, t = Error(D(130, s === null ? "null" : typeof s, "")), i = null;
        }
        return e = Ei(a, t, e, n), e.elementType = s, e.type = i, e.lanes = r, e;
      }
      function vr(s, e, t, i) {
        return s = Ei(7, s, i, e), s.lanes = t, s;
      }
      function x1(s, e, t, i) {
        s = Ei(22, s, i, e), s.elementType = bS, s.lanes = t;
        var n = {
          _visibility: 1,
          _pendingVisibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
          _current: null,
          detach: function() {
            var r = n._current;
            if (r === null) throw Error(D(456));
            if (!(n._pendingVisibility & 2)) {
              var a = qn(r, 2);
              a !== null && (n._pendingVisibility |= 2, zt(a, r, 2));
            }
          },
          attach: function() {
            var r = n._current;
            if (r === null) throw Error(D(456));
            if (n._pendingVisibility & 2) {
              var a = qn(r, 2);
              a !== null && (n._pendingVisibility &= -3, zt(a, r, 2));
            }
          }
        };
        return s.stateNode = n, s;
      }
      function Tf(s, e, t) {
        return s = Ei(6, s, null, e), s.lanes = t, s;
      }
      function vf(s, e, t) {
        return e = Ei(4, s.children !== null ? s.children : [], s.key, e), e.lanes = t, e.stateNode = {
          containerInfo: s.containerInfo,
          pendingChildren: null,
          implementation: s.implementation
        }, e;
      }
      function ys(s) {
        s.flags |= 4;
      }
      function _x(s, e) {
        if (e.type !== "stylesheet" || e.state.loading & 4) s.flags &= -16777217;
        else if (s.flags |= 16777216, !P1(e)) {
          if (e = Di.current, e !== null && ((he & 4194176) === he ? ns !== null : (he & 62914560) !== he && !(he & 536870912) || e !== ns)) throw Tl = sm, nT;
          s.flags |= 8192;
        }
      }
      function Zu(s, e) {
        e !== null && (s.flags |= 4), s.flags & 16384 && (e = s.tag !== 22 ? wS() : 536870912, s.lanes |= e, ho |= e);
      }
      function Yo(s, e) {
        if (!ge) switch (s.tailMode) {
          case "hidden":
            e = s.tail;
            for (var t = null; e !== null; ) e.alternate !== null && (t = e), e = e.sibling;
            t === null ? s.tail = null : t.sibling = null;
            break;
          case "collapsed":
            t = s.tail;
            for (var i = null; t !== null; ) t.alternate !== null && (i = t), t = t.sibling;
            i === null ? e || s.tail === null ? s.tail = null : s.tail.sibling = null : i.sibling = null;
        }
      }
      function Le(s) {
        var e = s.alternate !== null && s.alternate.child === s.child, t = 0, i = 0;
        if (e) for (var n = s.child; n !== null; ) t |= n.lanes | n.childLanes, i |= n.subtreeFlags & 31457280, i |= n.flags & 31457280, n.return = s, n = n.sibling;
        else for (n = s.child; n !== null; ) t |= n.lanes | n.childLanes, i |= n.subtreeFlags, i |= n.flags, n.return = s, n = n.sibling;
        return s.subtreeFlags |= i, s.childLanes = t, e;
      }
      function Rw(s, e, t) {
        var i = e.pendingProps;
        switch (qg(e), e.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return Le(e), null;
          case 1:
            return Le(e), null;
          case 3:
            return t = e.stateNode, i = null, s !== null && (i = s.memoizedState.cache), e.memoizedState.cache !== i && (e.flags |= 2048), Gs(at), ro(), t.pendingContext && (t.context = t.pendingContext, t.pendingContext = null), (s === null || s.child === null) && (Vo(e) ? ys(e) : s === null || s.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Ii !== null && (Mm(Ii), Ii = null))), Le(e), null;
          case 26:
            return t = e.memoizedState, s === null ? (ys(e), t !== null ? (Le(e), _x(e, t)) : (Le(e), e.flags &= -16777217)) : t ? t !== s.memoizedState ? (ys(e), Le(e), _x(e, t)) : (Le(e), e.flags &= -16777217) : (s.memoizedProps !== i && ys(e), Le(e), e.flags &= -16777217), null;
          case 27:
            fh(e), t = Dn.current;
            var n = e.type;
            if (s !== null && e.stateNode != null) s.memoizedProps !== i && ys(e);
            else {
              if (!i) {
                if (e.stateNode === null) throw Error(D(166));
                return Le(e), null;
              }
              s = is.current, Vo(e) ? X0(e) : (s = z1(n, i, t), e.stateNode = s, ys(e));
            }
            return Le(e), null;
          case 5:
            if (fh(e), t = e.type, s !== null && e.stateNode != null) s.memoizedProps !== i && ys(e);
            else {
              if (!i) {
                if (e.stateNode === null) throw Error(D(166));
                return Le(e), null;
              }
              if (s = is.current, Vo(e)) X0(e);
              else {
                switch (n = Uh(Dn.current), s) {
                  case 1:
                    s = n.createElementNS("http://www.w3.org/2000/svg", t);
                    break;
                  case 2:
                    s = n.createElementNS("http://www.w3.org/1998/Math/MathML", t);
                    break;
                  default:
                    switch (t) {
                      case "svg":
                        s = n.createElementNS("http://www.w3.org/2000/svg", t);
                        break;
                      case "math":
                        s = n.createElementNS("http://www.w3.org/1998/Math/MathML", t);
                        break;
                      case "script":
                        s = n.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild);
                        break;
                      case "select":
                        s = typeof i.is == "string" ? n.createElement("select", {
                          is: i.is
                        }) : n.createElement("select"), i.multiple ? s.multiple = true : i.size && (s.size = i.size);
                        break;
                      default:
                        s = typeof i.is == "string" ? n.createElement(t, {
                          is: i.is
                        }) : n.createElement(t);
                    }
                }
                s[Rt] = e, s[Xt] = i;
                e: for (n = e.child; n !== null; ) {
                  if (n.tag === 5 || n.tag === 6) s.appendChild(n.stateNode);
                  else if (n.tag !== 4 && n.tag !== 27 && n.child !== null) {
                    n.child.return = n, n = n.child;
                    continue;
                  }
                  if (n === e) break e;
                  for (; n.sibling === null; ) {
                    if (n.return === null || n.return === e) break e;
                    n = n.return;
                  }
                  n.sibling.return = n.return, n = n.sibling;
                }
                e.stateNode = s;
                e: switch (Mt(s, t, i), t) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    s = !!i.autoFocus;
                    break e;
                  case "img":
                    s = true;
                    break e;
                  default:
                    s = false;
                }
                s && ys(e);
              }
            }
            return Le(e), e.flags &= -16777217, null;
          case 6:
            if (s && e.stateNode != null) s.memoizedProps !== i && ys(e);
            else {
              if (typeof i != "string" && e.stateNode === null) throw Error(D(166));
              if (s = Dn.current, Vo(e)) {
                if (s = e.stateNode, t = e.memoizedProps, i = null, n = Ut, n !== null) switch (n.tag) {
                  case 27:
                  case 5:
                    i = n.memoizedProps;
                }
                s[Rt] = e, s = !!(s.nodeValue === t || i !== null && i.suppressHydrationWarning === true || U1(s.nodeValue, t)), s || Er(e);
              } else s = Uh(s).createTextNode(i), s[Rt] = e, e.stateNode = s;
            }
            return Le(e), null;
          case 13:
            if (i = e.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
              if (n = Vo(e), i !== null && i.dehydrated !== null) {
                if (s === null) {
                  if (!n) throw Error(D(318));
                  if (n = e.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(D(317));
                  n[Rt] = e;
                } else vu(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
                Le(e), n = false;
              } else Ii !== null && (Mm(Ii), Ii = null), n = true;
              if (!n) return e.flags & 256 ? (Os(e), e) : (Os(e), null);
            }
            if (Os(e), e.flags & 128) return e.lanes = t, e;
            if (t = i !== null, s = s !== null && s.memoizedState !== null, t) {
              i = e.child, n = null, i.alternate !== null && i.alternate.memoizedState !== null && i.alternate.memoizedState.cachePool !== null && (n = i.alternate.memoizedState.cachePool.pool);
              var r = null;
              i.memoizedState !== null && i.memoizedState.cachePool !== null && (r = i.memoizedState.cachePool.pool), r !== n && (i.flags |= 2048);
            }
            return t !== s && t && (e.child.flags |= 8192), Zu(e, e.updateQueue), Le(e), null;
          case 4:
            return ro(), s === null && gy(e.stateNode.containerInfo), Le(e), null;
          case 10:
            return Gs(e.type), Le(e), null;
          case 19:
            if (xt(ot), n = e.memoizedState, n === null) return Le(e), null;
            if (i = (e.flags & 128) !== 0, r = n.rendering, r === null) if (i) Yo(n, false);
            else {
              if (Ve !== 0 || s !== null && s.flags & 128) for (s = e.child; s !== null; ) {
                if (r = Sh(s), r !== null) {
                  for (e.flags |= 128, Yo(n, false), s = r.updateQueue, e.updateQueue = s, Zu(e, s), e.subtreeFlags = 0, s = t, t = e.child; t !== null; ) y1(t, s), t = t.sibling;
                  return Oe(ot, ot.current & 1 | 2), e.child;
                }
                s = s.sibling;
              }
              n.tail !== null && ss() > Eh && (e.flags |= 128, i = true, Yo(n, false), e.lanes = 4194304);
            }
            else {
              if (!i) if (s = Sh(r), s !== null) {
                if (e.flags |= 128, i = true, s = s.updateQueue, e.updateQueue = s, Zu(e, s), Yo(n, true), n.tail === null && n.tailMode === "hidden" && !r.alternate && !ge) return Le(e), null;
              } else 2 * ss() - n.renderingStartTime > Eh && t !== 536870912 && (e.flags |= 128, i = true, Yo(n, false), e.lanes = 4194304);
              n.isBackwards ? (r.sibling = e.child, e.child = r) : (s = n.last, s !== null ? s.sibling = r : e.child = r, n.last = r);
            }
            return n.tail !== null ? (e = n.tail, n.rendering = e, n.tail = e.sibling, n.renderingStartTime = ss(), e.sibling = null, s = ot.current, Oe(ot, i ? s & 1 | 2 : s & 1), e) : (Le(e), null);
          case 22:
          case 23:
            return Os(e), Yg(), i = e.memoizedState !== null, s !== null ? s.memoizedState !== null !== i && (e.flags |= 8192) : i && (e.flags |= 8192), i ? t & 536870912 && !(e.flags & 128) && (Le(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Le(e), t = e.updateQueue, t !== null && Zu(e, t.retryQueue), t = null, s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (t = s.memoizedState.cachePool.pool), i = null, e.memoizedState !== null && e.memoizedState.cachePool !== null && (i = e.memoizedState.cachePool.pool), i !== t && (e.flags |= 2048), s !== null && xt(Tr), null;
          case 24:
            return t = null, s !== null && (t = s.memoizedState.cache), e.memoizedState.cache !== t && (e.flags |= 2048), Gs(at), Le(e), null;
          case 25:
            return null;
        }
        throw Error(D(156, e.tag));
      }
      function Cw(s, e) {
        switch (qg(e), e.tag) {
          case 1:
            return s = e.flags, s & 65536 ? (e.flags = s & -65537 | 128, e) : null;
          case 3:
            return Gs(at), ro(), s = e.flags, s & 65536 && !(s & 128) ? (e.flags = s & -65537 | 128, e) : null;
          case 26:
          case 27:
          case 5:
            return fh(e), null;
          case 13:
            if (Os(e), s = e.memoizedState, s !== null && s.dehydrated !== null) {
              if (e.alternate === null) throw Error(D(340));
              vu();
            }
            return s = e.flags, s & 65536 ? (e.flags = s & -65537 | 128, e) : null;
          case 19:
            return xt(ot), null;
          case 4:
            return ro(), null;
          case 10:
            return Gs(e.type), null;
          case 22:
          case 23:
            return Os(e), Yg(), s !== null && xt(Tr), s = e.flags, s & 65536 ? (e.flags = s & -65537 | 128, e) : null;
          case 24:
            return Gs(at), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function _1(s, e) {
        switch (qg(e), e.tag) {
          case 3:
            Gs(at), ro();
            break;
          case 26:
          case 27:
          case 5:
            fh(e);
            break;
          case 4:
            ro();
            break;
          case 13:
            Os(e);
            break;
          case 19:
            xt(ot);
            break;
          case 10:
            Gs(e.type);
            break;
          case 22:
          case 23:
            Os(e), Yg(), s !== null && xt(Tr);
            break;
          case 24:
            Gs(at);
        }
      }
      var Bw = {
        getCacheForType: function(s) {
          var e = Ct(at), t = e.data.get(s);
          return t === void 0 && (t = s(), e.data.set(s, t)), t;
        }
      }, Dw = typeof WeakMap == "function" ? WeakMap : Map, ke = 0, Re = null, oe = null, he = 0, Ee = 0, ai = null, Es = false, Co = false, hy = false, js = 0, Ve = 0, jn = 0, Mr = 0, dy = 0, Ri = 0, ho = 0, Cl = null, es = null, bm = false, fy = 0, Eh = 1 / 0, Rh = null, zn = null, Qu = false, fr = null, Bl = 0, Sm = 0, Tm = null, Dl = 0, vm = null;
      function hi() {
        if (ke & 2 && he !== 0) return he & -he;
        if (J.T !== null) {
          var s = uo;
          return s !== 0 ? s : my();
        }
        return BS();
      }
      function b1() {
        Ri === 0 && (Ri = !(he & 536870912) || ge ? NS() : 536870912);
        var s = Di.current;
        return s !== null && (s.flags |= 32), Ri;
      }
      function zt(s, e, t) {
        (s === Re && Ee === 2 || s.cancelPendingCommit !== null) && (fo(s, 0), Rs(s, he, Ri, false)), Su(s, t), (!(ke & 2) || s !== Re) && (s === Re && (!(ke & 2) && (Mr |= t), Ve === 4 && Rs(s, he, Ri, false)), hs(s));
      }
      function S1(s, e, t) {
        if (ke & 6) throw Error(D(327));
        var i = !t && (e & 60) === 0 && (e & s.expiredLanes) === 0 || bu(s, e), n = i ? Ow(s, e) : Mf(s, e, true), r = i;
        do {
          if (n === 0) {
            Co && !i && Rs(s, e, 0, false);
            break;
          } else if (n === 6) Rs(s, e, 0, !Es);
          else {
            if (t = s.current.alternate, r && !Uw(t)) {
              n = Mf(s, e, false), r = false;
              continue;
            }
            if (n === 2) {
              if (r = e, s.errorRecoveryDisabledLanes & r) var a = 0;
              else a = s.pendingLanes & -536870913, a = a !== 0 ? a : a & 536870912 ? 536870912 : 0;
              if (a !== 0) {
                e = a;
                e: {
                  var l = s;
                  n = Cl;
                  var o = l.current.memoizedState.isDehydrated;
                  if (o && (fo(l, a).flags |= 256), a = Mf(l, a, false), a !== 2) {
                    if (hy && !o) {
                      l.errorRecoveryDisabledLanes |= r, Mr |= r, n = 4;
                      break e;
                    }
                    r = es, es = n, r !== null && Mm(r);
                  }
                  n = a;
                }
                if (r = false, n !== 2) continue;
              }
            }
            if (n === 1) {
              fo(s, 0), Rs(s, e, 0, true);
              break;
            }
            e: {
              switch (i = s, n) {
                case 0:
                case 1:
                  throw Error(D(345));
                case 4:
                  if ((e & 4194176) === e) {
                    Rs(i, e, Ri, !Es);
                    break e;
                  }
                  break;
                case 2:
                  es = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(D(329));
              }
              if (i.finishedWork = t, i.finishedLanes = e, (e & 62914560) === e && (r = fy + 300 - ss(), 10 < r)) {
                if (Rs(i, e, Ri, !Es), dd(i, 0) !== 0) break e;
                i.timeoutHandle = O1(bx.bind(null, i, t, es, Rh, bm, e, Ri, Mr, ho, Es, 2, -0, 0), r);
                break e;
              }
              bx(i, t, es, Rh, bm, e, Ri, Mr, ho, Es, 0, -0, 0);
            }
          }
          break;
        } while (true);
        hs(s);
      }
      function Mm(s) {
        es === null ? es = s : es.push.apply(es, s);
      }
      function bx(s, e, t, i, n, r, a, l, o, u, c, h, d) {
        var f = e.subtreeFlags;
        if ((f & 8192 || (f & 16785408) === 16785408) && (Ql = {
          stylesheets: null,
          count: 0,
          unsuspend: pE
        }, f1(e), e = gE(), e !== null)) {
          s.cancelPendingCommit = e(Tx.bind(null, s, t, i, n, a, l, o, 1, h, d)), Rs(s, r, a, !u);
          return;
        }
        Tx(s, t, i, n, a, l, o, c, h, d);
      }
      function Uw(s) {
        for (var e = s; ; ) {
          var t = e.tag;
          if ((t === 0 || t === 11 || t === 15) && e.flags & 16384 && (t = e.updateQueue, t !== null && (t = t.stores, t !== null))) for (var i = 0; i < t.length; i++) {
            var n = t[i], r = n.getSnapshot;
            n = n.value;
            try {
              if (!di(r(), n)) return false;
            } catch {
              return false;
            }
          }
          if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t;
          else {
            if (e === s) break;
            for (; e.sibling === null; ) {
              if (e.return === null || e.return === s) return true;
              e = e.return;
            }
            e.sibling.return = e.return, e = e.sibling;
          }
        }
        return true;
      }
      function Rs(s, e, t, i) {
        e &= ~dy, e &= ~Mr, s.suspendedLanes |= e, s.pingedLanes &= ~e, i && (s.warmLanes |= e), i = s.expirationTimes;
        for (var n = e; 0 < n; ) {
          var r = 31 - ci(n), a = 1 << r;
          i[r] = -1, n &= ~a;
        }
        t !== 0 && ES(s, t, e);
      }
      function Td() {
        return ke & 6 ? true : (Eu(0), false);
      }
      function py() {
        if (oe !== null) {
          if (Ee === 0) var s = oe.return;
          else s = oe, zs = Wr = null, Kg(s), Wa = null, jl = 0, s = oe;
          for (; s !== null; ) _1(s.alternate, s), s = s.return;
          oe = null;
        }
      }
      function fo(s, e) {
        s.finishedWork = null, s.finishedLanes = 0;
        var t = s.timeoutHandle;
        t !== -1 && (s.timeoutHandle = -1, Kw(t)), t = s.cancelPendingCommit, t !== null && (s.cancelPendingCommit = null, t()), py(), Re = s, oe = t = On(s.current, null), he = e, Ee = 0, ai = null, Es = false, Co = bu(s, e), hy = false, ho = Ri = dy = Mr = jn = Ve = 0, es = Cl = null, bm = false, e & 8 && (e |= e & 32);
        var i = s.entangledLanes;
        if (i !== 0) for (s = s.entanglements, i &= e; 0 < i; ) {
          var n = 31 - ci(i), r = 1 << n;
          e |= s[n], i &= ~r;
        }
        return js = e, gd(), t;
      }
      function T1(s, e) {
        re = null, J.H = rs, e === Sl ? (e = K0(), Ee = 3) : e === nT ? (e = K0(), Ee = 4) : Ee = e === jT ? 8 : e !== null && typeof e == "object" && typeof e.then == "function" ? 6 : 1, ai = e, oe === null && (Ve = 1, Ah(s, Ni(e, s.current)));
      }
      function v1() {
        var s = J.H;
        return J.H = rs, s === null ? rs : s;
      }
      function M1() {
        var s = J.A;
        return J.A = Bw, s;
      }
      function Am() {
        Ve = 4, Es || (he & 4194176) !== he && Di.current !== null || (Co = true), !(jn & 134217727) && !(Mr & 134217727) || Re === null || Rs(Re, he, Ri, false);
      }
      function Mf(s, e, t) {
        var i = ke;
        ke |= 2;
        var n = v1(), r = M1();
        (Re !== s || he !== e) && (Rh = null, fo(s, e)), e = false;
        var a = Ve;
        e: do
          try {
            if (Ee !== 0 && oe !== null) {
              var l = oe, o = ai;
              switch (Ee) {
                case 8:
                  py(), a = 6;
                  break e;
                case 3:
                case 2:
                case 6:
                  Di.current === null && (e = true);
                  var u = Ee;
                  if (Ee = 0, ai = null, Oa(s, l, o, u), t && Co) {
                    a = 0;
                    break e;
                  }
                  break;
                default:
                  u = Ee, Ee = 0, ai = null, Oa(s, l, o, u);
              }
            }
            Fw(), a = Ve;
            break;
          } catch (c) {
            T1(s, c);
          }
        while (true);
        return e && s.shellSuspendCounter++, zs = Wr = null, ke = i, J.H = n, J.A = r, oe === null && (Re = null, he = 0, gd()), a;
      }
      function Fw() {
        for (; oe !== null; ) A1(oe);
      }
      function Ow(s, e) {
        var t = ke;
        ke |= 2;
        var i = v1(), n = M1();
        Re !== s || he !== e ? (Rh = null, Eh = ss() + 500, fo(s, e)) : Co = bu(s, e);
        e: do
          try {
            if (Ee !== 0 && oe !== null) {
              e = oe;
              var r = ai;
              t: switch (Ee) {
                case 1:
                  Ee = 0, ai = null, Oa(s, e, r, 1);
                  break;
                case 2:
                  if (Q0(r)) {
                    Ee = 0, ai = null, Sx(e);
                    break;
                  }
                  e = function() {
                    Ee === 2 && Re === s && (Ee = 7), hs(s);
                  }, r.then(e, e);
                  break e;
                case 3:
                  Ee = 7;
                  break e;
                case 4:
                  Ee = 5;
                  break e;
                case 7:
                  Q0(r) ? (Ee = 0, ai = null, Sx(e)) : (Ee = 0, ai = null, Oa(s, e, r, 7));
                  break;
                case 5:
                  var a = null;
                  switch (oe.tag) {
                    case 26:
                      a = oe.memoizedState;
                    case 5:
                    case 27:
                      var l = oe;
                      if (!a || P1(a)) {
                        Ee = 0, ai = null;
                        var o = l.sibling;
                        if (o !== null) oe = o;
                        else {
                          var u = l.return;
                          u !== null ? (oe = u, vd(u)) : oe = null;
                        }
                        break t;
                      }
                  }
                  Ee = 0, ai = null, Oa(s, e, r, 5);
                  break;
                case 6:
                  Ee = 0, ai = null, Oa(s, e, r, 6);
                  break;
                case 8:
                  py(), Ve = 6;
                  break e;
                default:
                  throw Error(D(462));
              }
            }
            zw();
            break;
          } catch (c) {
            T1(s, c);
          }
        while (true);
        return zs = Wr = null, J.H = i, J.A = n, ke = t, oe !== null ? 0 : (Re = null, he = 0, gd(), Ve);
      }
      function zw() {
        for (; oe !== null && !nN(); ) A1(oe);
      }
      function A1(s) {
        var e = KT(s.alternate, s, js);
        s.memoizedProps = s.pendingProps, e === null ? vd(s) : oe = e;
      }
      function Sx(s) {
        var e = s, t = e.alternate;
        switch (e.tag) {
          case 15:
          case 0:
            e = dx(t, e, e.pendingProps, e.type, void 0, he);
            break;
          case 11:
            e = dx(t, e, e.pendingProps, e.type.render, e.ref, he);
            break;
          case 5:
            Kg(e);
          default:
            _1(t, e), e = oe = y1(e, js), e = KT(t, e, js);
        }
        s.memoizedProps = s.pendingProps, e === null ? vd(s) : oe = e;
      }
      function Oa(s, e, t, i) {
        zs = Wr = null, Kg(e), Wa = null, jl = 0;
        var n = e.return;
        try {
          if (Mw(s, n, e, t, he)) {
            Ve = 1, Ah(s, Ni(t, s.current)), oe = null;
            return;
          }
        } catch (r) {
          if (n !== null) throw oe = n, r;
          Ve = 1, Ah(s, Ni(t, s.current)), oe = null;
          return;
        }
        e.flags & 32768 ? (ge || i === 1 ? s = true : Co || he & 536870912 ? s = false : (Es = s = true, (i === 2 || i === 3 || i === 6) && (i = Di.current, i !== null && i.tag === 13 && (i.flags |= 16384))), N1(e, s)) : vd(e);
      }
      function vd(s) {
        var e = s;
        do {
          if (e.flags & 32768) {
            N1(e, Es);
            return;
          }
          s = e.return;
          var t = Rw(e.alternate, e, js);
          if (t !== null) {
            oe = t;
            return;
          }
          if (e = e.sibling, e !== null) {
            oe = e;
            return;
          }
          oe = e = s;
        } while (e !== null);
        Ve === 0 && (Ve = 5);
      }
      function N1(s, e) {
        do {
          var t = Cw(s.alternate, s);
          if (t !== null) {
            t.flags &= 32767, oe = t;
            return;
          }
          if (t = s.return, t !== null && (t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null), !e && (s = s.sibling, s !== null)) {
            oe = s;
            return;
          }
          oe = s = t;
        } while (s !== null);
        Ve = 6, oe = null;
      }
      function Tx(s, e, t, i, n, r, a, l, o, u) {
        var c = J.T, h = De.p;
        try {
          De.p = 2, J.T = null, Lw(s, e, t, i, h, n, r, a, l, o, u);
        } finally {
          J.T = c, De.p = h;
        }
      }
      function Lw(s, e, t, i, n, r, a, l) {
        do
          Za();
        while (fr !== null);
        if (ke & 6) throw Error(D(327));
        var o = s.finishedWork;
        if (i = s.finishedLanes, o === null) return null;
        if (s.finishedWork = null, s.finishedLanes = 0, o === s.current) throw Error(D(177));
        s.callbackNode = null, s.callbackPriority = 0, s.cancelPendingCommit = null;
        var u = o.lanes | o.childLanes;
        if (u |= Ig, mN(s, i, u, r, a, l), s === Re && (oe = Re = null, he = 0), !(o.subtreeFlags & 10256) && !(o.flags & 10256) || Qu || (Qu = true, Sm = u, Tm = t, Iw(ph, function() {
          return Za(), null;
        })), t = (o.flags & 15990) !== 0, o.subtreeFlags & 15990 || t ? (t = J.T, J.T = null, r = De.p, De.p = 2, a = ke, ke |= 4, Nw(s, o), c1(o, s), ow(Rm, s.containerInfo), Lh = !!Em, Rm = Em = null, s.current = o, a1(s, o.alternate, o), rN(), ke = a, De.p = r, J.T = t) : s.current = o, Qu ? (Qu = false, fr = s, Bl = i) : w1(s, u), u = s.pendingLanes, u === 0 && (zn = null), cN(o.stateNode), hs(s), e !== null) for (n = s.onRecoverableError, o = 0; o < e.length; o++) u = e[o], n(u.value, {
          componentStack: u.stack
        });
        return Bl & 3 && Za(), u = s.pendingLanes, i & 4194218 && u & 42 ? s === vm ? Dl++ : (Dl = 0, vm = s) : Dl = 0, Eu(0), null;
      }
      function w1(s, e) {
        (s.pooledCacheLanes &= e) === 0 && (e = s.pooledCache, e != null && (s.pooledCache = null, Mu(e)));
      }
      function Za() {
        if (fr !== null) {
          var s = fr, e = Sm;
          Sm = 0;
          var t = CS(Bl), i = J.T, n = De.p;
          try {
            if (De.p = 32 > t ? 32 : t, J.T = null, fr === null) var r = false;
            else {
              t = Tm, Tm = null;
              var a = fr, l = Bl;
              if (fr = null, Bl = 0, ke & 6) throw Error(D(331));
              var o = ke;
              if (ke |= 4, m1(a.current), d1(a, a.current, l, t), ke = o, Eu(0, false), ui && typeof ui.onPostCommitFiberRoot == "function") try {
                ui.onPostCommitFiberRoot(_u, a);
              } catch {
              }
              r = true;
            }
            return r;
          } finally {
            De.p = n, J.T = i, w1(s, e);
          }
        }
        return false;
      }
      function vx(s, e, t) {
        e = Ni(t, e), e = cm(s.stateNode, e, 2), s = Fn(s, e, 2), s !== null && (Su(s, 2), hs(s));
      }
      function we(s, e, t) {
        if (s.tag === 3) vx(s, s, t);
        else for (; e !== null; ) {
          if (e.tag === 3) {
            vx(e, s, t);
            break;
          } else if (e.tag === 1) {
            var i = e.stateNode;
            if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (zn === null || !zn.has(i))) {
              s = Ni(t, s), t = YT(2), i = Fn(e, t, 2), i !== null && (WT(t, i, e, s), Su(i, 2), hs(i));
              break;
            }
          }
          e = e.return;
        }
      }
      function Af(s, e, t) {
        var i = s.pingCache;
        if (i === null) {
          i = s.pingCache = new Dw();
          var n = /* @__PURE__ */ new Set();
          i.set(e, n);
        } else n = i.get(e), n === void 0 && (n = /* @__PURE__ */ new Set(), i.set(e, n));
        n.has(t) || (hy = true, n.add(t), s = Gw.bind(null, s, e, t), e.then(s, s));
      }
      function Gw(s, e, t) {
        var i = s.pingCache;
        i !== null && i.delete(e), s.pingedLanes |= s.suspendedLanes & t, s.warmLanes &= ~t, Re === s && (he & t) === t && (Ve === 4 || Ve === 3 && (he & 62914560) === he && 300 > ss() - fy ? !(ke & 2) && fo(s, 0) : dy |= t, ho === he && (ho = 0)), hs(s);
      }
      function E1(s, e) {
        e === 0 && (e = wS()), s = qn(s, e), s !== null && (Su(s, e), hs(s));
      }
      function Pw(s) {
        var e = s.memoizedState, t = 0;
        e !== null && (t = e.retryLane), E1(s, t);
      }
      function kw(s, e) {
        var t = 0;
        switch (s.tag) {
          case 13:
            var i = s.stateNode, n = s.memoizedState;
            n !== null && (t = n.retryLane);
            break;
          case 19:
            i = s.stateNode;
            break;
          case 22:
            i = s.stateNode._retryCache;
            break;
          default:
            throw Error(D(314));
        }
        i !== null && i.delete(e), E1(s, t);
      }
      function Iw(s, e) {
        return Ug(s, e);
      }
      var Ch = null, va = null, Nm = false, Bh = false, Nf = false, Ar = 0;
      function hs(s) {
        s !== va && s.next === null && (va === null ? Ch = va = s : va = va.next = s), Bh = true, Nm || (Nm = true, Hw(Vw));
      }
      function Eu(s, e) {
        if (!Nf && Bh) {
          Nf = true;
          do
            for (var t = false, i = Ch; i !== null; ) {
              if (s !== 0) {
                var n = i.pendingLanes;
                if (n === 0) var r = 0;
                else {
                  var a = i.suspendedLanes, l = i.pingedLanes;
                  r = (1 << 31 - ci(42 | s) + 1) - 1, r &= n & ~(a & ~l), r = r & 201326677 ? r & 201326677 | 1 : r ? r | 2 : 0;
                }
                r !== 0 && (t = true, Mx(i, r));
              } else r = he, r = dd(i, i === Re ? r : 0), !(r & 3) || bu(i, r) || (t = true, Mx(i, r));
              i = i.next;
            }
          while (t);
          Nf = false;
        }
      }
      function Vw() {
        Bh = Nm = false;
        var s = 0;
        Ar !== 0 && (Qw() && (s = Ar), Ar = 0);
        for (var e = ss(), t = null, i = Ch; i !== null; ) {
          var n = i.next, r = R1(i, e);
          r === 0 ? (i.next = null, t === null ? Ch = n : t.next = n, n === null && (va = t)) : (t = i, (s !== 0 || r & 3) && (Bh = true)), i = n;
        }
        Eu(s);
      }
      function R1(s, e) {
        for (var t = s.suspendedLanes, i = s.pingedLanes, n = s.expirationTimes, r = s.pendingLanes & -62914561; 0 < r; ) {
          var a = 31 - ci(r), l = 1 << a, o = n[a];
          o === -1 ? (!(l & t) || l & i) && (n[a] = pN(l, e)) : o <= e && (s.expiredLanes |= l), r &= ~l;
        }
        if (e = Re, t = he, t = dd(s, s === e ? t : 0), i = s.callbackNode, t === 0 || s === e && Ee === 2 || s.cancelPendingCommit !== null) return i !== null && i !== null && tf(i), s.callbackNode = null, s.callbackPriority = 0;
        if (!(t & 3) || bu(s, t)) {
          if (e = t & -t, e === s.callbackPriority) return e;
          switch (i !== null && tf(i), CS(t)) {
            case 2:
            case 8:
              t = MS;
              break;
            case 32:
              t = ph;
              break;
            case 268435456:
              t = AS;
              break;
            default:
              t = ph;
          }
          return i = C1.bind(null, s), t = Ug(t, i), s.callbackPriority = e, s.callbackNode = t, e;
        }
        return i !== null && i !== null && tf(i), s.callbackPriority = 2, s.callbackNode = null, 2;
      }
      function C1(s, e) {
        var t = s.callbackNode;
        if (Za() && s.callbackNode !== t) return null;
        var i = he;
        return i = dd(s, s === Re ? i : 0), i === 0 ? null : (S1(s, i, e), R1(s, ss()), s.callbackNode != null && s.callbackNode === t ? C1.bind(null, s) : null);
      }
      function Mx(s, e) {
        if (Za()) return null;
        S1(s, e, true);
      }
      function Hw(s) {
        Jw(function() {
          ke & 6 ? Ug(vS, s) : s();
        });
      }
      function my() {
        return Ar === 0 && (Ar = NS()), Ar;
      }
      function Ax(s) {
        return s == null || typeof s == "symbol" || typeof s == "boolean" ? null : typeof s == "function" ? s : Vc("" + s);
      }
      function Nx(s, e) {
        var t = e.ownerDocument.createElement("input");
        return t.name = e.name, t.value = e.value, s.id && t.setAttribute("form", s.id), e.parentNode.insertBefore(t, e), s = new FormData(s), t.parentNode.removeChild(t), s;
      }
      function qw(s, e, t, i, n) {
        if (e === "submit" && t && t.stateNode === n) {
          var r = Ax((n[Xt] || null).action), a = i.submitter;
          a && (e = (e = a[Xt] || null) ? Ax(e.formAction) : a.getAttribute("formAction"), e !== null && (r = e, a = null));
          var l = new fd("action", "action", null, i, n);
          s.push({
            event: l,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (i.defaultPrevented) {
                    if (Ar !== 0) {
                      var o = a ? Nx(n, a) : new FormData(n);
                      lm(t, {
                        pending: true,
                        data: o,
                        method: n.method,
                        action: r
                      }, null, o);
                    }
                  } else typeof r == "function" && (l.preventDefault(), o = a ? Nx(n, a) : new FormData(n), lm(t, {
                    pending: true,
                    data: o,
                    method: n.method,
                    action: r
                  }, r, o));
                },
                currentTarget: n
              }
            ]
          });
        }
      }
      for (var wf = 0; wf < j0.length; wf++) {
        var Ef = j0[wf], Yw = Ef.toLowerCase(), Ww = Ef[0].toUpperCase() + Ef.slice(1);
        Zi(Yw, "on" + Ww);
      }
      Zi(QS, "onAnimationEnd");
      Zi(KS, "onAnimationIteration");
      Zi(JS, "onAnimationStart");
      Zi("dblclick", "onDoubleClick");
      Zi("focusin", "onFocus");
      Zi("focusout", "onBlur");
      Zi(uw, "onTransitionRun");
      Zi(cw, "onTransitionStart");
      Zi(hw, "onTransitionCancel");
      Zi(eT, "onTransitionEnd");
      ao("onMouseEnter", [
        "mouseout",
        "mouseover"
      ]);
      ao("onMouseLeave", [
        "mouseout",
        "mouseover"
      ]);
      ao("onPointerEnter", [
        "pointerout",
        "pointerover"
      ]);
      ao("onPointerLeave", [
        "pointerout",
        "pointerover"
      ]);
      Ir("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      Ir("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      Ir("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      Ir("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      Ir("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      Ir("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var Xl = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), jw = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Xl));
      function B1(s, e) {
        e = (e & 4) !== 0;
        for (var t = 0; t < s.length; t++) {
          var i = s[t], n = i.event;
          i = i.listeners;
          e: {
            var r = void 0;
            if (e) for (var a = i.length - 1; 0 <= a; a--) {
              var l = i[a], o = l.instance, u = l.currentTarget;
              if (l = l.listener, o !== r && n.isPropagationStopped()) break e;
              r = l, n.currentTarget = u;
              try {
                r(n);
              } catch (c) {
                Mh(c);
              }
              n.currentTarget = null, r = o;
            }
            else for (a = 0; a < i.length; a++) {
              if (l = i[a], o = l.instance, u = l.currentTarget, l = l.listener, o !== r && n.isPropagationStopped()) break e;
              r = l, n.currentTarget = u;
              try {
                r(n);
              } catch (c) {
                Mh(c);
              }
              n.currentTarget = null, r = o;
            }
          }
        }
      }
      function ue(s, e) {
        var t = e[Xp];
        t === void 0 && (t = e[Xp] = /* @__PURE__ */ new Set());
        var i = s + "__bubble";
        t.has(i) || (D1(e, s, 2, false), t.add(i));
      }
      function Rf(s, e, t) {
        var i = 0;
        e && (i |= 4), D1(t, s, i, e);
      }
      var Ku = "_reactListening" + Math.random().toString(36).slice(2);
      function gy(s) {
        if (!s[Ku]) {
          s[Ku] = true, DS.forEach(function(t) {
            t !== "selectionchange" && (jw.has(t) || Rf(t, false, s), Rf(t, true, s));
          });
          var e = s.nodeType === 9 ? s : s.ownerDocument;
          e === null || e[Ku] || (e[Ku] = true, Rf("selectionchange", false, e));
        }
      }
      function D1(s, e, t, i) {
        switch (q1(e)) {
          case 2:
            var n = _E;
            break;
          case 8:
            n = bE;
            break;
          default:
            n = by;
        }
        t = n.bind(null, e, t, s), n = void 0, !Jp || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (n = true), i ? n !== void 0 ? s.addEventListener(e, t, {
          capture: true,
          passive: n
        }) : s.addEventListener(e, t, true) : n !== void 0 ? s.addEventListener(e, t, {
          passive: n
        }) : s.addEventListener(e, t, false);
      }
      function Cf(s, e, t, i, n) {
        var r = i;
        if (!(e & 1) && !(e & 2) && i !== null) e: for (; ; ) {
          if (i === null) return;
          var a = i.tag;
          if (a === 3 || a === 4) {
            var l = i.stateNode.containerInfo;
            if (l === n || l.nodeType === 8 && l.parentNode === n) break;
            if (a === 4) for (a = i.return; a !== null; ) {
              var o = a.tag;
              if ((o === 3 || o === 4) && (o = a.stateNode.containerInfo, o === n || o.nodeType === 8 && o.parentNode === n)) return;
              a = a.return;
            }
            for (; l !== null; ) {
              if (a = xr(l), a === null) return;
              if (o = a.tag, o === 5 || o === 6 || o === 26 || o === 27) {
                i = r = a;
                continue e;
              }
              l = l.parentNode;
            }
          }
          i = i.return;
        }
        kS(function() {
          var u = r, c = zg(t), h = [];
          e: {
            var d = tT.get(s);
            if (d !== void 0) {
              var f = fd, p = s;
              switch (s) {
                case "keypress":
                  if (qc(t) === 0) break e;
                case "keydown":
                case "keyup":
                  f = kN;
                  break;
                case "focusin":
                  p = "focus", f = of;
                  break;
                case "focusout":
                  p = "blur", f = of;
                  break;
                case "beforeblur":
                case "afterblur":
                  f = of;
                  break;
                case "click":
                  if (t.button === 2) break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  f = O0;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  f = EN;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  f = HN;
                  break;
                case QS:
                case KS:
                case JS:
                  f = BN;
                  break;
                case eT:
                  f = YN;
                  break;
                case "scroll":
                case "scrollend":
                  f = NN;
                  break;
                case "wheel":
                  f = jN;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  f = UN;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  f = L0;
                  break;
                case "toggle":
                case "beforetoggle":
                  f = XN;
              }
              var g = (e & 4) !== 0, _ = !g && (s === "scroll" || s === "scrollend"), m = g ? d !== null ? d + "Capture" : null : d;
              g = [];
              for (var y = u, x; y !== null; ) {
                var b = y;
                if (x = b.stateNode, b = b.tag, b !== 5 && b !== 26 && b !== 27 || x === null || m === null || (b = Hl(y, m), b != null && g.push(Zl(y, b, x))), _) break;
                y = y.return;
              }
              0 < g.length && (d = new f(d, p, null, t, c), h.push({
                event: d,
                listeners: g
              }));
            }
          }
          if (!(e & 7)) {
            e: {
              if (d = s === "mouseover" || s === "pointerover", f = s === "mouseout" || s === "pointerout", d && t !== Kp && (p = t.relatedTarget || t.fromElement) && (xr(p) || p[Eo])) break e;
              if ((f || d) && (d = c.window === c ? c : (d = c.ownerDocument) ? d.defaultView || d.parentWindow : window, f ? (p = t.relatedTarget || t.toElement, f = u, p = p ? xr(p) : null, p !== null && (_ = wo(p), g = p.tag, p !== _ || g !== 5 && g !== 27 && g !== 6) && (p = null)) : (f = null, p = u), f !== p)) {
                if (g = O0, b = "onMouseLeave", m = "onMouseEnter", y = "mouse", (s === "pointerout" || s === "pointerover") && (g = L0, b = "onPointerLeave", m = "onPointerEnter", y = "pointer"), _ = f == null ? d : dl(f), x = p == null ? d : dl(p), d = new g(b, y + "leave", f, t, c), d.target = _, d.relatedTarget = x, b = null, xr(c) === u && (g = new g(m, y + "enter", p, t, c), g.target = x, g.relatedTarget = _, b = g), _ = b, f && p) t: {
                  for (g = f, m = p, y = 0, x = g; x; x = Jr(x)) y++;
                  for (x = 0, b = m; b; b = Jr(b)) x++;
                  for (; 0 < y - x; ) g = Jr(g), y--;
                  for (; 0 < x - y; ) m = Jr(m), x--;
                  for (; y--; ) {
                    if (g === m || m !== null && g === m.alternate) break t;
                    g = Jr(g), m = Jr(m);
                  }
                  g = null;
                }
                else g = null;
                f !== null && wx(h, d, f, g, false), p !== null && _ !== null && wx(h, _, p, g, true);
              }
            }
            e: {
              if (d = u ? dl(u) : window, f = d.nodeName && d.nodeName.toLowerCase(), f === "select" || f === "input" && d.type === "file") var T = I0;
              else if (k0(d)) if (WS) T = rw;
              else {
                T = sw;
                var N = iw;
              }
              else f = d.nodeName, !f || f.toLowerCase() !== "input" || d.type !== "checkbox" && d.type !== "radio" ? u && Og(u.elementType) && (T = I0) : T = nw;
              if (T && (T = T(s, u))) {
                YS(h, T, t, c);
                break e;
              }
              N && N(s, d, u), s === "focusout" && u && d.type === "number" && u.memoizedProps.value != null && Qp(d, "number", d.value);
            }
            switch (N = u ? dl(u) : window, s) {
              case "focusin":
                (k0(N) || N.contentEditable === "true") && (Ra = N, em = u, bl = null);
                break;
              case "focusout":
                bl = em = Ra = null;
                break;
              case "mousedown":
                tm = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                tm = false, W0(h, t, c);
                break;
              case "selectionchange":
                if (lw) break;
              case "keydown":
              case "keyup":
                W0(h, t, c);
            }
            var A;
            if (Pg) e: {
              switch (s) {
                case "compositionstart":
                  var w = "onCompositionStart";
                  break e;
                case "compositionend":
                  w = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  w = "onCompositionUpdate";
                  break e;
              }
              w = void 0;
            }
            else Ea ? HS(s, t) && (w = "onCompositionEnd") : s === "keydown" && t.keyCode === 229 && (w = "onCompositionStart");
            w && (VS && t.locale !== "ko" && (Ea || w !== "onCompositionStart" ? w === "onCompositionEnd" && Ea && (A = IS()) : (Rn = c, Lg = "value" in Rn ? Rn.value : Rn.textContent, Ea = true)), N = Dh(u, w), 0 < N.length && (w = new z0(w, s, null, t, c), h.push({
              event: w,
              listeners: N
            }), A ? w.data = A : (A = qS(t), A !== null && (w.data = A)))), (A = QN ? KN(s, t) : JN(s, t)) && (w = Dh(u, "onBeforeInput"), 0 < w.length && (N = new z0("onBeforeInput", "beforeinput", null, t, c), h.push({
              event: N,
              listeners: w
            }), N.data = A)), qw(h, s, u, t, c);
          }
          B1(h, e);
        });
      }
      function Zl(s, e, t) {
        return {
          instance: s,
          listener: e,
          currentTarget: t
        };
      }
      function Dh(s, e) {
        for (var t = e + "Capture", i = []; s !== null; ) {
          var n = s, r = n.stateNode;
          n = n.tag, n !== 5 && n !== 26 && n !== 27 || r === null || (n = Hl(s, t), n != null && i.unshift(Zl(s, n, r)), n = Hl(s, e), n != null && i.push(Zl(s, n, r))), s = s.return;
        }
        return i;
      }
      function Jr(s) {
        if (s === null) return null;
        do
          s = s.return;
        while (s && s.tag !== 5 && s.tag !== 27);
        return s || null;
      }
      function wx(s, e, t, i, n) {
        for (var r = e._reactName, a = []; t !== null && t !== i; ) {
          var l = t, o = l.alternate, u = l.stateNode;
          if (l = l.tag, o !== null && o === i) break;
          l !== 5 && l !== 26 && l !== 27 || u === null || (o = u, n ? (u = Hl(t, r), u != null && a.unshift(Zl(t, u, o))) : n || (u = Hl(t, r), u != null && a.push(Zl(t, u, o)))), t = t.return;
        }
        a.length !== 0 && s.push({
          event: e,
          listeners: a
        });
      }
      var $w = /\r\n?/g, Xw = /\u0000|\uFFFD/g;
      function Ex(s) {
        return (typeof s == "string" ? s : "" + s).replace($w, `
`).replace(Xw, "");
      }
      function U1(s, e) {
        return e = Ex(e), Ex(s) === e;
      }
      function Md() {
      }
      function ve(s, e, t, i, n, r) {
        switch (t) {
          case "children":
            typeof i == "string" ? e === "body" || e === "textarea" && i === "" || oo(s, i) : (typeof i == "number" || typeof i == "bigint") && e !== "body" && oo(s, "" + i);
            break;
          case "className":
            qu(s, "class", i);
            break;
          case "tabIndex":
            qu(s, "tabindex", i);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            qu(s, t, i);
            break;
          case "style":
            PS(s, i, r);
            break;
          case "data":
            if (e !== "object") {
              qu(s, "data", i);
              break;
            }
          case "src":
          case "href":
            if (i === "" && (e !== "a" || t !== "href")) {
              s.removeAttribute(t);
              break;
            }
            if (i == null || typeof i == "function" || typeof i == "symbol" || typeof i == "boolean") {
              s.removeAttribute(t);
              break;
            }
            i = Vc("" + i), s.setAttribute(t, i);
            break;
          case "action":
          case "formAction":
            if (typeof i == "function") {
              s.setAttribute(t, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
              break;
            } else typeof r == "function" && (t === "formAction" ? (e !== "input" && ve(s, e, "name", n.name, n, null), ve(s, e, "formEncType", n.formEncType, n, null), ve(s, e, "formMethod", n.formMethod, n, null), ve(s, e, "formTarget", n.formTarget, n, null)) : (ve(s, e, "encType", n.encType, n, null), ve(s, e, "method", n.method, n, null), ve(s, e, "target", n.target, n, null)));
            if (i == null || typeof i == "symbol" || typeof i == "boolean") {
              s.removeAttribute(t);
              break;
            }
            i = Vc("" + i), s.setAttribute(t, i);
            break;
          case "onClick":
            i != null && (s.onclick = Md);
            break;
          case "onScroll":
            i != null && ue("scroll", s);
            break;
          case "onScrollEnd":
            i != null && ue("scrollend", s);
            break;
          case "dangerouslySetInnerHTML":
            if (i != null) {
              if (typeof i != "object" || !("__html" in i)) throw Error(D(61));
              if (t = i.__html, t != null) {
                if (n.children != null) throw Error(D(60));
                s.innerHTML = t;
              }
            }
            break;
          case "multiple":
            s.multiple = i && typeof i != "function" && typeof i != "symbol";
            break;
          case "muted":
            s.muted = i && typeof i != "function" && typeof i != "symbol";
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (i == null || typeof i == "function" || typeof i == "boolean" || typeof i == "symbol") {
              s.removeAttribute("xlink:href");
              break;
            }
            t = Vc("" + i), s.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", t);
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            i != null && typeof i != "function" && typeof i != "symbol" ? s.setAttribute(t, "" + i) : s.removeAttribute(t);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            i && typeof i != "function" && typeof i != "symbol" ? s.setAttribute(t, "") : s.removeAttribute(t);
            break;
          case "capture":
          case "download":
            i === true ? s.setAttribute(t, "") : i !== false && i != null && typeof i != "function" && typeof i != "symbol" ? s.setAttribute(t, i) : s.removeAttribute(t);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            i != null && typeof i != "function" && typeof i != "symbol" && !isNaN(i) && 1 <= i ? s.setAttribute(t, i) : s.removeAttribute(t);
            break;
          case "rowSpan":
          case "start":
            i == null || typeof i == "function" || typeof i == "symbol" || isNaN(i) ? s.removeAttribute(t) : s.setAttribute(t, i);
            break;
          case "popover":
            ue("beforetoggle", s), ue("toggle", s), Ic(s, "popover", i);
            break;
          case "xlinkActuate":
            ps(s, "http://www.w3.org/1999/xlink", "xlink:actuate", i);
            break;
          case "xlinkArcrole":
            ps(s, "http://www.w3.org/1999/xlink", "xlink:arcrole", i);
            break;
          case "xlinkRole":
            ps(s, "http://www.w3.org/1999/xlink", "xlink:role", i);
            break;
          case "xlinkShow":
            ps(s, "http://www.w3.org/1999/xlink", "xlink:show", i);
            break;
          case "xlinkTitle":
            ps(s, "http://www.w3.org/1999/xlink", "xlink:title", i);
            break;
          case "xlinkType":
            ps(s, "http://www.w3.org/1999/xlink", "xlink:type", i);
            break;
          case "xmlBase":
            ps(s, "http://www.w3.org/XML/1998/namespace", "xml:base", i);
            break;
          case "xmlLang":
            ps(s, "http://www.w3.org/XML/1998/namespace", "xml:lang", i);
            break;
          case "xmlSpace":
            ps(s, "http://www.w3.org/XML/1998/namespace", "xml:space", i);
            break;
          case "is":
            Ic(s, "is", i);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            (!(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (t = MN.get(t) || t, Ic(s, t, i));
        }
      }
      function wm(s, e, t, i, n, r) {
        switch (t) {
          case "style":
            PS(s, i, r);
            break;
          case "dangerouslySetInnerHTML":
            if (i != null) {
              if (typeof i != "object" || !("__html" in i)) throw Error(D(61));
              if (t = i.__html, t != null) {
                if (n.children != null) throw Error(D(60));
                s.innerHTML = t;
              }
            }
            break;
          case "children":
            typeof i == "string" ? oo(s, i) : (typeof i == "number" || typeof i == "bigint") && oo(s, "" + i);
            break;
          case "onScroll":
            i != null && ue("scroll", s);
            break;
          case "onScrollEnd":
            i != null && ue("scrollend", s);
            break;
          case "onClick":
            i != null && (s.onclick = Md);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!US.hasOwnProperty(t)) e: {
              if (t[0] === "o" && t[1] === "n" && (n = t.endsWith("Capture"), e = t.slice(2, n ? t.length - 7 : void 0), r = s[Xt] || null, r = r != null ? r[t] : null, typeof r == "function" && s.removeEventListener(e, r, n), typeof i == "function")) {
                typeof r != "function" && r !== null && (t in s ? s[t] = null : s.hasAttribute(t) && s.removeAttribute(t)), s.addEventListener(e, i, n);
                break e;
              }
              t in s ? s[t] = i : i === true ? s.setAttribute(t, "") : Ic(s, t, i);
            }
        }
      }
      function Mt(s, e, t) {
        switch (e) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            ue("error", s), ue("load", s);
            var i = false, n = false, r;
            for (r in t) if (t.hasOwnProperty(r)) {
              var a = t[r];
              if (a != null) switch (r) {
                case "src":
                  i = true;
                  break;
                case "srcSet":
                  n = true;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(D(137, e));
                default:
                  ve(s, e, r, a, t, null);
              }
            }
            n && ve(s, e, "srcSet", t.srcSet, t, null), i && ve(s, e, "src", t.src, t, null);
            return;
          case "input":
            ue("invalid", s);
            var l = r = a = n = null, o = null, u = null;
            for (i in t) if (t.hasOwnProperty(i)) {
              var c = t[i];
              if (c != null) switch (i) {
                case "name":
                  n = c;
                  break;
                case "type":
                  a = c;
                  break;
                case "checked":
                  o = c;
                  break;
                case "defaultChecked":
                  u = c;
                  break;
                case "value":
                  r = c;
                  break;
                case "defaultValue":
                  l = c;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (c != null) throw Error(D(137, e));
                  break;
                default:
                  ve(s, e, i, c, t, null);
              }
            }
            zS(s, r, l, o, u, a, n, false), mh(s);
            return;
          case "select":
            ue("invalid", s), i = a = r = null;
            for (n in t) if (t.hasOwnProperty(n) && (l = t[n], l != null)) switch (n) {
              case "value":
                r = l;
                break;
              case "defaultValue":
                a = l;
                break;
              case "multiple":
                i = l;
              default:
                ve(s, e, n, l, t, null);
            }
            e = r, t = a, s.multiple = !!i, e != null ? qa(s, !!i, e, false) : t != null && qa(s, !!i, t, true);
            return;
          case "textarea":
            ue("invalid", s), r = n = i = null;
            for (a in t) if (t.hasOwnProperty(a) && (l = t[a], l != null)) switch (a) {
              case "value":
                i = l;
                break;
              case "defaultValue":
                n = l;
                break;
              case "children":
                r = l;
                break;
              case "dangerouslySetInnerHTML":
                if (l != null) throw Error(D(91));
                break;
              default:
                ve(s, e, a, l, t, null);
            }
            GS(s, i, n, r), mh(s);
            return;
          case "option":
            for (o in t) if (t.hasOwnProperty(o) && (i = t[o], i != null)) switch (o) {
              case "selected":
                s.selected = i && typeof i != "function" && typeof i != "symbol";
                break;
              default:
                ve(s, e, o, i, t, null);
            }
            return;
          case "dialog":
            ue("cancel", s), ue("close", s);
            break;
          case "iframe":
          case "object":
            ue("load", s);
            break;
          case "video":
          case "audio":
            for (i = 0; i < Xl.length; i++) ue(Xl[i], s);
            break;
          case "image":
            ue("error", s), ue("load", s);
            break;
          case "details":
            ue("toggle", s);
            break;
          case "embed":
          case "source":
          case "link":
            ue("error", s), ue("load", s);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (u in t) if (t.hasOwnProperty(u) && (i = t[u], i != null)) switch (u) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(D(137, e));
              default:
                ve(s, e, u, i, t, null);
            }
            return;
          default:
            if (Og(e)) {
              for (c in t) t.hasOwnProperty(c) && (i = t[c], i !== void 0 && wm(s, e, c, i, t, void 0));
              return;
            }
        }
        for (l in t) t.hasOwnProperty(l) && (i = t[l], i != null && ve(s, e, l, i, t, null));
      }
      function Zw(s, e, t, i) {
        switch (e) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var n = null, r = null, a = null, l = null, o = null, u = null, c = null;
            for (f in t) {
              var h = t[f];
              if (t.hasOwnProperty(f) && h != null) switch (f) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  o = h;
                default:
                  i.hasOwnProperty(f) || ve(s, e, f, null, i, h);
              }
            }
            for (var d in i) {
              var f = i[d];
              if (h = t[d], i.hasOwnProperty(d) && (f != null || h != null)) switch (d) {
                case "type":
                  r = f;
                  break;
                case "name":
                  n = f;
                  break;
                case "checked":
                  u = f;
                  break;
                case "defaultChecked":
                  c = f;
                  break;
                case "value":
                  a = f;
                  break;
                case "defaultValue":
                  l = f;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (f != null) throw Error(D(137, e));
                  break;
                default:
                  f !== h && ve(s, e, d, f, i, h);
              }
            }
            Zp(s, a, l, o, u, c, r, n);
            return;
          case "select":
            f = a = l = d = null;
            for (r in t) if (o = t[r], t.hasOwnProperty(r) && o != null) switch (r) {
              case "value":
                break;
              case "multiple":
                f = o;
              default:
                i.hasOwnProperty(r) || ve(s, e, r, null, i, o);
            }
            for (n in i) if (r = i[n], o = t[n], i.hasOwnProperty(n) && (r != null || o != null)) switch (n) {
              case "value":
                d = r;
                break;
              case "defaultValue":
                l = r;
                break;
              case "multiple":
                a = r;
              default:
                r !== o && ve(s, e, n, r, i, o);
            }
            e = l, t = a, i = f, d != null ? qa(s, !!t, d, false) : !!i != !!t && (e != null ? qa(s, !!t, e, true) : qa(s, !!t, t ? [] : "", false));
            return;
          case "textarea":
            f = d = null;
            for (l in t) if (n = t[l], t.hasOwnProperty(l) && n != null && !i.hasOwnProperty(l)) switch (l) {
              case "value":
                break;
              case "children":
                break;
              default:
                ve(s, e, l, null, i, n);
            }
            for (a in i) if (n = i[a], r = t[a], i.hasOwnProperty(a) && (n != null || r != null)) switch (a) {
              case "value":
                d = n;
                break;
              case "defaultValue":
                f = n;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (n != null) throw Error(D(91));
                break;
              default:
                n !== r && ve(s, e, a, n, i, r);
            }
            LS(s, d, f);
            return;
          case "option":
            for (var p in t) if (d = t[p], t.hasOwnProperty(p) && d != null && !i.hasOwnProperty(p)) switch (p) {
              case "selected":
                s.selected = false;
                break;
              default:
                ve(s, e, p, null, i, d);
            }
            for (o in i) if (d = i[o], f = t[o], i.hasOwnProperty(o) && d !== f && (d != null || f != null)) switch (o) {
              case "selected":
                s.selected = d && typeof d != "function" && typeof d != "symbol";
                break;
              default:
                ve(s, e, o, d, i, f);
            }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var g in t) d = t[g], t.hasOwnProperty(g) && d != null && !i.hasOwnProperty(g) && ve(s, e, g, null, i, d);
            for (u in i) if (d = i[u], f = t[u], i.hasOwnProperty(u) && d !== f && (d != null || f != null)) switch (u) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (d != null) throw Error(D(137, e));
                break;
              default:
                ve(s, e, u, d, i, f);
            }
            return;
          default:
            if (Og(e)) {
              for (var _ in t) d = t[_], t.hasOwnProperty(_) && d !== void 0 && !i.hasOwnProperty(_) && wm(s, e, _, void 0, i, d);
              for (c in i) d = i[c], f = t[c], !i.hasOwnProperty(c) || d === f || d === void 0 && f === void 0 || wm(s, e, c, d, i, f);
              return;
            }
        }
        for (var m in t) d = t[m], t.hasOwnProperty(m) && d != null && !i.hasOwnProperty(m) && ve(s, e, m, null, i, d);
        for (h in i) d = i[h], f = t[h], !i.hasOwnProperty(h) || d === f || d == null && f == null || ve(s, e, h, d, i, f);
      }
      var Em = null, Rm = null;
      function Uh(s) {
        return s.nodeType === 9 ? s : s.ownerDocument;
      }
      function Rx(s) {
        switch (s) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function F1(s, e) {
        if (s === 0) switch (e) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
        return s === 1 && e === "foreignObject" ? 0 : s;
      }
      function Cm(s, e) {
        return s === "textarea" || s === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.children == "bigint" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
      }
      var Bf = null;
      function Qw() {
        var s = window.event;
        return s && s.type === "popstate" ? s === Bf ? false : (Bf = s, true) : (Bf = null, false);
      }
      var O1 = typeof setTimeout == "function" ? setTimeout : void 0, Kw = typeof clearTimeout == "function" ? clearTimeout : void 0, Cx = typeof Promise == "function" ? Promise : void 0, Jw = typeof queueMicrotask == "function" ? queueMicrotask : typeof Cx < "u" ? function(s) {
        return Cx.resolve(null).then(s).catch(eE);
      } : O1;
      function eE(s) {
        setTimeout(function() {
          throw s;
        });
      }
      function Df(s, e) {
        var t = e, i = 0;
        do {
          var n = t.nextSibling;
          if (s.removeChild(t), n && n.nodeType === 8) if (t = n.data, t === "/$") {
            if (i === 0) {
              s.removeChild(n), tu(e);
              return;
            }
            i--;
          } else t !== "$" && t !== "$?" && t !== "$!" || i++;
          t = n;
        } while (t);
        tu(e);
      }
      function Bm(s) {
        var e = s.firstChild;
        for (e && e.nodeType === 10 && (e = e.nextSibling); e; ) {
          var t = e;
          switch (e = e.nextSibling, t.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              Bm(t), Fg(t);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if (t.rel.toLowerCase() === "stylesheet") continue;
          }
          s.removeChild(t);
        }
      }
      function tE(s, e, t, i) {
        for (; s.nodeType === 1; ) {
          var n = t;
          if (s.nodeName.toLowerCase() !== e.toLowerCase()) {
            if (!i && (s.nodeName !== "INPUT" || s.type !== "hidden")) break;
          } else if (i) {
            if (!s[Vl]) switch (e) {
              case "meta":
                if (!s.hasAttribute("itemprop")) break;
                return s;
              case "link":
                if (r = s.getAttribute("rel"), r === "stylesheet" && s.hasAttribute("data-precedence")) break;
                if (r !== n.rel || s.getAttribute("href") !== (n.href == null ? null : n.href) || s.getAttribute("crossorigin") !== (n.crossOrigin == null ? null : n.crossOrigin) || s.getAttribute("title") !== (n.title == null ? null : n.title)) break;
                return s;
              case "style":
                if (s.hasAttribute("data-precedence")) break;
                return s;
              case "script":
                if (r = s.getAttribute("src"), (r !== (n.src == null ? null : n.src) || s.getAttribute("type") !== (n.type == null ? null : n.type) || s.getAttribute("crossorigin") !== (n.crossOrigin == null ? null : n.crossOrigin)) && r && s.hasAttribute("async") && !s.hasAttribute("itemprop")) break;
                return s;
              default:
                return s;
            }
          } else if (e === "input" && s.type === "hidden") {
            var r = n.name == null ? null : "" + n.name;
            if (n.type === "hidden" && s.getAttribute("name") === r) return s;
          } else return s;
          if (s = Yi(s.nextSibling), s === null) break;
        }
        return null;
      }
      function iE(s, e, t) {
        if (e === "") return null;
        for (; s.nodeType !== 3; ) if ((s.nodeType !== 1 || s.nodeName !== "INPUT" || s.type !== "hidden") && !t || (s = Yi(s.nextSibling), s === null)) return null;
        return s;
      }
      function Yi(s) {
        for (; s != null; s = s.nextSibling) {
          var e = s.nodeType;
          if (e === 1 || e === 3) break;
          if (e === 8) {
            if (e = s.data, e === "$" || e === "$!" || e === "$?" || e === "F!" || e === "F") break;
            if (e === "/$") return null;
          }
        }
        return s;
      }
      function Bx(s) {
        s = s.previousSibling;
        for (var e = 0; s; ) {
          if (s.nodeType === 8) {
            var t = s.data;
            if (t === "$" || t === "$!" || t === "$?") {
              if (e === 0) return s;
              e--;
            } else t === "/$" && e++;
          }
          s = s.previousSibling;
        }
        return null;
      }
      function z1(s, e, t) {
        switch (e = Uh(t), s) {
          case "html":
            if (s = e.documentElement, !s) throw Error(D(452));
            return s;
          case "head":
            if (s = e.head, !s) throw Error(D(453));
            return s;
          case "body":
            if (s = e.body, !s) throw Error(D(454));
            return s;
          default:
            throw Error(D(451));
        }
      }
      var Ui = /* @__PURE__ */ new Map(), Dx = /* @__PURE__ */ new Set();
      function Fh(s) {
        return typeof s.getRootNode == "function" ? s.getRootNode() : s.ownerDocument;
      }
      var Ks = De.d;
      De.d = {
        f: sE,
        r: nE,
        D: rE,
        C: aE,
        L: oE,
        m: lE,
        X: cE,
        S: uE,
        M: hE
      };
      function sE() {
        var s = Ks.f(), e = Td();
        return s || e;
      }
      function nE(s) {
        var e = Ro(s);
        e !== null && e.tag === 5 && e.type === "form" ? zT(e) : Ks.r(s);
      }
      var Bo = typeof document > "u" ? null : document;
      function L1(s, e, t) {
        var i = Bo;
        if (i && typeof e == "string" && e) {
          var n = Ai(e);
          n = 'link[rel="' + s + '"][href="' + n + '"]', typeof t == "string" && (n += '[crossorigin="' + t + '"]'), Dx.has(n) || (Dx.add(n), s = {
            rel: s,
            crossOrigin: t,
            href: e
          }, i.querySelector(n) === null && (e = i.createElement("link"), Mt(e, "link", s), mt(e), i.head.appendChild(e)));
        }
      }
      function rE(s) {
        Ks.D(s), L1("dns-prefetch", s, null);
      }
      function aE(s, e) {
        Ks.C(s, e), L1("preconnect", s, e);
      }
      function oE(s, e, t) {
        Ks.L(s, e, t);
        var i = Bo;
        if (i && s && e) {
          var n = 'link[rel="preload"][as="' + Ai(e) + '"]';
          e === "image" && t && t.imageSrcSet ? (n += '[imagesrcset="' + Ai(t.imageSrcSet) + '"]', typeof t.imageSizes == "string" && (n += '[imagesizes="' + Ai(t.imageSizes) + '"]')) : n += '[href="' + Ai(s) + '"]';
          var r = n;
          switch (e) {
            case "style":
              r = po(s);
              break;
            case "script":
              r = Do(s);
          }
          Ui.has(r) || (s = Ue({
            rel: "preload",
            href: e === "image" && t && t.imageSrcSet ? void 0 : s,
            as: e
          }, t), Ui.set(r, s), i.querySelector(n) !== null || e === "style" && i.querySelector(Ru(r)) || e === "script" && i.querySelector(Cu(r)) || (e = i.createElement("link"), Mt(e, "link", s), mt(e), i.head.appendChild(e)));
        }
      }
      function lE(s, e) {
        Ks.m(s, e);
        var t = Bo;
        if (t && s) {
          var i = e && typeof e.as == "string" ? e.as : "script", n = 'link[rel="modulepreload"][as="' + Ai(i) + '"][href="' + Ai(s) + '"]', r = n;
          switch (i) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              r = Do(s);
          }
          if (!Ui.has(r) && (s = Ue({
            rel: "modulepreload",
            href: s
          }, e), Ui.set(r, s), t.querySelector(n) === null)) {
            switch (i) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (t.querySelector(Cu(r))) return;
            }
            i = t.createElement("link"), Mt(i, "link", s), mt(i), t.head.appendChild(i);
          }
        }
      }
      function uE(s, e, t) {
        Ks.S(s, e, t);
        var i = Bo;
        if (i && s) {
          var n = Ha(i).hoistableStyles, r = po(s);
          e = e || "default";
          var a = n.get(r);
          if (!a) {
            var l = {
              loading: 0,
              preload: null
            };
            if (a = i.querySelector(Ru(r))) l.loading = 5;
            else {
              s = Ue({
                rel: "stylesheet",
                href: s,
                "data-precedence": e
              }, t), (t = Ui.get(r)) && yy(s, t);
              var o = a = i.createElement("link");
              mt(o), Mt(o, "link", s), o._p = new Promise(function(u, c) {
                o.onload = u, o.onerror = c;
              }), o.addEventListener("load", function() {
                l.loading |= 1;
              }), o.addEventListener("error", function() {
                l.loading |= 2;
              }), l.loading |= 4, Zc(a, e, i);
            }
            a = {
              type: "stylesheet",
              instance: a,
              count: 1,
              state: l
            }, n.set(r, a);
          }
        }
      }
      function cE(s, e) {
        Ks.X(s, e);
        var t = Bo;
        if (t && s) {
          var i = Ha(t).hoistableScripts, n = Do(s), r = i.get(n);
          r || (r = t.querySelector(Cu(n)), r || (s = Ue({
            src: s,
            async: true
          }, e), (e = Ui.get(n)) && xy(s, e), r = t.createElement("script"), mt(r), Mt(r, "link", s), t.head.appendChild(r)), r = {
            type: "script",
            instance: r,
            count: 1,
            state: null
          }, i.set(n, r));
        }
      }
      function hE(s, e) {
        Ks.M(s, e);
        var t = Bo;
        if (t && s) {
          var i = Ha(t).hoistableScripts, n = Do(s), r = i.get(n);
          r || (r = t.querySelector(Cu(n)), r || (s = Ue({
            src: s,
            async: true,
            type: "module"
          }, e), (e = Ui.get(n)) && xy(s, e), r = t.createElement("script"), mt(r), Mt(r, "link", s), t.head.appendChild(r)), r = {
            type: "script",
            instance: r,
            count: 1,
            state: null
          }, i.set(n, r));
        }
      }
      function Ux(s, e, t, i) {
        var n = (n = Dn.current) ? Fh(n) : null;
        if (!n) throw Error(D(446));
        switch (s) {
          case "meta":
          case "title":
            return null;
          case "style":
            return typeof t.precedence == "string" && typeof t.href == "string" ? (e = po(t.href), t = Ha(n).hoistableStyles, i = t.get(e), i || (i = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, t.set(e, i)), i) : {
              type: "void",
              instance: null,
              count: 0,
              state: null
            };
          case "link":
            if (t.rel === "stylesheet" && typeof t.href == "string" && typeof t.precedence == "string") {
              s = po(t.href);
              var r = Ha(n).hoistableStyles, a = r.get(s);
              if (a || (n = n.ownerDocument || n, a = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: {
                  loading: 0,
                  preload: null
                }
              }, r.set(s, a), (r = n.querySelector(Ru(s))) && !r._p && (a.instance = r, a.state.loading = 5), Ui.has(s) || (t = {
                rel: "preload",
                as: "style",
                href: t.href,
                crossOrigin: t.crossOrigin,
                integrity: t.integrity,
                media: t.media,
                hrefLang: t.hrefLang,
                referrerPolicy: t.referrerPolicy
              }, Ui.set(s, t), r || dE(n, s, t, a.state))), e && i === null) throw Error(D(528, ""));
              return a;
            }
            if (e && i !== null) throw Error(D(529, ""));
            return null;
          case "script":
            return e = t.async, t = t.src, typeof t == "string" && e && typeof e != "function" && typeof e != "symbol" ? (e = Do(t), t = Ha(n).hoistableScripts, i = t.get(e), i || (i = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, t.set(e, i)), i) : {
              type: "void",
              instance: null,
              count: 0,
              state: null
            };
          default:
            throw Error(D(444, s));
        }
      }
      function po(s) {
        return 'href="' + Ai(s) + '"';
      }
      function Ru(s) {
        return 'link[rel="stylesheet"][' + s + "]";
      }
      function G1(s) {
        return Ue({}, s, {
          "data-precedence": s.precedence,
          precedence: null
        });
      }
      function dE(s, e, t, i) {
        s.querySelector('link[rel="preload"][as="style"][' + e + "]") ? i.loading = 1 : (e = s.createElement("link"), i.preload = e, e.addEventListener("load", function() {
          return i.loading |= 1;
        }), e.addEventListener("error", function() {
          return i.loading |= 2;
        }), Mt(e, "link", t), mt(e), s.head.appendChild(e));
      }
      function Do(s) {
        return '[src="' + Ai(s) + '"]';
      }
      function Cu(s) {
        return "script[async]" + s;
      }
      function Fx(s, e, t) {
        if (e.count++, e.instance === null) switch (e.type) {
          case "style":
            var i = s.querySelector('style[data-href~="' + Ai(t.href) + '"]');
            if (i) return e.instance = i, mt(i), i;
            var n = Ue({}, t, {
              "data-href": t.href,
              "data-precedence": t.precedence,
              href: null,
              precedence: null
            });
            return i = (s.ownerDocument || s).createElement("style"), mt(i), Mt(i, "style", n), Zc(i, t.precedence, s), e.instance = i;
          case "stylesheet":
            n = po(t.href);
            var r = s.querySelector(Ru(n));
            if (r) return e.state.loading |= 4, e.instance = r, mt(r), r;
            i = G1(t), (n = Ui.get(n)) && yy(i, n), r = (s.ownerDocument || s).createElement("link"), mt(r);
            var a = r;
            return a._p = new Promise(function(l, o) {
              a.onload = l, a.onerror = o;
            }), Mt(r, "link", i), e.state.loading |= 4, Zc(r, t.precedence, s), e.instance = r;
          case "script":
            return r = Do(t.src), (n = s.querySelector(Cu(r))) ? (e.instance = n, mt(n), n) : (i = t, (n = Ui.get(r)) && (i = Ue({}, t), xy(i, n)), s = s.ownerDocument || s, n = s.createElement("script"), mt(n), Mt(n, "link", i), s.head.appendChild(n), e.instance = n);
          case "void":
            return null;
          default:
            throw Error(D(443, e.type));
        }
        else e.type === "stylesheet" && !(e.state.loading & 4) && (i = e.instance, e.state.loading |= 4, Zc(i, t.precedence, s));
        return e.instance;
      }
      function Zc(s, e, t) {
        for (var i = t.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), n = i.length ? i[i.length - 1] : null, r = n, a = 0; a < i.length; a++) {
          var l = i[a];
          if (l.dataset.precedence === e) r = l;
          else if (r !== n) break;
        }
        r ? r.parentNode.insertBefore(s, r.nextSibling) : (e = t.nodeType === 9 ? t.head : t, e.insertBefore(s, e.firstChild));
      }
      function yy(s, e) {
        s.crossOrigin == null && (s.crossOrigin = e.crossOrigin), s.referrerPolicy == null && (s.referrerPolicy = e.referrerPolicy), s.title == null && (s.title = e.title);
      }
      function xy(s, e) {
        s.crossOrigin == null && (s.crossOrigin = e.crossOrigin), s.referrerPolicy == null && (s.referrerPolicy = e.referrerPolicy), s.integrity == null && (s.integrity = e.integrity);
      }
      var Qc = null;
      function Ox(s, e, t) {
        if (Qc === null) {
          var i = /* @__PURE__ */ new Map(), n = Qc = /* @__PURE__ */ new Map();
          n.set(t, i);
        } else n = Qc, i = n.get(t), i || (i = /* @__PURE__ */ new Map(), n.set(t, i));
        if (i.has(s)) return i;
        for (i.set(s, null), t = t.getElementsByTagName(s), n = 0; n < t.length; n++) {
          var r = t[n];
          if (!(r[Vl] || r[Rt] || s === "link" && r.getAttribute("rel") === "stylesheet") && r.namespaceURI !== "http://www.w3.org/2000/svg") {
            var a = r.getAttribute(e) || "";
            a = s + a;
            var l = i.get(a);
            l ? l.push(r) : i.set(a, [
              r
            ]);
          }
        }
        return i;
      }
      function zx(s, e, t) {
        s = s.ownerDocument || s, s.head.insertBefore(t, e === "title" ? s.querySelector("head > title") : null);
      }
      function fE(s, e, t) {
        if (t === 1 || e.itemProp != null) return false;
        switch (s) {
          case "meta":
          case "title":
            return true;
          case "style":
            if (typeof e.precedence != "string" || typeof e.href != "string" || e.href === "") break;
            return true;
          case "link":
            if (typeof e.rel != "string" || typeof e.href != "string" || e.href === "" || e.onLoad || e.onError) break;
            switch (e.rel) {
              case "stylesheet":
                return s = e.disabled, typeof e.precedence == "string" && s == null;
              default:
                return true;
            }
          case "script":
            if (e.async && typeof e.async != "function" && typeof e.async != "symbol" && !e.onLoad && !e.onError && e.src && typeof e.src == "string") return true;
        }
        return false;
      }
      function P1(s) {
        return !(s.type === "stylesheet" && !(s.state.loading & 3));
      }
      var Ql = null;
      function pE() {
      }
      function mE(s, e, t) {
        if (Ql === null) throw Error(D(475));
        var i = Ql;
        if (e.type === "stylesheet" && (typeof t.media != "string" || matchMedia(t.media).matches !== false) && !(e.state.loading & 4)) {
          if (e.instance === null) {
            var n = po(t.href), r = s.querySelector(Ru(n));
            if (r) {
              s = r._p, s !== null && typeof s == "object" && typeof s.then == "function" && (i.count++, i = Oh.bind(i), s.then(i, i)), e.state.loading |= 4, e.instance = r, mt(r);
              return;
            }
            r = s.ownerDocument || s, t = G1(t), (n = Ui.get(n)) && yy(t, n), r = r.createElement("link"), mt(r);
            var a = r;
            a._p = new Promise(function(l, o) {
              a.onload = l, a.onerror = o;
            }), Mt(r, "link", t), e.instance = r;
          }
          i.stylesheets === null && (i.stylesheets = /* @__PURE__ */ new Map()), i.stylesheets.set(e, s), (s = e.state.preload) && !(e.state.loading & 3) && (i.count++, e = Oh.bind(i), s.addEventListener("load", e), s.addEventListener("error", e));
        }
      }
      function gE() {
        if (Ql === null) throw Error(D(475));
        var s = Ql;
        return s.stylesheets && s.count === 0 && Dm(s, s.stylesheets), 0 < s.count ? function(e) {
          var t = setTimeout(function() {
            if (s.stylesheets && Dm(s, s.stylesheets), s.unsuspend) {
              var i = s.unsuspend;
              s.unsuspend = null, i();
            }
          }, 6e4);
          return s.unsuspend = e, function() {
            s.unsuspend = null, clearTimeout(t);
          };
        } : null;
      }
      function Oh() {
        if (this.count--, this.count === 0) {
          if (this.stylesheets) Dm(this, this.stylesheets);
          else if (this.unsuspend) {
            var s = this.unsuspend;
            this.unsuspend = null, s();
          }
        }
      }
      var zh = null;
      function Dm(s, e) {
        s.stylesheets = null, s.unsuspend !== null && (s.count++, zh = /* @__PURE__ */ new Map(), e.forEach(yE, s), zh = null, Oh.call(s));
      }
      function yE(s, e) {
        if (!(e.state.loading & 4)) {
          var t = zh.get(s);
          if (t) var i = t.get(null);
          else {
            t = /* @__PURE__ */ new Map(), zh.set(s, t);
            for (var n = s.querySelectorAll("link[data-precedence],style[data-precedence]"), r = 0; r < n.length; r++) {
              var a = n[r];
              (a.nodeName === "LINK" || a.getAttribute("media") !== "not all") && (t.set(a.dataset.precedence, a), i = a);
            }
            i && t.set(null, i);
          }
          n = e.instance, a = n.getAttribute("data-precedence"), r = t.get(a) || i, r === i && t.set(null, n), t.set(a, n), this.count++, i = Oh.bind(this), n.addEventListener("load", i), n.addEventListener("error", i), r ? r.parentNode.insertBefore(n, r.nextSibling) : (s = s.nodeType === 9 ? s.head : s, s.insertBefore(n, s.firstChild)), e.state.loading |= 4;
        }
      }
      var Kl = {
        $$typeof: Ds,
        Provider: null,
        Consumer: null,
        _currentValue: br,
        _currentValue2: br,
        _threadCount: 0
      };
      function xE(s, e, t, i, n, r, a, l) {
        this.tag = 1, this.containerInfo = s, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = sf(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = sf(0), this.hiddenUpdates = sf(null), this.identifierPrefix = i, this.onUncaughtError = n, this.onCaughtError = r, this.onRecoverableError = a, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = l, this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function k1(s, e, t, i, n, r, a, l, o, u, c, h) {
        return s = new xE(s, e, t, a, l, o, u, h), e = 1, r === true && (e |= 24), r = Ei(3, null, null, e), s.current = r, r.stateNode = s, e = Wg(), e.refCount++, s.pooledCache = e, e.refCount++, r.memoizedState = {
          element: i,
          isDehydrated: t,
          cache: e
        }, oy(r), s;
      }
      function I1(s) {
        return s ? (s = Da, s) : Da;
      }
      function V1(s, e, t, i, n, r) {
        n = I1(n), i.context === null ? i.context = n : i.pendingContext = n, i = Un(e), i.payload = {
          element: t
        }, r = r === void 0 ? null : r, r !== null && (i.callback = r), t = Fn(s, i, e), t !== null && (zt(t, s, e), Nl(t, s, e));
      }
      function Lx(s, e) {
        if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
          var t = s.retryLane;
          s.retryLane = t !== 0 && t < e ? t : e;
        }
      }
      function _y(s, e) {
        Lx(s, e), (s = s.alternate) && Lx(s, e);
      }
      function H1(s) {
        if (s.tag === 13) {
          var e = qn(s, 67108864);
          e !== null && zt(e, s, 67108864), _y(s, 67108864);
        }
      }
      var Lh = true;
      function _E(s, e, t, i) {
        var n = J.T;
        J.T = null;
        var r = De.p;
        try {
          De.p = 2, by(s, e, t, i);
        } finally {
          De.p = r, J.T = n;
        }
      }
      function bE(s, e, t, i) {
        var n = J.T;
        J.T = null;
        var r = De.p;
        try {
          De.p = 8, by(s, e, t, i);
        } finally {
          De.p = r, J.T = n;
        }
      }
      function by(s, e, t, i) {
        if (Lh) {
          var n = Um(i);
          if (n === null) Cf(s, e, i, Gh, t), Gx(s, i);
          else if (TE(n, s, e, t, i)) i.stopPropagation();
          else if (Gx(s, i), e & 4 && -1 < SE.indexOf(s)) {
            for (; n !== null; ) {
              var r = Ro(n);
              if (r !== null) switch (r.tag) {
                case 3:
                  if (r = r.stateNode, r.current.memoizedState.isDehydrated) {
                    var a = lr(r.pendingLanes);
                    if (a !== 0) {
                      var l = r;
                      for (l.pendingLanes |= 2, l.entangledLanes |= 2; a; ) {
                        var o = 1 << 31 - ci(a);
                        l.entanglements[1] |= o, a &= ~o;
                      }
                      hs(r), !(ke & 6) && (Eh = ss() + 500, Eu(0));
                    }
                  }
                  break;
                case 13:
                  l = qn(r, 2), l !== null && zt(l, r, 2), Td(), _y(r, 2);
              }
              if (r = Um(i), r === null && Cf(s, e, i, Gh, t), r === n) break;
              n = r;
            }
            n !== null && i.stopPropagation();
          } else Cf(s, e, i, null, t);
        }
      }
      function Um(s) {
        return s = zg(s), Sy(s);
      }
      var Gh = null;
      function Sy(s) {
        if (Gh = null, s = xr(s), s !== null) {
          var e = wo(s);
          if (e === null) s = null;
          else {
            var t = e.tag;
            if (t === 13) {
              if (s = SS(e), s !== null) return s;
              s = null;
            } else if (t === 3) {
              if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
              s = null;
            } else e !== s && (s = null);
          }
        }
        return Gh = s, null;
      }
      function q1(s) {
        switch (s) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (aN()) {
              case vS:
                return 2;
              case MS:
                return 8;
              case ph:
              case oN:
                return 32;
              case AS:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var Fm = false, Ln = null, Gn = null, Pn = null, Jl = /* @__PURE__ */ new Map(), eu = /* @__PURE__ */ new Map(), vn = [], SE = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
      function Gx(s, e) {
        switch (s) {
          case "focusin":
          case "focusout":
            Ln = null;
            break;
          case "dragenter":
          case "dragleave":
            Gn = null;
            break;
          case "mouseover":
          case "mouseout":
            Pn = null;
            break;
          case "pointerover":
          case "pointerout":
            Jl.delete(e.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            eu.delete(e.pointerId);
        }
      }
      function Wo(s, e, t, i, n, r) {
        return s === null || s.nativeEvent !== r ? (s = {
          blockedOn: e,
          domEventName: t,
          eventSystemFlags: i,
          nativeEvent: r,
          targetContainers: [
            n
          ]
        }, e !== null && (e = Ro(e), e !== null && H1(e)), s) : (s.eventSystemFlags |= i, e = s.targetContainers, n !== null && e.indexOf(n) === -1 && e.push(n), s);
      }
      function TE(s, e, t, i, n) {
        switch (e) {
          case "focusin":
            return Ln = Wo(Ln, s, e, t, i, n), true;
          case "dragenter":
            return Gn = Wo(Gn, s, e, t, i, n), true;
          case "mouseover":
            return Pn = Wo(Pn, s, e, t, i, n), true;
          case "pointerover":
            var r = n.pointerId;
            return Jl.set(r, Wo(Jl.get(r) || null, s, e, t, i, n)), true;
          case "gotpointercapture":
            return r = n.pointerId, eu.set(r, Wo(eu.get(r) || null, s, e, t, i, n)), true;
        }
        return false;
      }
      function Y1(s) {
        var e = xr(s.target);
        if (e !== null) {
          var t = wo(e);
          if (t !== null) {
            if (e = t.tag, e === 13) {
              if (e = SS(t), e !== null) {
                s.blockedOn = e, gN(s.priority, function() {
                  if (t.tag === 13) {
                    var i = hi(), n = qn(t, i);
                    n !== null && zt(n, t, i), _y(t, i);
                  }
                });
                return;
              }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
              s.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
              return;
            }
          }
        }
        s.blockedOn = null;
      }
      function Kc(s) {
        if (s.blockedOn !== null) return false;
        for (var e = s.targetContainers; 0 < e.length; ) {
          var t = Um(s.nativeEvent);
          if (t === null) {
            t = s.nativeEvent;
            var i = new t.constructor(t.type, t);
            Kp = i, t.target.dispatchEvent(i), Kp = null;
          } else return e = Ro(t), e !== null && H1(e), s.blockedOn = t, false;
          e.shift();
        }
        return true;
      }
      function Px(s, e, t) {
        Kc(s) && t.delete(e);
      }
      function vE() {
        Fm = false, Ln !== null && Kc(Ln) && (Ln = null), Gn !== null && Kc(Gn) && (Gn = null), Pn !== null && Kc(Pn) && (Pn = null), Jl.forEach(Px), eu.forEach(Px);
      }
      function Ju(s, e) {
        s.blockedOn === e && (s.blockedOn = null, Fm || (Fm = true, ut.unstable_scheduleCallback(ut.unstable_NormalPriority, vE)));
      }
      var ec = null;
      function kx(s) {
        ec !== s && (ec = s, ut.unstable_scheduleCallback(ut.unstable_NormalPriority, function() {
          ec === s && (ec = null);
          for (var e = 0; e < s.length; e += 3) {
            var t = s[e], i = s[e + 1], n = s[e + 2];
            if (typeof i != "function") {
              if (Sy(i || t) === null) continue;
              break;
            }
            var r = Ro(t);
            r !== null && (s.splice(e, 3), e -= 3, lm(r, {
              pending: true,
              data: n,
              method: t.method,
              action: i
            }, i, n));
          }
        }));
      }
      function tu(s) {
        function e(o) {
          return Ju(o, s);
        }
        Ln !== null && Ju(Ln, s), Gn !== null && Ju(Gn, s), Pn !== null && Ju(Pn, s), Jl.forEach(e), eu.forEach(e);
        for (var t = 0; t < vn.length; t++) {
          var i = vn[t];
          i.blockedOn === s && (i.blockedOn = null);
        }
        for (; 0 < vn.length && (t = vn[0], t.blockedOn === null); ) Y1(t), t.blockedOn === null && vn.shift();
        if (t = (s.ownerDocument || s).$$reactFormReplay, t != null) for (i = 0; i < t.length; i += 3) {
          var n = t[i], r = t[i + 1], a = n[Xt] || null;
          if (typeof r == "function") a || kx(t);
          else if (a) {
            var l = null;
            if (r && r.hasAttribute("formAction")) {
              if (n = r, a = r[Xt] || null) l = a.formAction;
              else if (Sy(n) !== null) continue;
            } else l = a.action;
            typeof l == "function" ? t[i + 1] = l : (t.splice(i, 3), i -= 3), kx(t);
          }
        }
      }
      function Ty(s) {
        this._internalRoot = s;
      }
      Ad.prototype.render = Ty.prototype.render = function(s) {
        var e = this._internalRoot;
        if (e === null) throw Error(D(409));
        var t = e.current, i = hi();
        V1(t, i, s, e, null, null);
      };
      Ad.prototype.unmount = Ty.prototype.unmount = function() {
        var s = this._internalRoot;
        if (s !== null) {
          this._internalRoot = null;
          var e = s.containerInfo;
          s.tag === 0 && Za(), V1(s.current, 2, null, s, null, null), Td(), e[Eo] = null;
        }
      };
      function Ad(s) {
        this._internalRoot = s;
      }
      Ad.prototype.unstable_scheduleHydration = function(s) {
        if (s) {
          var e = BS();
          s = {
            blockedOn: null,
            target: s,
            priority: e
          };
          for (var t = 0; t < vn.length && e !== 0 && e < vn[t].priority; t++) ;
          vn.splice(t, 0, s), t === 0 && Y1(s);
        }
      };
      var Ix = gS.version;
      if (Ix !== "19.0.0") throw Error(D(527, Ix, "19.0.0"));
      De.findDOMNode = function(s) {
        var e = s._reactInternals;
        if (e === void 0) throw typeof s.render == "function" ? Error(D(188)) : (s = Object.keys(s).join(","), Error(D(268, s)));
        return s = sN(e), s = s !== null ? TS(s) : null, s = s === null ? null : s.stateNode, s;
      };
      var ME = {
        bundleType: 0,
        version: "19.0.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: J,
        findFiberByHostInstance: xr,
        reconcilerVersion: "19.0.0"
      };
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var tc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!tc.isDisabled && tc.supportsFiber) try {
          _u = tc.inject(ME), ui = tc;
        } catch {
        }
      }
      cd.createRoot = function(s, e) {
        if (!yS(s)) throw Error(D(299));
        var t = false, i = "", n = VT, r = HT, a = qT, l = null;
        return e != null && (e.unstable_strictMode === true && (t = true), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onUncaughtError !== void 0 && (n = e.onUncaughtError), e.onCaughtError !== void 0 && (r = e.onCaughtError), e.onRecoverableError !== void 0 && (a = e.onRecoverableError), e.unstable_transitionCallbacks !== void 0 && (l = e.unstable_transitionCallbacks)), e = k1(s, 1, false, null, null, t, i, n, r, a, l, null), s[Eo] = e.current, gy(s.nodeType === 8 ? s.parentNode : s), new Ty(e);
      };
      cd.hydrateRoot = function(s, e, t) {
        if (!yS(s)) throw Error(D(299));
        var i = false, n = "", r = VT, a = HT, l = qT, o = null, u = null;
        return t != null && (t.unstable_strictMode === true && (i = true), t.identifierPrefix !== void 0 && (n = t.identifierPrefix), t.onUncaughtError !== void 0 && (r = t.onUncaughtError), t.onCaughtError !== void 0 && (a = t.onCaughtError), t.onRecoverableError !== void 0 && (l = t.onRecoverableError), t.unstable_transitionCallbacks !== void 0 && (o = t.unstable_transitionCallbacks), t.formState !== void 0 && (u = t.formState)), e = k1(s, 1, true, e, t ?? null, i, n, r, a, l, o, u), e.context = I1(null), t = e.current, i = hi(), n = Un(i), n.callback = null, Fn(t, n, i), e.current.lanes = i, Su(e, i), hs(e), s[Eo] = e.current, gy(s), new Ad(e);
      };
      cd.version = "19.0.0";
      function W1() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(W1);
        } catch (s) {
          console.error(s);
        }
      }
      W1(), cS.exports = cd;
      var AE = cS.exports;
      const NE = "/StephensSausageRollSolver/assets/stephens_sausage_roll_solver_bg-DeFeMfaa.wasm", wE = async (s = {}, e) => {
        let t;
        if (e.startsWith("data:")) {
          const i = e.replace(/^data:.*?base64,/, "");
          let n;
          if (typeof Buffer == "function" && typeof Buffer.from == "function") n = Buffer.from(i, "base64");
          else if (typeof atob == "function") {
            const r = atob(i);
            n = new Uint8Array(r.length);
            for (let a = 0; a < r.length; a++) n[a] = r.charCodeAt(a);
          } else throw new Error("Cannot decode base64-encoded data URL");
          t = await WebAssembly.instantiate(n, s);
        } else {
          const i = await fetch(e), n = i.headers.get("Content-Type") || "";
          if ("instantiateStreaming" in WebAssembly && n.startsWith("application/wasm")) t = await WebAssembly.instantiateStreaming(i, s);
          else {
            const r = await i.arrayBuffer();
            t = await WebAssembly.instantiate(r, s);
          }
        }
        return t.instance.exports;
      };
      let _t;
      function EE(s) {
        _t = s;
      }
      function RE(s) {
        const e = _t.__externref_table_alloc();
        return _t.__wbindgen_export_2.set(e, s), e;
      }
      function vy(s, e) {
        try {
          return s.apply(this, e);
        } catch (t) {
          const i = RE(t);
          _t.__wbindgen_exn_store(i);
        }
      }
      const CE = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
      let j1 = new CE("utf-8", {
        ignoreBOM: true,
        fatal: true
      });
      j1.decode();
      let ic = null;
      function Jc() {
        return (ic === null || ic.byteLength === 0) && (ic = new Uint8Array(_t.memory.buffer)), ic;
      }
      function Bu(s, e) {
        return s = s >>> 0, j1.decode(Jc().subarray(s, s + e));
      }
      let iu = 0;
      const BE = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
      let eh = new BE("utf-8");
      const DE = typeof eh.encodeInto == "function" ? function(s, e) {
        return eh.encodeInto(s, e);
      } : function(s, e) {
        const t = eh.encode(s);
        return e.set(t), {
          read: s.length,
          written: t.length
        };
      };
      function My(s, e, t) {
        if (t === void 0) {
          const l = eh.encode(s), o = e(l.length, 1) >>> 0;
          return Jc().subarray(o, o + l.length).set(l), iu = l.length, o;
        }
        let i = s.length, n = e(i, 1) >>> 0;
        const r = Jc();
        let a = 0;
        for (; a < i; a++) {
          const l = s.charCodeAt(a);
          if (l > 127) break;
          r[n + a] = l;
        }
        if (a !== i) {
          a !== 0 && (s = s.slice(a)), n = t(n, i, i = a + s.length * 3, 1) >>> 0;
          const l = Jc().subarray(n + a, n + i), o = DE(s, l);
          a += o.written, n = t(n, i, a, 1) >>> 0;
        }
        return iu = a, n;
      }
      let ea = null;
      function $n() {
        return (ea === null || ea.buffer.detached === true || ea.buffer.detached === void 0 && ea.buffer !== _t.memory.buffer) && (ea = new DataView(_t.memory.buffer)), ea;
      }
      function Om(s) {
        const e = typeof s;
        if (e == "number" || e == "boolean" || s == null) return `${s}`;
        if (e == "string") return `"${s}"`;
        if (e == "symbol") {
          const n = s.description;
          return n == null ? "Symbol" : `Symbol(${n})`;
        }
        if (e == "function") {
          const n = s.name;
          return typeof n == "string" && n.length > 0 ? `Function(${n})` : "Function";
        }
        if (Array.isArray(s)) {
          const n = s.length;
          let r = "[";
          n > 0 && (r += Om(s[0]));
          for (let a = 1; a < n; a++) r += ", " + Om(s[a]);
          return r += "]", r;
        }
        const t = /\[object ([^\]]+)\]/.exec(toString.call(s));
        let i;
        if (t && t.length > 1) i = t[1];
        else return toString.call(s);
        if (i == "Object") try {
          return "Object(" + JSON.stringify(s) + ")";
        } catch {
          return "Object";
        }
        return s instanceof Error ? `${s.name}: ${s.message}
${s.stack}` : i;
      }
      function zm(s) {
        return s == null;
      }
      function UE(s) {
        let e, t;
        try {
          const i = _t.solve(s);
          return e = i[0], t = i[1], Bu(i[0], i[1]);
        } finally {
          _t.__wbindgen_free(e, t, 1);
        }
      }
      function FE(s) {
        return s.buffer;
      }
      function OE() {
        return vy(function(s, e) {
          return s.call(e);
        }, arguments);
      }
      function zE(s) {
        return s.done;
      }
      function LE(s) {
        return Object.entries(s);
      }
      function GE(s, e) {
        let t, i;
        try {
          t = s, i = e, console.error(Bu(s, e));
        } finally {
          _t.__wbindgen_free(t, i, 1);
        }
      }
      function PE(s, e) {
        return s[e >>> 0];
      }
      function kE() {
        return vy(function(s, e) {
          return Reflect.get(s, e);
        }, arguments);
      }
      function IE(s, e) {
        return s[e];
      }
      function VE(s) {
        let e;
        try {
          e = s instanceof ArrayBuffer;
        } catch {
          e = false;
        }
        return e;
      }
      function HE(s) {
        let e;
        try {
          e = s instanceof Uint8Array;
        } catch {
          e = false;
        }
        return e;
      }
      function qE(s) {
        return Array.isArray(s);
      }
      function YE(s) {
        return Number.isSafeInteger(s);
      }
      function WE() {
        return Symbol.iterator;
      }
      function jE(s) {
        return s.length;
      }
      function $E(s) {
        return s.length;
      }
      function XE(s, e) {
        console.log(s, e);
      }
      function ZE(s) {
        return new Uint8Array(s);
      }
      function QE() {
        return new Error();
      }
      function KE() {
        return vy(function(s) {
          return s.next();
        }, arguments);
      }
      function JE(s) {
        return s.next;
      }
      function e2(s, e, t) {
        s.set(e, t >>> 0);
      }
      function t2(s, e) {
        const t = e.stack, i = My(t, _t.__wbindgen_malloc, _t.__wbindgen_realloc), n = iu;
        $n().setInt32(s + 4 * 1, n, true), $n().setInt32(s + 4 * 0, i, true);
      }
      function i2(s) {
        return s.value;
      }
      function s2(s) {
        return +s;
      }
      function n2(s) {
        const e = s;
        return typeof e == "boolean" ? e ? 1 : 0 : 2;
      }
      function r2(s, e) {
        const t = Om(e), i = My(t, _t.__wbindgen_malloc, _t.__wbindgen_realloc), n = iu;
        $n().setInt32(s + 4 * 1, n, true), $n().setInt32(s + 4 * 0, i, true);
      }
      function a2(s, e) {
        return new Error(Bu(s, e));
      }
      function o2(s, e) {
        return s in e;
      }
      function l2() {
        const s = _t.__wbindgen_export_2, e = s.grow(4);
        s.set(0, void 0), s.set(e + 0, void 0), s.set(e + 1, null), s.set(e + 2, true), s.set(e + 3, false);
      }
      function u2(s) {
        return typeof s == "function";
      }
      function c2(s) {
        const e = s;
        return typeof e == "object" && e !== null;
      }
      function h2(s) {
        return typeof s == "string";
      }
      function d2(s) {
        return s === void 0;
      }
      function f2(s, e) {
        return s == e;
      }
      function p2() {
        return _t.memory;
      }
      function m2(s, e) {
        const t = e, i = typeof t == "number" ? t : void 0;
        $n().setFloat64(s + 8 * 1, zm(i) ? 0 : i, true), $n().setInt32(s + 4 * 0, !zm(i), true);
      }
      function g2(s, e) {
        const t = e, i = typeof t == "string" ? t : void 0;
        var n = zm(i) ? 0 : My(i, _t.__wbindgen_malloc, _t.__wbindgen_realloc), r = iu;
        $n().setInt32(s + 4 * 1, r, true), $n().setInt32(s + 4 * 0, n, true);
      }
      function y2(s, e) {
        return Bu(s, e);
      }
      function x2(s, e) {
        throw new Error(Bu(s, e));
      }
      URL = globalThis.URL;
      const Js = await wE({
        "./stephens_sausage_roll_solver_bg.js": {
          __wbindgen_string_new: y2,
          __wbindgen_string_get: g2,
          __wbindgen_is_string: h2,
          __wbindgen_is_object: c2,
          __wbindgen_is_undefined: d2,
          __wbindgen_in: o2,
          __wbindgen_error_new: a2,
          __wbg_log_5f82480ac7a101b6: XE,
          __wbindgen_jsval_loose_eq: f2,
          __wbindgen_boolean_get: n2,
          __wbindgen_number_get: m2,
          __wbindgen_as_number: s2,
          __wbg_getwithrefkey_1dc361bd10053bfe: IE,
          __wbg_new_8a6f238a6ece86ea: QE,
          __wbg_stack_0ed75d68575b0f3c: t2,
          __wbg_error_7534b8e9a36f1ab4: GE,
          __wbg_get_9aa3dff3f0266054: PE,
          __wbg_length_d65cf0786bfc5739: $E,
          __wbindgen_is_function: u2,
          __wbg_next_137428deb98342b0: JE,
          __wbg_next_01dd9234a5bf6d05: KE,
          __wbg_done_f22c1561fa919baa: zE,
          __wbg_value_4c32fd138a88eee2: i2,
          __wbg_iterator_23604bb983791576: WE,
          __wbg_get_bbccf8970793c087: kE,
          __wbg_call_b0d8e36992d9900d: OE,
          __wbg_isArray_1ba11a930108ec51: qE,
          __wbg_instanceof_ArrayBuffer_670ddde44cdb2602: VE,
          __wbg_isSafeInteger_12f5549b2fca23f4: YE,
          __wbg_entries_4f2bb9b0d701c0f6: LE,
          __wbg_buffer_61b7ce01341d7f88: FE,
          __wbg_new_3ff5b33b1ce712df: ZE,
          __wbg_set_23d69db4e5c66a6e: e2,
          __wbg_length_65d1cd11729ced11: jE,
          __wbg_instanceof_Uint8Array_28af5bc19d6acad8: HE,
          __wbindgen_debug_string: r2,
          __wbindgen_throw: x2,
          __wbindgen_memory: p2,
          __wbindgen_init_externref_table: l2
        }
      }, NE), _2 = Js.memory, b2 = Js.solve, S2 = Js.__wbindgen_exn_store, T2 = Js.__externref_table_alloc, v2 = Js.__wbindgen_export_2, M2 = Js.__wbindgen_free, A2 = Js.__wbindgen_malloc, N2 = Js.__wbindgen_realloc, $1 = Js.__wbindgen_start, w2 = Object.freeze(Object.defineProperty({
        __proto__: null,
        __externref_table_alloc: T2,
        __wbindgen_exn_store: S2,
        __wbindgen_export_2: v2,
        __wbindgen_free: M2,
        __wbindgen_malloc: A2,
        __wbindgen_realloc: N2,
        __wbindgen_start: $1,
        memory: _2,
        solve: b2
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      EE(w2);
      $1();
      var de;
      ((s) => {
        function e(i, n) {
          return i[0] === n[0] && i[1] === n[1] && i[2] === n[2];
        }
        s.compare = e;
        function t(i, n) {
          return [
            i[0] + n[0],
            i[1] + n[1],
            i[2] + n[2]
          ];
        }
        s.add = t;
      })(de || (de = {}));
      var Lm;
      ((s) => {
        function e(t, i) {
          return t.sausages.find((n) => !!(de.compare(n.pos, i) || de.compare(n.pos, de.add(i, [
            -1,
            0,
            0
          ])) && n.orientation === "Horizontal" || de.compare(n.pos, de.add(i, [
            0,
            -1,
            0
          ])) && n.orientation === "Vertical")) ?? null;
        }
        s.getSausageAt = e;
      })(Lm || (Lm = {}));
      var Ph;
      ((s) => {
        function e(t) {
          const i = JSON.parse(UE(t)), n = i.initial_state.id, r = i.states.find((a) => a.id === n);
          return r !== void 0 && (r.is_initial = true, i.initial_state = r), i;
        }
        s.fromDescription = e;
      })(Ph || (Ph = {}));
      var su;
      ((s) => {
        function e(t, i) {
          return t.sausages.find((n) => !!(de.compare(n.pos, i) || de.compare(n.pos, de.add(i, [
            -1,
            0,
            0
          ])) && n.orientation === "Horizontal" || de.compare(n.pos, de.add(i, [
            0,
            -1,
            0
          ])) && n.orientation === "Vertical")) ?? null;
        }
        s.getSausageAt = e;
      })(su || (su = {}));
      var X1 = Symbol.for("immer-nothing"), Vx = Symbol.for("immer-draftable"), xe = Symbol.for("immer-state");
      function wi(s, ...e) {
        throw new Error(`[Immer] minified error nr: ${s}. Full error at: https://bit.ly/3cXEKWf`);
      }
      var mo = Object.getPrototypeOf;
      function go(s) {
        return !!s && !!s[xe];
      }
      function $s(s) {
        var _a2;
        return s ? Z1(s) || Array.isArray(s) || !!s[Vx] || !!((_a2 = s.constructor) == null ? void 0 : _a2[Vx]) || wd(s) || Ed(s) : false;
      }
      var E2 = Object.prototype.constructor.toString();
      function Z1(s) {
        if (!s || typeof s != "object") return false;
        const e = mo(s);
        if (e === null) return true;
        const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
        return t === Object ? true : typeof t == "function" && Function.toString.call(t) === E2;
      }
      function nu(s, e) {
        Nd(s) === 0 ? Reflect.ownKeys(s).forEach((t) => {
          e(t, s[t], s);
        }) : s.forEach((t, i) => e(i, t, s));
      }
      function Nd(s) {
        const e = s[xe];
        return e ? e.type_ : Array.isArray(s) ? 1 : wd(s) ? 2 : Ed(s) ? 3 : 0;
      }
      function Gm(s, e) {
        return Nd(s) === 2 ? s.has(e) : Object.prototype.hasOwnProperty.call(s, e);
      }
      function Q1(s, e, t) {
        const i = Nd(s);
        i === 2 ? s.set(e, t) : i === 3 ? s.add(t) : s[e] = t;
      }
      function R2(s, e) {
        return s === e ? s !== 0 || 1 / s === 1 / e : s !== s && e !== e;
      }
      function wd(s) {
        return s instanceof Map;
      }
      function Ed(s) {
        return s instanceof Set;
      }
      function ft(s) {
        return s.copy_ || s.base_;
      }
      function Pm(s, e) {
        if (wd(s)) return new Map(s);
        if (Ed(s)) return new Set(s);
        if (Array.isArray(s)) return Array.prototype.slice.call(s);
        const t = Z1(s);
        if (e === true || e === "class_only" && !t) {
          const i = Object.getOwnPropertyDescriptors(s);
          delete i[xe];
          let n = Reflect.ownKeys(i);
          for (let r = 0; r < n.length; r++) {
            const a = n[r], l = i[a];
            l.writable === false && (l.writable = true, l.configurable = true), (l.get || l.set) && (i[a] = {
              configurable: true,
              writable: true,
              enumerable: l.enumerable,
              value: s[a]
            });
          }
          return Object.create(mo(s), i);
        } else {
          const i = mo(s);
          if (i !== null && t) return {
            ...s
          };
          const n = Object.create(i);
          return Object.assign(n, s);
        }
      }
      function Ay(s, e = false) {
        return Rd(s) || go(s) || !$s(s) || (Nd(s) > 1 && (s.set = s.add = s.clear = s.delete = C2), Object.freeze(s), e && Object.entries(s).forEach(([t, i]) => Ay(i, true))), s;
      }
      function C2() {
        wi(2);
      }
      function Rd(s) {
        return Object.isFrozen(s);
      }
      var km = {};
      function Ur(s) {
        const e = km[s];
        return e || wi(0, s), e;
      }
      function B2(s, e) {
        km[s] || (km[s] = e);
      }
      var ru;
      function kh() {
        return ru;
      }
      function D2(s, e) {
        return {
          drafts_: [],
          parent_: s,
          immer_: e,
          canAutoFreeze_: true,
          unfinalizedDrafts_: 0
        };
      }
      function Hx(s, e) {
        e && (Ur("Patches"), s.patches_ = [], s.inversePatches_ = [], s.patchListener_ = e);
      }
      function Im(s) {
        Vm(s), s.drafts_.forEach(U2), s.drafts_ = null;
      }
      function Vm(s) {
        s === ru && (ru = s.parent_);
      }
      function qx(s) {
        return ru = D2(ru, s);
      }
      function U2(s) {
        const e = s[xe];
        e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = true;
      }
      function Yx(s, e) {
        e.unfinalizedDrafts_ = e.drafts_.length;
        const t = e.drafts_[0];
        return s !== void 0 && s !== t ? (t[xe].modified_ && (Im(e), wi(4)), $s(s) && (s = Ih(e, s), e.parent_ || Vh(e, s)), e.patches_ && Ur("Patches").generateReplacementPatches_(t[xe].base_, s, e.patches_, e.inversePatches_)) : s = Ih(e, t, []), Im(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), s !== X1 ? s : void 0;
      }
      function Ih(s, e, t) {
        if (Rd(e)) return e;
        const i = e[xe];
        if (!i) return nu(e, (n, r) => Wx(s, i, e, n, r, t)), e;
        if (i.scope_ !== s) return e;
        if (!i.modified_) return Vh(s, i.base_, true), i.base_;
        if (!i.finalized_) {
          i.finalized_ = true, i.scope_.unfinalizedDrafts_--;
          const n = i.copy_;
          let r = n, a = false;
          i.type_ === 3 && (r = new Set(n), n.clear(), a = true), nu(r, (l, o) => Wx(s, i, n, l, o, t, a)), Vh(s, n, false), t && s.patches_ && Ur("Patches").generatePatches_(i, t, s.patches_, s.inversePatches_);
        }
        return i.copy_;
      }
      function Wx(s, e, t, i, n, r, a) {
        if (go(n)) {
          const l = r && e && e.type_ !== 3 && !Gm(e.assigned_, i) ? r.concat(i) : void 0, o = Ih(s, n, l);
          if (Q1(t, i, o), go(o)) s.canAutoFreeze_ = false;
          else return;
        } else a && t.add(n);
        if ($s(n) && !Rd(n)) {
          if (!s.immer_.autoFreeze_ && s.unfinalizedDrafts_ < 1) return;
          Ih(s, n), (!e || !e.scope_.parent_) && typeof i != "symbol" && Object.prototype.propertyIsEnumerable.call(t, i) && Vh(s, n);
        }
      }
      function Vh(s, e, t = false) {
        !s.parent_ && s.immer_.autoFreeze_ && s.canAutoFreeze_ && Ay(e, t);
      }
      function F2(s, e) {
        const t = Array.isArray(s), i = {
          type_: t ? 1 : 0,
          scope_: e ? e.scope_ : kh(),
          modified_: false,
          finalized_: false,
          assigned_: {},
          parent_: e,
          base_: s,
          draft_: null,
          copy_: null,
          revoke_: null,
          isManual_: false
        };
        let n = i, r = Ny;
        t && (n = [
          i
        ], r = au);
        const { revoke: a, proxy: l } = Proxy.revocable(n, r);
        return i.draft_ = l, i.revoke_ = a, l;
      }
      var Ny = {
        get(s, e) {
          if (e === xe) return s;
          const t = ft(s);
          if (!Gm(t, e)) return O2(s, t, e);
          const i = t[e];
          return s.finalized_ || !$s(i) ? i : i === Uf(s.base_, e) ? (Ff(s), s.copy_[e] = ou(i, s)) : i;
        },
        has(s, e) {
          return e in ft(s);
        },
        ownKeys(s) {
          return Reflect.ownKeys(ft(s));
        },
        set(s, e, t) {
          const i = K1(ft(s), e);
          if (i == null ? void 0 : i.set) return i.set.call(s.draft_, t), true;
          if (!s.modified_) {
            const n = Uf(ft(s), e), r = n == null ? void 0 : n[xe];
            if (r && r.base_ === t) return s.copy_[e] = t, s.assigned_[e] = false, true;
            if (R2(t, n) && (t !== void 0 || Gm(s.base_, e))) return true;
            Ff(s), Ms(s);
          }
          return s.copy_[e] === t && (t !== void 0 || e in s.copy_) || Number.isNaN(t) && Number.isNaN(s.copy_[e]) || (s.copy_[e] = t, s.assigned_[e] = true), true;
        },
        deleteProperty(s, e) {
          return Uf(s.base_, e) !== void 0 || e in s.base_ ? (s.assigned_[e] = false, Ff(s), Ms(s)) : delete s.assigned_[e], s.copy_ && delete s.copy_[e], true;
        },
        getOwnPropertyDescriptor(s, e) {
          const t = ft(s), i = Reflect.getOwnPropertyDescriptor(t, e);
          return i && {
            writable: true,
            configurable: s.type_ !== 1 || e !== "length",
            enumerable: i.enumerable,
            value: t[e]
          };
        },
        defineProperty() {
          wi(11);
        },
        getPrototypeOf(s) {
          return mo(s.base_);
        },
        setPrototypeOf() {
          wi(12);
        }
      }, au = {};
      nu(Ny, (s, e) => {
        au[s] = function() {
          return arguments[0] = arguments[0][0], e.apply(this, arguments);
        };
      });
      au.deleteProperty = function(s, e) {
        return au.set.call(this, s, e, void 0);
      };
      au.set = function(s, e, t) {
        return Ny.set.call(this, s[0], e, t, s[0]);
      };
      function Uf(s, e) {
        const t = s[xe];
        return (t ? ft(t) : s)[e];
      }
      function O2(s, e, t) {
        var _a2;
        const i = K1(e, t);
        return i ? "value" in i ? i.value : (_a2 = i.get) == null ? void 0 : _a2.call(s.draft_) : void 0;
      }
      function K1(s, e) {
        if (!(e in s)) return;
        let t = mo(s);
        for (; t; ) {
          const i = Object.getOwnPropertyDescriptor(t, e);
          if (i) return i;
          t = mo(t);
        }
      }
      function Ms(s) {
        s.modified_ || (s.modified_ = true, s.parent_ && Ms(s.parent_));
      }
      function Ff(s) {
        s.copy_ || (s.copy_ = Pm(s.base_, s.scope_.immer_.useStrictShallowCopy_));
      }
      var z2 = class {
        constructor(s) {
          this.autoFreeze_ = true, this.useStrictShallowCopy_ = false, this.produce = (e, t, i) => {
            if (typeof e == "function" && typeof t != "function") {
              const r = t;
              t = e;
              const a = this;
              return function(o = r, ...u) {
                return a.produce(o, (c) => t.call(this, c, ...u));
              };
            }
            typeof t != "function" && wi(6), i !== void 0 && typeof i != "function" && wi(7);
            let n;
            if ($s(e)) {
              const r = qx(this), a = ou(e, void 0);
              let l = true;
              try {
                n = t(a), l = false;
              } finally {
                l ? Im(r) : Vm(r);
              }
              return Hx(r, i), Yx(n, r);
            } else if (!e || typeof e != "object") {
              if (n = t(e), n === void 0 && (n = e), n === X1 && (n = void 0), this.autoFreeze_ && Ay(n, true), i) {
                const r = [], a = [];
                Ur("Patches").generateReplacementPatches_(e, n, r, a), i(r, a);
              }
              return n;
            } else wi(1, e);
          }, this.produceWithPatches = (e, t) => {
            if (typeof e == "function") return (a, ...l) => this.produceWithPatches(a, (o) => e(o, ...l));
            let i, n;
            return [
              this.produce(e, t, (a, l) => {
                i = a, n = l;
              }),
              i,
              n
            ];
          }, typeof (s == null ? void 0 : s.autoFreeze) == "boolean" && this.setAutoFreeze(s.autoFreeze), typeof (s == null ? void 0 : s.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(s.useStrictShallowCopy);
        }
        createDraft(s) {
          $s(s) || wi(8), go(s) && (s = L2(s));
          const e = qx(this), t = ou(s, void 0);
          return t[xe].isManual_ = true, Vm(e), t;
        }
        finishDraft(s, e) {
          const t = s && s[xe];
          (!t || !t.isManual_) && wi(9);
          const { scope_: i } = t;
          return Hx(i, e), Yx(void 0, i);
        }
        setAutoFreeze(s) {
          this.autoFreeze_ = s;
        }
        setUseStrictShallowCopy(s) {
          this.useStrictShallowCopy_ = s;
        }
        applyPatches(s, e) {
          let t;
          for (t = e.length - 1; t >= 0; t--) {
            const n = e[t];
            if (n.path.length === 0 && n.op === "replace") {
              s = n.value;
              break;
            }
          }
          t > -1 && (e = e.slice(t + 1));
          const i = Ur("Patches").applyPatches_;
          return go(s) ? i(s, e) : this.produce(s, (n) => i(n, e));
        }
      };
      function ou(s, e) {
        const t = wd(s) ? Ur("MapSet").proxyMap_(s, e) : Ed(s) ? Ur("MapSet").proxySet_(s, e) : F2(s, e);
        return (e ? e.scope_ : kh()).drafts_.push(t), t;
      }
      function L2(s) {
        return go(s) || wi(10, s), J1(s);
      }
      function J1(s) {
        if (!$s(s) || Rd(s)) return s;
        const e = s[xe];
        let t;
        if (e) {
          if (!e.modified_) return e.base_;
          e.finalized_ = true, t = Pm(s, e.scope_.immer_.useStrictShallowCopy_);
        } else t = Pm(s, true);
        return nu(t, (i, n) => {
          Q1(t, i, J1(n));
        }), e && (e.finalized_ = false), t;
      }
      function G2() {
        class s extends Map {
          constructor(o, u) {
            super(), this[xe] = {
              type_: 2,
              parent_: u,
              scope_: u ? u.scope_ : kh(),
              modified_: false,
              finalized_: false,
              copy_: void 0,
              assigned_: void 0,
              base_: o,
              draft_: this,
              isManual_: false,
              revoked_: false
            };
          }
          get size() {
            return ft(this[xe]).size;
          }
          has(o) {
            return ft(this[xe]).has(o);
          }
          set(o, u) {
            const c = this[xe];
            return a(c), (!ft(c).has(o) || ft(c).get(o) !== u) && (t(c), Ms(c), c.assigned_.set(o, true), c.copy_.set(o, u), c.assigned_.set(o, true)), this;
          }
          delete(o) {
            if (!this.has(o)) return false;
            const u = this[xe];
            return a(u), t(u), Ms(u), u.base_.has(o) ? u.assigned_.set(o, false) : u.assigned_.delete(o), u.copy_.delete(o), true;
          }
          clear() {
            const o = this[xe];
            a(o), ft(o).size && (t(o), Ms(o), o.assigned_ = /* @__PURE__ */ new Map(), nu(o.base_, (u) => {
              o.assigned_.set(u, false);
            }), o.copy_.clear());
          }
          forEach(o, u) {
            const c = this[xe];
            ft(c).forEach((h, d, f) => {
              o.call(u, this.get(d), d, this);
            });
          }
          get(o) {
            const u = this[xe];
            a(u);
            const c = ft(u).get(o);
            if (u.finalized_ || !$s(c) || c !== u.base_.get(o)) return c;
            const h = ou(c, u);
            return t(u), u.copy_.set(o, h), h;
          }
          keys() {
            return ft(this[xe]).keys();
          }
          values() {
            const o = this.keys();
            return {
              [Symbol.iterator]: () => this.values(),
              next: () => {
                const u = o.next();
                return u.done ? u : {
                  done: false,
                  value: this.get(u.value)
                };
              }
            };
          }
          entries() {
            const o = this.keys();
            return {
              [Symbol.iterator]: () => this.entries(),
              next: () => {
                const u = o.next();
                if (u.done) return u;
                const c = this.get(u.value);
                return {
                  done: false,
                  value: [
                    u.value,
                    c
                  ]
                };
              }
            };
          }
          [Symbol.iterator]() {
            return this.entries();
          }
        }
        function e(l, o) {
          return new s(l, o);
        }
        function t(l) {
          l.copy_ || (l.assigned_ = /* @__PURE__ */ new Map(), l.copy_ = new Map(l.base_));
        }
        class i extends Set {
          constructor(o, u) {
            super(), this[xe] = {
              type_: 3,
              parent_: u,
              scope_: u ? u.scope_ : kh(),
              modified_: false,
              finalized_: false,
              copy_: void 0,
              base_: o,
              draft_: this,
              drafts_: /* @__PURE__ */ new Map(),
              revoked_: false,
              isManual_: false
            };
          }
          get size() {
            return ft(this[xe]).size;
          }
          has(o) {
            const u = this[xe];
            return a(u), u.copy_ ? !!(u.copy_.has(o) || u.drafts_.has(o) && u.copy_.has(u.drafts_.get(o))) : u.base_.has(o);
          }
          add(o) {
            const u = this[xe];
            return a(u), this.has(o) || (r(u), Ms(u), u.copy_.add(o)), this;
          }
          delete(o) {
            if (!this.has(o)) return false;
            const u = this[xe];
            return a(u), r(u), Ms(u), u.copy_.delete(o) || (u.drafts_.has(o) ? u.copy_.delete(u.drafts_.get(o)) : false);
          }
          clear() {
            const o = this[xe];
            a(o), ft(o).size && (r(o), Ms(o), o.copy_.clear());
          }
          values() {
            const o = this[xe];
            return a(o), r(o), o.copy_.values();
          }
          entries() {
            const o = this[xe];
            return a(o), r(o), o.copy_.entries();
          }
          keys() {
            return this.values();
          }
          [Symbol.iterator]() {
            return this.values();
          }
          forEach(o, u) {
            const c = this.values();
            let h = c.next();
            for (; !h.done; ) o.call(u, h.value, h.value, this), h = c.next();
          }
        }
        function n(l, o) {
          return new i(l, o);
        }
        function r(l) {
          l.copy_ || (l.copy_ = /* @__PURE__ */ new Set(), l.base_.forEach((o) => {
            if ($s(o)) {
              const u = ou(o, l);
              l.drafts_.set(o, u), l.copy_.add(u);
            } else l.copy_.add(o);
          }));
        }
        function a(l) {
          l.revoked_ && wi(3, JSON.stringify(ft(l)));
        }
        B2("MapSet", {
          proxyMap_: e,
          proxySet_: n
        });
      }
      var fi = new z2(), yi = fi.produce;
      fi.produceWithPatches.bind(fi);
      fi.setAutoFreeze.bind(fi);
      fi.setUseStrictShallowCopy.bind(fi);
      fi.applyPatches.bind(fi);
      fi.createDraft.bind(fi);
      fi.finishDraft.bind(fi);
      const P2 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3c!--%20Created%20with%20Inkscape%20(http://www.inkscape.org/)%20--%3e%3csvg%20width='48'%20height='48'%20viewBox='0%200%2012.7%2012.7'%20version='1.1'%20id='svg5'%20inkscape:version='1.2.1%20(9c6d41e410,%202022-07-14)'%20sodipodi:docname='stephen.svg'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3csodipodi:namedview%20id='namedview7'%20pagecolor='%23505050'%20bordercolor='%23eeeeee'%20borderopacity='1'%20inkscape:showpageshadow='0'%20inkscape:pageopacity='0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23505050'%20inkscape:document-units='mm'%20showgrid='true'%20inkscape:zoom='8.4359982'%20inkscape:cx='20.388814'%20inkscape:cy='37.22144'%20inkscape:window-width='1920'%20inkscape:window-height='1017'%20inkscape:window-x='1912'%20inkscape:window-y='-8'%20inkscape:window-maximized='1'%20inkscape:current-layer='layer1'%3e%3cinkscape:grid%20type='xygrid'%20id='grid4183'%20/%3e%3c/sodipodi:namedview%3e%3cdefs%20id='defs2'%20/%3e%3cg%20inkscape:label='Layer%201'%20inkscape:groupmode='layer'%20id='layer1'%3e%3ccircle%20style='fill:%23794700;stroke:%23000000;stroke-width:0.264999;fill-opacity:1;stroke-opacity:0'%20id='path5637'%20cx='6.3499999'%20cy='6.3499999'%20r='5.5562501'%20/%3e%3c/g%3e%3c/svg%3e", k2 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3c!--%20Created%20with%20Inkscape%20(http://www.inkscape.org/)%20--%3e%3csvg%20width='48'%20height='48'%20viewBox='0%200%2012.7%2012.7'%20version='1.1'%20id='svg5'%20inkscape:version='1.2.1%20(9c6d41e410,%202022-07-14)'%20sodipodi:docname='stephen_goal.svg'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3csodipodi:namedview%20id='namedview7'%20pagecolor='%23505050'%20bordercolor='%23eeeeee'%20borderopacity='1'%20inkscape:showpageshadow='0'%20inkscape:pageopacity='0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23505050'%20inkscape:document-units='mm'%20showgrid='true'%20inkscape:zoom='8.4359982'%20inkscape:cx='16.239928'%20inkscape:cy='37.33998'%20inkscape:window-width='1920'%20inkscape:window-height='1017'%20inkscape:window-x='-8'%20inkscape:window-y='-8'%20inkscape:window-maximized='1'%20inkscape:current-layer='layer1'%3e%3cinkscape:grid%20type='xygrid'%20id='grid4183'%20/%3e%3c/sodipodi:namedview%3e%3cdefs%20id='defs2'%20/%3e%3cg%20inkscape:label='Layer%201'%20inkscape:groupmode='layer'%20id='layer1'%3e%3cellipse%20style='fill:%239bffa9;fill-opacity:1;stroke:%23000000;stroke-width:0.282173;stroke-opacity:0'%20id='path5637'%20cx='6.3499999'%20cy='6.2862678'%20rx='5.9482975'%20ry='5.8845654'%20/%3e%3c/g%3e%3c/svg%3e", I2 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3c!--%20Created%20with%20Inkscape%20(http://www.inkscape.org/)%20--%3e%3csvg%20width='48'%20height='48'%20viewBox='0%200%2012.7%2012.7'%20version='1.1'%20id='svg11314'%20inkscape:version='1.2.1%20(9c6d41e410,%202022-07-14)'%20sodipodi:docname='fork.svg'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3csodipodi:namedview%20id='namedview11316'%20pagecolor='%23505050'%20bordercolor='%23eeeeee'%20borderopacity='1'%20inkscape:showpageshadow='0'%20inkscape:pageopacity='0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23505050'%20inkscape:document-units='mm'%20showgrid='true'%20inkscape:zoom='11.930303'%20inkscape:cx='18.608077'%20inkscape:cy='26.906274'%20inkscape:window-width='1920'%20inkscape:window-height='1017'%20inkscape:window-x='1912'%20inkscape:window-y='-8'%20inkscape:window-maximized='1'%20inkscape:current-layer='layer1'%3e%3cinkscape:grid%20type='xygrid'%20id='grid12524'%20dotted='true'%20originx='0'%20originy='0'%20/%3e%3c/sodipodi:namedview%3e%3cdefs%20id='defs11311'%20/%3e%3cg%20inkscape:label='Layer%201'%20inkscape:groupmode='layer'%20id='layer1'%3e%3cpath%20style='fill:%231f1d1a;fill-opacity:1;stroke:%23000000;stroke-width:0.264999;stroke-opacity:0'%20d='M%206.0854166,0.79374999%20H%206.6145832%20L%207.14375,11.1125%20l%203.175,-0.264583%200.264583,-8.7312503%20H%2011.1125%20L%2011.641667,11.90625%207.14375,12.435417%20H%205.55625%20L%201.0583333,11.90625%201.5875,2.1166667%20H%202.1166667%20L%202.38125,10.847917%205.55625,11.1125%20Z'%20id='path13669'%20sodipodi:nodetypes='ccccccccccccccc'%20/%3e%3c/g%3e%3c/svg%3e", V2 = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3c!--%20Created%20with%20Inkscape%20(http://www.inkscape.org/)%20--%3e%3csvg%20width='48'%20height='48'%20viewBox='0%200%2012.7%2012.7'%20version='1.1'%20id='svg11314'%20inkscape:version='1.2.1%20(9c6d41e410,%202022-07-14)'%20sodipodi:docname='fork_goal.svg'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3csodipodi:namedview%20id='namedview11316'%20pagecolor='%23505050'%20bordercolor='%23eeeeee'%20borderopacity='1'%20inkscape:showpageshadow='0'%20inkscape:pageopacity='0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23505050'%20inkscape:document-units='mm'%20showgrid='true'%20inkscape:zoom='11.930303'%20inkscape:cx='15.674371'%20inkscape:cy='26.990094'%20inkscape:window-width='1920'%20inkscape:window-height='1017'%20inkscape:window-x='-8'%20inkscape:window-y='-8'%20inkscape:window-maximized='1'%20inkscape:current-layer='layer1'%3e%3cinkscape:grid%20type='xygrid'%20id='grid12524'%20dotted='true'%20originx='0'%20originy='0'%20/%3e%3c/sodipodi:namedview%3e%3cdefs%20id='defs11311'%20/%3e%3cg%20inkscape:label='Layer%201'%20inkscape:groupmode='layer'%20id='layer1'%3e%3cpath%20style='fill:%239bffa9;fill-opacity:1;stroke:%23000000;stroke-width:0.28362;stroke-opacity:0'%20d='m%206.0530995,0.40655545%20h%200.593637%20L%207.2403736,10.9427%2010.802196,10.672543%2011.099014,1.7573433%20h%200.593637%20l%200.593638,9.9958297%20-5.0459154,0.540316%20H%205.4594626%20L%200.41354804,11.753173%201.0071851,1.7573433%20h%200.593637%20l%200.2968185,8.9151997%203.561822,0.270157%20z'%20id='path13669'%20sodipodi:nodetypes='ccccccccccccccc'%20/%3e%3c/g%3e%3c/svg%3e", ev = (s) => {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
        const [e, t] = Ne.useState(1), i = new Set(s.description.ground.map((f) => JSON.stringify(f))), n = new Set(s.description.grills.map((f) => JSON.stringify(f))), r = [];
        for (let f = 0; f < s.lenZ; f++) r.push(V.jsx("button", {
          className: `layer-control ${e === f ? "active" : null}`,
          onClick: () => {
            t(f);
          },
          children: f === 0 ? "W" : f
        }, f));
        const a = {};
        ((_a2 = s.state) == null ? void 0 : _a2.player_dir) && de.compare((_b2 = s.state) == null ? void 0 : _b2.player_dir, [
          1,
          0,
          0
        ]) && (a.transform = "rotate(0.25turn)"), ((_c2 = s.state) == null ? void 0 : _c2.player_dir) && de.compare((_d2 = s.state) == null ? void 0 : _d2.player_dir, [
          0,
          1,
          0
        ]) && (a.transform = "rotate(0.5turn)"), ((_e2 = s.state) == null ? void 0 : _e2.player_dir) && de.compare((_f2 = s.state) == null ? void 0 : _f2.player_dir, [
          -1,
          0,
          0
        ]) && (a.transform = "rotate(0.75turn)");
        const l = V.jsx("img", {
          src: P2,
          className: "icon"
        }), o = V.jsx("img", {
          src: I2,
          className: "icon",
          style: a
        }), u = V.jsx("img", {
          src: k2,
          className: "icon"
        }), c = {};
        de.compare(s.description.start_dir, [
          1,
          0,
          0
        ]) && (c.transform = "rotate(0.25turn)"), de.compare(s.description.start_dir, [
          0,
          1,
          0
        ]) && (c.transform = "rotate(0.5turn)"), de.compare(s.description.start_dir, [
          -1,
          0,
          0
        ]) && (c.transform = "rotate(0.75turn)");
        const h = V.jsx("img", {
          src: V2,
          className: "icon",
          style: c
        }), d = [];
        for (let f = 0; f < s.lenY; f++) {
          const p = [];
          for (let g = 0; g < s.lenX; g++) {
            let _;
            i.has(JSON.stringify([
              g,
              f,
              e
            ])) || n.has(JSON.stringify([
              g,
              f,
              e
            ])) ? _ = "dirt" : i.has(JSON.stringify([
              g,
              f,
              e - 1
            ])) ? _ = "grass" : n.has(JSON.stringify([
              g,
              f,
              e - 1
            ])) ? _ = "grill" : e > 1 ? _ = "air" : _ = "water", p.push(V.jsxs("div", {
              className: `tile ${_} `,
              onDragOver: (m) => {
                m.preventDefault(), m.dataTransfer.dropEffect = "copy";
              },
              onDrop: (m) => {
                s.onDrop && s.onDrop(m, g, f, e);
              },
              onClick: () => {
                s.onClick && s.onClick(g, f, e);
              },
              children: [
                s.state !== void 0 ? (_g2 = Lm.getSausageAt(s.state, [
                  g,
                  f,
                  e
                ])) == null ? void 0 : _g2.orientation[0] : (_h2 = su.getSausageAt(s.description, [
                  g,
                  f,
                  e
                ])) == null ? void 0 : _h2.orientation[0],
                de.compare(s.description.start_pos, [
                  g,
                  f,
                  e
                ]) && u,
                de.compare(de.add(s.description.start_pos, s.description.start_dir), [
                  g,
                  f,
                  e
                ]) && h,
                s.state && de.compare(s.state.player_pos, [
                  g,
                  f,
                  e
                ]) && l,
                s.state && de.compare(de.add(s.state.player_pos, s.state.player_dir), [
                  g,
                  f,
                  e
                ]) && o
              ]
            }, g));
          }
          d.push(p);
        }
        return V.jsxs(V.Fragment, {
          children: [
            V.jsx("div", {
              children: r
            }),
            V.jsx("div", {
              className: "tilegrid",
              children: d.map((f, p) => V.jsx("div", {
                className: "row",
                children: f.map((g) => g)
              }, p))
            })
          ]
        });
      };
      function H2(s) {
        return V.jsxs("form", {
          children: [
            V.jsxs("label", {
              children: [
                "Width",
                V.jsx("input", {
                  type: "number",
                  onChange: (e) => {
                    s.setDimensions([
                      e.target.valueAsNumber,
                      s.dimensions[1],
                      s.dimensions[2]
                    ]);
                  },
                  defaultValue: s.dimensions[0]
                })
              ]
            }),
            V.jsxs("label", {
              children: [
                "Height",
                V.jsx("input", {
                  type: "number",
                  onChange: (e) => {
                    s.setDimensions([
                      s.dimensions[0],
                      e.target.valueAsNumber,
                      s.dimensions[2]
                    ]);
                  },
                  defaultValue: s.dimensions[1]
                })
              ]
            }),
            V.jsxs("label", {
              children: [
                "Layers",
                V.jsx("input", {
                  type: "number",
                  onChange: (e) => {
                    s.setDimensions([
                      s.dimensions[0],
                      s.dimensions[1],
                      e.target.valueAsNumber
                    ]);
                  },
                  defaultValue: s.dimensions[2]
                })
              ]
            })
          ]
        });
      }
      function q2(s) {
        return V.jsxs("div", {
          className: "controls",
          children: [
            V.jsx("button", {
              className: s.tool === "remove" ? "active" : "",
              onClick: () => s.setTool("remove"),
              children: "Remove"
            }),
            V.jsx("button", {
              className: s.tool === "dirt" ? "active" : "",
              onClick: () => s.setTool("dirt"),
              children: "Dirt"
            }),
            V.jsx("button", {
              className: s.tool === "grass" ? "active" : "",
              onClick: () => s.setTool("grass"),
              children: "Grass"
            }),
            V.jsx("button", {
              className: s.tool === "grill" ? "active" : "",
              onClick: () => s.setTool("grill"),
              children: "Grill"
            }),
            V.jsx("button", {
              draggable: "true",
              onDragStart: (e) => {
                e.dataTransfer.setData("internal", "horizontal");
              },
              children: "Sausage - H"
            }),
            V.jsx("button", {
              draggable: "true",
              onDragStart: (e) => {
                e.dataTransfer.setData("internal", "vertical");
              },
              children: "Sausage - V"
            }),
            V.jsx("button", {
              draggable: "true",
              onDragStart: (e) => {
                e.dataTransfer.setData("internal", "player");
              },
              children: "Player"
            }),
            V.jsxs("div", {
              className: "player-direction-controls",
              children: [
                V.jsx("button", {
                  className: de.compare(s.playerDir, [
                    0,
                    -1,
                    0
                  ]) ? "active" : "",
                  onClick: () => {
                    s.setPlayerDir([
                      0,
                      -1,
                      0
                    ]);
                  },
                  children: "Up"
                }),
                V.jsx("button", {
                  className: de.compare(s.playerDir, [
                    -1,
                    0,
                    0
                  ]) ? "active" : "",
                  onClick: () => {
                    s.setPlayerDir([
                      -1,
                      0,
                      0
                    ]);
                  },
                  children: "Left"
                }),
                V.jsx("button", {
                  className: de.compare(s.playerDir, [
                    1,
                    0,
                    0
                  ]) ? "active" : "",
                  onClick: () => {
                    s.setPlayerDir([
                      1,
                      0,
                      0
                    ]);
                  },
                  children: "right"
                }),
                V.jsx("button", {
                  className: de.compare(s.playerDir, [
                    0,
                    1,
                    0
                  ]) ? "active" : "",
                  onClick: () => {
                    s.setPlayerDir([
                      0,
                      1,
                      0
                    ]);
                  },
                  children: "down"
                })
              ]
            })
          ]
        });
      }
      function Y2(s) {
        const [e, t] = Ne.useState([
          10,
          10,
          3
        ]), [i, n] = Ne.useState(/* @__PURE__ */ new Set()), [r, a] = Ne.useState(/* @__PURE__ */ new Set()), [l, o] = Ne.useState("remove"), [u, c] = Ne.useState([]), [h, d] = Ne.useState([
          0,
          -1,
          0
        ]), [f, p] = Ne.useState(null), g = (() => {
          let y = h, x = [
            ...i
          ].map((T) => JSON.parse(T)), b = [
            ...r
          ].map((T) => JSON.parse(T));
          return {
            start_pos: f ?? [
              -1,
              -1,
              -1
            ],
            start_dir: y,
            ground: x,
            grills: b,
            sausages: u
          };
        })(), _ = (y) => {
          de.compare(y.start_dir, [
            1,
            0,
            0
          ]) && d([
            1,
            0,
            0
          ]), de.compare(y.start_dir, [
            -1,
            0,
            0
          ]) && d([
            -1,
            0,
            0
          ]), de.compare(y.start_dir, [
            0,
            1,
            0
          ]) && d([
            0,
            1,
            0
          ]), de.compare(y.start_dir, [
            0,
            -1,
            0
          ]) && d([
            0,
            -1,
            0
          ]), p(y.start_pos), c(y.sausages), n(new Set(y.ground.map((x) => JSON.stringify(x)))), a(new Set(y.grills.map((x) => JSON.stringify(x))));
        }, m = (y, x, b) => {
          let T = su.getSausageAt(g, [
            y,
            x,
            b
          ]);
          T !== null && c(yi(u, (N) => (N.filter((A) => JSON.stringify(A.pos) !== JSON.stringify(T.pos)), N))), JSON.stringify(f) === JSON.stringify([
            y,
            x,
            b
          ]) && p(null), i.has(JSON.stringify([
            y,
            x,
            b
          ])) && n(yi(i, (N) => {
            N.delete(JSON.stringify([
              y,
              x,
              b
            ]));
          })), r.has(JSON.stringify([
            y,
            x,
            b
          ])) && a(yi(r, (N) => {
            N.delete(JSON.stringify([
              y,
              x,
              b
            ]));
          }));
        };
        return Ne.useEffect(() => {
          var _a2;
          const y = JSON.parse('{"start_pos":[2,2,1],"start_dir":[1,0,0],"ground":[[2,2,0],[3,2,0],[4,2,0],[4,1,0]],"grills":[[5,1,0],[5,2,0],[6,2,0],[6,1,0]],"sausages":[{"pos":[4,1,1],"cooked":[[0,0],[0,0]],"orientation":"Vertical"}]}');
          _(y);
          const x = Ph.fromDescription(y);
          (_a2 = s.setSolution) == null ? void 0 : _a2.call(s, x);
        }, []), V.jsxs(V.Fragment, {
          children: [
            V.jsx(H2, {
              dimensions: e,
              setDimensions: t
            }),
            V.jsx("form", {
              action: (y) => {
                var _a2;
                const x = JSON.parse(((_a2 = y.get("data")) == null ? void 0 : _a2.toString()) ?? "{}");
                _(x);
              },
              children: V.jsxs("label", {
                children: [
                  "Paste here to load a description ",
                  V.jsx("input", {
                    type: "text",
                    name: "data"
                  })
                ]
              })
            }),
            V.jsx(q2, {
              tool: l,
              setTool: o,
              playerDir: h,
              setPlayerDir: d
            }),
            V.jsx(ev, {
              description: g,
              lenX: e[0],
              lenY: e[1],
              lenZ: e[2],
              onDrop: (y, x, b, T) => {
                let N = y.dataTransfer.getData("internal");
                if (N.length > 0) switch (N) {
                  case "horizontal":
                    m(x, b, T), m(x + 1, b, T), c(yi(u, (A) => {
                      A.push({
                        pos: [
                          x,
                          b,
                          T
                        ],
                        cooked: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        orientation: "Horizontal"
                      });
                    }));
                    break;
                  case "vertical":
                    m(x, b, T), m(x, b + 1, T), c(yi(u, (A) => {
                      A.push({
                        pos: [
                          x,
                          b,
                          T
                        ],
                        cooked: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        orientation: "Vertical"
                      });
                    }));
                    break;
                  case "player":
                    m(x, b, T), p([
                      x,
                      b,
                      T
                    ]);
                    break;
                }
              },
              onClick: (y, x, b) => {
                if (l === "remove") {
                  let T = su.getSausageAt(g, [
                    y,
                    x,
                    b
                  ]);
                  T !== null ? c(yi(u, (N) => N.filter((A) => !de.compare(A.pos, T.pos)))) : JSON.stringify(f) === JSON.stringify([
                    y,
                    x,
                    b
                  ]) ? p(null) : i.has(JSON.stringify([
                    y,
                    x,
                    b
                  ])) ? n(yi(i, (N) => {
                    N.delete(JSON.stringify([
                      y,
                      x,
                      b
                    ]));
                  })) : i.has(JSON.stringify([
                    y,
                    x,
                    b - 1
                  ])) ? n(yi(i, (N) => {
                    N.delete(JSON.stringify([
                      y,
                      x,
                      b - 1
                    ]));
                  })) : r.has(JSON.stringify([
                    y,
                    x,
                    b - 1
                  ])) && a(yi(r, (N) => {
                    N.delete(JSON.stringify([
                      y,
                      x,
                      b - 1
                    ]));
                  }));
                } else l === "dirt" ? (m(y, x, b), n(yi(i, (T) => {
                  T.add(JSON.stringify([
                    y,
                    x,
                    b
                  ]));
                }))) : l === "grass" ? b !== 0 && (m(y, x, b - 1), n(yi(i, (T) => {
                  T.add(JSON.stringify([
                    y,
                    x,
                    b - 1
                  ]));
                }))) : l === "grill" && b !== 0 && (m(y, x, b - 1), a(yi(r, (T) => {
                  T.add(JSON.stringify([
                    y,
                    x,
                    b - 1
                  ]));
                })));
              }
            }),
            V.jsx("p", {
              children: "LevelDescription"
            }),
            V.jsx("code", {
              children: JSON.stringify(g)
            }),
            V.jsx("br", {}),
            V.jsx("button", {
              onClick: () => {
                ((x) => x.start_pos !== null)(g) && s.setSolution(Ph.fromDescription(g));
              },
              children: "Show Graph"
            })
          ]
        });
      }
      const Cd = "172", Qa = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      }, za = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      }, W2 = 0, j2 = 1, $2 = 2, X2 = 0, Z2 = 1, sc = 3, yo = 0, Fi = 1, Ka = 2, xo = 0, kn = 1, Hh = 2, qh = 3, Yh = 4, tv = 5, Mn = 100, iv = 101, sv = 102, Q2 = 103, K2 = 104, nv = 200, rv = 201, av = 202, ov = 203, Wh = 204, jh = 205, lv = 206, uv = 207, cv = 208, hv = 209, dv = 210, fv = 0, pv = 1, mv = 2, $h = 3, gv = 4, yv = 5, xv = 6, _v = 7, Bd = 0, J2 = 1, eR = 2, Ja = 0, tR = 1, iR = 2, sR = 3, nR = 4, rR = 6, aR = 7, wy = 300, Fr = 301, _o = 302, Du = 303, Uu = 304, Hm = 306, bo = 1e3, Cn = 1001, So = 1002, gt = 1003, qm = 1004, eo = 1005, pi = 1006, Ym = 1007, Ps = 1008, In = 1009, Ul = 1010, Fl = 1011, La = 1012, Dt = 1013, Tt = 1014, Yt = 1015, ks = 1016, oR = 1017, lR = 1018, Fu = 1020, bv = 35902, uR = 1021, Ey = 1022, Or = 1023, cR = 1024, hR = 1025, Nr = 1026, To = 1027, Dd = 1028, Ry = 1029, lu = 1030, Cy = 1031, dR = 1032, By = 1033, Of = 33776, th = 33777, ih = 33778, sh = 33779, jx = 35840, $x = 35841, Xx = 35842, Zx = 35843, Qx = 36196, Wm = 37492, jm = 37496, $m = 37808, Xm = 37809, Zm = 37810, Qm = 37811, Km = 37812, Jm = 37813, eg = 37814, tg = 37815, ig = 37816, sg = 37817, ng = 37818, rg = 37819, ag = 37820, og = 37821, zf = 36492, fR = 36283, Kx = 36284, Jx = 36285, e_ = 36286, Xn = 0, pR = 1, zr = "", H = "srgb", Vn = "srgb-linear", t_ = "linear", Ol = "srgb", mR = 0, cr = 7680, gR = 7681, yR = 7682, xR = 7683, _R = 34055, bR = 34056, SR = 5386, TR = 512, vR = 513, MR = 514, AR = 515, NR = 516, wR = 517, ER = 518, lg = 519, Sv = 512, Dy = 513, Tv = 514, vv = 515, Mv = 516, Av = 517, Nv = 518, wv = 519, Xh = 35044, Ga = 35048, li = 2e3, Zn = 2001;
      class jr {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const i = this._listeners;
          i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
        }
        hasEventListener(e, t) {
          if (this._listeners === void 0) return false;
          const i = this._listeners;
          return i[e] !== void 0 && i[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          if (this._listeners === void 0) return;
          const n = this._listeners[e];
          if (n !== void 0) {
            const r = n.indexOf(t);
            r !== -1 && n.splice(r, 1);
          }
        }
        dispatchEvent(e) {
          if (this._listeners === void 0) return;
          const i = this._listeners[e.type];
          if (i !== void 0) {
            e.target = this;
            const n = i.slice(0);
            for (let r = 0, a = n.length; r < a; r++) n[r].call(this, e);
            e.target = null;
          }
        }
      }
      const At = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
      ];
      let i_ = 1234567;
      const zl = Math.PI / 180, uu = 180 / Math.PI;
      function Is() {
        const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
        return (At[s & 255] + At[s >> 8 & 255] + At[s >> 16 & 255] + At[s >> 24 & 255] + "-" + At[e & 255] + At[e >> 8 & 255] + "-" + At[e >> 16 & 15 | 64] + At[e >> 24 & 255] + "-" + At[t & 63 | 128] + At[t >> 8 & 255] + "-" + At[t >> 16 & 255] + At[t >> 24 & 255] + At[i & 255] + At[i >> 8 & 255] + At[i >> 16 & 255] + At[i >> 24 & 255]).toLowerCase();
      }
      function ee(s, e, t) {
        return Math.max(e, Math.min(t, s));
      }
      function Uy(s, e) {
        return (s % e + e) % e;
      }
      function RR(s, e, t, i, n) {
        return i + (s - e) * (n - i) / (t - e);
      }
      function CR(s, e, t) {
        return s !== e ? (t - s) / (e - s) : 0;
      }
      function Ll(s, e, t) {
        return (1 - t) * s + t * e;
      }
      function BR(s, e, t, i) {
        return Ll(s, e, 1 - Math.exp(-t * i));
      }
      function DR(s, e = 1) {
        return e - Math.abs(Uy(s, e * 2) - e);
      }
      function UR(s, e, t) {
        return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
      }
      function FR(s, e, t) {
        return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
      }
      function OR(s, e) {
        return s + Math.floor(Math.random() * (e - s + 1));
      }
      function zR(s, e) {
        return s + Math.random() * (e - s);
      }
      function LR(s) {
        return s * (0.5 - Math.random());
      }
      function GR(s) {
        s !== void 0 && (i_ = s);
        let e = i_ += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
      }
      function PR(s) {
        return s * zl;
      }
      function kR(s) {
        return s * uu;
      }
      function IR(s) {
        return (s & s - 1) === 0 && s !== 0;
      }
      function VR(s) {
        return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
      }
      function HR(s) {
        return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
      }
      function qR(s, e, t, i, n) {
        const r = Math.cos, a = Math.sin, l = r(t / 2), o = a(t / 2), u = r((e + i) / 2), c = a((e + i) / 2), h = r((e - i) / 2), d = a((e - i) / 2), f = r((i - e) / 2), p = a((i - e) / 2);
        switch (n) {
          case "XYX":
            s.set(l * c, o * h, o * d, l * u);
            break;
          case "YZY":
            s.set(o * d, l * c, o * h, l * u);
            break;
          case "ZXZ":
            s.set(o * h, o * d, l * c, l * u);
            break;
          case "XZX":
            s.set(l * c, o * p, o * f, l * u);
            break;
          case "YXY":
            s.set(o * f, l * c, o * p, l * u);
            break;
          case "ZYZ":
            s.set(o * p, o * f, l * c, l * u);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
        }
      }
      function Ft(s, e) {
        switch (e.constructor) {
          case Float32Array:
            return s;
          case Uint32Array:
            return s / 4294967295;
          case Uint16Array:
            return s / 65535;
          case Uint8Array:
            return s / 255;
          case Int32Array:
            return Math.max(s / 2147483647, -1);
          case Int16Array:
            return Math.max(s / 32767, -1);
          case Int8Array:
            return Math.max(s / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function K(s, e) {
        switch (e.constructor) {
          case Float32Array:
            return s;
          case Uint32Array:
            return Math.round(s * 4294967295);
          case Uint16Array:
            return Math.round(s * 65535);
          case Uint8Array:
            return Math.round(s * 255);
          case Int32Array:
            return Math.round(s * 2147483647);
          case Int16Array:
            return Math.round(s * 32767);
          case Int8Array:
            return Math.round(s * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const Ev = {
        DEG2RAD: zl,
        RAD2DEG: uu,
        generateUUID: Is,
        clamp: ee,
        euclideanModulo: Uy,
        mapLinear: RR,
        inverseLerp: CR,
        lerp: Ll,
        damp: BR,
        pingpong: DR,
        smoothstep: UR,
        smootherstep: FR,
        randInt: OR,
        randFloat: zR,
        randFloatSpread: LR,
        seededRandom: GR,
        degToRad: PR,
        radToDeg: kR,
        isPowerOfTwo: IR,
        ceilPowerOfTwo: VR,
        floorPowerOfTwo: HR,
        setQuaternionFromProperEuler: qR,
        normalize: K,
        denormalize: Ft
      };
      class q {
        constructor(e = 0, t = 0) {
          q.prototype.isVector2 = true, this.x = e, this.y = t;
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return this.x = e, this.y = t, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this;
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x, i = this.y, n = e.elements;
          return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
        }
        clamp(e, t) {
          return this.x = ee(this.x, e.x, t.x), this.y = ee(this.y, e.y, t.y), this;
        }
        clampScalar(e, t) {
          return this.x = ee(this.x, e, t), this.y = ee(this.y, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(ee(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(ee(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x, i = this.y - e.y;
          return t * t + i * i;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this;
        }
        rotateAround(e, t) {
          const i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
          return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Jt {
        constructor(e, t, i, n, r, a, l, o, u) {
          Jt.prototype.isMatrix3 = true, this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], e !== void 0 && this.set(e, t, i, n, r, a, l, o, u);
        }
        set(e, t, i, n, r, a, l, o, u) {
          const c = this.elements;
          return c[0] = e, c[1] = n, c[2] = l, c[3] = t, c[4] = r, c[5] = o, c[6] = i, c[7] = a, c[8] = u, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements, i = e.elements;
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
        }
        extractBasis(e, t, i) {
          return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements, n = t.elements, r = this.elements, a = i[0], l = i[3], o = i[6], u = i[1], c = i[4], h = i[7], d = i[2], f = i[5], p = i[8], g = n[0], _ = n[3], m = n[6], y = n[1], x = n[4], b = n[7], T = n[2], N = n[5], A = n[8];
          return r[0] = a * g + l * y + o * T, r[3] = a * _ + l * x + o * N, r[6] = a * m + l * b + o * A, r[1] = u * g + c * y + h * T, r[4] = u * _ + c * x + h * N, r[7] = u * m + c * b + h * A, r[2] = d * g + f * y + p * T, r[5] = d * _ + f * x + p * N, r[8] = d * m + f * b + p * A, this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
        }
        determinant() {
          const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], l = e[5], o = e[6], u = e[7], c = e[8];
          return t * a * c - t * l * u - i * r * c + i * l * o + n * r * u - n * a * o;
        }
        invert() {
          const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], l = e[5], o = e[6], u = e[7], c = e[8], h = c * a - l * u, d = l * o - c * r, f = u * r - a * o, p = t * h + i * d + n * f;
          if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const g = 1 / p;
          return e[0] = h * g, e[1] = (n * u - c * i) * g, e[2] = (l * i - n * a) * g, e[3] = d * g, e[4] = (c * t - n * o) * g, e[5] = (n * r - l * t) * g, e[6] = f * g, e[7] = (i * o - u * t) * g, e[8] = (a * t - i * r) * g, this;
        }
        transpose() {
          let e;
          const t = this.elements;
          return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
        }
        setUvTransform(e, t, i, n, r, a, l) {
          const o = Math.cos(r), u = Math.sin(r);
          return this.set(i * o, i * u, -i * (o * a + u * l) + a + e, -n * u, n * o, -n * (-u * a + o * l) + l + t, 0, 0, 1), this;
        }
        scale(e, t) {
          return this.premultiply(Lf.makeScale(e, t)), this;
        }
        rotate(e) {
          return this.premultiply(Lf.makeRotation(-e)), this;
        }
        translate(e, t) {
          return this.premultiply(Lf.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
          return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
        }
        makeRotation(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
          const t = this.elements, i = e.elements;
          for (let n = 0; n < 9; n++) if (t[n] !== i[n]) return false;
          return true;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const Lf = new Jt();
      function YR(s) {
        for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return true;
        return false;
      }
      function ug(s) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", s);
      }
      function WR() {
        const s = ug("canvas");
        return s.style.display = "block", s;
      }
      const s_ = {};
      function jR(s) {
        s in s_ || (s_[s] = true, console.warn(s));
      }
      const n_ = new Jt().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), r_ = new Jt().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
      function $R() {
        const s = {
          enabled: true,
          workingColorSpace: Vn,
          spaces: {},
          convert: function(n, r, a) {
            return this.enabled === false || r === a || !r || !a || (this.spaces[r].transfer === Ol && (n.r = Vs(n.r), n.g = Vs(n.g), n.b = Vs(n.b)), this.spaces[r].primaries !== this.spaces[a].primaries && (n.applyMatrix3(this.spaces[r].toXYZ), n.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === Ol && (n.r = to(n.r), n.g = to(n.g), n.b = to(n.b))), n;
          },
          fromWorkingColorSpace: function(n, r) {
            return this.convert(n, this.workingColorSpace, r);
          },
          toWorkingColorSpace: function(n, r) {
            return this.convert(n, r, this.workingColorSpace);
          },
          getPrimaries: function(n) {
            return this.spaces[n].primaries;
          },
          getTransfer: function(n) {
            return n === zr ? t_ : this.spaces[n].transfer;
          },
          getLuminanceCoefficients: function(n, r = this.workingColorSpace) {
            return n.fromArray(this.spaces[r].luminanceCoefficients);
          },
          define: function(n) {
            Object.assign(this.spaces, n);
          },
          _getMatrix: function(n, r, a) {
            return n.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ);
          },
          _getDrawingBufferColorSpace: function(n) {
            return this.spaces[n].outputColorSpaceConfig.drawingBufferColorSpace;
          },
          _getUnpackColorSpace: function(n = this.workingColorSpace) {
            return this.spaces[n].workingColorSpaceConfig.unpackColorSpace;
          }
        }, e = [
          0.64,
          0.33,
          0.3,
          0.6,
          0.15,
          0.06
        ], t = [
          0.2126,
          0.7152,
          0.0722
        ], i = [
          0.3127,
          0.329
        ];
        return s.define({
          [Vn]: {
            primaries: e,
            whitePoint: i,
            transfer: t_,
            toXYZ: n_,
            fromXYZ: r_,
            luminanceCoefficients: t,
            workingColorSpaceConfig: {
              unpackColorSpace: H
            },
            outputColorSpaceConfig: {
              drawingBufferColorSpace: H
            }
          },
          [H]: {
            primaries: e,
            whitePoint: i,
            transfer: Ol,
            toXYZ: n_,
            fromXYZ: r_,
            luminanceCoefficients: t,
            outputColorSpaceConfig: {
              drawingBufferColorSpace: H
            }
          }
        }), s;
      }
      const rt = $R();
      function Vs(s) {
        return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
      }
      function to(s) {
        return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
      }
      let ta;
      class XR {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            ta === void 0 && (ta = ug("canvas")), ta.width = e.width, ta.height = e.height;
            const i = ta.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = ta;
          }
          return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = ug("canvas");
            t.width = e.width, t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const n = i.getImageData(0, 0, e.width, e.height), r = n.data;
            for (let a = 0; a < r.length; a++) r[a] = Vs(r[a] / 255) * 255;
            return i.putImageData(n, 0, 0), t;
          } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Vs(t[i] / 255) * 255) : t[i] = Vs(t[i]);
            return {
              data: t,
              width: e.width,
              height: e.height
            };
          } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
        }
      }
      let ZR = 0;
      class Rv {
        constructor(e = null) {
          this.isSource = true, Object.defineProperty(this, "id", {
            value: ZR++
          }), this.uuid = Is(), this.data = e, this.dataReady = true, this.version = 0;
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
          const i = {
            uuid: this.uuid,
            url: ""
          }, n = this.data;
          if (n !== null) {
            let r;
            if (Array.isArray(n)) {
              r = [];
              for (let a = 0, l = n.length; a < l; a++) n[a].isDataTexture ? r.push(Gf(n[a].image)) : r.push(Gf(n[a]));
            } else r = Gf(n);
            i.url = r;
          }
          return t || (e.images[this.uuid] = i), i;
        }
      }
      function Gf(s) {
        return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? XR.getDataURL(s) : s.data ? {
          data: Array.from(s.data),
          width: s.width,
          height: s.height,
          type: s.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let QR = 0;
      class Lt extends jr {
        constructor(e = Lt.DEFAULT_IMAGE, t = Lt.DEFAULT_MAPPING, i = Cn, n = Cn, r = pi, a = Ps, l = Or, o = In, u = Lt.DEFAULT_ANISOTROPY, c = zr) {
          super(), this.isTexture = true, Object.defineProperty(this, "id", {
            value: QR++
          }), this.uuid = Is(), this.name = "", this.source = new Rv(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = a, this.anisotropy = u, this.format = l, this.internalFormat = null, this.type = o, this.offset = new q(0, 0), this.repeat = new q(1, 1), this.center = new q(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Jt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
        }
        get image() {
          return this.source.data;
        }
        set image(e = null) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
          const i = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [
              this.repeat.x,
              this.repeat.y
            ],
            offset: [
              this.offset.x,
              this.offset.y
            ],
            center: [
              this.center.x,
              this.center.y
            ],
            rotation: this.rotation,
            wrap: [
              this.wrapS,
              this.wrapT
            ],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(e) {
          if (this.mapping !== wy) return e;
          if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case bo:
              e.x = e.x - Math.floor(e.x);
              break;
            case Cn:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case So:
              Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
              break;
          }
          if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case bo:
              e.y = e.y - Math.floor(e.y);
              break;
            case Cn:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case So:
              Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
              break;
          }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === true && (this.version++, this.source.needsUpdate = true);
        }
        set needsPMREMUpdate(e) {
          e === true && this.pmremVersion++;
        }
      }
      Lt.DEFAULT_IMAGE = null;
      Lt.DEFAULT_MAPPING = wy;
      Lt.DEFAULT_ANISOTROPY = 1;
      class Te {
        constructor(e = 0, t = 0, i = 0, n = 1) {
          Te.prototype.isVector4 = true, this.x = e, this.y = t, this.z = i, this.w = n;
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, i, n) {
          return this.x = e, this.y = t, this.z = i, this.w = n, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this.z = e, this.w = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setZ(e) {
          return this.z = e, this;
        }
        setW(e) {
          return this.w = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this.z += e, this.w += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
        }
        applyMatrix4(e) {
          const t = this.x, i = this.y, n = this.z, r = this.w, a = e.elements;
          return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this;
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, i, n, r;
          const o = e.elements, u = o[0], c = o[4], h = o[8], d = o[1], f = o[5], p = o[9], g = o[2], _ = o[6], m = o[10];
          if (Math.abs(c - d) < 0.01 && Math.abs(h - g) < 0.01 && Math.abs(p - _) < 0.01) {
            if (Math.abs(c + d) < 0.1 && Math.abs(h + g) < 0.1 && Math.abs(p + _) < 0.1 && Math.abs(u + f + m - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const x = (u + 1) / 2, b = (f + 1) / 2, T = (m + 1) / 2, N = (c + d) / 4, A = (h + g) / 4, w = (p + _) / 4;
            return x > b && x > T ? x < 0.01 ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(x), n = N / i, r = A / i) : b > T ? b < 0.01 ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(b), i = N / n, r = w / n) : T < 0.01 ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(T), i = A / r, n = w / r), this.set(i, n, r, t), this;
          }
          let y = Math.sqrt((_ - p) * (_ - p) + (h - g) * (h - g) + (d - c) * (d - c));
          return Math.abs(y) < 1e-3 && (y = 1), this.x = (_ - p) / y, this.y = (h - g) / y, this.z = (d - c) / y, this.w = Math.acos((u + f + m - 1) / 2), this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
        }
        clamp(e, t) {
          return this.x = ee(this.x, e.x, t.x), this.y = ee(this.y, e.y, t.y), this.z = ee(this.z, e.z, t.z), this.w = ee(this.w, e.w, t.w), this;
        }
        clampScalar(e, t) {
          return this.x = ee(this.x, e, t), this.y = ee(this.y, e, t), this.z = ee(this.z, e, t), this.w = ee(this.w, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(ee(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class Uo extends jr {
        constructor(e = 1, t = 1, i = {}) {
          super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new Te(0, 0, e, t), this.scissorTest = false, this.viewport = new Te(0, 0, e, t);
          const n = {
            width: e,
            height: t,
            depth: 1
          };
          i = Object.assign({
            generateMipmaps: false,
            internalFormat: null,
            minFilter: pi,
            depthBuffer: true,
            stencilBuffer: false,
            resolveDepthBuffer: true,
            resolveStencilBuffer: true,
            depthTexture: null,
            samples: 0,
            count: 1
          }, i);
          const r = new Lt(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
          r.flipY = false, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
          const a = i.count;
          for (let l = 0; l < a; l++) this.textures[l] = r.clone(), this.textures[l].isRenderTargetTexture = true, this.textures[l].renderTarget = this;
          this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples;
        }
        get texture() {
          return this.textures[0];
        }
        set texture(e) {
          this.textures[0] = e;
        }
        set depthTexture(e) {
          this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
        }
        get depthTexture() {
          return this._depthTexture;
        }
        setSize(e, t, i = 1) {
          if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e, this.height = t, this.depth = i;
            for (let n = 0, r = this.textures.length; n < r; n++) this.textures[n].image.width = e, this.textures[n].image.height = t, this.textures[n].image.depth = i;
            this.dispose();
          }
          this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
          for (let i = 0, n = e.textures.length; i < n; i++) this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = true, this.textures[i].renderTarget = this;
          const t = Object.assign({}, e.texture.image);
          return this.texture.source = new Rv(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class KR extends Uo {
        constructor(e = 1, t = 1, i = {}) {
          super(e, t, i), this.isWebGLRenderTarget = true;
        }
      }
      class JR extends Lt {
        constructor(e = null, t = 1, i = 1, n = 1) {
          super(null), this.isDataArrayTexture = true, this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
          }, this.magFilter = gt, this.minFilter = gt, this.wrapR = Cn, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class Lr {
        constructor(e = 0, t = 0, i = 0, n = 1) {
          this.isQuaternion = true, this._x = e, this._y = t, this._z = i, this._w = n;
        }
        static slerpFlat(e, t, i, n, r, a, l) {
          let o = i[n + 0], u = i[n + 1], c = i[n + 2], h = i[n + 3];
          const d = r[a + 0], f = r[a + 1], p = r[a + 2], g = r[a + 3];
          if (l === 0) {
            e[t + 0] = o, e[t + 1] = u, e[t + 2] = c, e[t + 3] = h;
            return;
          }
          if (l === 1) {
            e[t + 0] = d, e[t + 1] = f, e[t + 2] = p, e[t + 3] = g;
            return;
          }
          if (h !== g || o !== d || u !== f || c !== p) {
            let _ = 1 - l;
            const m = o * d + u * f + c * p + h * g, y = m >= 0 ? 1 : -1, x = 1 - m * m;
            if (x > Number.EPSILON) {
              const T = Math.sqrt(x), N = Math.atan2(T, m * y);
              _ = Math.sin(_ * N) / T, l = Math.sin(l * N) / T;
            }
            const b = l * y;
            if (o = o * _ + d * b, u = u * _ + f * b, c = c * _ + p * b, h = h * _ + g * b, _ === 1 - l) {
              const T = 1 / Math.sqrt(o * o + u * u + c * c + h * h);
              o *= T, u *= T, c *= T, h *= T;
            }
          }
          e[t] = o, e[t + 1] = u, e[t + 2] = c, e[t + 3] = h;
        }
        static multiplyQuaternionsFlat(e, t, i, n, r, a) {
          const l = i[n], o = i[n + 1], u = i[n + 2], c = i[n + 3], h = r[a], d = r[a + 1], f = r[a + 2], p = r[a + 3];
          return e[t] = l * p + c * h + o * f - u * d, e[t + 1] = o * p + c * d + u * h - l * f, e[t + 2] = u * p + c * f + l * d - o * h, e[t + 3] = c * p - l * h - o * d - u * f, e;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          this._w = e, this._onChangeCallback();
        }
        set(e, t, i, n) {
          return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
        }
        setFromEuler(e, t = true) {
          const i = e._x, n = e._y, r = e._z, a = e._order, l = Math.cos, o = Math.sin, u = l(i / 2), c = l(n / 2), h = l(r / 2), d = o(i / 2), f = o(n / 2), p = o(r / 2);
          switch (a) {
            case "XYZ":
              this._x = d * c * h + u * f * p, this._y = u * f * h - d * c * p, this._z = u * c * p + d * f * h, this._w = u * c * h - d * f * p;
              break;
            case "YXZ":
              this._x = d * c * h + u * f * p, this._y = u * f * h - d * c * p, this._z = u * c * p - d * f * h, this._w = u * c * h + d * f * p;
              break;
            case "ZXY":
              this._x = d * c * h - u * f * p, this._y = u * f * h + d * c * p, this._z = u * c * p + d * f * h, this._w = u * c * h - d * f * p;
              break;
            case "ZYX":
              this._x = d * c * h - u * f * p, this._y = u * f * h + d * c * p, this._z = u * c * p - d * f * h, this._w = u * c * h + d * f * p;
              break;
            case "YZX":
              this._x = d * c * h + u * f * p, this._y = u * f * h + d * c * p, this._z = u * c * p - d * f * h, this._w = u * c * h - d * f * p;
              break;
            case "XZY":
              this._x = d * c * h - u * f * p, this._y = u * f * h - d * c * p, this._z = u * c * p + d * f * h, this._w = u * c * h + d * f * p;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
          }
          return t === true && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const i = t / 2, n = Math.sin(i);
          return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e) {
          const t = e.elements, i = t[0], n = t[4], r = t[8], a = t[1], l = t[5], o = t[9], u = t[2], c = t[6], h = t[10], d = i + l + h;
          if (d > 0) {
            const f = 0.5 / Math.sqrt(d + 1);
            this._w = 0.25 / f, this._x = (c - o) * f, this._y = (r - u) * f, this._z = (a - n) * f;
          } else if (i > l && i > h) {
            const f = 2 * Math.sqrt(1 + i - l - h);
            this._w = (c - o) / f, this._x = 0.25 * f, this._y = (n + a) / f, this._z = (r + u) / f;
          } else if (l > h) {
            const f = 2 * Math.sqrt(1 + l - i - h);
            this._w = (r - u) / f, this._x = (n + a) / f, this._y = 0.25 * f, this._z = (o + c) / f;
          } else {
            const f = 2 * Math.sqrt(1 + h - i - l);
            this._w = (a - n) / f, this._x = (r + u) / f, this._y = (o + c) / f, this._z = 0.25 * f;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let i = e.dot(t) + 1;
          return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(ee(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const i = this.angleTo(e);
          if (i === 0) return this;
          const n = Math.min(1, t / i);
          return this.slerp(e, n), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(e) {
          return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let e = this.length();
          return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const i = e._x, n = e._y, r = e._z, a = e._w, l = t._x, o = t._y, u = t._z, c = t._w;
          return this._x = i * c + a * l + n * u - r * o, this._y = n * c + a * o + r * l - i * u, this._z = r * c + a * u + i * o - n * l, this._w = a * c - i * l - n * o - r * u, this._onChangeCallback(), this;
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const i = this._x, n = this._y, r = this._z, a = this._w;
          let l = a * e._w + i * e._x + n * e._y + r * e._z;
          if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1) return this._w = a, this._x = i, this._y = n, this._z = r, this;
          const o = 1 - l * l;
          if (o <= Number.EPSILON) {
            const f = 1 - t;
            return this._w = f * a + t * this._w, this._x = f * i + t * this._x, this._y = f * n + t * this._y, this._z = f * r + t * this._z, this.normalize(), this;
          }
          const u = Math.sqrt(o), c = Math.atan2(u, l), h = Math.sin((1 - t) * c) / u, d = Math.sin(t * c) / u;
          return this._w = a * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = r * h + this._z * d, this._onChangeCallback(), this;
        }
        slerpQuaternions(e, t, i) {
          return this.copy(e).slerp(t, i);
        }
        random() {
          const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), r = Math.sqrt(i);
          return this.set(n * Math.sin(e), n * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
          return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
        }
        fromBufferAttribute(e, t) {
          return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(e) {
          return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class v {
        constructor(e = 0, t = 0, i = 0) {
          v.prototype.isVector3 = true, this.x = e, this.y = t, this.z = i;
        }
        set(e, t, i) {
          return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this.z = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setZ(e) {
          return this.z = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this.z += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this.z -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this.z *= e, this;
        }
        multiplyVectors(e, t) {
          return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
        }
        applyEuler(e) {
          return this.applyQuaternion(a_.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(a_.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x, i = this.y, n = this.z, r = e.elements;
          return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this;
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x, i = this.y, n = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
          return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this;
        }
        applyQuaternion(e) {
          const t = this.x, i = this.y, n = this.z, r = e.x, a = e.y, l = e.z, o = e.w, u = 2 * (a * n - l * i), c = 2 * (l * t - r * n), h = 2 * (r * i - a * t);
          return this.x = t + o * u + a * h - l * c, this.y = i + o * c + l * u - r * h, this.z = n + o * h + r * c - a * u, this;
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
          const t = this.x, i = this.y, n = this.z, r = e.elements;
          return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize();
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
        }
        clamp(e, t) {
          return this.x = ee(this.x, e.x, t.x), this.y = ee(this.y, e.y, t.y), this.z = ee(this.z, e.z, t.z), this;
        }
        clampScalar(e, t) {
          return this.x = ee(this.x, e, t), this.y = ee(this.y, e, t), this.z = ee(this.z, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(ee(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const i = e.x, n = e.y, r = e.z, a = t.x, l = t.y, o = t.z;
          return this.x = n * o - r * l, this.y = r * a - i * o, this.z = i * l - n * a, this;
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const i = e.dot(this) / t;
          return this.copy(e).multiplyScalar(i);
        }
        projectOnPlane(e) {
          return Pf.copy(this).projectOnVector(e), this.sub(Pf);
        }
        reflect(e) {
          return this.sub(Pf.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(ee(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
          return t * t + i * i + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, i) {
          const n = Math.sin(t) * e;
          return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this;
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, i) {
          return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12], this.y = t[13], this.z = t[14], this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
          return this.x = t, this.y = i, this.z = n, this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
          return this.x = e._x, this.y = e._y, this.z = e._z, this;
        }
        setFromColor(e) {
          return this.x = e.r, this.y = e.g, this.z = e.b, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
          const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, i = Math.sqrt(1 - t * t);
          return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const Pf = new v(), a_ = new Lr();
      class $r {
        constructor(e = new v(1 / 0, 1 / 0, 1 / 0), t = new v(-1 / 0, -1 / 0, -1 / 0)) {
          this.isBox3 = true, this.min = e, this.max = t;
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(zi.fromArray(e, t));
          return this;
        }
        setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(zi.fromBufferAttribute(e, t));
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const i = zi.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
        }
        setFromObject(e, t = false) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = false) {
          e.updateWorldMatrix(false, false);
          const i = e.geometry;
          if (i !== void 0) {
            const r = i.getAttribute("position");
            if (t === true && r !== void 0 && e.isInstancedMesh !== true) for (let a = 0, l = r.count; a < l; a++) e.isMesh === true ? e.getVertexPosition(a, zi) : zi.fromBufferAttribute(r, a), zi.applyMatrix4(e.matrixWorld), this.expandByPoint(zi);
            else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), nc.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), nc.copy(i.boundingBox)), nc.applyMatrix4(e.matrixWorld), this.union(nc);
          }
          const n = e.children;
          for (let r = 0, a = n.length; r < a; r++) this.expandByObject(n[r], t);
          return this;
        }
        containsPoint(e) {
          return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
        }
        containsBox(e) {
          return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
        }
        getParameter(e, t) {
          return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e) {
          return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
        }
        intersectsSphere(e) {
          return this.clampPoint(e.center, zi), zi.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
          let t, i;
          return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return false;
          this.getCenter(jo), rc.subVectors(this.max, jo), ia.subVectors(e.a, jo), sa.subVectors(e.b, jo), na.subVectors(e.c, jo), ln.subVectors(sa, ia), un.subVectors(na, sa), sr.subVectors(ia, na);
          let t = [
            0,
            -ln.z,
            ln.y,
            0,
            -un.z,
            un.y,
            0,
            -sr.z,
            sr.y,
            ln.z,
            0,
            -ln.x,
            un.z,
            0,
            -un.x,
            sr.z,
            0,
            -sr.x,
            -ln.y,
            ln.x,
            0,
            -un.y,
            un.x,
            0,
            -sr.y,
            sr.x,
            0
          ];
          return !kf(t, ia, sa, na, rc) || (t = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], !kf(t, ia, sa, na, rc)) ? false : (ac.crossVectors(ln, un), t = [
            ac.x,
            ac.y,
            ac.z
          ], kf(t, ia, sa, na, rc));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, zi).distanceTo(e);
        }
        getBoundingSphere(e) {
          return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(zi).length() * 0.5), e;
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty() ? this : (xs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), xs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), xs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), xs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), xs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), xs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), xs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), xs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(xs), this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const xs = [
        new v(),
        new v(),
        new v(),
        new v(),
        new v(),
        new v(),
        new v(),
        new v()
      ], zi = new v(), nc = new $r(), ia = new v(), sa = new v(), na = new v(), ln = new v(), un = new v(), sr = new v(), jo = new v(), rc = new v(), ac = new v(), nr = new v();
      function kf(s, e, t, i, n) {
        for (let r = 0, a = s.length - 3; r <= a; r += 3) {
          nr.fromArray(s, r);
          const l = n.x * Math.abs(nr.x) + n.y * Math.abs(nr.y) + n.z * Math.abs(nr.z), o = e.dot(nr), u = t.dot(nr), c = i.dot(nr);
          if (Math.max(-Math.max(o, u, c), Math.min(o, u, c)) > l) return false;
        }
        return true;
      }
      const eC = new $r(), $o = new v(), If = new v();
      class Fo {
        constructor(e = new v(), t = -1) {
          this.isSphere = true, this.center = e, this.radius = t;
        }
        set(e, t) {
          return this.center.copy(e), this.radius = t, this;
        }
        setFromPoints(e, t) {
          const i = this.center;
          t !== void 0 ? i.copy(t) : eC.setFromPoints(e).getCenter(i);
          let n = 0;
          for (let r = 0, a = e.length; r < a; r++) n = Math.max(n, i.distanceToSquared(e[r]));
          return this.radius = Math.sqrt(n), this;
        }
        copy(e) {
          return this.center.copy(e.center), this.radius = e.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const i = this.center.distanceToSquared(e);
          return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
        }
        getBoundingBox(e) {
          return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
        }
        applyMatrix4(e) {
          return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
          $o.subVectors(e, this.center);
          const t = $o.lengthSq();
          if (t > this.radius * this.radius) {
            const i = Math.sqrt(t), n = (i - this.radius) * 0.5;
            this.center.addScaledVector($o, n / i), this.radius += n;
          }
          return this;
        }
        union(e) {
          return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (If.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint($o.copy(e.center).add(If)), this.expandByPoint($o.copy(e.center).sub(If))), this);
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const _s = new v(), Vf = new v(), oc = new v(), cn = new v(), Hf = new v(), lc = new v(), qf = new v();
      class Ud {
        constructor(e = new v(), t = new v(0, 0, -1)) {
          this.origin = e, this.direction = t;
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
        }
        at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, _s)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const i = t.dot(this.direction);
          return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = _s.subVectors(e, this.origin).dot(this.direction);
          return t < 0 ? this.origin.distanceToSquared(e) : (_s.copy(this.origin).addScaledVector(this.direction, t), _s.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, i, n) {
          Vf.copy(e).add(t).multiplyScalar(0.5), oc.copy(t).sub(e).normalize(), cn.copy(this.origin).sub(Vf);
          const r = e.distanceTo(t) * 0.5, a = -this.direction.dot(oc), l = cn.dot(this.direction), o = -cn.dot(oc), u = cn.lengthSq(), c = Math.abs(1 - a * a);
          let h, d, f, p;
          if (c > 0) if (h = a * o - l, d = a * l - o, p = r * c, h >= 0) if (d >= -p) if (d <= p) {
            const g = 1 / c;
            h *= g, d *= g, f = h * (h + a * d + 2 * l) + d * (a * h + d + 2 * o) + u;
          } else d = r, h = Math.max(0, -(a * d + l)), f = -h * h + d * (d + 2 * o) + u;
          else d = -r, h = Math.max(0, -(a * d + l)), f = -h * h + d * (d + 2 * o) + u;
          else d <= -p ? (h = Math.max(0, -(-a * r + l)), d = h > 0 ? -r : Math.min(Math.max(-r, -o), r), f = -h * h + d * (d + 2 * o) + u) : d <= p ? (h = 0, d = Math.min(Math.max(-r, -o), r), f = d * (d + 2 * o) + u) : (h = Math.max(0, -(a * r + l)), d = h > 0 ? r : Math.min(Math.max(-r, -o), r), f = -h * h + d * (d + 2 * o) + u);
          else d = a > 0 ? -r : r, h = Math.max(0, -(a * d + l)), f = -h * h + d * (d + 2 * o) + u;
          return i && i.copy(this.origin).addScaledVector(this.direction, h), n && n.copy(Vf).addScaledVector(oc, d), f;
        }
        intersectSphere(e, t) {
          _s.subVectors(e.center, this.origin);
          const i = _s.dot(this.direction), n = _s.dot(_s) - i * i, r = e.radius * e.radius;
          if (n > r) return null;
          const a = Math.sqrt(r - n), l = i - a, o = i + a;
          return o < 0 ? null : l < 0 ? this.at(o, t) : this.at(l, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const i = -(this.origin.dot(e.normal) + e.constant) / t;
          return i >= 0 ? i : null;
        }
        intersectPlane(e, t) {
          const i = this.distanceToPlane(e);
          return i === null ? null : this.at(i, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let i, n, r, a, l, o;
          const u = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
          return u >= 0 ? (i = (e.min.x - d.x) * u, n = (e.max.x - d.x) * u) : (i = (e.max.x - d.x) * u, n = (e.min.x - d.x) * u), c >= 0 ? (r = (e.min.y - d.y) * c, a = (e.max.y - d.y) * c) : (r = (e.max.y - d.y) * c, a = (e.min.y - d.y) * c), i > a || r > n || ((r > i || isNaN(i)) && (i = r), (a < n || isNaN(n)) && (n = a), h >= 0 ? (l = (e.min.z - d.z) * h, o = (e.max.z - d.z) * h) : (l = (e.max.z - d.z) * h, o = (e.min.z - d.z) * h), i > o || l > n) || ((l > i || i !== i) && (i = l), (o < n || n !== n) && (n = o), n < 0) ? null : this.at(i >= 0 ? i : n, t);
        }
        intersectsBox(e) {
          return this.intersectBox(e, _s) !== null;
        }
        intersectTriangle(e, t, i, n, r) {
          Hf.subVectors(t, e), lc.subVectors(i, e), qf.crossVectors(Hf, lc);
          let a = this.direction.dot(qf), l;
          if (a > 0) {
            if (n) return null;
            l = 1;
          } else if (a < 0) l = -1, a = -a;
          else return null;
          cn.subVectors(this.origin, e);
          const o = l * this.direction.dot(lc.crossVectors(cn, lc));
          if (o < 0) return null;
          const u = l * this.direction.dot(Hf.cross(cn));
          if (u < 0 || o + u > a) return null;
          const c = -l * cn.dot(qf);
          return c < 0 ? null : this.at(c / a, r);
        }
        applyMatrix4(e) {
          return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
        }
        equals(e) {
          return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class pe {
        constructor(e, t, i, n, r, a, l, o, u, c, h, d, f, p, g, _) {
          pe.prototype.isMatrix4 = true, this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ], e !== void 0 && this.set(e, t, i, n, r, a, l, o, u, c, h, d, f, p, g, _);
        }
        set(e, t, i, n, r, a, l, o, u, c, h, d, f, p, g, _) {
          const m = this.elements;
          return m[0] = e, m[4] = t, m[8] = i, m[12] = n, m[1] = r, m[5] = a, m[9] = l, m[13] = o, m[2] = u, m[6] = c, m[10] = h, m[14] = d, m[3] = f, m[7] = p, m[11] = g, m[15] = _, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new pe().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements, i = e.elements;
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
        }
        copyPosition(e) {
          const t = this.elements, i = e.elements;
          return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e, t, i) {
          return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e, t, i) {
          return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e) {
          const t = this.elements, i = e.elements, n = 1 / ra.setFromMatrixColumn(e, 0).length(), r = 1 / ra.setFromMatrixColumn(e, 1).length(), a = 1 / ra.setFromMatrixColumn(e, 2).length();
          return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromEuler(e) {
          const t = this.elements, i = e.x, n = e.y, r = e.z, a = Math.cos(i), l = Math.sin(i), o = Math.cos(n), u = Math.sin(n), c = Math.cos(r), h = Math.sin(r);
          if (e.order === "XYZ") {
            const d = a * c, f = a * h, p = l * c, g = l * h;
            t[0] = o * c, t[4] = -o * h, t[8] = u, t[1] = f + p * u, t[5] = d - g * u, t[9] = -l * o, t[2] = g - d * u, t[6] = p + f * u, t[10] = a * o;
          } else if (e.order === "YXZ") {
            const d = o * c, f = o * h, p = u * c, g = u * h;
            t[0] = d + g * l, t[4] = p * l - f, t[8] = a * u, t[1] = a * h, t[5] = a * c, t[9] = -l, t[2] = f * l - p, t[6] = g + d * l, t[10] = a * o;
          } else if (e.order === "ZXY") {
            const d = o * c, f = o * h, p = u * c, g = u * h;
            t[0] = d - g * l, t[4] = -a * h, t[8] = p + f * l, t[1] = f + p * l, t[5] = a * c, t[9] = g - d * l, t[2] = -a * u, t[6] = l, t[10] = a * o;
          } else if (e.order === "ZYX") {
            const d = a * c, f = a * h, p = l * c, g = l * h;
            t[0] = o * c, t[4] = p * u - f, t[8] = d * u + g, t[1] = o * h, t[5] = g * u + d, t[9] = f * u - p, t[2] = -u, t[6] = l * o, t[10] = a * o;
          } else if (e.order === "YZX") {
            const d = a * o, f = a * u, p = l * o, g = l * u;
            t[0] = o * c, t[4] = g - d * h, t[8] = p * h + f, t[1] = h, t[5] = a * c, t[9] = -l * c, t[2] = -u * c, t[6] = f * h + p, t[10] = d - g * h;
          } else if (e.order === "XZY") {
            const d = a * o, f = a * u, p = l * o, g = l * u;
            t[0] = o * c, t[4] = -h, t[8] = u * c, t[1] = d * h + g, t[5] = a * c, t[9] = f * h - p, t[2] = p * h - f, t[6] = l * c, t[10] = g * h + d;
          }
          return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromQuaternion(e) {
          return this.compose(tC, e, iC);
        }
        lookAt(e, t, i) {
          const n = this.elements;
          return ei.subVectors(e, t), ei.lengthSq() === 0 && (ei.z = 1), ei.normalize(), hn.crossVectors(i, ei), hn.lengthSq() === 0 && (Math.abs(i.z) === 1 ? ei.x += 1e-4 : ei.z += 1e-4, ei.normalize(), hn.crossVectors(i, ei)), hn.normalize(), uc.crossVectors(ei, hn), n[0] = hn.x, n[4] = uc.x, n[8] = ei.x, n[1] = hn.y, n[5] = uc.y, n[9] = ei.y, n[2] = hn.z, n[6] = uc.z, n[10] = ei.z, this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements, n = t.elements, r = this.elements, a = i[0], l = i[4], o = i[8], u = i[12], c = i[1], h = i[5], d = i[9], f = i[13], p = i[2], g = i[6], _ = i[10], m = i[14], y = i[3], x = i[7], b = i[11], T = i[15], N = n[0], A = n[4], w = n[8], k = n[12], G = n[1], I = n[5], be = n[9], ce = n[13], Fe = n[2], qe = n[6], P = n[10], W = n[14], Y = n[3], ne = n[7], le = n[11], ht = n[15];
          return r[0] = a * N + l * G + o * Fe + u * Y, r[4] = a * A + l * I + o * qe + u * ne, r[8] = a * w + l * be + o * P + u * le, r[12] = a * k + l * ce + o * W + u * ht, r[1] = c * N + h * G + d * Fe + f * Y, r[5] = c * A + h * I + d * qe + f * ne, r[9] = c * w + h * be + d * P + f * le, r[13] = c * k + h * ce + d * W + f * ht, r[2] = p * N + g * G + _ * Fe + m * Y, r[6] = p * A + g * I + _ * qe + m * ne, r[10] = p * w + g * be + _ * P + m * le, r[14] = p * k + g * ce + _ * W + m * ht, r[3] = y * N + x * G + b * Fe + T * Y, r[7] = y * A + x * I + b * qe + T * ne, r[11] = y * w + x * be + b * P + T * le, r[15] = y * k + x * ce + b * W + T * ht, this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
        }
        determinant() {
          const e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], a = e[1], l = e[5], o = e[9], u = e[13], c = e[2], h = e[6], d = e[10], f = e[14], p = e[3], g = e[7], _ = e[11], m = e[15];
          return p * (+r * o * h - n * u * h - r * l * d + i * u * d + n * l * f - i * o * f) + g * (+t * o * f - t * u * d + r * a * d - n * a * f + n * u * c - r * o * c) + _ * (+t * u * h - t * l * f - r * a * h + i * a * f + r * l * c - i * u * c) + m * (-n * l * c - t * o * h + t * l * d + n * a * h - i * a * d + i * o * c);
        }
        transpose() {
          const e = this.elements;
          let t;
          return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        setPosition(e, t, i) {
          const n = this.elements;
          return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this;
        }
        invert() {
          const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], l = e[5], o = e[6], u = e[7], c = e[8], h = e[9], d = e[10], f = e[11], p = e[12], g = e[13], _ = e[14], m = e[15], y = h * _ * u - g * d * u + g * o * f - l * _ * f - h * o * m + l * d * m, x = p * d * u - c * _ * u - p * o * f + a * _ * f + c * o * m - a * d * m, b = c * g * u - p * h * u + p * l * f - a * g * f - c * l * m + a * h * m, T = p * h * o - c * g * o - p * l * d + a * g * d + c * l * _ - a * h * _, N = t * y + i * x + n * b + r * T;
          if (N === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const A = 1 / N;
          return e[0] = y * A, e[1] = (g * d * r - h * _ * r - g * n * f + i * _ * f + h * n * m - i * d * m) * A, e[2] = (l * _ * r - g * o * r + g * n * u - i * _ * u - l * n * m + i * o * m) * A, e[3] = (h * o * r - l * d * r - h * n * u + i * d * u + l * n * f - i * o * f) * A, e[4] = x * A, e[5] = (c * _ * r - p * d * r + p * n * f - t * _ * f - c * n * m + t * d * m) * A, e[6] = (p * o * r - a * _ * r - p * n * u + t * _ * u + a * n * m - t * o * m) * A, e[7] = (a * d * r - c * o * r + c * n * u - t * d * u - a * n * f + t * o * f) * A, e[8] = b * A, e[9] = (p * h * r - c * g * r - p * i * f + t * g * f + c * i * m - t * h * m) * A, e[10] = (a * g * r - p * l * r + p * i * u - t * g * u - a * i * m + t * l * m) * A, e[11] = (c * l * r - a * h * r - c * i * u + t * h * u + a * i * f - t * l * f) * A, e[12] = T * A, e[13] = (c * g * n - p * h * n + p * i * d - t * g * d - c * i * _ + t * h * _) * A, e[14] = (p * l * n - a * g * n - p * i * o + t * g * o + a * i * _ - t * l * _) * A, e[15] = (a * h * n - c * l * n + c * i * o - t * h * o - a * i * d + t * l * d) * A, this;
        }
        scale(e) {
          const t = this.elements, i = e.x, n = e.y, r = e.z;
          return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this;
        }
        getMaxScaleOnAxis() {
          const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, i, n));
        }
        makeTranslation(e, t, i) {
          return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e, t) {
          const i = Math.cos(t), n = Math.sin(t), r = 1 - i, a = e.x, l = e.y, o = e.z, u = r * a, c = r * l;
          return this.set(u * a + i, u * l - n * o, u * o + n * l, 0, u * l + n * o, c * l + i, c * o - n * a, 0, u * o - n * l, c * o + n * a, r * o * o + i, 0, 0, 0, 0, 1), this;
        }
        makeScale(e, t, i) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, i, n, r, a) {
          return this.set(1, i, r, 0, e, 1, a, 0, t, n, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, i) {
          const n = this.elements, r = t._x, a = t._y, l = t._z, o = t._w, u = r + r, c = a + a, h = l + l, d = r * u, f = r * c, p = r * h, g = a * c, _ = a * h, m = l * h, y = o * u, x = o * c, b = o * h, T = i.x, N = i.y, A = i.z;
          return n[0] = (1 - (g + m)) * T, n[1] = (f + b) * T, n[2] = (p - x) * T, n[3] = 0, n[4] = (f - b) * N, n[5] = (1 - (d + m)) * N, n[6] = (_ + y) * N, n[7] = 0, n[8] = (p + x) * A, n[9] = (_ - y) * A, n[10] = (1 - (d + g)) * A, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
        }
        decompose(e, t, i) {
          const n = this.elements;
          let r = ra.set(n[0], n[1], n[2]).length();
          const a = ra.set(n[4], n[5], n[6]).length(), l = ra.set(n[8], n[9], n[10]).length();
          this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], Li.copy(this);
          const u = 1 / r, c = 1 / a, h = 1 / l;
          return Li.elements[0] *= u, Li.elements[1] *= u, Li.elements[2] *= u, Li.elements[4] *= c, Li.elements[5] *= c, Li.elements[6] *= c, Li.elements[8] *= h, Li.elements[9] *= h, Li.elements[10] *= h, t.setFromRotationMatrix(Li), i.x = r, i.y = a, i.z = l, this;
        }
        makePerspective(e, t, i, n, r, a, l = li) {
          const o = this.elements, u = 2 * r / (t - e), c = 2 * r / (i - n), h = (t + e) / (t - e), d = (i + n) / (i - n);
          let f, p;
          if (l === li) f = -(a + r) / (a - r), p = -2 * a * r / (a - r);
          else if (l === Zn) f = -a / (a - r), p = -a * r / (a - r);
          else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
          return o[0] = u, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = d, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = f, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
        }
        makeOrthographic(e, t, i, n, r, a, l = li) {
          const o = this.elements, u = 1 / (t - e), c = 1 / (i - n), h = 1 / (a - r), d = (t + e) * u, f = (i + n) * c;
          let p, g;
          if (l === li) p = (a + r) * h, g = -2 * h;
          else if (l === Zn) p = r * h, g = -1 * h;
          else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
          return o[0] = 2 * u, o[4] = 0, o[8] = 0, o[12] = -d, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -f, o[2] = 0, o[6] = 0, o[10] = g, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
        }
        equals(e) {
          const t = this.elements, i = e.elements;
          for (let n = 0; n < 16; n++) if (t[n] !== i[n]) return false;
          return true;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
        }
      }
      const ra = new v(), Li = new pe(), tC = new v(0, 0, 0), iC = new v(1, 1, 1), hn = new v(), uc = new v(), ei = new v(), o_ = new pe(), l_ = new Lr();
      class $i {
        constructor(e = 0, t = 0, i = 0, n = $i.DEFAULT_ORDER) {
          this.isEuler = true, this._x = e, this._y = t, this._z = i, this._order = n;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          this._order = e, this._onChangeCallback();
        }
        set(e, t, i, n = this._order) {
          return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e, t = this._order, i = true) {
          const n = e.elements, r = n[0], a = n[4], l = n[8], o = n[1], u = n[5], c = n[9], h = n[2], d = n[6], f = n[10];
          switch (t) {
            case "XYZ":
              this._y = Math.asin(ee(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-c, f), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, u), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-ee(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(o, u)) : (this._y = Math.atan2(-h, r), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(ee(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(o, r));
              break;
            case "ZYX":
              this._y = Math.asin(-ee(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-a, u));
              break;
            case "YZX":
              this._z = Math.asin(ee(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-c, u), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(l, f));
              break;
            case "XZY":
              this._z = Math.asin(-ee(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, u), this._y = Math.atan2(l, r)) : (this._x = Math.atan2(-c, f), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
          }
          return this._order = t, i === true && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, i) {
          return o_.makeRotationFromQuaternion(e), this.setFromRotationMatrix(o_, t, i);
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return l_.setFromEuler(this), this.setFromQuaternion(l_, e);
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
          return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
        }
        _onChange(e) {
          return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      $i.DEFAULT_ORDER = "XYZ";
      class Cv {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e | 0) >>> 0;
        }
        enable(e) {
          this.mask |= 1 << e | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= 1 << e | 0;
        }
        disable(e) {
          this.mask &= ~(1 << e | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
          return (this.mask & (1 << e | 0)) !== 0;
        }
      }
      let sC = 0;
      const u_ = new v(), aa = new Lr(), bs = new pe(), cc = new v(), Xo = new v(), nC = new v(), rC = new Lr(), c_ = new v(1, 0, 0), h_ = new v(0, 1, 0), d_ = new v(0, 0, 1), f_ = {
        type: "added"
      }, aC = {
        type: "removed"
      }, oa = {
        type: "childadded",
        child: null
      }, Yf = {
        type: "childremoved",
        child: null
      };
      class lt extends jr {
        constructor() {
          super(), this.isObject3D = true, Object.defineProperty(this, "id", {
            value: sC++
          }), this.uuid = Is(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = lt.DEFAULT_UP.clone();
          const e = new v(), t = new $i(), i = new Lr(), n = new v(1, 1, 1);
          function r() {
            i.setFromEuler(t, false);
          }
          function a() {
            t.setFromQuaternion(i, void 0, false);
          }
          t._onChange(r), i._onChange(a), Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: e
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: t
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: i
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: n
            },
            modelViewMatrix: {
              value: new pe()
            },
            normalMatrix: {
              value: new Jt()
            }
          }), this.matrix = new pe(), this.matrixWorld = new pe(), this.matrixAutoUpdate = lt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = lt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Cv(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
        }
        onBeforeShadow() {
        }
        onAfterShadow() {
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, true);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return aa.setFromAxisAngle(e, t), this.quaternion.multiply(aa), this;
        }
        rotateOnWorldAxis(e, t) {
          return aa.setFromAxisAngle(e, t), this.quaternion.premultiply(aa), this;
        }
        rotateX(e) {
          return this.rotateOnAxis(c_, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(h_, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(d_, e);
        }
        translateOnAxis(e, t) {
          return u_.copy(e).applyQuaternion(this.quaternion), this.position.add(u_.multiplyScalar(t)), this;
        }
        translateX(e) {
          return this.translateOnAxis(c_, e);
        }
        translateY(e) {
          return this.translateOnAxis(h_, e);
        }
        translateZ(e) {
          return this.translateOnAxis(d_, e);
        }
        localToWorld(e) {
          return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return this.updateWorldMatrix(true, false), e.applyMatrix4(bs.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, i) {
          e.isVector3 ? cc.copy(e) : cc.set(e, t, i);
          const n = this.parent;
          this.updateWorldMatrix(true, false), Xo.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? bs.lookAt(Xo, cc, this.up) : bs.lookAt(cc, Xo, this.up), this.quaternion.setFromRotationMatrix(bs), n && (bs.extractRotation(n.matrixWorld), aa.setFromRotationMatrix(bs), this.quaternion.premultiply(aa.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(f_), oa.child = e, this.dispatchEvent(oa), oa.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
          }
          const t = this.children.indexOf(e);
          return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(aC), Yf.child = e, this.dispatchEvent(Yf), Yf.child = null), this;
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(e) {
          return this.updateWorldMatrix(true, false), bs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), bs.multiply(e.parent.matrixWorld)), e.applyMatrix4(bs), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(false, true), e.dispatchEvent(f_), oa.child = e, this.dispatchEvent(oa), oa.child = null, this;
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let i = 0, n = this.children.length; i < n; i++) {
            const a = this.children[i].getObjectByProperty(e, t);
            if (a !== void 0) return a;
          }
        }
        getObjectsByProperty(e, t, i = []) {
          this[e] === t && i.push(this);
          const n = this.children;
          for (let r = 0, a = n.length; r < a; r++) n[r].getObjectsByProperty(e, t, i);
          return i;
        }
        getWorldPosition(e) {
          return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Xo, e, nC), e;
        }
        getWorldScale(e) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Xo, rC, e), e;
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(true, false);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {
        }
        traverse(e) {
          e(this);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === false) return;
          e(this);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, e = true);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const i = this.parent;
          if (e === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === true) {
            const n = this.children;
            for (let r = 0, a = n.length; r < a; r++) n[r].updateWorldMatrix(false, true);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string", i = {};
          t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          }, i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
          });
          const n = {};
          n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === true && (n.castShadow = true), this.receiveShadow === true && (n.receiveShadow = true), this.visible === false && (n.visible = false), this.frustumCulled === false && (n.frustumCulled = false), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === false && (n.matrixAutoUpdate = false), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((l) => ({
            boxInitialized: l.boxInitialized,
            boxMin: l.box.min.toArray(),
            boxMax: l.box.max.toArray(),
            sphereInitialized: l.sphereInitialized,
            sphereRadius: l.sphere.radius,
            sphereCenter: l.sphere.center.toArray()
          })), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (n.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (n.boundingSphere = {
            center: n.boundingSphere.center.toArray(),
            radius: n.boundingSphere.radius
          }), this.boundingBox !== null && (n.boundingBox = {
            min: n.boundingBox.min.toArray(),
            max: n.boundingBox.max.toArray()
          }));
          function r(l, o) {
            return l[o.uuid] === void 0 && (l[o.uuid] = o.toJSON(e)), o.uuid;
          }
          if (this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (n.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = r(e.geometries, this.geometry);
            const l = this.geometry.parameters;
            if (l !== void 0 && l.shapes !== void 0) {
              const o = l.shapes;
              if (Array.isArray(o)) for (let u = 0, c = o.length; u < c; u++) {
                const h = o[u];
                r(e.shapes, h);
              }
              else r(e.shapes, o);
            }
          }
          if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
            const l = [];
            for (let o = 0, u = this.material.length; o < u; o++) l.push(r(e.materials, this.material[o]));
            n.material = l;
          } else n.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            n.children = [];
            for (let l = 0; l < this.children.length; l++) n.children.push(this.children[l].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            n.animations = [];
            for (let l = 0; l < this.animations.length; l++) {
              const o = this.animations[l];
              n.animations.push(r(e.animations, o));
            }
          }
          if (t) {
            const l = a(e.geometries), o = a(e.materials), u = a(e.textures), c = a(e.images), h = a(e.shapes), d = a(e.skeletons), f = a(e.animations), p = a(e.nodes);
            l.length > 0 && (i.geometries = l), o.length > 0 && (i.materials = o), u.length > 0 && (i.textures = u), c.length > 0 && (i.images = c), h.length > 0 && (i.shapes = h), d.length > 0 && (i.skeletons = d), f.length > 0 && (i.animations = f), p.length > 0 && (i.nodes = p);
          }
          return i.object = n, i;
          function a(l) {
            const o = [];
            for (const u in l) {
              const c = l[u];
              delete c.metadata, o.push(c);
            }
            return o;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = true) {
          if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let i = 0; i < e.children.length; i++) {
            const n = e.children[i];
            this.add(n.clone());
          }
          return this;
        }
      }
      lt.DEFAULT_UP = new v(0, 1, 0);
      lt.DEFAULT_MATRIX_AUTO_UPDATE = true;
      lt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
      const Gi = new v(), Ss = new v(), Wf = new v(), Ts = new v(), la = new v(), ua = new v(), p_ = new v(), jf = new v(), $f = new v(), Xf = new v(), Zf = new Te(), Qf = new Te(), Kf = new Te();
      class Hi {
        constructor(e = new v(), t = new v(), i = new v()) {
          this.a = e, this.b = t, this.c = i;
        }
        static getNormal(e, t, i, n) {
          n.subVectors(i, t), Gi.subVectors(e, t), n.cross(Gi);
          const r = n.lengthSq();
          return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
        }
        static getBarycoord(e, t, i, n, r) {
          Gi.subVectors(n, t), Ss.subVectors(i, t), Wf.subVectors(e, t);
          const a = Gi.dot(Gi), l = Gi.dot(Ss), o = Gi.dot(Wf), u = Ss.dot(Ss), c = Ss.dot(Wf), h = a * u - l * l;
          if (h === 0) return r.set(0, 0, 0), null;
          const d = 1 / h, f = (u * o - l * c) * d, p = (a * c - l * o) * d;
          return r.set(1 - f - p, p, f);
        }
        static containsPoint(e, t, i, n) {
          return this.getBarycoord(e, t, i, n, Ts) === null ? false : Ts.x >= 0 && Ts.y >= 0 && Ts.x + Ts.y <= 1;
        }
        static getInterpolation(e, t, i, n, r, a, l, o) {
          return this.getBarycoord(e, t, i, n, Ts) === null ? (o.x = 0, o.y = 0, "z" in o && (o.z = 0), "w" in o && (o.w = 0), null) : (o.setScalar(0), o.addScaledVector(r, Ts.x), o.addScaledVector(a, Ts.y), o.addScaledVector(l, Ts.z), o);
        }
        static getInterpolatedAttribute(e, t, i, n, r, a) {
          return Zf.setScalar(0), Qf.setScalar(0), Kf.setScalar(0), Zf.fromBufferAttribute(e, t), Qf.fromBufferAttribute(e, i), Kf.fromBufferAttribute(e, n), a.setScalar(0), a.addScaledVector(Zf, r.x), a.addScaledVector(Qf, r.y), a.addScaledVector(Kf, r.z), a;
        }
        static isFrontFacing(e, t, i, n) {
          return Gi.subVectors(i, t), Ss.subVectors(e, t), Gi.cross(Ss).dot(n) < 0;
        }
        set(e, t, i) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
        }
        setFromPointsAndIndices(e, t, i, n) {
          return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
        }
        setFromAttributeAndIndices(e, t, i, n) {
          return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return Gi.subVectors(this.c, this.b), Ss.subVectors(this.a, this.b), Gi.cross(Ss).length() * 0.5;
        }
        getMidpoint(e) {
          return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return Hi.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return Hi.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, i, n, r) {
          return Hi.getInterpolation(e, this.a, this.b, this.c, t, i, n, r);
        }
        containsPoint(e) {
          return Hi.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return Hi.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const i = this.a, n = this.b, r = this.c;
          let a, l;
          la.subVectors(n, i), ua.subVectors(r, i), jf.subVectors(e, i);
          const o = la.dot(jf), u = ua.dot(jf);
          if (o <= 0 && u <= 0) return t.copy(i);
          $f.subVectors(e, n);
          const c = la.dot($f), h = ua.dot($f);
          if (c >= 0 && h <= c) return t.copy(n);
          const d = o * h - c * u;
          if (d <= 0 && o >= 0 && c <= 0) return a = o / (o - c), t.copy(i).addScaledVector(la, a);
          Xf.subVectors(e, r);
          const f = la.dot(Xf), p = ua.dot(Xf);
          if (p >= 0 && f <= p) return t.copy(r);
          const g = f * u - o * p;
          if (g <= 0 && u >= 0 && p <= 0) return l = u / (u - p), t.copy(i).addScaledVector(ua, l);
          const _ = c * p - f * h;
          if (_ <= 0 && h - c >= 0 && f - p >= 0) return p_.subVectors(r, n), l = (h - c) / (h - c + (f - p)), t.copy(n).addScaledVector(p_, l);
          const m = 1 / (_ + g + d);
          return a = g * m, l = d * m, t.copy(i).addScaledVector(la, a).addScaledVector(ua, l);
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      const Bv = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      }, dn = {
        h: 0,
        s: 0,
        l: 0
      }, hc = {
        h: 0,
        s: 0,
        l: 0
      };
      function Jf(s, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
      }
      class ie {
        constructor(e, t, i) {
          return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
        }
        set(e, t, i) {
          if (t === void 0 && i === void 0) {
            const n = e;
            n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
          } else this.setRGB(e, t, i);
          return this;
        }
        setScalar(e) {
          return this.r = e, this.g = e, this.b = e, this;
        }
        setHex(e, t = H) {
          return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, rt.toWorkingColorSpace(this, t), this;
        }
        setRGB(e, t, i, n = rt.workingColorSpace) {
          return this.r = e, this.g = t, this.b = i, rt.toWorkingColorSpace(this, n), this;
        }
        setHSL(e, t, i, n = rt.workingColorSpace) {
          if (e = Uy(e, 1), t = ee(t, 0, 1), i = ee(i, 0, 1), t === 0) this.r = this.g = this.b = i;
          else {
            const r = i <= 0.5 ? i * (1 + t) : i + t - i * t, a = 2 * i - r;
            this.r = Jf(a, r, e + 1 / 3), this.g = Jf(a, r, e), this.b = Jf(a, r, e - 1 / 3);
          }
          return rt.toWorkingColorSpace(this, n), this;
        }
        setStyle(e, t = H) {
          function i(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
          }
          let n;
          if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let r;
            const a = n[1], l = n[2];
            switch (a) {
              case "rgb":
              case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                break;
              case "hsl":
              case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + e);
            }
          } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const r = n[1], a = r.length;
            if (a === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
            if (a === 6) return this.setHex(parseInt(r, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e);
          } else if (e && e.length > 0) return this.setColorName(e, t);
          return this;
        }
        setColorName(e, t = H) {
          const i = Bv[e.toLowerCase()];
          return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return this.r = e.r, this.g = e.g, this.b = e.b, this;
        }
        copySRGBToLinear(e) {
          return this.r = Vs(e.r), this.g = Vs(e.g), this.b = Vs(e.b), this;
        }
        copyLinearToSRGB(e) {
          return this.r = to(e.r), this.g = to(e.g), this.b = to(e.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = H) {
          return rt.fromWorkingColorSpace(Nt.copy(this), e), Math.round(ee(Nt.r * 255, 0, 255)) * 65536 + Math.round(ee(Nt.g * 255, 0, 255)) * 256 + Math.round(ee(Nt.b * 255, 0, 255));
        }
        getHexString(e = H) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = rt.workingColorSpace) {
          rt.fromWorkingColorSpace(Nt.copy(this), t);
          const i = Nt.r, n = Nt.g, r = Nt.b, a = Math.max(i, n, r), l = Math.min(i, n, r);
          let o, u;
          const c = (l + a) / 2;
          if (l === a) o = 0, u = 0;
          else {
            const h = a - l;
            switch (u = c <= 0.5 ? h / (a + l) : h / (2 - a - l), a) {
              case i:
                o = (n - r) / h + (n < r ? 6 : 0);
                break;
              case n:
                o = (r - i) / h + 2;
                break;
              case r:
                o = (i - n) / h + 4;
                break;
            }
            o /= 6;
          }
          return e.h = o, e.s = u, e.l = c, e;
        }
        getRGB(e, t = rt.workingColorSpace) {
          return rt.fromWorkingColorSpace(Nt.copy(this), t), e.r = Nt.r, e.g = Nt.g, e.b = Nt.b, e;
        }
        getStyle(e = H) {
          rt.fromWorkingColorSpace(Nt.copy(this), e);
          const t = Nt.r, i = Nt.g, n = Nt.b;
          return e !== H ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
        }
        offsetHSL(e, t, i) {
          return this.getHSL(dn), this.setHSL(dn.h + e, dn.s + t, dn.l + i);
        }
        add(e) {
          return this.r += e.r, this.g += e.g, this.b += e.b, this;
        }
        addColors(e, t) {
          return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
        }
        addScalar(e) {
          return this.r += e, this.g += e, this.b += e, this;
        }
        sub(e) {
          return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
        }
        multiply(e) {
          return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
        }
        multiplyScalar(e) {
          return this.r *= e, this.g *= e, this.b *= e, this;
        }
        lerp(e, t) {
          return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
        }
        lerpColors(e, t, i) {
          return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
        }
        lerpHSL(e, t) {
          this.getHSL(dn), e.getHSL(hc);
          const i = Ll(dn.h, hc.h, t), n = Ll(dn.s, hc.s, t), r = Ll(dn.l, hc.l, t);
          return this.setHSL(i, n, r), this;
        }
        setFromVector3(e) {
          return this.r = e.x, this.g = e.y, this.b = e.z, this;
        }
        applyMatrix3(e) {
          const t = this.r, i = this.g, n = this.b, r = e.elements;
          return this.r = r[0] * t + r[3] * i + r[6] * n, this.g = r[1] * t + r[4] * i + r[7] * n, this.b = r[2] * t + r[5] * i + r[8] * n, this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
        }
        fromBufferAttribute(e, t) {
          return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const Nt = new ie();
      ie.NAMES = Bv;
      let oC = 0;
      class Zt extends jr {
        constructor() {
          super(), this.isMaterial = true, Object.defineProperty(this, "id", {
            value: oC++
          }), this.uuid = Is(), this.name = "", this.type = "Material", this.blending = kn, this.side = yo, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = Wh, this.blendDst = jh, this.blendEquation = Mn, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new ie(0, 0, 0), this.blendAlpha = 0, this.depthFunc = $h, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = lg, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = cr, this.stencilZFail = cr, this.stencilZPass = cr, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0) for (const t in e) {
            const i = e[t];
            if (i === void 0) {
              console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
              continue;
            }
            const n = this[t];
            if (n === void 0) {
              console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
              continue;
            }
            n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i;
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = {
            textures: {},
            images: {}
          });
          const i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== kn && (i.blending = this.blending), this.side !== yo && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== Wh && (i.blendSrc = this.blendSrc), this.blendDst !== jh && (i.blendDst = this.blendDst), this.blendEquation !== Mn && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== $h && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== lg && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== cr && (i.stencilFail = this.stencilFail), this.stencilZFail !== cr && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== cr && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
          function n(r) {
            const a = [];
            for (const l in r) {
              const o = r[l];
              delete o.metadata, a.push(o);
            }
            return a;
          }
          if (t) {
            const r = n(e.textures), a = n(e.images);
            r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
          const t = e.clippingPlanes;
          let i = null;
          if (t !== null) {
            const n = t.length;
            i = new Array(n);
            for (let r = 0; r !== n; ++r) i[r] = t[r].clone();
          }
          return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      }
      class Fy extends Zt {
        constructor(e) {
          super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new ie(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $i(), this.combine = Bd, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
      }
      const Cs = lC();
      function lC() {
        const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), i = new Uint32Array(512), n = new Uint32Array(512);
        for (let o = 0; o < 256; ++o) {
          const u = o - 127;
          u < -27 ? (i[o] = 0, i[o | 256] = 32768, n[o] = 24, n[o | 256] = 24) : u < -14 ? (i[o] = 1024 >> -u - 14, i[o | 256] = 1024 >> -u - 14 | 32768, n[o] = -u - 1, n[o | 256] = -u - 1) : u <= 15 ? (i[o] = u + 15 << 10, i[o | 256] = u + 15 << 10 | 32768, n[o] = 13, n[o | 256] = 13) : u < 128 ? (i[o] = 31744, i[o | 256] = 64512, n[o] = 24, n[o | 256] = 24) : (i[o] = 31744, i[o | 256] = 64512, n[o] = 13, n[o | 256] = 13);
        }
        const r = new Uint32Array(2048), a = new Uint32Array(64), l = new Uint32Array(64);
        for (let o = 1; o < 1024; ++o) {
          let u = o << 13, c = 0;
          for (; !(u & 8388608); ) u <<= 1, c -= 8388608;
          u &= -8388609, c += 947912704, r[o] = u | c;
        }
        for (let o = 1024; o < 2048; ++o) r[o] = 939524096 + (o - 1024 << 13);
        for (let o = 1; o < 31; ++o) a[o] = o << 23;
        a[31] = 1199570944, a[32] = 2147483648;
        for (let o = 33; o < 63; ++o) a[o] = 2147483648 + (o - 32 << 23);
        a[63] = 3347054592;
        for (let o = 1; o < 64; ++o) o !== 32 && (l[o] = 1024);
        return {
          floatView: e,
          uint32View: t,
          baseTable: i,
          shiftTable: n,
          mantissaTable: r,
          exponentTable: a,
          offsetTable: l
        };
      }
      function ti(s) {
        Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = ee(s, -65504, 65504), Cs.floatView[0] = s;
        const e = Cs.uint32View[0], t = e >> 23 & 511;
        return Cs.baseTable[t] + ((e & 8388607) >> Cs.shiftTable[t]);
      }
      function dc(s) {
        const e = s >> 10;
        return Cs.uint32View[0] = Cs.mantissaTable[Cs.offsetTable[e] + (s & 1023)] + Cs.exponentTable[e], Cs.floatView[0];
      }
      const je = new v(), fc = new q();
      class Ci {
        constructor(e, t, i = false) {
          if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = true, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = Xh, this.updateRanges = [], this.gpuType = Yt, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({
            start: e,
            count: t
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
        }
        copyAt(e, t, i) {
          e *= this.itemSize, i *= t.itemSize;
          for (let n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) fc.fromBufferAttribute(this, t), fc.applyMatrix3(e), this.setXY(t, fc.x, fc.y);
          else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++) je.fromBufferAttribute(this, t), je.applyMatrix3(e), this.setXYZ(t, je.x, je.y, je.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.count; t < i; t++) je.fromBufferAttribute(this, t), je.applyMatrix4(e), this.setXYZ(t, je.x, je.y, je.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) je.fromBufferAttribute(this, t), je.applyNormalMatrix(e), this.setXYZ(t, je.x, je.y, je.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) je.fromBufferAttribute(this, t), je.transformDirection(e), this.setXYZ(t, je.x, je.y, je.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.itemSize + t];
          return this.normalized && (i = Ft(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return this.normalized && (i = K(i, this.array)), this.array[e * this.itemSize + t] = i, this;
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setX(e, t) {
          return this.normalized && (t = K(t, this.array)), this.array[e * this.itemSize] = t, this;
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setY(e, t) {
          return this.normalized && (t = K(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setZ(e, t) {
          return this.normalized && (t = K(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setW(e, t) {
          return this.normalized && (t = K(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
        }
        setXY(e, t, i) {
          return e *= this.itemSize, this.normalized && (t = K(t, this.array), i = K(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
        }
        setXYZ(e, t, i, n) {
          return e *= this.itemSize, this.normalized && (t = K(t, this.array), i = K(i, this.array), n = K(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
        }
        setXYZW(e, t, i, n, r) {
          return e *= this.itemSize, this.normalized && (t = K(t, this.array), i = K(i, this.array), n = K(n, this.array), r = K(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this;
        }
        onUpload(e) {
          return this.onUploadCallback = e, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          return this.name !== "" && (e.name = this.name), this.usage !== Xh && (e.usage = this.usage), e;
        }
      }
      class Dv extends Ci {
        constructor(e, t, i) {
          super(new Uint16Array(e), t, i);
        }
      }
      class Uv extends Ci {
        constructor(e, t, i) {
          super(new Uint32Array(e), t, i);
        }
      }
      class Fv extends Ci {
        constructor(e, t, i) {
          super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = true;
        }
        getX(e) {
          let t = dc(this.array[e * this.itemSize]);
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setX(e, t) {
          return this.normalized && (t = K(t, this.array)), this.array[e * this.itemSize] = ti(t), this;
        }
        getY(e) {
          let t = dc(this.array[e * this.itemSize + 1]);
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setY(e, t) {
          return this.normalized && (t = K(t, this.array)), this.array[e * this.itemSize + 1] = ti(t), this;
        }
        getZ(e) {
          let t = dc(this.array[e * this.itemSize + 2]);
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setZ(e, t) {
          return this.normalized && (t = K(t, this.array)), this.array[e * this.itemSize + 2] = ti(t), this;
        }
        getW(e) {
          let t = dc(this.array[e * this.itemSize + 3]);
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setW(e, t) {
          return this.normalized && (t = K(t, this.array)), this.array[e * this.itemSize + 3] = ti(t), this;
        }
        setXY(e, t, i) {
          return e *= this.itemSize, this.normalized && (t = K(t, this.array), i = K(i, this.array)), this.array[e + 0] = ti(t), this.array[e + 1] = ti(i), this;
        }
        setXYZ(e, t, i, n) {
          return e *= this.itemSize, this.normalized && (t = K(t, this.array), i = K(i, this.array), n = K(n, this.array)), this.array[e + 0] = ti(t), this.array[e + 1] = ti(i), this.array[e + 2] = ti(n), this;
        }
        setXYZW(e, t, i, n, r) {
          return e *= this.itemSize, this.normalized && (t = K(t, this.array), i = K(i, this.array), n = K(n, this.array), r = K(r, this.array)), this.array[e + 0] = ti(t), this.array[e + 1] = ti(i), this.array[e + 2] = ti(n), this.array[e + 3] = ti(r), this;
        }
      }
      class Wi extends Ci {
        constructor(e, t, i) {
          super(new Float32Array(e), t, i);
        }
      }
      let uC = 0;
      const xi = new pe(), ep = new lt(), ca = new v(), ii = new $r(), Zo = new $r(), dt = new v();
      class en extends jr {
        constructor() {
          super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
            value: uC++
          }), this.uuid = Is(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
          }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return Array.isArray(e) ? this.index = new (YR(e) ? Uv : Dv)(e, 1) : this.index = e, this;
        }
        setIndirect(e) {
          return this.indirect = e, this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return this.attributes[e] = t, this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, i = 0) {
          this.groups.push({
            start: e,
            count: t,
            materialIndex: i
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          this.drawRange.start = e, this.drawRange.count = t;
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
          const i = this.attributes.normal;
          if (i !== void 0) {
            const r = new Jt().getNormalMatrix(e);
            i.applyNormalMatrix(r), i.needsUpdate = true;
          }
          const n = this.attributes.tangent;
          return n !== void 0 && (n.transformDirection(e), n.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(e) {
          return xi.makeRotationFromQuaternion(e), this.applyMatrix4(xi), this;
        }
        rotateX(e) {
          return xi.makeRotationX(e), this.applyMatrix4(xi), this;
        }
        rotateY(e) {
          return xi.makeRotationY(e), this.applyMatrix4(xi), this;
        }
        rotateZ(e) {
          return xi.makeRotationZ(e), this.applyMatrix4(xi), this;
        }
        translate(e, t, i) {
          return xi.makeTranslation(e, t, i), this.applyMatrix4(xi), this;
        }
        scale(e, t, i) {
          return xi.makeScale(e, t, i), this.applyMatrix4(xi), this;
        }
        lookAt(e) {
          return ep.lookAt(e), ep.updateMatrix(), this.applyMatrix4(ep.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(ca).negate(), this.translate(ca.x, ca.y, ca.z), this;
        }
        setFromPoints(e) {
          const t = this.getAttribute("position");
          if (t === void 0) {
            const i = [];
            for (let n = 0, r = e.length; n < r; n++) {
              const a = e[n];
              i.push(a.x, a.y, a.z || 0);
            }
            this.setAttribute("position", new Wi(i, 3));
          } else {
            const i = Math.min(e.length, t.count);
            for (let n = 0; n < i; n++) {
              const r = e[n];
              t.setXYZ(n, r.x, r.y, r.z || 0);
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = true;
          }
          return this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new $r());
          const e = this.attributes.position, t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new v(-1 / 0, -1 / 0, -1 / 0), new v(1 / 0, 1 / 0, 1 / 0));
            return;
          }
          if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, n = t.length; i < n; i++) {
              const r = t[i];
              ii.setFromBufferAttribute(r), this.morphTargetsRelative ? (dt.addVectors(this.boundingBox.min, ii.min), this.boundingBox.expandByPoint(dt), dt.addVectors(this.boundingBox.max, ii.max), this.boundingBox.expandByPoint(dt)) : (this.boundingBox.expandByPoint(ii.min), this.boundingBox.expandByPoint(ii.max));
            }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new Fo());
          const e = this.attributes.position, t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new v(), 1 / 0);
            return;
          }
          if (e) {
            const i = this.boundingSphere.center;
            if (ii.setFromBufferAttribute(e), t) for (let r = 0, a = t.length; r < a; r++) {
              const l = t[r];
              Zo.setFromBufferAttribute(l), this.morphTargetsRelative ? (dt.addVectors(ii.min, Zo.min), ii.expandByPoint(dt), dt.addVectors(ii.max, Zo.max), ii.expandByPoint(dt)) : (ii.expandByPoint(Zo.min), ii.expandByPoint(Zo.max));
            }
            ii.getCenter(i);
            let n = 0;
            for (let r = 0, a = e.count; r < a; r++) dt.fromBufferAttribute(e, r), n = Math.max(n, i.distanceToSquared(dt));
            if (t) for (let r = 0, a = t.length; r < a; r++) {
              const l = t[r], o = this.morphTargetsRelative;
              for (let u = 0, c = l.count; u < c; u++) dt.fromBufferAttribute(l, u), o && (ca.fromBufferAttribute(e, u), dt.add(ca)), n = Math.max(n, i.distanceToSquared(dt));
            }
            this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const e = this.index, t = this.attributes;
          if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const i = t.position, n = t.normal, r = t.uv;
          this.hasAttribute("tangent") === false && this.setAttribute("tangent", new Ci(new Float32Array(4 * i.count), 4));
          const a = this.getAttribute("tangent"), l = [], o = [];
          for (let w = 0; w < i.count; w++) l[w] = new v(), o[w] = new v();
          const u = new v(), c = new v(), h = new v(), d = new q(), f = new q(), p = new q(), g = new v(), _ = new v();
          function m(w, k, G) {
            u.fromBufferAttribute(i, w), c.fromBufferAttribute(i, k), h.fromBufferAttribute(i, G), d.fromBufferAttribute(r, w), f.fromBufferAttribute(r, k), p.fromBufferAttribute(r, G), c.sub(u), h.sub(u), f.sub(d), p.sub(d);
            const I = 1 / (f.x * p.y - p.x * f.y);
            isFinite(I) && (g.copy(c).multiplyScalar(p.y).addScaledVector(h, -f.y).multiplyScalar(I), _.copy(h).multiplyScalar(f.x).addScaledVector(c, -p.x).multiplyScalar(I), l[w].add(g), l[k].add(g), l[G].add(g), o[w].add(_), o[k].add(_), o[G].add(_));
          }
          let y = this.groups;
          y.length === 0 && (y = [
            {
              start: 0,
              count: e.count
            }
          ]);
          for (let w = 0, k = y.length; w < k; ++w) {
            const G = y[w], I = G.start, be = G.count;
            for (let ce = I, Fe = I + be; ce < Fe; ce += 3) m(e.getX(ce + 0), e.getX(ce + 1), e.getX(ce + 2));
          }
          const x = new v(), b = new v(), T = new v(), N = new v();
          function A(w) {
            T.fromBufferAttribute(n, w), N.copy(T);
            const k = l[w];
            x.copy(k), x.sub(T.multiplyScalar(T.dot(k))).normalize(), b.crossVectors(N, k);
            const I = b.dot(o[w]) < 0 ? -1 : 1;
            a.setXYZW(w, x.x, x.y, x.z, I);
          }
          for (let w = 0, k = y.length; w < k; ++w) {
            const G = y[w], I = G.start, be = G.count;
            for (let ce = I, Fe = I + be; ce < Fe; ce += 3) A(e.getX(ce + 0)), A(e.getX(ce + 1)), A(e.getX(ce + 2));
          }
        }
        computeVertexNormals() {
          const e = this.index, t = this.getAttribute("position");
          if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new Ci(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
            else for (let d = 0, f = i.count; d < f; d++) i.setXYZ(d, 0, 0, 0);
            const n = new v(), r = new v(), a = new v(), l = new v(), o = new v(), u = new v(), c = new v(), h = new v();
            if (e) for (let d = 0, f = e.count; d < f; d += 3) {
              const p = e.getX(d + 0), g = e.getX(d + 1), _ = e.getX(d + 2);
              n.fromBufferAttribute(t, p), r.fromBufferAttribute(t, g), a.fromBufferAttribute(t, _), c.subVectors(a, r), h.subVectors(n, r), c.cross(h), l.fromBufferAttribute(i, p), o.fromBufferAttribute(i, g), u.fromBufferAttribute(i, _), l.add(c), o.add(c), u.add(c), i.setXYZ(p, l.x, l.y, l.z), i.setXYZ(g, o.x, o.y, o.z), i.setXYZ(_, u.x, u.y, u.z);
            }
            else for (let d = 0, f = t.count; d < f; d += 3) n.fromBufferAttribute(t, d + 0), r.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), c.subVectors(a, r), h.subVectors(n, r), c.cross(h), i.setXYZ(d + 0, c.x, c.y, c.z), i.setXYZ(d + 1, c.x, c.y, c.z), i.setXYZ(d + 2, c.x, c.y, c.z);
            this.normalizeNormals(), i.needsUpdate = true;
          }
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, i = e.count; t < i; t++) dt.fromBufferAttribute(e, t), dt.normalize(), e.setXYZ(t, dt.x, dt.y, dt.z);
        }
        toNonIndexed() {
          function e(l, o) {
            const u = l.array, c = l.itemSize, h = l.normalized, d = new u.constructor(o.length * c);
            let f = 0, p = 0;
            for (let g = 0, _ = o.length; g < _; g++) {
              l.isInterleavedBufferAttribute ? f = o[g] * l.data.stride + l.offset : f = o[g] * c;
              for (let m = 0; m < c; m++) d[p++] = u[f++];
            }
            return new Ci(d, c, h);
          }
          if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const t = new en(), i = this.index.array, n = this.attributes;
          for (const l in n) {
            const o = n[l], u = e(o, i);
            t.setAttribute(l, u);
          }
          const r = this.morphAttributes;
          for (const l in r) {
            const o = [], u = r[l];
            for (let c = 0, h = u.length; c < h; c++) {
              const d = u[c], f = e(d, i);
              o.push(f);
            }
            t.morphAttributes[l] = o;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const a = this.groups;
          for (let l = 0, o = a.length; l < o; l++) {
            const u = a[l];
            t.addGroup(u.start, u.count, u.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const o = this.parameters;
            for (const u in o) o[u] !== void 0 && (e[u] = o[u]);
            return e;
          }
          e.data = {
            attributes: {}
          };
          const t = this.index;
          t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
          });
          const i = this.attributes;
          for (const o in i) {
            const u = i[o];
            e.data.attributes[o] = u.toJSON(e.data);
          }
          const n = {};
          let r = false;
          for (const o in this.morphAttributes) {
            const u = this.morphAttributes[o], c = [];
            for (let h = 0, d = u.length; h < d; h++) {
              const f = u[h];
              c.push(f.toJSON(e.data));
            }
            c.length > 0 && (n[o] = c, r = true);
          }
          r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
          const a = this.groups;
          a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
          const l = this.boundingSphere;
          return l !== null && (e.data.boundingSphere = {
            center: l.center.toArray(),
            radius: l.radius
          }), e;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const t = {};
          this.name = e.name;
          const i = e.index;
          i !== null && this.setIndex(i.clone(t));
          const n = e.attributes;
          for (const u in n) {
            const c = n[u];
            this.setAttribute(u, c.clone(t));
          }
          const r = e.morphAttributes;
          for (const u in r) {
            const c = [], h = r[u];
            for (let d = 0, f = h.length; d < f; d++) c.push(h[d].clone(t));
            this.morphAttributes[u] = c;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const a = e.groups;
          for (let u = 0, c = a.length; u < c; u++) {
            const h = a[u];
            this.addGroup(h.start, h.count, h.materialIndex);
          }
          const l = e.boundingBox;
          l !== null && (this.boundingBox = l.clone());
          const o = e.boundingSphere;
          return o !== null && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      const m_ = new pe(), rr = new Ud(), pc = new Fo(), g_ = new v(), mc = new v(), gc = new v(), yc = new v(), tp = new v(), xc = new v(), y_ = new v(), _c = new v();
      class as extends lt {
        constructor(e = new en(), t = new Fy()) {
          super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes, i = Object.keys(t);
          if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, a = n.length; r < a; r++) {
                const l = n[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = r;
              }
            }
          }
        }
        getVertexPosition(e, t) {
          const i = this.geometry, n = i.attributes.position, r = i.morphAttributes.position, a = i.morphTargetsRelative;
          t.fromBufferAttribute(n, e);
          const l = this.morphTargetInfluences;
          if (r && l) {
            xc.set(0, 0, 0);
            for (let o = 0, u = r.length; o < u; o++) {
              const c = l[o], h = r[o];
              c !== 0 && (tp.fromBufferAttribute(h, e), a ? xc.addScaledVector(tp, c) : xc.addScaledVector(tp.sub(t), c));
            }
            t.add(xc);
          }
          return t;
        }
        raycast(e, t) {
          const i = this.geometry, n = this.material, r = this.matrixWorld;
          n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), pc.copy(i.boundingSphere), pc.applyMatrix4(r), rr.copy(e.ray).recast(e.near), !(pc.containsPoint(rr.origin) === false && (rr.intersectSphere(pc, g_) === null || rr.origin.distanceToSquared(g_) > (e.far - e.near) ** 2)) && (m_.copy(r).invert(), rr.copy(e.ray).applyMatrix4(m_), !(i.boundingBox !== null && rr.intersectsBox(i.boundingBox) === false) && this._computeIntersections(e, t, rr)));
        }
        _computeIntersections(e, t, i) {
          let n;
          const r = this.geometry, a = this.material, l = r.index, o = r.attributes.position, u = r.attributes.uv, c = r.attributes.uv1, h = r.attributes.normal, d = r.groups, f = r.drawRange;
          if (l !== null) if (Array.isArray(a)) for (let p = 0, g = d.length; p < g; p++) {
            const _ = d[p], m = a[_.materialIndex], y = Math.max(_.start, f.start), x = Math.min(l.count, Math.min(_.start + _.count, f.start + f.count));
            for (let b = y, T = x; b < T; b += 3) {
              const N = l.getX(b), A = l.getX(b + 1), w = l.getX(b + 2);
              n = bc(this, m, e, i, u, c, h, N, A, w), n && (n.faceIndex = Math.floor(b / 3), n.face.materialIndex = _.materialIndex, t.push(n));
            }
          }
          else {
            const p = Math.max(0, f.start), g = Math.min(l.count, f.start + f.count);
            for (let _ = p, m = g; _ < m; _ += 3) {
              const y = l.getX(_), x = l.getX(_ + 1), b = l.getX(_ + 2);
              n = bc(this, a, e, i, u, c, h, y, x, b), n && (n.faceIndex = Math.floor(_ / 3), t.push(n));
            }
          }
          else if (o !== void 0) if (Array.isArray(a)) for (let p = 0, g = d.length; p < g; p++) {
            const _ = d[p], m = a[_.materialIndex], y = Math.max(_.start, f.start), x = Math.min(o.count, Math.min(_.start + _.count, f.start + f.count));
            for (let b = y, T = x; b < T; b += 3) {
              const N = b, A = b + 1, w = b + 2;
              n = bc(this, m, e, i, u, c, h, N, A, w), n && (n.faceIndex = Math.floor(b / 3), n.face.materialIndex = _.materialIndex, t.push(n));
            }
          }
          else {
            const p = Math.max(0, f.start), g = Math.min(o.count, f.start + f.count);
            for (let _ = p, m = g; _ < m; _ += 3) {
              const y = _, x = _ + 1, b = _ + 2;
              n = bc(this, a, e, i, u, c, h, y, x, b), n && (n.faceIndex = Math.floor(_ / 3), t.push(n));
            }
          }
        }
      }
      function cC(s, e, t, i, n, r, a, l) {
        let o;
        if (e.side === Fi ? o = i.intersectTriangle(a, r, n, true, l) : o = i.intersectTriangle(n, r, a, e.side === yo, l), o === null) return null;
        _c.copy(l), _c.applyMatrix4(s.matrixWorld);
        const u = t.ray.origin.distanceTo(_c);
        return u < t.near || u > t.far ? null : {
          distance: u,
          point: _c.clone(),
          object: s
        };
      }
      function bc(s, e, t, i, n, r, a, l, o, u) {
        s.getVertexPosition(l, mc), s.getVertexPosition(o, gc), s.getVertexPosition(u, yc);
        const c = cC(s, e, t, i, mc, gc, yc, y_);
        if (c) {
          const h = new v();
          Hi.getBarycoord(y_, mc, gc, yc, h), n && (c.uv = Hi.getInterpolatedAttribute(n, l, o, u, h, new q())), r && (c.uv1 = Hi.getInterpolatedAttribute(r, l, o, u, h, new q())), a && (c.normal = Hi.getInterpolatedAttribute(a, l, o, u, h, new v()), c.normal.dot(i.direction) > 0 && c.normal.multiplyScalar(-1));
          const d = {
            a: l,
            b: o,
            c: u,
            normal: new v(),
            materialIndex: 0
          };
          Hi.getNormal(mc, gc, yc, d.normal), c.face = d, c.barycoord = h;
        }
        return c;
      }
      class Oo extends en {
        constructor(e = 1, t = 1, i = 1, n = 1, r = 1, a = 1) {
          super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
          };
          const l = this;
          n = Math.floor(n), r = Math.floor(r), a = Math.floor(a);
          const o = [], u = [], c = [], h = [];
          let d = 0, f = 0;
          p("z", "y", "x", -1, -1, i, t, e, a, r, 0), p("z", "y", "x", 1, -1, i, t, -e, a, r, 1), p("x", "z", "y", 1, 1, e, i, t, n, a, 2), p("x", "z", "y", 1, -1, e, i, -t, n, a, 3), p("x", "y", "z", 1, -1, e, t, i, n, r, 4), p("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(o), this.setAttribute("position", new Wi(u, 3)), this.setAttribute("normal", new Wi(c, 3)), this.setAttribute("uv", new Wi(h, 2));
          function p(g, _, m, y, x, b, T, N, A, w, k) {
            const G = b / A, I = T / w, be = b / 2, ce = T / 2, Fe = N / 2, qe = A + 1, P = w + 1;
            let W = 0, Y = 0;
            const ne = new v();
            for (let le = 0; le < P; le++) {
              const ht = le * I - ce;
              for (let Oi = 0; Oi < qe; Oi++) {
                const rn = Oi * G - be;
                ne[g] = rn * y, ne[_] = ht * x, ne[m] = Fe, u.push(ne.x, ne.y, ne.z), ne[g] = 0, ne[_] = 0, ne[m] = N > 0 ? 1 : -1, c.push(ne.x, ne.y, ne.z), h.push(Oi / A), h.push(1 - le / w), W += 1;
              }
            }
            for (let le = 0; le < w; le++) for (let ht = 0; ht < A; ht++) {
              const Oi = d + ht + qe * le, rn = d + ht + qe * (le + 1), fs = d + (ht + 1) + qe * (le + 1), tr = d + (ht + 1) + qe * le;
              o.push(Oi, rn, tr), o.push(rn, fs, tr), Y += 6;
            }
            l.addGroup(f, Y, k), f += Y, d += W;
          }
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
          return new Oo(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
      }
      function Fd(s) {
        const e = {};
        for (const t in s) {
          e[t] = {};
          for (const i in s[t]) {
            const n = s[t][i];
            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n;
          }
        }
        return e;
      }
      function hC(s) {
        const e = {};
        for (let t = 0; t < s.length; t++) {
          const i = Fd(s[t]);
          for (const n in i) e[n] = i[n];
        }
        return e;
      }
      function dC(s) {
        const e = [];
        for (let t = 0; t < s.length; t++) e.push(s[t].clone());
        return e;
      }
      const fC = {
        clone: Fd,
        merge: hC
      };
      var pC = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, mC = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class Ov extends Zt {
        constructor(e) {
          super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = pC, this.fragmentShader = mC, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
            clipCullDistance: false,
            multiDraw: false
          }, this.defaultAttributeValues = {
            color: [
              1,
              1,
              1
            ],
            uv: [
              0,
              0
            ],
            uv1: [
              0,
              0
            ]
          }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Fd(e.uniforms), this.uniformsGroups = dC(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          t.glslVersion = this.glslVersion, t.uniforms = {};
          for (const n in this.uniforms) {
            const a = this.uniforms[n].value;
            a && a.isTexture ? t.uniforms[n] = {
              type: "t",
              value: a.toJSON(e).uuid
            } : a && a.isColor ? t.uniforms[n] = {
              type: "c",
              value: a.getHex()
            } : a && a.isVector2 ? t.uniforms[n] = {
              type: "v2",
              value: a.toArray()
            } : a && a.isVector3 ? t.uniforms[n] = {
              type: "v3",
              value: a.toArray()
            } : a && a.isVector4 ? t.uniforms[n] = {
              type: "v4",
              value: a.toArray()
            } : a && a.isMatrix3 ? t.uniforms[n] = {
              type: "m3",
              value: a.toArray()
            } : a && a.isMatrix4 ? t.uniforms[n] = {
              type: "m4",
              value: a.toArray()
            } : t.uniforms[n] = {
              value: a
            };
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
          const i = {};
          for (const n in this.extensions) this.extensions[n] === true && (i[n] = true);
          return Object.keys(i).length > 0 && (t.extensions = i), t;
        }
      }
      class zv extends lt {
        constructor() {
          super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new pe(), this.projectionMatrix = new pe(), this.projectionMatrixInverse = new pe(), this.coordinateSystem = li;
        }
        copy(e, t) {
          return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
        }
        getWorldDirection(e) {
          return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const fn = new v(), x_ = new q(), __ = new q();
      class Ki extends zv {
        constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
          super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(e, t) {
          return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
        }
        setFocalLength(e) {
          const t = 0.5 * this.getFilmHeight() / e;
          this.fov = uu * 2 * Math.atan(t), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(zl * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / e;
        }
        getEffectiveFOV() {
          return uu * 2 * Math.atan(Math.tan(zl * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, i) {
          fn.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(fn.x, fn.y).multiplyScalar(-e / fn.z), fn.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(fn.x, fn.y).multiplyScalar(-e / fn.z);
        }
        getViewSize(e, t) {
          return this.getViewBounds(e, x_, __), t.subVectors(__, x_);
        }
        setViewOffset(e, t, i, n, r, a) {
          this.aspect = e / t, this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = e * Math.tan(zl * 0.5 * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, r = -0.5 * n;
          const a = this.view;
          if (this.view !== null && this.view.enabled) {
            const o = a.fullWidth, u = a.fullHeight;
            r += a.offsetX * n / o, t -= a.offsetY * i / u, n *= a.width / o, i *= a.height / u;
          }
          const l = this.filmOffset;
          l !== 0 && (r += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
        }
      }
      const ha = -90, da = 1;
      class Lv extends lt {
        constructor(e, t, i) {
          super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
          const n = new Ki(ha, da, e, t);
          n.layers = this.layers, this.add(n);
          const r = new Ki(ha, da, e, t);
          r.layers = this.layers, this.add(r);
          const a = new Ki(ha, da, e, t);
          a.layers = this.layers, this.add(a);
          const l = new Ki(ha, da, e, t);
          l.layers = this.layers, this.add(l);
          const o = new Ki(ha, da, e, t);
          o.layers = this.layers, this.add(o);
          const u = new Ki(ha, da, e, t);
          u.layers = this.layers, this.add(u);
        }
        updateCoordinateSystem() {
          const e = this.coordinateSystem, t = this.children.concat(), [i, n, r, a, l, o] = t;
          for (const u of t) this.remove(u);
          if (e === li) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1);
          else if (e === Zn) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1);
          else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
          for (const u of t) this.add(u), u.updateMatrixWorld();
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const { renderTarget: i, activeMipmapLevel: n } = this;
          this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
          const [r, a, l, o, u, c] = this.children, h = e.getRenderTarget(), d = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), p = e.xr.enabled;
          e.xr.enabled = false;
          const g = i.texture.generateMipmaps;
          i.texture.generateMipmaps = false, e.setRenderTarget(i, 0, n), e.render(t, r), e.setRenderTarget(i, 1, n), e.render(t, a), e.setRenderTarget(i, 2, n), e.render(t, l), e.setRenderTarget(i, 3, n), e.render(t, o), e.setRenderTarget(i, 4, n), e.render(t, u), i.texture.generateMipmaps = g, e.setRenderTarget(i, 5, n), e.render(t, c), e.setRenderTarget(h, d, f), e.xr.enabled = p, i.texture.needsPMREMUpdate = true;
        }
      }
      class Oy extends Lt {
        constructor(e, t, i, n, r, a, l, o, u, c) {
          e = e !== void 0 ? e : [], t = t !== void 0 ? t : Fr, super(e, t, i, n, r, a, l, o, u, c), this.isCubeTexture = true, this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class gC extends KR {
        constructor(e = 1, t = {}) {
          super(e, e, t), this.isWebGLCubeRenderTarget = true;
          const i = {
            width: e,
            height: e,
            depth: 1
          }, n = [
            i,
            i,
            i,
            i,
            i,
            i
          ];
          this.texture = new Oy(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : pi;
        }
        fromEquirectangularTexture(e, t) {
          this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
          const i = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          }, n = new Oo(5, 5, 5), r = new Ov({
            name: "CubemapFromEquirect",
            uniforms: Fd(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Fi,
            blending: xo
          });
          r.uniforms.tEquirect.value = t;
          const a = new as(n, r), l = t.minFilter;
          return t.minFilter === Ps && (t.minFilter = pi), new Lv(1, 10, this).update(e, a), t.minFilter = l, a.geometry.dispose(), a.material.dispose(), this;
        }
        clear(e, t, i, n) {
          const r = e.getRenderTarget();
          for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, n);
          e.setRenderTarget(r);
        }
      }
      class zy extends lt {
        constructor() {
          super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new $i(), this.environmentIntensity = 1, this.environmentRotation = new $i(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        copy(e, t) {
          return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
        }
      }
      class Gv {
        constructor(e, t) {
          this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Xh, this.updateRanges = [], this.version = 0, this.uuid = Is();
        }
        onUploadCallback() {
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({
            start: e,
            count: t
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
        }
        copyAt(e, t, i) {
          e *= this.stride, i *= t.stride;
          for (let n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Is()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(e) {
          return this.onUploadCallback = e, this;
        }
        toJSON(e) {
          return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Is()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      }
      const Bt = new v();
      class Ly {
        constructor(e, t, i, n = false) {
          this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.data.count; t < i; t++) Bt.fromBufferAttribute(this, t), Bt.applyMatrix4(e), this.setXYZ(t, Bt.x, Bt.y, Bt.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) Bt.fromBufferAttribute(this, t), Bt.applyNormalMatrix(e), this.setXYZ(t, Bt.x, Bt.y, Bt.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) Bt.fromBufferAttribute(this, t), Bt.transformDirection(e), this.setXYZ(t, Bt.x, Bt.y, Bt.z);
          return this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.data.stride + this.offset + t];
          return this.normalized && (i = Ft(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return this.normalized && (i = K(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
        }
        setX(e, t) {
          return this.normalized && (t = K(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
        }
        setY(e, t) {
          return this.normalized && (t = K(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
        }
        setZ(e, t) {
          return this.normalized && (t = K(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
        }
        setW(e, t) {
          return this.normalized && (t = K(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
        }
        getX(e) {
          let t = this.data.array[e * this.data.stride + this.offset];
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        getY(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 1];
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        getZ(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 2];
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        getW(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 3];
          return this.normalized && (t = Ft(t, this.array)), t;
        }
        setXY(e, t, i) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = K(t, this.array), i = K(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
        }
        setXYZ(e, t, i, n) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = K(t, this.array), i = K(i, this.array), n = K(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
        }
        setXYZW(e, t, i, n, r) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = K(t, this.array), i = K(i, this.array), n = K(n, this.array), r = K(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this;
        }
        clone(e) {
          if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const n = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[n + r]);
            }
            return new Ci(new this.array.constructor(t), this.itemSize, this.normalized);
          } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Ly(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(e) {
          if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const n = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[n + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized
            };
          } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
      class yC extends Zt {
        constructor(e) {
          super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new ie(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
      }
      class Pv extends Lt {
        constructor(e = null, t = 1, i = 1, n, r, a, l, o, u = gt, c = gt, h, d) {
          super(null, a, l, o, u, c, n, r, h, d), this.isDataTexture = true, this.image = {
            data: e,
            width: t,
            height: i
          }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      class cg extends Ci {
        constructor(e, t, i, n = 1) {
          super(e, t, i), this.isInstancedBufferAttribute = true, this.meshPerAttribute = n;
        }
        copy(e) {
          return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
        }
      }
      const fa = new pe(), b_ = new pe(), Sc = [], S_ = new $r(), xC = new pe(), Qo = new as(), Ko = new Fo();
      class _C extends as {
        constructor(e, t, i) {
          super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new cg(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
          for (let n = 0; n < i; n++) this.setMatrixAt(n, xC);
        }
        computeBoundingBox() {
          const e = this.geometry, t = this.count;
          this.boundingBox === null && (this.boundingBox = new $r()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
          for (let i = 0; i < t; i++) this.getMatrixAt(i, fa), S_.copy(e.boundingBox).applyMatrix4(fa), this.boundingBox.union(S_);
        }
        computeBoundingSphere() {
          const e = this.geometry, t = this.count;
          this.boundingSphere === null && (this.boundingSphere = new Fo()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
          for (let i = 0; i < t; i++) this.getMatrixAt(i, fa), Ko.copy(e.boundingSphere).applyMatrix4(fa), this.boundingSphere.union(Ko);
        }
        copy(e, t) {
          return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        getMorphAt(e, t) {
          const i = t.morphTargetInfluences, n = this.morphTexture.source.data.data, r = i.length + 1, a = e * r + 1;
          for (let l = 0; l < i.length; l++) i[l] = n[a + l];
        }
        raycast(e, t) {
          const i = this.matrixWorld, n = this.count;
          if (Qo.geometry = this.geometry, Qo.material = this.material, Qo.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ko.copy(this.boundingSphere), Ko.applyMatrix4(i), e.ray.intersectsSphere(Ko) !== false)) for (let r = 0; r < n; r++) {
            this.getMatrixAt(r, fa), b_.multiplyMatrices(i, fa), Qo.matrixWorld = b_, Qo.raycast(e, Sc);
            for (let a = 0, l = Sc.length; a < l; a++) {
              const o = Sc[a];
              o.instanceId = r, o.object = this, t.push(o);
            }
            Sc.length = 0;
          }
        }
        setColorAt(e, t) {
          this.instanceColor === null && (this.instanceColor = new cg(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        setMorphAt(e, t) {
          const i = t.morphTargetInfluences, n = i.length + 1;
          this.morphTexture === null && (this.morphTexture = new Pv(new Float32Array(n * this.count), n, this.count, Dd, Yt));
          const r = this.morphTexture.source.data.data;
          let a = 0;
          for (let u = 0; u < i.length; u++) a += i[u];
          const l = this.geometry.morphTargetsRelative ? 1 : 1 - a, o = n * e;
          r[o] = l, r.set(i, o + 1);
        }
        updateMorphTargets() {
        }
        dispose() {
          return this.dispatchEvent({
            type: "dispose"
          }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
        }
      }
      const ip = new v(), bC = new v(), SC = new Jt();
      class As {
        constructor(e = new v(1, 0, 0), t = 0) {
          this.isPlane = true, this.normal = e, this.constant = t;
        }
        set(e, t) {
          return this.normal.copy(e), this.constant = t, this;
        }
        setComponents(e, t, i, n) {
          return this.normal.set(e, t, i), this.constant = n, this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
        }
        setFromCoplanarPoints(e, t, i) {
          const n = ip.subVectors(i, t).cross(bC.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(n, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), this.constant = e.constant, this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), this.constant *= e, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
          const i = e.delta(ip), n = this.normal.dot(i);
          if (n === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / n;
          return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
          return t < 0 && i > 0 || i < 0 && t > 0;
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const i = t || SC.getNormalMatrix(e), n = this.coplanarPoint(ip).applyMatrix4(e), r = this.normal.applyMatrix3(i).normalize();
          return this.constant = -n.dot(r), this;
        }
        translate(e) {
          return this.constant -= e.dot(this.normal), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const ar = new Fo(), Tc = new v();
      class kv {
        constructor(e = new As(), t = new As(), i = new As(), n = new As(), r = new As(), a = new As()) {
          this.planes = [
            e,
            t,
            i,
            n,
            r,
            a
          ];
        }
        set(e, t, i, n, r, a) {
          const l = this.planes;
          return l[0].copy(e), l[1].copy(t), l[2].copy(i), l[3].copy(n), l[4].copy(r), l[5].copy(a), this;
        }
        copy(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
          return this;
        }
        setFromProjectionMatrix(e, t = li) {
          const i = this.planes, n = e.elements, r = n[0], a = n[1], l = n[2], o = n[3], u = n[4], c = n[5], h = n[6], d = n[7], f = n[8], p = n[9], g = n[10], _ = n[11], m = n[12], y = n[13], x = n[14], b = n[15];
          if (i[0].setComponents(o - r, d - u, _ - f, b - m).normalize(), i[1].setComponents(o + r, d + u, _ + f, b + m).normalize(), i[2].setComponents(o + a, d + c, _ + p, b + y).normalize(), i[3].setComponents(o - a, d - c, _ - p, b - y).normalize(), i[4].setComponents(o - l, d - h, _ - g, b - x).normalize(), t === li) i[5].setComponents(o + l, d + h, _ + g, b + x).normalize();
          else if (t === Zn) i[5].setComponents(l, h, g, x).normalize();
          else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
          return this;
        }
        intersectsObject(e) {
          if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), ar.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(), ar.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          }
          return this.intersectsSphere(ar);
        }
        intersectsSprite(e) {
          return ar.center.set(0, 0, 0), ar.radius = 0.7071067811865476, ar.applyMatrix4(e.matrixWorld), this.intersectsSphere(ar);
        }
        intersectsSphere(e) {
          const t = this.planes, i = e.center, n = -e.radius;
          for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(i) < n) return false;
          return true;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            const n = t[i];
            if (Tc.x = n.normal.x > 0 ? e.max.x : e.min.x, Tc.y = n.normal.y > 0 ? e.max.y : e.min.y, Tc.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(Tc) < 0) return false;
          }
          return true;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Od extends Zt {
        constructor(e) {
          super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new ie(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
        }
      }
      const Zh = new v(), Qh = new v(), T_ = new pe(), Jo = new Ud(), vc = new Fo(), sp = new v(), v_ = new v();
      class TC extends lt {
        constructor(e = new en(), t = new Od()) {
          super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.index === null) {
            const t = e.attributes.position, i = [
              0
            ];
            for (let n = 1, r = t.count; n < r; n++) Zh.fromBufferAttribute(t, n - 1), Qh.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += Zh.distanceTo(Qh);
            e.setAttribute("lineDistance", new Wi(i, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(e, t) {
          const i = this.geometry, n = this.matrixWorld, r = e.params.Line.threshold, a = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), vc.copy(i.boundingSphere), vc.applyMatrix4(n), vc.radius += r, e.ray.intersectsSphere(vc) === false) return;
          T_.copy(n).invert(), Jo.copy(e.ray).applyMatrix4(T_);
          const l = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = l * l, u = this.isLineSegments ? 2 : 1, c = i.index, d = i.attributes.position;
          if (c !== null) {
            const f = Math.max(0, a.start), p = Math.min(c.count, a.start + a.count);
            for (let g = f, _ = p - 1; g < _; g += u) {
              const m = c.getX(g), y = c.getX(g + 1), x = Mc(this, e, Jo, o, m, y);
              x && t.push(x);
            }
            if (this.isLineLoop) {
              const g = c.getX(p - 1), _ = c.getX(f), m = Mc(this, e, Jo, o, g, _);
              m && t.push(m);
            }
          } else {
            const f = Math.max(0, a.start), p = Math.min(d.count, a.start + a.count);
            for (let g = f, _ = p - 1; g < _; g += u) {
              const m = Mc(this, e, Jo, o, g, g + 1);
              m && t.push(m);
            }
            if (this.isLineLoop) {
              const g = Mc(this, e, Jo, o, p - 1, f);
              g && t.push(g);
            }
          }
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes, i = Object.keys(t);
          if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, a = n.length; r < a; r++) {
                const l = n[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = r;
              }
            }
          }
        }
      }
      function Mc(s, e, t, i, n, r) {
        const a = s.geometry.attributes.position;
        if (Zh.fromBufferAttribute(a, n), Qh.fromBufferAttribute(a, r), t.distanceSqToSegment(Zh, Qh, sp, v_) > i) return;
        sp.applyMatrix4(s.matrixWorld);
        const o = e.ray.origin.distanceTo(sp);
        if (!(o < e.near || o > e.far)) return {
          distance: o,
          point: v_.clone().applyMatrix4(s.matrixWorld),
          index: n,
          face: null,
          faceIndex: null,
          barycoord: null,
          object: s
        };
      }
      const M_ = new v(), A_ = new v();
      class vC extends TC {
        constructor(e, t) {
          super(e, t), this.isLineSegments = true, this.type = "LineSegments";
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.index === null) {
            const t = e.attributes.position, i = [];
            for (let n = 0, r = t.count; n < r; n += 2) M_.fromBufferAttribute(t, n), A_.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + M_.distanceTo(A_);
            e.setAttribute("lineDistance", new Wi(i, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class MC extends Zt {
        constructor(e) {
          super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new ie(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
      }
      class AC extends Lt {
        constructor(e, t) {
          super({
            width: e,
            height: t
          }), this.isFramebufferTexture = true, this.magFilter = gt, this.minFilter = gt, this.generateMipmaps = false, this.needsUpdate = true;
        }
      }
      class zo extends Lt {
        constructor(e, t, i, n, r, a, l, o, u, c = Nr) {
          if (c !== Nr && c !== To) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          i === void 0 && c === Nr && (i = Tt), i === void 0 && c === To && (i = Fu), super(null, n, r, a, l, o, c, i, u), this.isDepthTexture = true, this.image = {
            width: e,
            height: t
          }, this.magFilter = l !== void 0 ? l : gt, this.minFilter = o !== void 0 ? o : gt, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
        }
        copy(e) {
          return super.copy(e), this.compareFunction = e.compareFunction, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
        }
      }
      class zd extends en {
        constructor(e = 1, t = 32, i = 16, n = 0, r = Math.PI * 2, a = 0, l = Math.PI) {
          super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: a,
            thetaLength: l
          }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
          const o = Math.min(a + l, Math.PI);
          let u = 0;
          const c = [], h = new v(), d = new v(), f = [], p = [], g = [], _ = [];
          for (let m = 0; m <= i; m++) {
            const y = [], x = m / i;
            let b = 0;
            m === 0 && a === 0 ? b = 0.5 / t : m === i && o === Math.PI && (b = -0.5 / t);
            for (let T = 0; T <= t; T++) {
              const N = T / t;
              h.x = -e * Math.cos(n + N * r) * Math.sin(a + x * l), h.y = e * Math.cos(a + x * l), h.z = e * Math.sin(n + N * r) * Math.sin(a + x * l), p.push(h.x, h.y, h.z), d.copy(h).normalize(), g.push(d.x, d.y, d.z), _.push(N + b, 1 - x), y.push(u++);
            }
            c.push(y);
          }
          for (let m = 0; m < i; m++) for (let y = 0; y < t; y++) {
            const x = c[m][y + 1], b = c[m][y], T = c[m + 1][y], N = c[m + 1][y + 1];
            (m !== 0 || a > 0) && f.push(x, b, N), (m !== i - 1 || o < Math.PI) && f.push(b, T, N);
          }
          this.setIndex(f), this.setAttribute("position", new Wi(p, 3)), this.setAttribute("normal", new Wi(g, 3)), this.setAttribute("uv", new Wi(_, 2));
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
          return new zd(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
        }
      }
      class NC extends Zt {
        constructor(e) {
          super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new ie(0), this.transparent = true, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
        }
      }
      class Gy extends Zt {
        constructor(e) {
          super(), this.isMeshStandardMaterial = true, this.type = "MeshStandardMaterial", this.defines = {
            STANDARD: ""
          }, this.color = new ie(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ie(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xn, this.normalScale = new q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $i(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.defines = {
            STANDARD: ""
          }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class wC extends Gy {
        constructor(e) {
          super(), this.isMeshPhysicalMaterial = true, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new q(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
              return ee(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(t) {
              this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
            }
          }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
            100,
            400
          ], this.iridescenceThicknessMap = null, this.sheenColor = new ie(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ie(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ie(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(e) {
          this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e) {
          this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
        }
        get dispersion() {
          return this._dispersion;
        }
        set dispersion(e) {
          this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
        }
        copy(e) {
          return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
            ...e.iridescenceThicknessRange
          ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
        }
      }
      class EC extends Zt {
        constructor(e) {
          super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new ie(16777215), this.specular = new ie(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ie(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xn, this.normalScale = new q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $i(), this.combine = Bd, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class RC extends Zt {
        constructor(e) {
          super(), this.isMeshToonMaterial = true, this.defines = {
            TOON: ""
          }, this.type = "MeshToonMaterial", this.color = new ie(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ie(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xn, this.normalScale = new q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
      }
      class CC extends Zt {
        constructor(e) {
          super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xn, this.normalScale = new q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
        }
      }
      class BC extends Zt {
        constructor(e) {
          super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new ie(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ie(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xn, this.normalScale = new q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $i(), this.combine = Bd, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class DC extends Zt {
        constructor(e) {
          super(), this.isMeshMatcapMaterial = true, this.defines = {
            MATCAP: ""
          }, this.type = "MeshMatcapMaterial", this.color = new ie(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Xn, this.normalScale = new q(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.defines = {
            MATCAP: ""
          }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class UC extends Od {
        constructor(e) {
          super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
        }
      }
      class Xr extends lt {
        constructor(e, t = 1) {
          super(), this.isLight = true, this.type = "Light", this.color = new ie(e), this.intensity = t;
        }
        dispose() {
        }
        copy(e, t) {
          return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
        }
      }
      class FC extends Xr {
        constructor(e, t, i) {
          super(e, i), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(lt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new ie(t);
        }
        copy(e, t) {
          return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
        }
      }
      const np = new pe(), N_ = new v(), w_ = new v();
      class Py {
        constructor(e) {
          this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new q(512, 512), this.map = null, this.mapPass = null, this.matrix = new pe(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new kv(), this._frameExtents = new q(1, 1), this._viewportCount = 1, this._viewports = [
            new Te(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera, i = this.matrix;
          N_.setFromMatrixPosition(e.matrixWorld), t.position.copy(N_), w_.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(w_), t.updateMatrixWorld(), np.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(np), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(np);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
        }
      }
      class OC extends Py {
        constructor() {
          super(new Ki(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
        }
        updateMatrices(e) {
          const t = this.camera, i = uu * 2 * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
          (i !== t.fov || n !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), this.focus = e.focus, this;
        }
      }
      class Iv extends Xr {
        constructor(e, t, i = 0, n = Math.PI / 3, r = 0, a = 2) {
          super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(lt.DEFAULT_UP), this.updateMatrix(), this.target = new lt(), this.distance = i, this.angle = n, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new OC();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
      }
      const E_ = new pe(), el = new v(), rp = new v();
      class zC extends Py {
        constructor() {
          super(new Ki(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new q(4, 2), this._viewportCount = 6, this._viewports = [
            new Te(2, 1, 1, 1),
            new Te(0, 1, 1, 1),
            new Te(3, 1, 1, 1),
            new Te(1, 1, 1, 1),
            new Te(3, 0, 1, 1),
            new Te(1, 0, 1, 1)
          ], this._cubeDirections = [
            new v(1, 0, 0),
            new v(-1, 0, 0),
            new v(0, 0, 1),
            new v(0, 0, -1),
            new v(0, 1, 0),
            new v(0, -1, 0)
          ], this._cubeUps = [
            new v(0, 1, 0),
            new v(0, 1, 0),
            new v(0, 1, 0),
            new v(0, 1, 0),
            new v(0, 0, 1),
            new v(0, 0, -1)
          ];
        }
        updateMatrices(e, t = 0) {
          const i = this.camera, n = this.matrix, r = e.distance || i.far;
          r !== i.far && (i.far = r, i.updateProjectionMatrix()), el.setFromMatrixPosition(e.matrixWorld), i.position.copy(el), rp.copy(i.position), rp.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(rp), i.updateMatrixWorld(), n.makeTranslation(-el.x, -el.y, -el.z), E_.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(E_);
        }
      }
      class LC extends Xr {
        constructor(e, t, i = 0, n = 2) {
          super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new zC();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
        }
      }
      class ky extends zv {
        constructor(e = -1, t = 1, i = 1, n = -1, r = 0.1, a = 2e3) {
          super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = a, this.updateProjectionMatrix();
        }
        copy(e, t) {
          return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
        }
        setViewOffset(e, t, i, n, r, a) {
          this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
          let r = i - e, a = i + e, l = n + t, o = n - t;
          if (this.view !== null && this.view.enabled) {
            const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += u * this.view.offsetX, a = r + u * this.view.width, l -= c * this.view.offsetY, o = l - c * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(r, a, l, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
        }
      }
      class GC extends Py {
        constructor() {
          super(new ky(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
        }
      }
      class Vv extends Xr {
        constructor(e, t) {
          super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(lt.DEFAULT_UP), this.updateMatrix(), this.target = new lt(), this.shadow = new GC();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
      }
      class Hv extends Xr {
        constructor(e, t) {
          super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
        }
      }
      class PC extends Xr {
        constructor(e, t, i = 10, n = 10) {
          super(e, t), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = i, this.height = n;
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(e) {
          this.intensity = e / (this.width * this.height * Math.PI);
        }
        copy(e) {
          return super.copy(e), this.width = e.width, this.height = e.height, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.width = this.width, t.object.height = this.height, t;
        }
      }
      class kC {
        constructor() {
          this.isSphericalHarmonics3 = true, this.coefficients = [];
          for (let e = 0; e < 9; e++) this.coefficients.push(new v());
        }
        set(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
          return this;
        }
        zero() {
          for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
          return this;
        }
        getAt(e, t) {
          const i = e.x, n = e.y, r = e.z, a = this.coefficients;
          return t.copy(a[0]).multiplyScalar(0.282095), t.addScaledVector(a[1], 0.488603 * n), t.addScaledVector(a[2], 0.488603 * r), t.addScaledVector(a[3], 0.488603 * i), t.addScaledVector(a[4], 1.092548 * (i * n)), t.addScaledVector(a[5], 1.092548 * (n * r)), t.addScaledVector(a[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(a[7], 1.092548 * (i * r)), t.addScaledVector(a[8], 0.546274 * (i * i - n * n)), t;
        }
        getIrradianceAt(e, t) {
          const i = e.x, n = e.y, r = e.z, a = this.coefficients;
          return t.copy(a[0]).multiplyScalar(0.886227), t.addScaledVector(a[1], 2 * 0.511664 * n), t.addScaledVector(a[2], 2 * 0.511664 * r), t.addScaledVector(a[3], 2 * 0.511664 * i), t.addScaledVector(a[4], 2 * 0.429043 * i * n), t.addScaledVector(a[5], 2 * 0.429043 * n * r), t.addScaledVector(a[6], 0.743125 * r * r - 0.247708), t.addScaledVector(a[7], 2 * 0.429043 * i * r), t.addScaledVector(a[8], 0.429043 * (i * i - n * n)), t;
        }
        add(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
          return this;
        }
        addScaledSH(e, t) {
          for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(e.coefficients[i], t);
          return this;
        }
        scale(e) {
          for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
          return this;
        }
        lerp(e, t) {
          for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
          return this;
        }
        equals(e) {
          for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return false;
          return true;
        }
        copy(e) {
          return this.set(e.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
          const i = this.coefficients;
          for (let n = 0; n < 9; n++) i[n].fromArray(e, t + n * 3);
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.coefficients;
          for (let n = 0; n < 9; n++) i[n].toArray(e, t + n * 3);
          return e;
        }
        static getBasisAt(e, t) {
          const i = e.x, n = e.y, r = e.z;
          t[0] = 0.282095, t[1] = 0.488603 * n, t[2] = 0.488603 * r, t[3] = 0.488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * i * r, t[8] = 0.546274 * (i * i - n * n);
        }
      }
      class IC extends Xr {
        constructor(e = new kC(), t = 1) {
          super(void 0, t), this.isLightProbe = true, this.sh = e;
        }
        copy(e) {
          return super.copy(e), this.sh.copy(e.sh), this;
        }
        fromJSON(e) {
          return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.sh = this.sh.toArray(), t;
        }
      }
      class VC extends Gv {
        constructor(e, t, i = 1) {
          super(e, t), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = i;
        }
        copy(e) {
          return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        clone(e) {
          const t = super.clone(e);
          return t.meshPerAttribute = this.meshPerAttribute, t;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.isInstancedInterleavedBuffer = true, t.meshPerAttribute = this.meshPerAttribute, t;
        }
      }
      const R_ = new pe();
      class HC {
        constructor(e, t, i = 0, n = 1 / 0) {
          this.ray = new Ud(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new Cv(), this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(e, t) {
          this.ray.set(e, t);
        }
        setFromCamera(e, t) {
          t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
        }
        setFromXRController(e) {
          return R_.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(R_), this;
        }
        intersectObject(e, t = true, i = []) {
          return hg(e, this, i, t), i.sort(C_), i;
        }
        intersectObjects(e, t = true, i = []) {
          for (let n = 0, r = e.length; n < r; n++) hg(e[n], this, i, t);
          return i.sort(C_), i;
        }
      }
      function C_(s, e) {
        return s.distance - e.distance;
      }
      function hg(s, e, t, i) {
        let n = true;
        if (s.layers.test(e.layers) && s.raycast(e, t) === false && (n = false), n === true && i === true) {
          const r = s.children;
          for (let a = 0, l = r.length; a < l; a++) hg(r[a], e, t, true);
        }
      }
      class B_ {
        constructor(e = 1, t = 0, i = 0) {
          return this.radius = e, this.phi = t, this.theta = i, this;
        }
        set(e, t, i) {
          return this.radius = e, this.phi = t, this.theta = i, this;
        }
        copy(e) {
          return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
        }
        makeSafe() {
          return this.phi = ee(this.phi, 1e-6, Math.PI - 1e-6), this;
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, i) {
          return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(ee(t / this.radius, -1, 1))), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class qC extends jr {
        constructor(e, t = null) {
          super(), this.object = e, this.domElement = t, this.enabled = true, this.state = -1, this.keys = {}, this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
          }, this.touches = {
            ONE: null,
            TWO: null
          };
        }
        connect() {
        }
        disconnect() {
        }
        dispose() {
        }
        update() {
        }
      }
      typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: Cd
        }
      }));
      typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Cd);
      const YC = [
        "alphaMap",
        "alphaTest",
        "anisotropy",
        "anisotropyMap",
        "anisotropyRotation",
        "aoMap",
        "attenuationColor",
        "attenuationDistance",
        "bumpMap",
        "clearcoat",
        "clearcoatMap",
        "clearcoatNormalMap",
        "clearcoatNormalScale",
        "clearcoatRoughness",
        "color",
        "dispersion",
        "displacementMap",
        "emissive",
        "emissiveMap",
        "envMap",
        "gradientMap",
        "ior",
        "iridescence",
        "iridescenceIOR",
        "iridescenceMap",
        "iridescenceThicknessMap",
        "lightMap",
        "map",
        "matcap",
        "metalness",
        "metalnessMap",
        "normalMap",
        "normalScale",
        "opacity",
        "roughness",
        "roughnessMap",
        "sheen",
        "sheenColor",
        "sheenColorMap",
        "sheenRoughnessMap",
        "shininess",
        "specular",
        "specularColor",
        "specularColorMap",
        "specularIntensity",
        "specularIntensityMap",
        "specularMap",
        "thickness",
        "transmission",
        "transmissionMap"
      ];
      class WC {
        constructor(e) {
          this.renderObjects = /* @__PURE__ */ new WeakMap(), this.hasNode = this.containsNode(e), this.hasAnimation = e.object.isSkinnedMesh === true, this.refreshUniforms = YC, this.renderId = 0;
        }
        firstInitialization(e) {
          return this.renderObjects.has(e) === false ? (this.getRenderObjectData(e), true) : false;
        }
        getRenderObjectData(e) {
          let t = this.renderObjects.get(e);
          if (t === void 0) {
            const { geometry: i, material: n, object: r } = e;
            if (t = {
              material: this.getMaterialData(n),
              geometry: {
                attributes: this.getAttributesData(i.attributes),
                indexVersion: i.index ? i.index.version : null,
                drawRange: {
                  start: i.drawRange.start,
                  count: i.drawRange.count
                }
              },
              worldMatrix: r.matrixWorld.clone()
            }, r.center && (t.center = r.center.clone()), r.morphTargetInfluences && (t.morphTargetInfluences = r.morphTargetInfluences.slice()), e.bundle !== null && (t.version = e.bundle.version), t.material.transmission > 0) {
              const { width: a, height: l } = e.context;
              t.bufferWidth = a, t.bufferHeight = l;
            }
            this.renderObjects.set(e, t);
          }
          return t;
        }
        getAttributesData(e) {
          const t = {};
          for (const i in e) {
            const n = e[i];
            t[i] = {
              version: n.version
            };
          }
          return t;
        }
        containsNode(e) {
          const t = e.material;
          for (const i in t) if (t[i] && t[i].isNode) return true;
          return e.renderer.nodes.modelViewMatrix !== null || e.renderer.nodes.modelNormalViewMatrix !== null;
        }
        getMaterialData(e) {
          const t = {};
          for (const i of this.refreshUniforms) {
            const n = e[i];
            n != null && (typeof n == "object" && n.clone !== void 0 ? n.isTexture === true ? t[i] = {
              id: n.id,
              version: n.version
            } : t[i] = n.clone() : t[i] = n);
          }
          return t;
        }
        equals(e) {
          const { object: t, material: i, geometry: n } = e, r = this.getRenderObjectData(e);
          if (r.worldMatrix.equals(t.matrixWorld) !== true) return r.worldMatrix.copy(t.matrixWorld), false;
          const a = r.material;
          for (const g in a) {
            const _ = a[g], m = i[g];
            if (_.equals !== void 0) {
              if (_.equals(m) === false) return _.copy(m), false;
            } else if (m.isTexture === true) {
              if (_.id !== m.id || _.version !== m.version) return _.id = m.id, _.version = m.version, false;
            } else if (_ !== m) return a[g] = m, false;
          }
          if (a.transmission > 0) {
            const { width: g, height: _ } = e.context;
            if (r.bufferWidth !== g || r.bufferHeight !== _) return r.bufferWidth = g, r.bufferHeight = _, false;
          }
          const l = r.geometry, o = n.attributes, u = l.attributes, c = Object.keys(u), h = Object.keys(o);
          if (c.length !== h.length) return r.geometry.attributes = this.getAttributesData(o), false;
          for (const g of c) {
            const _ = u[g], m = o[g];
            if (m === void 0) return delete u[g], false;
            if (_.version !== m.version) return _.version = m.version, false;
          }
          const d = n.index, f = l.indexVersion, p = d ? d.version : null;
          if (f !== p) return l.indexVersion = p, false;
          if (l.drawRange.start !== n.drawRange.start || l.drawRange.count !== n.drawRange.count) return l.drawRange.start = n.drawRange.start, l.drawRange.count = n.drawRange.count, false;
          if (r.morphTargetInfluences) {
            let g = false;
            for (let _ = 0; _ < r.morphTargetInfluences.length; _++) r.morphTargetInfluences[_] !== t.morphTargetInfluences[_] && (g = true);
            if (g) return true;
          }
          return r.center && r.center.equals(t.center) === false ? (r.center.copy(t.center), true) : (e.bundle !== null && (r.version = e.bundle.version), true);
        }
        needsRefresh(e, t) {
          if (this.hasNode || this.hasAnimation || this.firstInitialization(e)) return true;
          const { renderId: i } = t;
          if (this.renderId !== i) return this.renderId = i, true;
          const n = e.object.static === true, r = e.bundle !== null && e.bundle.static === true && this.getRenderObjectData(e).version === e.bundle.version;
          return n || r ? false : this.equals(e) !== true;
        }
      }
      function cu(s, e = 0) {
        let t = 3735928559 ^ e, i = 1103547991 ^ e;
        if (s instanceof Array) for (let n = 0, r; n < s.length; n++) r = s[n], t = Math.imul(t ^ r, 2654435761), i = Math.imul(i ^ r, 1597334677);
        else for (let n = 0, r; n < s.length; n++) r = s.charCodeAt(n), t = Math.imul(t ^ r, 2654435761), i = Math.imul(i ^ r, 1597334677);
        return t = Math.imul(t ^ t >>> 16, 2246822507), t ^= Math.imul(i ^ i >>> 13, 3266489909), i = Math.imul(i ^ i >>> 16, 2246822507), i ^= Math.imul(t ^ t >>> 13, 3266489909), 4294967296 * (2097151 & i) + (t >>> 0);
      }
      const jC = (s) => cu(s), Iy = (s) => cu(s), Vy = (...s) => cu(s);
      function qv(s, e = false) {
        const t = [];
        s.isNode === true && (t.push(s.id), s = s.getSelf());
        for (const { property: i, childNode: n } of Kh(s)) t.push(t, cu(i.slice(0, -4)), n.getCacheKey(e));
        return cu(t);
      }
      function* Kh(s, e = false) {
        for (const t in s) {
          if (t.startsWith("_") === true) continue;
          const i = s[t];
          if (Array.isArray(i) === true) for (let n = 0; n < i.length; n++) {
            const r = i[n];
            r && (r.isNode === true || e && typeof r.toJSON == "function") && (yield {
              property: t,
              index: n,
              childNode: r
            });
          }
          else if (i && i.isNode === true) yield {
            property: t,
            childNode: i
          };
          else if (typeof i == "object") for (const n in i) {
            const r = i[n];
            r && (r.isNode === true || e && typeof r.toJSON == "function") && (yield {
              property: t,
              index: n,
              childNode: r
            });
          }
        }
      }
      const $C = /* @__PURE__ */ new Map([
        [
          1,
          "float"
        ],
        [
          2,
          "vec2"
        ],
        [
          3,
          "vec3"
        ],
        [
          4,
          "vec4"
        ],
        [
          9,
          "mat3"
        ],
        [
          16,
          "mat4"
        ]
      ]), D_ = /* @__PURE__ */ new WeakMap();
      function XC(s) {
        return $C.get(s);
      }
      function Jh(s) {
        if (s == null) return null;
        const e = typeof s;
        return s.isNode === true ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : s.isVector2 === true ? "vec2" : s.isVector3 === true ? "vec3" : s.isVector4 === true ? "vec4" : s.isMatrix3 === true ? "mat3" : s.isMatrix4 === true ? "mat4" : s.isColor === true ? "color" : s instanceof ArrayBuffer ? "ArrayBuffer" : null;
      }
      function Yv(s, ...e) {
        const t = s ? s.slice(-4) : void 0;
        return e.length === 1 && (t === "vec2" ? e = [
          e[0],
          e[0]
        ] : t === "vec3" ? e = [
          e[0],
          e[0],
          e[0]
        ] : t === "vec4" && (e = [
          e[0],
          e[0],
          e[0],
          e[0]
        ])), s === "color" ? new ie(...e) : t === "vec2" ? new q(...e) : t === "vec3" ? new v(...e) : t === "vec4" ? new Te(...e) : t === "mat3" ? new Jt(...e) : t === "mat4" ? new pe(...e) : s === "bool" ? e[0] || false : s === "float" || s === "int" || s === "uint" ? e[0] || 0 : s === "string" ? e[0] || "" : s === "ArrayBuffer" ? QC(e[0]) : null;
      }
      function Wv(s) {
        let e = D_.get(s);
        return e === void 0 && (e = {}, D_.set(s, e)), e;
      }
      function ZC(s) {
        let e = "";
        const t = new Uint8Array(s);
        for (let i = 0; i < t.length; i++) e += String.fromCharCode(t[i]);
        return btoa(e);
      }
      function QC(s) {
        return Uint8Array.from(atob(s), (e) => e.charCodeAt(0)).buffer;
      }
      const U_ = {
        VERTEX: "vertex",
        FRAGMENT: "fragment"
      }, te = {
        NONE: "none",
        FRAME: "frame",
        RENDER: "render",
        OBJECT: "object"
      }, Ls = {
        READ_ONLY: "readOnly",
        WRITE_ONLY: "writeOnly",
        READ_WRITE: "readWrite"
      }, KC = [
        "fragment",
        "vertex"
      ], F_ = [
        "setup",
        "analyze",
        "generate"
      ], O_ = [
        ...KC,
        "compute"
      ], Lo = [
        "x",
        "y",
        "z",
        "w"
      ];
      let JC = 0;
      class Q extends jr {
        static get type() {
          return "Node";
        }
        constructor(e = null) {
          super(), this.nodeType = e, this.updateType = te.NONE, this.updateBeforeType = te.NONE, this.updateAfterType = te.NONE, this.uuid = Ev.generateUUID(), this.version = 0, this.global = false, this.isNode = true, this._cacheKey = null, this._cacheKeyVersion = 0, Object.defineProperty(this, "id", {
            value: JC++
          });
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        get type() {
          return this.constructor.type;
        }
        onUpdate(e, t) {
          return this.updateType = t, this.update = e.bind(this.getSelf()), this;
        }
        onFrameUpdate(e) {
          return this.onUpdate(e, te.FRAME);
        }
        onRenderUpdate(e) {
          return this.onUpdate(e, te.RENDER);
        }
        onObjectUpdate(e) {
          return this.onUpdate(e, te.OBJECT);
        }
        onReference(e) {
          return this.updateReference = e.bind(this.getSelf()), this;
        }
        getSelf() {
          return this.self || this;
        }
        updateReference() {
          return this;
        }
        isGlobal() {
          return this.global;
        }
        *getChildren() {
          for (const { childNode: e } of Kh(this)) yield e;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        traverse(e) {
          e(this);
          for (const t of this.getChildren()) t.traverse(e);
        }
        getCacheKey(e = false) {
          return e = e || this.version !== this._cacheKeyVersion, (e === true || this._cacheKey === null) && (this._cacheKey = Vy(qv(this, e), this.customCacheKey()), this._cacheKeyVersion = this.version), this._cacheKey;
        }
        customCacheKey() {
          return 0;
        }
        getScope() {
          return this;
        }
        getHash() {
          return this.uuid;
        }
        getUpdateType() {
          return this.updateType;
        }
        getUpdateBeforeType() {
          return this.updateBeforeType;
        }
        getUpdateAfterType() {
          return this.updateAfterType;
        }
        getElementType(e) {
          const t = this.getNodeType(e);
          return e.getElementType(t);
        }
        getNodeType(e) {
          const t = e.getNodeProperties(this);
          return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
        }
        getShared(e) {
          const t = this.getHash(e);
          return e.getNodeFromHash(t) || this;
        }
        setup(e) {
          const t = e.getNodeProperties(this);
          let i = 0;
          for (const n of this.getChildren()) t["node" + i++] = n;
          return t.outputNode || null;
        }
        analyze(e) {
          if (e.increaseUsage(this) === 1) {
            const i = e.getNodeProperties(this);
            for (const n of Object.values(i)) n && n.isNode === true && n.build(e);
          }
        }
        generate(e, t) {
          const { outputNode: i } = e.getNodeProperties(this);
          if (i && i.isNode === true) return i.build(e, t);
        }
        updateBefore() {
          console.warn("Abstract function.");
        }
        updateAfter() {
          console.warn("Abstract function.");
        }
        update() {
          console.warn("Abstract function.");
        }
        build(e, t = null) {
          const i = this.getShared(e);
          if (this !== i) return i.build(e, t);
          e.addNode(this), e.addChain(this);
          let n = null;
          const r = e.getBuildStage();
          if (r === "setup") {
            this.updateReference(e);
            const a = e.getNodeProperties(this);
            if (a.initialized !== true) {
              a.initialized = true;
              const l = this.setup(e), o = l && l.isNode === true;
              for (const u of Object.values(a)) u && u.isNode === true && u.build(e);
              o && l.build(e), a.outputNode = l;
            }
          } else if (r === "analyze") this.analyze(e);
          else if (r === "generate") if (this.generate.length === 1) {
            const l = this.getNodeType(e), o = e.getDataFromNode(this);
            n = o.snippet, n === void 0 ? (n = this.generate(e) || "", o.snippet = n) : o.flowCodes !== void 0 && e.context.nodeBlock !== void 0 && e.addFlowCodeHierarchy(this, e.context.nodeBlock), n = e.format(n, l, t);
          } else n = this.generate(e, t) || "";
          return e.removeChain(this), e.addSequentialNode(this), n;
        }
        getSerializeChildren() {
          return Kh(this);
        }
        serialize(e) {
          const t = this.getSerializeChildren(), i = {};
          for (const { property: n, index: r, childNode: a } of t) r !== void 0 ? (i[n] === void 0 && (i[n] = Number.isInteger(r) ? [] : {}), i[n][r] = a.toJSON(e.meta).uuid) : i[n] = a.toJSON(e.meta).uuid;
          Object.keys(i).length > 0 && (e.inputNodes = i);
        }
        deserialize(e) {
          if (e.inputNodes !== void 0) {
            const t = e.meta.nodes;
            for (const i in e.inputNodes) if (Array.isArray(e.inputNodes[i])) {
              const n = [];
              for (const r of e.inputNodes[i]) n.push(t[r]);
              this[i] = n;
            } else if (typeof e.inputNodes[i] == "object") {
              const n = {};
              for (const r in e.inputNodes[i]) {
                const a = e.inputNodes[i][r];
                n[r] = t[a];
              }
              this[i] = n;
            } else {
              const n = e.inputNodes[i];
              this[i] = t[n];
            }
          }
        }
        toJSON(e) {
          const { uuid: t, type: i } = this, n = e === void 0 || typeof e == "string";
          n && (e = {
            textures: {},
            images: {},
            nodes: {}
          });
          let r = e.nodes[t];
          r === void 0 && (r = {
            uuid: t,
            type: i,
            meta: e,
            metadata: {
              version: 4.6,
              type: "Node",
              generator: "Node.toJSON"
            }
          }, n !== true && (e.nodes[r.uuid] = r), this.serialize(r), delete r.meta);
          function a(l) {
            const o = [];
            for (const u in l) {
              const c = l[u];
              delete c.metadata, o.push(c);
            }
            return o;
          }
          if (n) {
            const l = a(e.textures), o = a(e.images), u = a(e.nodes);
            l.length > 0 && (r.textures = l), o.length > 0 && (r.images = o), u.length > 0 && (r.nodes = u);
          }
          return r;
        }
      }
      class Ou extends Q {
        static get type() {
          return "ArrayElementNode";
        }
        constructor(e, t) {
          super(), this.node = e, this.indexNode = t, this.isArrayElementNode = true;
        }
        getNodeType(e) {
          return this.node.getElementType(e);
        }
        generate(e) {
          const t = this.node.build(e), i = this.indexNode.build(e, "uint");
          return `${t}[ ${i} ]`;
        }
      }
      class jv extends Q {
        static get type() {
          return "ConvertNode";
        }
        constructor(e, t) {
          super(), this.node = e, this.convertTo = t;
        }
        getNodeType(e) {
          const t = this.node.getNodeType(e);
          let i = null;
          for (const n of this.convertTo.split("|")) (i === null || e.getTypeLength(t) === e.getTypeLength(n)) && (i = n);
          return i;
        }
        serialize(e) {
          super.serialize(e), e.convertTo = this.convertTo;
        }
        deserialize(e) {
          super.deserialize(e), this.convertTo = e.convertTo;
        }
        generate(e, t) {
          const i = this.node, n = this.getNodeType(e), r = i.build(e, n);
          return e.format(r, n, t);
        }
      }
      class ct extends Q {
        static get type() {
          return "TempNode";
        }
        constructor(e = null) {
          super(e), this.isTempNode = true;
        }
        hasDependencies(e) {
          return e.getDataFromNode(this).usageCount > 1;
        }
        build(e, t) {
          if (e.getBuildStage() === "generate") {
            const n = e.getVectorType(this.getNodeType(e, t)), r = e.getDataFromNode(this);
            if (r.propertyName !== void 0) return e.format(r.propertyName, n, t);
            if (n !== "void" && t !== "void" && this.hasDependencies(e)) {
              const a = super.build(e, n), l = e.getVarFromNode(this, null, n), o = e.getPropertyName(l);
              return e.addLineFlowCode(`${o} = ${a}`, this), r.snippet = a, r.propertyName = o, e.format(r.propertyName, n, t);
            }
          }
          return super.build(e, t);
        }
      }
      class eB extends ct {
        static get type() {
          return "JoinNode";
        }
        constructor(e = [], t = null) {
          super(t), this.nodes = e;
        }
        getNodeType(e) {
          return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((t, i) => t + e.getTypeLength(i.getNodeType(e)), 0));
        }
        generate(e, t) {
          const i = this.getNodeType(e), n = this.nodes, r = e.getComponentType(i), a = [];
          for (const o of n) {
            let u = o.build(e);
            const c = e.getComponentType(o.getNodeType(e));
            c !== r && (u = e.format(u, c, r)), a.push(u);
          }
          const l = `${e.getType(i)}( ${a.join(", ")} )`;
          return e.format(l, i, t);
        }
      }
      const tB = Lo.join("");
      class z_ extends Q {
        static get type() {
          return "SplitNode";
        }
        constructor(e, t = "x") {
          super(), this.node = e, this.components = t, this.isSplitNode = true;
        }
        getVectorLength() {
          let e = this.components.length;
          for (const t of this.components) e = Math.max(Lo.indexOf(t) + 1, e);
          return e;
        }
        getComponentType(e) {
          return e.getComponentType(this.node.getNodeType(e));
        }
        getNodeType(e) {
          return e.getTypeFromLength(this.components.length, this.getComponentType(e));
        }
        generate(e, t) {
          const i = this.node, n = e.getTypeLength(i.getNodeType(e));
          let r = null;
          if (n > 1) {
            let a = null;
            this.getVectorLength() >= n && (a = e.getTypeFromLength(this.getVectorLength(), this.getComponentType(e)));
            const o = i.build(e, a);
            this.components.length === n && this.components === tB.slice(0, this.components.length) ? r = e.format(o, a, t) : r = e.format(`${o}.${this.components}`, this.getNodeType(e), t);
          } else r = i.build(e, t);
          return r;
        }
        serialize(e) {
          super.serialize(e), e.components = this.components;
        }
        deserialize(e) {
          super.deserialize(e), this.components = e.components;
        }
      }
      class iB extends ct {
        static get type() {
          return "SetNode";
        }
        constructor(e, t, i) {
          super(), this.sourceNode = e, this.components = t, this.targetNode = i;
        }
        getNodeType(e) {
          return this.sourceNode.getNodeType(e);
        }
        generate(e) {
          const { sourceNode: t, components: i, targetNode: n } = this, r = this.getNodeType(e), a = e.getComponentType(n.getNodeType(e)), l = e.getTypeFromLength(i.length, a), o = n.build(e, l), u = t.build(e, r), c = e.getTypeLength(r), h = [];
          for (let d = 0; d < c; d++) {
            const f = Lo[d];
            f === i[0] ? (h.push(o), d += i.length - 1) : h.push(u + "." + f);
          }
          return `${e.getType(r)}( ${h.join(", ")} )`;
        }
      }
      class sB extends ct {
        static get type() {
          return "FlipNode";
        }
        constructor(e, t) {
          super(), this.sourceNode = e, this.components = t;
        }
        getNodeType(e) {
          return this.sourceNode.getNodeType(e);
        }
        generate(e) {
          const { components: t, sourceNode: i } = this, n = this.getNodeType(e), r = i.build(e), a = e.getVarFromNode(this), l = e.getPropertyName(a);
          e.addLineFlowCode(l + " = " + r, this);
          const o = e.getTypeLength(n), u = [];
          let c = 0;
          for (let h = 0; h < o; h++) {
            const d = Lo[h];
            d === t[c] ? (u.push("1.0 - " + (l + "." + d)), c++) : u.push(l + "." + d);
          }
          return `${e.getType(n)}( ${u.join(", ")} )`;
        }
      }
      class Hy extends Q {
        static get type() {
          return "InputNode";
        }
        constructor(e, t = null) {
          super(t), this.isInputNode = true, this.value = e, this.precision = null;
        }
        getNodeType() {
          return this.nodeType === null ? Jh(this.value) : this.nodeType;
        }
        getInputType(e) {
          return this.getNodeType(e);
        }
        setPrecision(e) {
          return this.precision = e, this;
        }
        serialize(e) {
          super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = Jh(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = ZC(e.value)), e.precision = this.precision;
        }
        deserialize(e) {
          super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? Yv(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
        }
        generate() {
          console.warn("Abstract function.");
        }
      }
      class tn extends Hy {
        static get type() {
          return "ConstNode";
        }
        constructor(e, t = null) {
          super(e, t), this.isConstNode = true;
        }
        generateConst(e) {
          return e.generateConst(this.getNodeType(e), this.value);
        }
        generate(e, t) {
          const i = this.getNodeType(e);
          return e.format(this.generateConst(e), i, t);
        }
      }
      let vo = null;
      const Pa = /* @__PURE__ */ new Map();
      function R(s, e) {
        if (Pa.has(s)) {
          console.warn(`Redefinition of method chaining ${s}`);
          return;
        }
        if (typeof e != "function") throw new Error(`Node element ${s} is not a function`);
        Pa.set(s, e);
      }
      const $v = (s) => s.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), L_ = (s) => $v(s).split("").sort().join(""), Xv = {
        setup(s, e) {
          const t = e.shift();
          return s(Pd(t), ...e);
        },
        get(s, e, t) {
          if (typeof e == "string" && s[e] === void 0) {
            if (s.isStackNode !== true && e === "assign") return (...i) => (vo.assign(t, ...i), t);
            if (Pa.has(e)) {
              const i = Pa.get(e);
              return s.isStackNode ? (...n) => t.add(i(...n)) : (...n) => i(t, ...n);
            } else {
              if (e === "self") return s;
              if (e.endsWith("Assign") && Pa.has(e.slice(0, e.length - 6))) {
                const i = Pa.get(e.slice(0, e.length - 6));
                return s.isStackNode ? (...n) => t.assign(n[0], i(...n)) : (...n) => t.assign(i(t, ...n));
              } else {
                if (/^[xyzwrgbastpq]{1,4}$/.test(e) === true) return e = $v(e), F(new z_(t, e));
                if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === true) return e = L_(e.slice(3).toLowerCase()), (i) => F(new iB(s, e, i));
                if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(e) === true) return e = L_(e.slice(4).toLowerCase()), () => F(new sB(F(s), e));
                if (e === "width" || e === "height" || e === "depth") return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), F(new z_(s, e));
                if (/^\d+$/.test(e) === true) return F(new Ou(t, new tn(Number(e), "uint")));
              }
            }
          }
          return Reflect.get(s, e, t);
        },
        set(s, e, t, i) {
          return typeof e == "string" && s[e] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(e) === true || e === "width" || e === "height" || e === "depth" || /^\d+$/.test(e) === true) ? (i[e].assign(t), true) : Reflect.set(s, e, t, i);
        }
      }, ap = /* @__PURE__ */ new WeakMap(), G_ = /* @__PURE__ */ new WeakMap(), nB = function(s, e = null) {
        const t = Jh(s);
        if (t === "node") {
          let i = ap.get(s);
          return i === void 0 && (i = new Proxy(s, Xv), ap.set(s, i), ap.set(i, i)), i;
        } else {
          if (e === null && (t === "float" || t === "boolean") || t && t !== "shader" && t !== "string") return F(dg(s, e));
          if (t === "shader") return O(s);
        }
        return s;
      }, rB = function(s, e = null) {
        for (const t in s) s[t] = F(s[t], e);
        return s;
      }, aB = function(s, e = null) {
        const t = s.length;
        for (let i = 0; i < t; i++) s[i] = F(s[i], e);
        return s;
      }, oB = function(s, e = null, t = null, i = null) {
        const n = (r) => F(i !== null ? Object.assign(r, i) : r);
        return e === null ? (...r) => n(new s(...io(r))) : t !== null ? (t = F(t), (...r) => n(new s(e, ...io(r), t))) : (...r) => n(new s(e, ...io(r)));
      }, lB = function(s, ...e) {
        return F(new s(...io(e)));
      };
      class uB extends Q {
        constructor(e, t) {
          super(), this.shaderNode = e, this.inputNodes = t;
        }
        getNodeType(e) {
          return this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e);
        }
        call(e) {
          const { shaderNode: t, inputNodes: i } = this, n = e.getNodeProperties(t);
          if (n.onceOutput) return n.onceOutput;
          let r = null;
          if (t.layout) {
            let a = G_.get(e.constructor);
            a === void 0 && (a = /* @__PURE__ */ new WeakMap(), G_.set(e.constructor, a));
            let l = a.get(t);
            l === void 0 && (l = F(e.buildFunctionNode(t)), a.set(t, l)), e.currentFunctionNode !== null && e.currentFunctionNode.includes.push(l), r = F(l.call(i));
          } else {
            const a = t.jsFunc, l = i !== null ? a(i, e) : a(e);
            r = F(l);
          }
          return t.once && (n.onceOutput = r), r;
        }
        getOutputNode(e) {
          const t = e.getNodeProperties(this);
          return t.outputNode === null && (t.outputNode = this.setupOutput(e)), t.outputNode;
        }
        setup(e) {
          return this.getOutputNode(e);
        }
        setupOutput(e) {
          return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
        }
        generate(e, t) {
          return this.getOutputNode(e).build(e, t);
        }
      }
      class cB extends Q {
        constructor(e, t) {
          super(t), this.jsFunc = e, this.layout = null, this.global = true, this.once = false;
        }
        setLayout(e) {
          return this.layout = e, this;
        }
        call(e = null) {
          return Pd(e), F(new uB(this, e));
        }
        setup() {
          return this.call();
        }
      }
      const hB = [
        false,
        true
      ], dB = [
        0,
        1,
        2,
        3
      ], fB = [
        -1,
        -2
      ], Zv = [
        0.5,
        1.5,
        1 / 3,
        1e-6,
        1e6,
        Math.PI,
        Math.PI * 2,
        1 / Math.PI,
        2 / Math.PI,
        1 / (Math.PI * 2),
        Math.PI / 2
      ], qy = /* @__PURE__ */ new Map();
      for (const s of hB) qy.set(s, new tn(s));
      const Yy = /* @__PURE__ */ new Map();
      for (const s of dB) Yy.set(s, new tn(s, "uint"));
      const Wy = new Map([
        ...Yy
      ].map((s) => new tn(s.value, "int")));
      for (const s of fB) Wy.set(s, new tn(s, "int"));
      const Ld = new Map([
        ...Wy
      ].map((s) => new tn(s.value)));
      for (const s of Zv) Ld.set(s, new tn(s));
      for (const s of Zv) Ld.set(-s, new tn(-s));
      const Gd = {
        bool: qy,
        uint: Yy,
        ints: Wy,
        float: Ld
      }, P_ = new Map([
        ...qy,
        ...Ld
      ]), dg = (s, e) => P_.has(s) ? P_.get(s) : s.isNode === true ? s : new tn(s, e), pB = (s) => {
        try {
          return s.getNodeType();
        } catch {
          return;
        }
      }, it = function(s, e = null) {
        return (...t) => {
          if ((t.length === 0 || ![
            "bool",
            "float",
            "int",
            "uint"
          ].includes(s) && t.every((n) => typeof n != "object")) && (t = [
            Yv(s, ...t)
          ]), t.length === 1 && e !== null && e.has(t[0])) return F(e.get(t[0]));
          if (t.length === 1) {
            const n = dg(t[0], s);
            return pB(n) === s ? F(n) : F(new jv(n, s));
          }
          const i = t.map((n) => dg(n));
          return F(new eB(i, s));
        };
      }, k_ = (s) => typeof s == "object" && s !== null ? s.value : s, mB = (s) => s != null ? s.nodeType || s.convertTo || (typeof s == "string" ? s : null) : null;
      function nh(s, e) {
        return new Proxy(new cB(s, e), Xv);
      }
      const F = (s, e = null) => nB(s, e), Pd = (s, e = null) => new rB(s, e), io = (s, e = null) => new aB(s, e), U = (...s) => new oB(...s), z = (...s) => new lB(...s), O = (s, e) => {
        const t = new nh(s, e), i = (...n) => {
          let r;
          return Pd(n), n[0] && n[0].isNode ? r = [
            ...n
          ] : r = n[0], t.call(r);
        };
        return i.shaderNode = t, i.setLayout = (n) => (t.setLayout(n), i), i.once = () => (t.once = true, i), i;
      };
      R("toGlobal", (s) => (s.global = true, s));
      const ed = (s) => {
        vo = s;
      }, Qv = () => vo, et = (...s) => vo.If(...s);
      function gB(s) {
        return vo && vo.add(s), s;
      }
      R("append", gB);
      const yB = new it("color"), C = new it("float", Gd.float), He = new it("int", Gd.ints), xB = new it("uint", Gd.uint), Kv = new it("bool", Gd.bool), L = new it("vec2"), Ns = new it("ivec2"), _B = new it("uvec2"), bB = new it("bvec2"), B = new it("vec3"), SB = new it("ivec3"), TB = new it("uvec3"), vB = new it("bvec3"), X = new it("vec4"), MB = new it("ivec4"), AB = new it("uvec4"), NB = new it("bvec4"), jy = new it("mat2"), Gt = new it("mat3"), so = new it("mat4");
      R("toColor", yB);
      R("toFloat", C);
      R("toInt", He);
      R("toUint", xB);
      R("toBool", Kv);
      R("toVec2", L);
      R("toIVec2", Ns);
      R("toUVec2", _B);
      R("toBVec2", bB);
      R("toVec3", B);
      R("toIVec3", SB);
      R("toUVec3", TB);
      R("toBVec3", vB);
      R("toVec4", X);
      R("toIVec4", MB);
      R("toUVec4", AB);
      R("toBVec4", NB);
      R("toMat2", jy);
      R("toMat3", Gt);
      R("toMat4", so);
      const wB = U(Ou), EB = (s, e) => F(new jv(F(s), e));
      R("element", wB);
      R("convert", EB);
      class Jv extends Q {
        static get type() {
          return "UniformGroupNode";
        }
        constructor(e, t = false, i = 1) {
          super("string"), this.name = e, this.shared = t, this.order = i, this.isUniformGroup = true;
        }
        serialize(e) {
          super.serialize(e), e.name = this.name, e.version = this.version, e.shared = this.shared;
        }
        deserialize(e) {
          super.deserialize(e), this.name = e.name, this.version = e.version, this.shared = e.shared;
        }
      }
      const RB = (s) => new Jv(s), eM = (s, e = 0) => new Jv(s, true, e), CB = eM("frame"), $ = eM("render"), tM = RB("object");
      class zu extends Hy {
        static get type() {
          return "UniformNode";
        }
        constructor(e, t = null) {
          super(e, t), this.isUniformNode = true, this.name = "", this.groupNode = tM;
        }
        label(e) {
          return this.name = e, this;
        }
        setGroup(e) {
          return this.groupNode = e, this;
        }
        getGroup() {
          return this.groupNode;
        }
        getUniformHash(e) {
          return this.getHash(e);
        }
        onUpdate(e, t) {
          const i = this.getSelf();
          return e = e.bind(i), super.onUpdate((n) => {
            const r = e(n, i);
            r !== void 0 && (this.value = r);
          }, t);
        }
        generate(e, t) {
          const i = this.getNodeType(e), n = this.getUniformHash(e);
          let r = e.getNodeFromHash(n);
          r === void 0 && (e.setHashNode(this, n), r = this);
          const a = r.getInputType(e), l = e.getUniformFromNode(r, a, e.shaderStage, this.name || e.context.label), o = e.getPropertyName(l);
          return e.context.label !== void 0 && delete e.context.label, e.format(o, i, t);
        }
      }
      const Z = (s, e) => {
        const t = mB(e || s), i = s && s.isNode === true ? s.node && s.node.value || s.value : s;
        return F(new zu(i, t));
      };
      class _e extends Q {
        static get type() {
          return "PropertyNode";
        }
        constructor(e, t = null, i = false) {
          super(e), this.name = t, this.varying = i, this.isPropertyNode = true;
        }
        getHash(e) {
          return this.name || super.getHash(e);
        }
        isGlobal() {
          return true;
        }
        generate(e) {
          let t;
          return this.varying === true ? (t = e.getVaryingFromNode(this, this.name), t.needsInterpolation = true) : t = e.getVarFromNode(this, this.name), e.getPropertyName(t);
        }
      }
      const BB = (s, e) => F(new _e(s, e)), td = (s, e) => F(new _e(s, e, true)), ye = z(_e, "vec4", "DiffuseColor"), I_ = z(_e, "vec3", "EmissiveColor"), Bs = z(_e, "float", "Roughness"), id = z(_e, "float", "Metalness"), fg = z(_e, "float", "Clearcoat"), sd = z(_e, "float", "ClearcoatRoughness"), ka = z(_e, "vec3", "Sheen"), $y = z(_e, "float", "SheenRoughness"), Xy = z(_e, "float", "Iridescence"), iM = z(_e, "float", "IridescenceIOR"), sM = z(_e, "float", "IridescenceThickness"), pg = z(_e, "float", "AlphaT"), hr = z(_e, "float", "Anisotropy"), rh = z(_e, "vec3", "AnisotropyT"), no = z(_e, "vec3", "AnisotropyB"), ri = z(_e, "color", "SpecularColor"), nd = z(_e, "float", "SpecularF90"), mg = z(_e, "float", "Shininess"), rd = z(_e, "vec4", "Output"), op = z(_e, "float", "dashSize"), V_ = z(_e, "float", "gapSize"), ah = z(_e, "float", "IOR"), gg = z(_e, "float", "Transmission"), nM = z(_e, "float", "Thickness"), rM = z(_e, "float", "AttenuationDistance"), aM = z(_e, "color", "AttenuationColor"), oM = z(_e, "float", "Dispersion");
      class DB extends ct {
        static get type() {
          return "AssignNode";
        }
        constructor(e, t) {
          super(), this.targetNode = e, this.sourceNode = t;
        }
        hasDependencies() {
          return false;
        }
        getNodeType(e, t) {
          return t !== "void" ? this.targetNode.getNodeType(e) : "void";
        }
        needsSplitAssign(e) {
          const { targetNode: t } = this;
          if (e.isAvailable("swizzleAssign") === false && t.isSplitNode && t.components.length > 1) {
            const i = e.getTypeLength(t.node.getNodeType(e));
            return Lo.join("").slice(0, i) !== t.components;
          }
          return false;
        }
        generate(e, t) {
          const { targetNode: i, sourceNode: n } = this, r = this.needsSplitAssign(e), a = i.getNodeType(e), l = i.context({
            assign: true
          }).build(e), o = n.build(e, a), u = n.getNodeType(e), c = e.getDataFromNode(this);
          let h;
          if (c.initialized === true) t !== "void" && (h = l);
          else if (r) {
            const d = e.getVarFromNode(this, null, a), f = e.getPropertyName(d);
            e.addLineFlowCode(`${f} = ${o}`, this);
            const p = i.node.context({
              assign: true
            }).build(e);
            for (let g = 0; g < i.components.length; g++) {
              const _ = i.components[g];
              e.addLineFlowCode(`${p}.${_} = ${f}[ ${g} ]`, this);
            }
            t !== "void" && (h = l);
          } else h = `${l} = ${o}`, (t === "void" || u === "void") && (e.addLineFlowCode(h, this), t !== "void" && (h = l));
          return c.initialized = true, e.format(h, a, t);
        }
      }
      const UB = U(DB);
      R("assign", UB);
      class FB extends ct {
        static get type() {
          return "FunctionCallNode";
        }
        constructor(e = null, t = {}) {
          super(), this.functionNode = e, this.parameters = t;
        }
        setParameters(e) {
          return this.parameters = e, this;
        }
        getParameters() {
          return this.parameters;
        }
        getNodeType(e) {
          return this.functionNode.getNodeType(e);
        }
        generate(e) {
          const t = [], i = this.functionNode, n = i.getInputs(e), r = this.parameters, a = (o, u) => {
            const c = u.type, h = c === "pointer";
            let d;
            return h ? d = "&" + o.build(e) : d = o.build(e, c), d;
          };
          if (Array.isArray(r)) for (let o = 0; o < r.length; o++) t.push(a(r[o], n[o]));
          else for (const o of n) {
            const u = r[o.name];
            if (u !== void 0) t.push(a(u, o));
            else throw new Error(`FunctionCallNode: Input '${o.name}' not found in FunctionNode.`);
          }
          return `${i.build(e, "property")}( ${t.join(", ")} )`;
        }
      }
      const OB = (s, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === true ? io(e) : Pd(e[0]), F(new FB(F(s), e)));
      R("call", OB);
      class ze extends ct {
        static get type() {
          return "OperatorNode";
        }
        constructor(e, t, i, ...n) {
          if (super(), n.length > 0) {
            let r = new ze(e, t, i);
            for (let a = 0; a < n.length - 1; a++) r = new ze(e, r, n[a]);
            t = r, i = n[n.length - 1];
          }
          this.op = e, this.aNode = t, this.bNode = i;
        }
        getNodeType(e, t) {
          const i = this.op, n = this.aNode, r = this.bNode, a = n.getNodeType(e), l = typeof r < "u" ? r.getNodeType(e) : null;
          if (a === "void" || l === "void") return "void";
          if (i === "%") return a;
          if (i === "~" || i === "&" || i === "|" || i === "^" || i === ">>" || i === "<<") return e.getIntegerType(a);
          if (i === "!" || i === "==" || i === "&&" || i === "||" || i === "^^") return "bool";
          if (i === "<" || i === ">" || i === "<=" || i === ">=") {
            const o = t ? e.getTypeLength(t) : Math.max(e.getTypeLength(a), e.getTypeLength(l));
            return o > 1 ? `bvec${o}` : "bool";
          } else return a === "float" && e.isMatrix(l) ? l : e.isMatrix(a) && e.isVector(l) ? e.getVectorFromMatrix(a) : e.isVector(a) && e.isMatrix(l) ? e.getVectorFromMatrix(l) : e.getTypeLength(l) > e.getTypeLength(a) ? l : a;
        }
        generate(e, t) {
          const i = this.op, n = this.aNode, r = this.bNode, a = this.getNodeType(e, t);
          let l = null, o = null;
          a !== "void" ? (l = n.getNodeType(e), o = typeof r < "u" ? r.getNodeType(e) : null, i === "<" || i === ">" || i === "<=" || i === ">=" || i === "==" ? e.isVector(l) ? o = l : l !== o && (l = o = "float") : i === ">>" || i === "<<" ? (l = a, o = e.changeComponentType(o, "uint")) : e.isMatrix(l) && e.isVector(o) ? o = e.getVectorFromMatrix(l) : e.isVector(l) && e.isMatrix(o) ? l = e.getVectorFromMatrix(o) : l = o = a) : l = o = a;
          const u = n.build(e, l), c = typeof r < "u" ? r.build(e, o) : null, h = e.getTypeLength(t), d = e.getFunctionOperator(i);
          if (t !== "void") return i === "<" && h > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThan", t)}( ${u}, ${c} )`, a, t) : e.format(`( ${u} < ${c} )`, a, t) : i === "<=" && h > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("lessThanEqual", t)}( ${u}, ${c} )`, a, t) : e.format(`( ${u} <= ${c} )`, a, t) : i === ">" && h > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThan", t)}( ${u}, ${c} )`, a, t) : e.format(`( ${u} > ${c} )`, a, t) : i === ">=" && h > 1 ? e.useComparisonMethod ? e.format(`${e.getMethod("greaterThanEqual", t)}( ${u}, ${c} )`, a, t) : e.format(`( ${u} >= ${c} )`, a, t) : i === "!" || i === "~" ? e.format(`(${i}${u})`, l, t) : d ? e.format(`${d}( ${u}, ${c} )`, a, t) : e.format(`( ${u} ${i} ${c} )`, a, t);
          if (l !== "void") return d ? e.format(`${d}( ${u}, ${c} )`, a, t) : e.format(`${u} ${i} ${c}`, a, t);
        }
        serialize(e) {
          super.serialize(e), e.op = this.op;
        }
        deserialize(e) {
          super.deserialize(e), this.op = e.op;
        }
      }
      const Pt = U(ze, "+"), qt = U(ze, "-"), ae = U(ze, "*"), Xs = U(ze, "/"), lM = U(ze, "%"), zB = U(ze, "=="), LB = U(ze, "!="), GB = U(ze, "<"), PB = U(ze, ">"), kB = U(ze, "<="), IB = U(ze, ">="), VB = U(ze, "&&"), HB = U(ze, "||"), qB = U(ze, "!"), YB = U(ze, "^^"), WB = U(ze, "&"), jB = U(ze, "~"), $B = U(ze, "|"), XB = U(ze, "^"), ZB = U(ze, "<<"), QB = U(ze, ">>");
      R("add", Pt);
      R("sub", qt);
      R("mul", ae);
      R("div", Xs);
      R("modInt", lM);
      R("equal", zB);
      R("notEqual", LB);
      R("lessThan", GB);
      R("greaterThan", PB);
      R("lessThanEqual", kB);
      R("greaterThanEqual", IB);
      R("and", VB);
      R("or", HB);
      R("not", qB);
      R("xor", YB);
      R("bitAnd", WB);
      R("bitNot", jB);
      R("bitOr", $B);
      R("bitXor", XB);
      R("shiftLeft", ZB);
      R("shiftRight", QB);
      const KB = (...s) => (console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt()."), lM(...s));
      R("remainder", KB);
      class M extends ct {
        static get type() {
          return "MathNode";
        }
        constructor(e, t, i = null, n = null) {
          super(), this.method = e, this.aNode = t, this.bNode = i, this.cNode = n;
        }
        getInputType(e) {
          const t = this.aNode.getNodeType(e), i = this.bNode ? this.bNode.getNodeType(e) : null, n = this.cNode ? this.cNode.getNodeType(e) : null, r = e.isMatrix(t) ? 0 : e.getTypeLength(t), a = e.isMatrix(i) ? 0 : e.getTypeLength(i), l = e.isMatrix(n) ? 0 : e.getTypeLength(n);
          return r > a && r > l ? t : a > l ? i : l > r ? n : t;
        }
        getNodeType(e) {
          const t = this.method;
          return t === M.LENGTH || t === M.DISTANCE || t === M.DOT ? "float" : t === M.CROSS ? "vec3" : t === M.ALL ? "bool" : t === M.EQUALS ? e.changeComponentType(this.aNode.getNodeType(e), "bool") : t === M.MOD ? this.aNode.getNodeType(e) : this.getInputType(e);
        }
        generate(e, t) {
          let i = this.method;
          const n = this.getNodeType(e), r = this.getInputType(e), a = this.aNode, l = this.bNode, o = this.cNode, u = e.renderer.coordinateSystem;
          if (i === M.TRANSFORM_DIRECTION) {
            let c = a, h = l;
            e.isMatrix(c.getNodeType(e)) ? h = X(B(h), 0) : c = X(B(c), 0);
            const d = ae(c, h).xyz;
            return du(d).build(e, t);
          } else {
            if (i === M.NEGATE) return e.format("( - " + a.build(e, r) + " )", n, t);
            if (i === M.ONE_MINUS) return qt(1, a).build(e, t);
            if (i === M.RECIPROCAL) return Xs(1, a).build(e, t);
            if (i === M.DIFFERENCE) return Mi(qt(a, l)).build(e, t);
            {
              const c = [];
              return i === M.CROSS || i === M.MOD ? c.push(a.build(e, n), l.build(e, n)) : u === li && i === M.STEP ? c.push(a.build(e, e.getTypeLength(a.getNodeType(e)) === 1 ? "float" : r), l.build(e, r)) : u === li && (i === M.MIN || i === M.MAX) || i === M.MOD ? c.push(a.build(e, r), l.build(e, e.getTypeLength(l.getNodeType(e)) === 1 ? "float" : r)) : i === M.REFRACT ? c.push(a.build(e, r), l.build(e, r), o.build(e, "float")) : i === M.MIX ? c.push(a.build(e, r), l.build(e, r), o.build(e, e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : r)) : (u === Zn && i === M.ATAN && l !== null && (i = "atan2"), c.push(a.build(e, r)), l !== null && c.push(l.build(e, r)), o !== null && c.push(o.build(e, r))), e.format(`${e.getMethod(i, n)}( ${c.join(", ")} )`, n, t);
            }
          }
        }
        serialize(e) {
          super.serialize(e), e.method = this.method;
        }
        deserialize(e) {
          super.deserialize(e), this.method = e.method;
        }
      }
      M.ALL = "all";
      M.ANY = "any";
      M.RADIANS = "radians";
      M.DEGREES = "degrees";
      M.EXP = "exp";
      M.EXP2 = "exp2";
      M.LOG = "log";
      M.LOG2 = "log2";
      M.SQRT = "sqrt";
      M.INVERSE_SQRT = "inversesqrt";
      M.FLOOR = "floor";
      M.CEIL = "ceil";
      M.NORMALIZE = "normalize";
      M.FRACT = "fract";
      M.SIN = "sin";
      M.COS = "cos";
      M.TAN = "tan";
      M.ASIN = "asin";
      M.ACOS = "acos";
      M.ATAN = "atan";
      M.ABS = "abs";
      M.SIGN = "sign";
      M.LENGTH = "length";
      M.NEGATE = "negate";
      M.ONE_MINUS = "oneMinus";
      M.DFDX = "dFdx";
      M.DFDY = "dFdy";
      M.ROUND = "round";
      M.RECIPROCAL = "reciprocal";
      M.TRUNC = "trunc";
      M.FWIDTH = "fwidth";
      M.TRANSPOSE = "transpose";
      M.BITCAST = "bitcast";
      M.EQUALS = "equals";
      M.MIN = "min";
      M.MAX = "max";
      M.MOD = "mod";
      M.STEP = "step";
      M.REFLECT = "reflect";
      M.DISTANCE = "distance";
      M.DIFFERENCE = "difference";
      M.DOT = "dot";
      M.CROSS = "cross";
      M.POW = "pow";
      M.TRANSFORM_DIRECTION = "transformDirection";
      M.MIX = "mix";
      M.CLAMP = "clamp";
      M.REFRACT = "refract";
      M.SMOOTHSTEP = "smoothstep";
      M.FACEFORWARD = "faceforward";
      const JB = C(1e-6), e3 = C(Math.PI), uM = U(M, M.ALL), t3 = U(M, M.ANY), i3 = U(M, M.RADIANS), s3 = U(M, M.DEGREES), cM = U(M, M.EXP), hu = U(M, M.EXP2), hM = U(M, M.LOG), Hs = U(M, M.LOG2), Zy = U(M, M.SQRT), n3 = U(M, M.INVERSE_SQRT), wr = U(M, M.FLOOR), Qy = U(M, M.CEIL), du = U(M, M.NORMALIZE), Jn = U(M, M.FRACT), Vi = U(M, M.SIN), _n = U(M, M.COS), r3 = U(M, M.TAN), a3 = U(M, M.ASIN), o3 = U(M, M.ACOS), dM = U(M, M.ATAN), Mi = U(M, M.ABS), ad = U(M, M.SIGN), Hn = U(M, M.LENGTH), l3 = U(M, M.NEGATE), u3 = U(M, M.ONE_MINUS), fM = U(M, M.DFDX), pM = U(M, M.DFDY), c3 = U(M, M.ROUND), h3 = U(M, M.RECIPROCAL), d3 = U(M, M.TRUNC), f3 = U(M, M.FWIDTH), p3 = U(M, M.TRANSPOSE);
      M.BITCAST;
      const m3 = U(M, M.EQUALS), fu = U(M, M.MIN), Qt = U(M, M.MAX), mM = U(M, M.MOD), gM = U(M, M.STEP), g3 = U(M, M.REFLECT), y3 = U(M, M.DISTANCE), x3 = U(M, M.DIFFERENCE), Ky = U(M, M.DOT), yM = U(M, M.CROSS), kd = U(M, M.POW), xM = U(M, M.POW, 2), _3 = U(M, M.POW, 3), b3 = U(M, M.POW, 4), S3 = U(M, M.TRANSFORM_DIRECTION), T3 = (s) => ae(ad(s), kd(Mi(s), 1 / 3)), v3 = (s) => Ky(s, s), Ce = U(M, M.MIX), Zs = (s, e = 0, t = 1) => F(new M(M.CLAMP, F(s), F(e), F(t))), M3 = (s) => Zs(s), _M = U(M, M.REFRACT), Gr = U(M, M.SMOOTHSTEP), A3 = U(M, M.FACEFORWARD), N3 = O(([s]) => {
        const i = 43758.5453, n = Ky(s.xy, L(12.9898, 78.233)), r = mM(n, e3);
        return Jn(Vi(r).mul(i));
      }), w3 = (s, e, t) => Ce(e, t, s), E3 = (s, e, t) => Gr(e, t, s), R3 = (s, e) => (console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.'), dM(s, e));
      R("all", uM);
      R("any", t3);
      R("equals", m3);
      R("radians", i3);
      R("degrees", s3);
      R("exp", cM);
      R("exp2", hu);
      R("log", hM);
      R("log2", Hs);
      R("sqrt", Zy);
      R("inverseSqrt", n3);
      R("floor", wr);
      R("ceil", Qy);
      R("normalize", du);
      R("fract", Jn);
      R("sin", Vi);
      R("cos", _n);
      R("tan", r3);
      R("asin", a3);
      R("acos", o3);
      R("atan", dM);
      R("abs", Mi);
      R("sign", ad);
      R("length", Hn);
      R("lengthSq", v3);
      R("negate", l3);
      R("oneMinus", u3);
      R("dFdx", fM);
      R("dFdy", pM);
      R("round", c3);
      R("reciprocal", h3);
      R("trunc", d3);
      R("fwidth", f3);
      R("atan2", R3);
      R("min", fu);
      R("max", Qt);
      R("mod", mM);
      R("step", gM);
      R("reflect", g3);
      R("distance", y3);
      R("dot", Ky);
      R("cross", yM);
      R("pow", kd);
      R("pow2", xM);
      R("pow3", _3);
      R("pow4", b3);
      R("transformDirection", S3);
      R("mix", w3);
      R("clamp", Zs);
      R("refract", _M);
      R("smoothstep", E3);
      R("faceForward", A3);
      R("difference", x3);
      R("saturate", M3);
      R("cbrt", T3);
      R("transpose", p3);
      R("rand", N3);
      class C3 extends Q {
        static get type() {
          return "ConditionalNode";
        }
        constructor(e, t, i = null) {
          super(), this.condNode = e, this.ifNode = t, this.elseNode = i;
        }
        getNodeType(e) {
          const { ifNode: t, elseNode: i } = e.getNodeProperties(this);
          if (t === void 0) return this.setup(e), this.getNodeType(e);
          const n = t.getNodeType(e);
          if (i !== null) {
            const r = i.getNodeType(e);
            if (e.getTypeLength(r) > e.getTypeLength(n)) return r;
          }
          return n;
        }
        setup(e) {
          const t = this.condNode.cache(), i = this.ifNode.cache(), n = this.elseNode ? this.elseNode.cache() : null, r = e.context.nodeBlock;
          e.getDataFromNode(i).parentNodeBlock = r, n !== null && (e.getDataFromNode(n).parentNodeBlock = r);
          const a = e.getNodeProperties(this);
          a.condNode = t, a.ifNode = i.context({
            nodeBlock: i
          }), a.elseNode = n ? n.context({
            nodeBlock: n
          }) : null;
        }
        generate(e, t) {
          const i = this.getNodeType(e), n = e.getDataFromNode(this);
          if (n.nodeProperty !== void 0) return n.nodeProperty;
          const { condNode: r, ifNode: a, elseNode: l } = e.getNodeProperties(this), o = t !== "void", u = o ? BB(i).build(e) : "";
          n.nodeProperty = u;
          const c = r.build(e, "bool");
          e.addFlowCode(`
${e.tab}if ( ${c} ) {

`).addFlowTab();
          let h = a.build(e, i);
          if (h && (o ? h = u + " = " + h + ";" : h = "return " + h + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + h + `

` + e.tab + "}"), l !== null) {
            e.addFlowCode(` else {

`).addFlowTab();
            let d = l.build(e, i);
            d && (o ? d = u + " = " + d + ";" : d = "return " + d + ";"), e.removeFlowTab().addFlowCode(e.tab + "	" + d + `

` + e.tab + `}

`);
          } else e.addFlowCode(`

`);
          return e.format(u, i, t);
        }
      }
      const Wt = U(C3);
      R("select", Wt);
      const B3 = (...s) => (console.warn("TSL.ConditionalNode: cond() has been renamed to select()."), Wt(...s));
      R("cond", B3);
      class bM extends Q {
        static get type() {
          return "ContextNode";
        }
        constructor(e, t = {}) {
          super(), this.isContextNode = true, this.node = e, this.value = t;
        }
        getScope() {
          return this.node.getScope();
        }
        getNodeType(e) {
          return this.node.getNodeType(e);
        }
        analyze(e) {
          this.node.build(e);
        }
        setup(e) {
          const t = e.getContext();
          e.setContext({
            ...e.context,
            ...this.value
          });
          const i = this.node.build(e);
          return e.setContext(t), i;
        }
        generate(e, t) {
          const i = e.getContext();
          e.setContext({
            ...e.context,
            ...this.value
          });
          const n = this.node.build(e, t);
          return e.setContext(i), n;
        }
      }
      const Jy = U(bM), D3 = (s, e) => Jy(s, {
        label: e
      });
      R("context", Jy);
      R("label", D3);
      class oh extends Q {
        static get type() {
          return "VarNode";
        }
        constructor(e, t = null) {
          super(), this.node = e, this.name = t, this.global = true, this.isVarNode = true;
        }
        getHash(e) {
          return this.name || super.getHash(e);
        }
        getNodeType(e) {
          return this.node.getNodeType(e);
        }
        generate(e) {
          const { node: t, name: i } = this, n = e.getVarFromNode(this, i, e.getVectorType(this.getNodeType(e))), r = e.getPropertyName(n), a = t.build(e, n.type);
          return e.addLineFlowCode(`${r} = ${a}`, this), r;
        }
      }
      const SM = U(oh);
      R("toVar", (...s) => SM(...s).append());
      const U3 = (s) => (console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.'), SM(s));
      R("temp", U3);
      class F3 extends Q {
        static get type() {
          return "VaryingNode";
        }
        constructor(e, t = null) {
          super(), this.node = e, this.name = t, this.isVaryingNode = true;
        }
        isGlobal() {
          return true;
        }
        getHash(e) {
          return this.name || super.getHash(e);
        }
        getNodeType(e) {
          return this.node.getNodeType(e);
        }
        setupVarying(e) {
          const t = e.getNodeProperties(this);
          let i = t.varying;
          if (i === void 0) {
            const n = this.name, r = this.getNodeType(e);
            t.varying = i = e.getVaryingFromNode(this, n, r), t.node = this.node;
          }
          return i.needsInterpolation || (i.needsInterpolation = e.shaderStage === "fragment"), i;
        }
        setup(e) {
          this.setupVarying(e);
        }
        analyze(e) {
          return this.setupVarying(e), this.node.analyze(e);
        }
        generate(e) {
          const t = e.getNodeProperties(this), i = this.setupVarying(e), n = e.shaderStage === "fragment" && t.reassignPosition === true && e.context.needsPositionReassign;
          if (t.propertyName === void 0 || n) {
            const r = this.getNodeType(e), a = e.getPropertyName(i, U_.VERTEX);
            e.flowNodeFromShaderStage(U_.VERTEX, this.node, r, a), t.propertyName = a, n ? t.reassignPosition = false : t.reassignPosition === void 0 && e.context.isPositionNodeInput && (t.reassignPosition = true);
          }
          return e.getPropertyName(i);
        }
      }
      const sn = U(F3), O3 = (s) => sn(s);
      R("varying", sn);
      R("vertexStage", O3);
      const z3 = O(([s]) => {
        const e = s.mul(0.9478672986).add(0.0521327014).pow(2.4), t = s.mul(0.0773993808), i = s.lessThanEqual(0.04045);
        return Ce(e, t, i);
      }).setLayout({
        name: "sRGBTransferEOTF",
        type: "vec3",
        inputs: [
          {
            name: "color",
            type: "vec3"
          }
        ]
      }), L3 = O(([s]) => {
        const e = s.pow(0.41666).mul(1.055).sub(0.055), t = s.mul(12.92), i = s.lessThanEqual(31308e-7);
        return Ce(e, t, i);
      }).setLayout({
        name: "sRGBTransferOETF",
        type: "vec3",
        inputs: [
          {
            name: "color",
            type: "vec3"
          }
        ]
      }), Lu = "WorkingColorSpace", e0 = "OutputColorSpace";
      class Id extends ct {
        static get type() {
          return "ColorSpaceNode";
        }
        constructor(e, t, i) {
          super("vec4"), this.colorNode = e, this.source = t, this.target = i;
        }
        resolveColorSpace(e, t) {
          return t === Lu ? rt.workingColorSpace : t === e0 ? e.context.outputColorSpace || e.renderer.outputColorSpace : t;
        }
        setup(e) {
          const { colorNode: t } = this, i = this.resolveColorSpace(e, this.source), n = this.resolveColorSpace(e, this.target);
          let r = t;
          return rt.enabled === false || i === n || !i || !n || (rt.getTransfer(i) === Ol && (r = X(z3(r.rgb), r.a)), rt.getPrimaries(i) !== rt.getPrimaries(n) && (r = X(Gt(rt._getMatrix(new Jt(), i, n)).mul(r.rgb), r.a)), rt.getTransfer(n) === Ol && (r = X(L3(r.rgb), r.a))), r;
        }
      }
      const G3 = (s) => F(new Id(F(s), Lu, e0)), P3 = (s) => F(new Id(F(s), e0, Lu)), k3 = (s, e) => F(new Id(F(s), Lu, e)), TM = (s, e) => F(new Id(F(s), e, Lu));
      R("toOutputColorSpace", G3);
      R("toWorkingColorSpace", P3);
      R("workingToColorSpace", k3);
      R("colorSpaceToWorking", TM);
      let I3 = class extends Ou {
        static get type() {
          return "ReferenceElementNode";
        }
        constructor(e, t) {
          super(e, t), this.referenceNode = e, this.isReferenceElementNode = true;
        }
        getNodeType() {
          return this.referenceNode.uniformType;
        }
        generate(e) {
          const t = super.generate(e), i = this.referenceNode.getNodeType(), n = this.getNodeType();
          return e.format(t, i, n);
        }
      };
      class vM extends Q {
        static get type() {
          return "ReferenceBaseNode";
        }
        constructor(e, t, i = null, n = null) {
          super(), this.property = e, this.uniformType = t, this.object = i, this.count = n, this.properties = e.split("."), this.reference = i, this.node = null, this.group = null, this.updateType = te.OBJECT;
        }
        setGroup(e) {
          return this.group = e, this;
        }
        element(e) {
          return F(new I3(this, F(e)));
        }
        setNodeType(e) {
          const t = Z(null, e).getSelf();
          this.group !== null && t.setGroup(this.group), this.node = t;
        }
        getNodeType(e) {
          return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
        }
        getValueFromReference(e = this.reference) {
          const { properties: t } = this;
          let i = e[t[0]];
          for (let n = 1; n < t.length; n++) i = i[t[n]];
          return i;
        }
        updateReference(e) {
          return this.reference = this.object !== null ? this.object : e.object, this.reference;
        }
        setup() {
          return this.updateValue(), this.node;
        }
        update() {
          this.updateValue();
        }
        updateValue() {
          this.node === null && this.setNodeType(this.uniformType);
          const e = this.getValueFromReference();
          Array.isArray(e) ? this.node.array = e : this.node.value = e;
        }
      }
      const V3 = (s, e, t) => F(new vM(s, e, t));
      class H3 extends vM {
        static get type() {
          return "RendererReferenceNode";
        }
        constructor(e, t, i = null) {
          super(e, t, i), this.renderer = i, this.setGroup($);
        }
        updateReference(e) {
          return this.reference = this.renderer !== null ? this.renderer : e.renderer, this.reference;
        }
      }
      const q3 = (s, e, t = null) => F(new H3(s, e, t));
      class Y3 extends ct {
        static get type() {
          return "ToneMappingNode";
        }
        constructor(e, t = j3, i = null) {
          super("vec3"), this.toneMapping = e, this.exposureNode = t, this.colorNode = i;
        }
        customCacheKey() {
          return Vy(this.toneMapping);
        }
        setup(e) {
          const t = this.colorNode || e.context.color, i = this.toneMapping;
          if (i === Ja) return t;
          let n = null;
          const r = e.renderer.library.getToneMappingFunction(i);
          return r !== null ? n = X(r(t.rgb, this.exposureNode), t.a) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", i), n = t), n;
        }
      }
      const W3 = (s, e, t) => F(new Y3(s, F(e), F(t))), j3 = q3("toneMappingExposure", "float");
      R("toneMapping", (s, e, t) => W3(e, t, s));
      class $3 extends Hy {
        static get type() {
          return "BufferAttributeNode";
        }
        constructor(e, t = null, i = 0, n = 0) {
          super(e, t), this.isBufferNode = true, this.bufferType = t, this.bufferStride = i, this.bufferOffset = n, this.usage = Xh, this.instanced = false, this.attribute = null, this.global = true, e && e.isBufferAttribute === true && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
        }
        getHash(e) {
          if (this.bufferStride === 0 && this.bufferOffset === 0) {
            let t = e.globalCache.getData(this.value);
            return t === void 0 && (t = {
              node: this
            }, e.globalCache.setData(this.value, t)), t.node.uuid;
          }
          return this.uuid;
        }
        getNodeType(e) {
          return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
        }
        setup(e) {
          if (this.attribute !== null) return;
          const t = this.getNodeType(e), i = this.value, n = e.getTypeLength(t), r = this.bufferStride || n, a = this.bufferOffset, l = i.isInterleavedBuffer === true ? i : new Gv(i, r), o = new Ly(l, n, a);
          l.setUsage(this.usage), this.attribute = o, this.attribute.isInstancedBufferAttribute = this.instanced;
        }
        generate(e) {
          const t = this.getNodeType(e), i = e.getBufferAttributeFromNode(this, t), n = e.getPropertyName(i);
          let r = null;
          return e.shaderStage === "vertex" || e.shaderStage === "compute" ? (this.name = n, r = n) : r = sn(this).build(e, t), r;
        }
        getInputType() {
          return "bufferAttribute";
        }
        setUsage(e) {
          return this.usage = e, this.attribute && this.attribute.isBufferAttribute === true && (this.attribute.usage = e), this;
        }
        setInstanced(e) {
          return this.instanced = e, this;
        }
      }
      const t0 = (s, e = null, t = 0, i = 0) => F(new $3(s, e, t, i)), X3 = (s, e = null, t = 0, i = 0) => t0(s, e, t, i).setUsage(Ga), H_ = (s, e = null, t = 0, i = 0) => t0(s, e, t, i).setInstanced(true), q_ = (s, e = null, t = 0, i = 0) => X3(s, e, t, i).setInstanced(true);
      R("toAttribute", (s) => t0(s.value));
      class Z3 extends Q {
        static get type() {
          return "ComputeNode";
        }
        constructor(e, t, i = [
          64
        ]) {
          super("void"), this.isComputeNode = true, this.computeNode = e, this.count = t, this.workgroupSize = i, this.dispatchCount = 0, this.version = 1, this.name = "", this.updateBeforeType = te.OBJECT, this.onInitFunction = null, this.updateDispatchCount();
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        label(e) {
          return this.name = e, this;
        }
        updateDispatchCount() {
          const { count: e, workgroupSize: t } = this;
          let i = t[0];
          for (let n = 1; n < t.length; n++) i *= t[n];
          this.dispatchCount = Math.ceil(e / i);
        }
        onInit(e) {
          return this.onInitFunction = e, this;
        }
        updateBefore({ renderer: e }) {
          e.compute(this);
        }
        generate(e) {
          const { shaderStage: t } = e;
          if (t === "compute") {
            const i = this.computeNode.build(e, "void");
            i !== "" && e.addLineFlowCode(i, this);
          }
        }
      }
      const Q3 = (s, e, t) => F(new Z3(F(s), e, t));
      R("compute", Q3);
      class K3 extends Q {
        static get type() {
          return "CacheNode";
        }
        constructor(e, t = true) {
          super(), this.node = e, this.parent = t, this.isCacheNode = true;
        }
        getNodeType(e) {
          const t = e.getCache(), i = e.getCacheFromNode(this, this.parent);
          e.setCache(i);
          const n = this.node.getNodeType(e);
          return e.setCache(t), n;
        }
        build(e, ...t) {
          const i = e.getCache(), n = e.getCacheFromNode(this, this.parent);
          e.setCache(n);
          const r = this.node.build(e, ...t);
          return e.setCache(i), r;
        }
      }
      const lh = (s, e) => F(new K3(F(s), e));
      R("cache", lh);
      class J3 extends Q {
        static get type() {
          return "BypassNode";
        }
        constructor(e, t) {
          super(), this.isBypassNode = true, this.outputNode = e, this.callNode = t;
        }
        getNodeType(e) {
          return this.outputNode.getNodeType(e);
        }
        generate(e) {
          const t = this.callNode.build(e, "void");
          return t !== "" && e.addLineFlowCode(t, this), this.outputNode.build(e);
        }
      }
      const eD = U(J3);
      R("bypass", eD);
      class MM extends Q {
        static get type() {
          return "RemapNode";
        }
        constructor(e, t, i, n = C(0), r = C(1)) {
          super(), this.node = e, this.inLowNode = t, this.inHighNode = i, this.outLowNode = n, this.outHighNode = r, this.doClamp = true;
        }
        setup() {
          const { node: e, inLowNode: t, inHighNode: i, outLowNode: n, outHighNode: r, doClamp: a } = this;
          let l = e.sub(t).div(i.sub(t));
          return a === true && (l = l.clamp()), l.mul(r.sub(n)).add(n);
        }
      }
      const tD = U(MM, null, null, {
        doClamp: false
      }), iD = U(MM);
      R("remap", tD);
      R("remapClamp", iD);
      class uh extends Q {
        static get type() {
          return "ExpressionNode";
        }
        constructor(e = "", t = "void") {
          super(t), this.snippet = e;
        }
        generate(e, t) {
          const i = this.getNodeType(e), n = this.snippet;
          if (i === "void") e.addLineFlowCode(n, this);
          else return e.format(`( ${n} )`, i, t);
        }
      }
      const pu = U(uh), sD = (s) => (s ? Wt(s, pu("discard")) : pu("discard")).append();
      R("discard", sD);
      class nD extends ct {
        static get type() {
          return "RenderOutputNode";
        }
        constructor(e, t, i) {
          super("vec4"), this.colorNode = e, this.toneMapping = t, this.outputColorSpace = i, this.isRenderOutputNode = true;
        }
        setup({ context: e }) {
          let t = this.colorNode || e.color;
          const i = (this.toneMapping !== null ? this.toneMapping : e.toneMapping) || Ja, n = (this.outputColorSpace !== null ? this.outputColorSpace : e.outputColorSpace) || zr;
          return i !== Ja && (t = t.toneMapping(i)), n !== zr && n !== rt.workingColorSpace && (t = t.workingToColorSpace(n)), t;
        }
      }
      const rD = (s, e = null, t = null) => F(new nD(F(s), e, t));
      R("renderOutput", rD);
      class aD extends Q {
        static get type() {
          return "AttributeNode";
        }
        constructor(e, t = null) {
          super(t), this.global = true, this._attributeName = e;
        }
        getHash(e) {
          return this.getAttributeName(e);
        }
        getNodeType(e) {
          let t = this.nodeType;
          if (t === null) {
            const i = this.getAttributeName(e);
            if (e.hasGeometryAttribute(i)) {
              const n = e.geometry.getAttribute(i);
              t = e.getTypeFromAttribute(n);
            } else t = "float";
          }
          return t;
        }
        setAttributeName(e) {
          return this._attributeName = e, this;
        }
        getAttributeName() {
          return this._attributeName;
        }
        generate(e) {
          const t = this.getAttributeName(e), i = this.getNodeType(e);
          if (e.hasGeometryAttribute(t) === true) {
            const r = e.geometry.getAttribute(t), a = e.getTypeFromAttribute(r), l = e.getAttribute(t, a);
            return e.shaderStage === "vertex" ? e.format(l.name, a, i) : sn(this).build(e, i);
          } else return console.warn(`AttributeNode: Vertex attribute "${t}" not found on geometry.`), e.generateConst(i);
        }
        serialize(e) {
          super.serialize(e), e.global = this.global, e._attributeName = this._attributeName;
        }
        deserialize(e) {
          super.deserialize(e), this.global = e.global, this._attributeName = e._attributeName;
        }
      }
      const Qs = (s, e) => F(new aD(s, e)), Vd = (s = 0) => Qs("uv" + (s > 0 ? s : ""), "vec2");
      class oD extends Q {
        static get type() {
          return "TextureSizeNode";
        }
        constructor(e, t = null) {
          super("uvec2"), this.isTextureSizeNode = true, this.textureNode = e, this.levelNode = t;
        }
        generate(e, t) {
          const i = this.textureNode.build(e, "property"), n = this.levelNode === null ? "0" : this.levelNode.build(e, "int");
          return e.format(`${e.getMethod("textureDimensions")}( ${i}, ${n} )`, this.getNodeType(e), t);
        }
      }
      const Gl = U(oD);
      class lD extends zu {
        static get type() {
          return "MaxMipLevelNode";
        }
        constructor(e) {
          super(0), this._textureNode = e, this.updateType = te.FRAME;
        }
        get textureNode() {
          return this._textureNode;
        }
        get texture() {
          return this._textureNode.value;
        }
        update() {
          const e = this.texture, t = e.images, i = t && t.length > 0 ? t[0] && t[0].image || t[0] : e.image;
          if (i && i.width !== void 0) {
            const { width: n, height: r } = i;
            this.value = Math.log2(Math.max(n, r));
          }
        }
      }
      const uD = U(lD);
      class Gu extends zu {
        static get type() {
          return "TextureNode";
        }
        constructor(e, t = null, i = null, n = null) {
          super(e), this.isTextureNode = true, this.uvNode = t, this.levelNode = i, this.biasNode = n, this.compareNode = null, this.depthNode = null, this.gradNode = null, this.sampler = true, this.updateMatrix = false, this.updateType = te.NONE, this.referenceNode = null, this._value = e, this._matrixUniform = null, this.setUpdateMatrix(t === null);
        }
        set value(e) {
          this.referenceNode ? this.referenceNode.value = e : this._value = e;
        }
        get value() {
          return this.referenceNode ? this.referenceNode.value : this._value;
        }
        getUniformHash() {
          return this.value.uuid;
        }
        getNodeType() {
          return this.value.isDepthTexture === true ? "float" : this.value.type === Tt ? "uvec4" : this.value.type === Dt ? "ivec4" : "vec4";
        }
        getInputType() {
          return "texture";
        }
        getDefaultUV() {
          return Vd(this.value.channel);
        }
        updateReference() {
          return this.value;
        }
        getTransformedUV(e) {
          return this._matrixUniform === null && (this._matrixUniform = Z(this.value.matrix)), this._matrixUniform.mul(B(e, 1)).xy;
        }
        setUpdateMatrix(e) {
          return this.updateMatrix = e, this.updateType = e ? te.RENDER : te.NONE, this;
        }
        setupUV(e, t) {
          const i = this.value;
          return e.isFlipY() && (i.image instanceof ImageBitmap && i.flipY === true || i.isRenderTargetTexture === true || i.isFramebufferTexture === true || i.isDepthTexture === true) && (this.sampler ? t = t.flipY() : t = t.setY(He(Gl(this, this.levelNode).y).sub(t.y).sub(1))), t;
        }
        setup(e) {
          const t = e.getNodeProperties(this);
          t.referenceNode = this.referenceNode;
          const i = this.value;
          if (!i || i.isTexture !== true) throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");
          let n = this.uvNode;
          (n === null || e.context.forceUVContext === true) && e.context.getUV && (n = e.context.getUV(this)), n || (n = this.getDefaultUV()), this.updateMatrix === true && (n = this.getTransformedUV(n)), n = this.setupUV(e, n);
          let r = this.levelNode;
          r === null && e.context.getTextureLevel && (r = e.context.getTextureLevel(this)), t.uvNode = n, t.levelNode = r, t.biasNode = this.biasNode, t.compareNode = this.compareNode, t.gradNode = this.gradNode, t.depthNode = this.depthNode;
        }
        generateUV(e, t) {
          return t.build(e, this.sampler === true ? "vec2" : "ivec2");
        }
        generateSnippet(e, t, i, n, r, a, l, o) {
          const u = this.value;
          let c;
          return n ? c = e.generateTextureLevel(u, t, i, n, a) : r ? c = e.generateTextureBias(u, t, i, r, a) : o ? c = e.generateTextureGrad(u, t, i, o, a) : l ? c = e.generateTextureCompare(u, t, i, l, a) : this.sampler === false ? c = e.generateTextureLoad(u, t, i, a) : c = e.generateTexture(u, t, i, a), c;
        }
        generate(e, t) {
          const i = this.value, n = e.getNodeProperties(this), r = super.generate(e, "property");
          if (t === "sampler") return r + "_sampler";
          if (e.isReference(t)) return r;
          {
            const a = e.getDataFromNode(this);
            let l = a.propertyName;
            if (l === void 0) {
              const { uvNode: c, levelNode: h, biasNode: d, compareNode: f, depthNode: p, gradNode: g } = n, _ = this.generateUV(e, c), m = h ? h.build(e, "float") : null, y = d ? d.build(e, "float") : null, x = p ? p.build(e, "int") : null, b = f ? f.build(e, "float") : null, T = g ? [
                g[0].build(e, "vec2"),
                g[1].build(e, "vec2")
              ] : null, N = e.getVarFromNode(this);
              l = e.getPropertyName(N);
              const A = this.generateSnippet(e, r, _, m, y, x, b, T);
              e.addLineFlowCode(`${l} = ${A}`, this), a.snippet = A, a.propertyName = l;
            }
            let o = l;
            const u = this.getNodeType(e);
            return e.needsToWorkingColorSpace(i) && (o = TM(pu(o, u), i.colorSpace).setup(e).build(e, u)), e.format(o, u, t);
          }
        }
        setSampler(e) {
          return this.sampler = e, this;
        }
        getSampler() {
          return this.sampler;
        }
        uv(e) {
          return console.warn("THREE.TextureNode: .uv() has been renamed. Use .sample() instead."), this.sample(e);
        }
        sample(e) {
          const t = this.clone();
          return t.uvNode = F(e), t.referenceNode = this.getSelf(), F(t);
        }
        blur(e) {
          const t = this.clone();
          return t.biasNode = F(e).mul(uD(t)), t.referenceNode = this.getSelf(), F(t);
        }
        level(e) {
          const t = this.clone();
          return t.levelNode = F(e), t.referenceNode = this.getSelf(), F(t);
        }
        size(e) {
          return Gl(this, e);
        }
        bias(e) {
          const t = this.clone();
          return t.biasNode = F(e), t.referenceNode = this.getSelf(), F(t);
        }
        compare(e) {
          const t = this.clone();
          return t.compareNode = F(e), t.referenceNode = this.getSelf(), F(t);
        }
        grad(e, t) {
          const i = this.clone();
          return i.gradNode = [
            F(e),
            F(t)
          ], i.referenceNode = this.getSelf(), F(i);
        }
        depth(e) {
          const t = this.clone();
          return t.depthNode = F(e), t.referenceNode = this.getSelf(), F(t);
        }
        serialize(e) {
          super.serialize(e), e.value = this.value.toJSON(e.meta).uuid, e.sampler = this.sampler, e.updateMatrix = this.updateMatrix, e.updateType = this.updateType;
        }
        deserialize(e) {
          super.deserialize(e), this.value = e.meta.textures[e.value], this.sampler = e.sampler, this.updateMatrix = e.updateMatrix, this.updateType = e.updateType;
        }
        update() {
          const e = this.value, t = this._matrixUniform;
          t !== null && (t.value = e.matrix), e.matrixAutoUpdate === true && e.updateMatrix();
        }
        clone() {
          const e = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
          return e.sampler = this.sampler, e;
        }
      }
      const fe = U(Gu), Pi = (...s) => fe(...s).setSampler(false), pr = Z("float").label("cameraNear").setGroup($).onRenderUpdate(({ camera: s }) => s.near), mr = Z("float").label("cameraFar").setGroup($).onRenderUpdate(({ camera: s }) => s.far), i0 = Z("mat4").label("cameraProjectionMatrix").setGroup($).onRenderUpdate(({ camera: s }) => s.projectionMatrix), nn = Z("mat4").label("cameraViewMatrix").setGroup($).onRenderUpdate(({ camera: s }) => s.matrixWorldInverse), cD = Z(new v()).label("cameraPosition").setGroup($).onRenderUpdate(({ camera: s }, e) => e.value.setFromMatrixPosition(s.matrixWorld));
      class me extends Q {
        static get type() {
          return "Object3DNode";
        }
        constructor(e, t = null) {
          super(), this.scope = e, this.object3d = t, this.updateType = te.OBJECT, this._uniformNode = new zu(null);
        }
        getNodeType() {
          const e = this.scope;
          if (e === me.WORLD_MATRIX) return "mat4";
          if (e === me.POSITION || e === me.VIEW_POSITION || e === me.DIRECTION || e === me.SCALE) return "vec3";
        }
        update(e) {
          const t = this.object3d, i = this._uniformNode, n = this.scope;
          if (n === me.WORLD_MATRIX) i.value = t.matrixWorld;
          else if (n === me.POSITION) i.value = i.value || new v(), i.value.setFromMatrixPosition(t.matrixWorld);
          else if (n === me.SCALE) i.value = i.value || new v(), i.value.setFromMatrixScale(t.matrixWorld);
          else if (n === me.DIRECTION) i.value = i.value || new v(), t.getWorldDirection(i.value);
          else if (n === me.VIEW_POSITION) {
            const r = e.camera;
            i.value = i.value || new v(), i.value.setFromMatrixPosition(t.matrixWorld), i.value.applyMatrix4(r.matrixWorldInverse);
          }
        }
        generate(e) {
          const t = this.scope;
          return t === me.WORLD_MATRIX ? this._uniformNode.nodeType = "mat4" : (t === me.POSITION || t === me.VIEW_POSITION || t === me.DIRECTION || t === me.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(e);
        }
        serialize(e) {
          super.serialize(e), e.scope = this.scope;
        }
        deserialize(e) {
          super.deserialize(e), this.scope = e.scope;
        }
      }
      me.WORLD_MATRIX = "worldMatrix";
      me.POSITION = "position";
      me.SCALE = "scale";
      me.VIEW_POSITION = "viewPosition";
      me.DIRECTION = "direction";
      me.DIRECTION;
      me.WORLD_MATRIX;
      const hD = U(me, me.POSITION);
      me.SCALE;
      me.VIEW_POSITION;
      class os extends me {
        static get type() {
          return "ModelNode";
        }
        constructor(e) {
          super(e);
        }
        update(e) {
          this.object3d = e.object, super.update(e);
        }
      }
      os.DIRECTION;
      const Pr = z(os, os.WORLD_MATRIX);
      os.POSITION;
      os.SCALE;
      os.VIEW_POSITION;
      const dD = Z(new Jt()).onObjectUpdate(({ object: s }, e) => e.value.getNormalMatrix(s.matrixWorld)), s0 = O((s) => s.renderer.nodes.modelViewMatrix || fD).once()().toVar("modelViewMatrix"), fD = nn.mul(Pr), n0 = Qs("position", "vec3"), Et = n0.varying("positionLocal"), Y_ = n0.varying("positionPrevious"), mu = Pr.mul(Et).xyz.varying("v_positionWorld").context({
        needsPositionReassign: true
      }), AM = Et.transformDirection(Pr).varying("v_positionWorldDirection").normalize().toVar("positionWorldDirection").context({
        needsPositionReassign: true
      }), Ke = O((s) => s.context.setupPositionView(), "vec3").once()().varying("v_positionView").context({
        needsPositionReassign: true
      }), Ge = Ke.negate().varying("v_positionViewDirection").normalize().toVar("positionViewDirection");
      class pD extends Q {
        static get type() {
          return "FrontFacingNode";
        }
        constructor() {
          super("bool"), this.isFrontFacingNode = true;
        }
        generate(e) {
          const { renderer: t, material: i } = e;
          return t.coordinateSystem === li && i.side === Fi ? "false" : e.getFrontFacing();
        }
      }
      const mD = z(pD), Hd = C(mD).mul(2).sub(1), NM = Qs("normal", "vec3"), ls = O((s) => s.geometry.hasAttribute("normal") === false ? (console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.'), B(0, 1, 0)) : NM, "vec3").once()().toVar("normalLocal"), gD = Ke.dFdx().cross(Ke.dFdy()).normalize().toVar("normalFlat"), Xi = O((s) => {
        let e;
        return s.material.flatShading === true ? e = gD : e = sn(EM(ls), "v_normalView").normalize(), e;
      }, "vec3").once()().toVar("normalView"), wM = sn(Xi.transformDirection(nn), "v_normalWorld").normalize().toVar("normalWorld"), Qe = O((s) => s.context.setupNormal(), "vec3").once()().mul(Hd).toVar("transformedNormalView"), r0 = Qe.transformDirection(nn).toVar("transformedNormalWorld"), pl = O((s) => s.context.setupClearcoatNormal(), "vec3").once()().mul(Hd).toVar("transformedClearcoatNormalView"), yD = O(([s, e = Pr]) => {
        const t = Gt(e), i = s.div(B(t[0].dot(t[0]), t[1].dot(t[1]), t[2].dot(t[2])));
        return t.mul(i).xyz;
      }), EM = O(([s], e) => {
        const t = e.renderer.nodes.modelNormalViewMatrix;
        if (t !== null) return t.transformDirection(s);
        const i = dD.mul(s);
        return nn.transformDirection(i);
      }), xD = Z(0).onReference(({ material: s }) => s).onRenderUpdate(({ material: s }) => s.refractionRatio), _D = Ge.negate().reflect(Qe), bD = Ge.negate().refract(Qe, xD), SD = _D.transformDirection(nn).toVar("reflectVector"), TD = bD.transformDirection(nn).toVar("reflectVector");
      class vD extends Gu {
        static get type() {
          return "CubeTextureNode";
        }
        constructor(e, t = null, i = null, n = null) {
          super(e, t, i, n), this.isCubeTextureNode = true;
        }
        getInputType() {
          return "cubeTexture";
        }
        getDefaultUV() {
          const e = this.value;
          return e.mapping === Fr ? SD : e.mapping === _o ? TD : (console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', e.mapping), B(0, 0, 0));
        }
        setUpdateMatrix() {
        }
        setupUV(e, t) {
          const i = this.value;
          return e.renderer.coordinateSystem === Zn || !i.isRenderTargetTexture ? B(t.x.negate(), t.yz) : t;
        }
        generateUV(e, t) {
          return t.build(e, "vec3");
        }
      }
      const gu = U(vD);
      class RM extends zu {
        static get type() {
          return "BufferNode";
        }
        constructor(e, t, i = 0) {
          super(e, t), this.isBufferNode = true, this.bufferType = t, this.bufferCount = i;
        }
        getElementType(e) {
          return this.getNodeType(e);
        }
        getInputType() {
          return "buffer";
        }
      }
      const a0 = (s, e, t) => F(new RM(s, e, t));
      class MD extends Ou {
        static get type() {
          return "UniformArrayElementNode";
        }
        constructor(e, t) {
          super(e, t), this.isArrayBufferElementNode = true;
        }
        generate(e) {
          const t = super.generate(e), i = this.getNodeType(), n = this.node.getPaddedType();
          return e.format(t, n, i);
        }
      }
      class AD extends RM {
        static get type() {
          return "UniformArrayNode";
        }
        constructor(e, t = null) {
          super(null), this.array = e, this.elementType = t === null ? Jh(e[0]) : t, this.paddedType = this.getPaddedType(), this.updateType = te.RENDER, this.isArrayBufferNode = true;
        }
        getNodeType() {
          return this.paddedType;
        }
        getElementType() {
          return this.elementType;
        }
        getPaddedType() {
          const e = this.elementType;
          let t = "vec4";
          return e === "mat2" ? t = "mat2" : /mat/.test(e) === true ? t = "mat4" : e.charAt(0) === "i" ? t = "ivec4" : e.charAt(0) === "u" && (t = "uvec4"), t;
        }
        update() {
          const { array: e, value: t } = this, i = this.elementType;
          if (i === "float" || i === "int" || i === "uint") for (let n = 0; n < e.length; n++) {
            const r = n * 4;
            t[r] = e[n];
          }
          else if (i === "color") for (let n = 0; n < e.length; n++) {
            const r = n * 4, a = e[n];
            t[r] = a.r, t[r + 1] = a.g, t[r + 2] = a.b || 0;
          }
          else if (i === "mat2") for (let n = 0; n < e.length; n++) {
            const r = n * 4, a = e[n];
            t[r] = a.elements[0], t[r + 1] = a.elements[1], t[r + 2] = a.elements[2], t[r + 3] = a.elements[3];
          }
          else if (i === "mat3") for (let n = 0; n < e.length; n++) {
            const r = n * 16, a = e[n];
            t[r] = a.elements[0], t[r + 1] = a.elements[1], t[r + 2] = a.elements[2], t[r + 4] = a.elements[3], t[r + 5] = a.elements[4], t[r + 6] = a.elements[5], t[r + 8] = a.elements[6], t[r + 9] = a.elements[7], t[r + 10] = a.elements[8], t[r + 15] = 1;
          }
          else if (i === "mat4") for (let n = 0; n < e.length; n++) {
            const r = n * 16, a = e[n];
            for (let l = 0; l < a.elements.length; l++) t[r + l] = a.elements[l];
          }
          else for (let n = 0; n < e.length; n++) {
            const r = n * 4, a = e[n];
            t[r] = a.x, t[r + 1] = a.y, t[r + 2] = a.z || 0, t[r + 3] = a.w || 0;
          }
        }
        setup(e) {
          const t = this.array.length, i = this.elementType;
          let n = Float32Array;
          const r = this.paddedType, a = e.getTypeLength(r);
          return i.charAt(0) === "i" && (n = Int32Array), i.charAt(0) === "u" && (n = Uint32Array), this.value = new n(t * a), this.bufferCount = t, this.bufferType = r, super.setup(e);
        }
        element(e) {
          return F(new MD(this, F(e)));
        }
      }
      const An = (s, e) => F(new AD(s, e));
      class ND extends Ou {
        static get type() {
          return "ReferenceElementNode";
        }
        constructor(e, t) {
          super(e, t), this.referenceNode = e, this.isReferenceElementNode = true;
        }
        getNodeType() {
          return this.referenceNode.uniformType;
        }
        generate(e) {
          const t = super.generate(e), i = this.referenceNode.getNodeType(), n = this.getNodeType();
          return e.format(t, i, n);
        }
      }
      class o0 extends Q {
        static get type() {
          return "ReferenceNode";
        }
        constructor(e, t, i = null, n = null) {
          super(), this.property = e, this.uniformType = t, this.object = i, this.count = n, this.properties = e.split("."), this.reference = i, this.node = null, this.group = null, this.name = null, this.updateType = te.OBJECT;
        }
        element(e) {
          return F(new ND(this, F(e)));
        }
        setGroup(e) {
          return this.group = e, this;
        }
        label(e) {
          return this.name = e, this;
        }
        setNodeType(e) {
          let t = null;
          this.count !== null ? t = a0(null, e, this.count) : Array.isArray(this.getValueFromReference()) ? t = An(null, e) : e === "texture" ? t = fe(null) : e === "cubeTexture" ? t = gu(null) : t = Z(null, e), this.group !== null && t.setGroup(this.group), this.name !== null && t.label(this.name), this.node = t.getSelf();
        }
        getNodeType(e) {
          return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
        }
        getValueFromReference(e = this.reference) {
          const { properties: t } = this;
          let i = e[t[0]];
          for (let n = 1; n < t.length; n++) i = i[t[n]];
          return i;
        }
        updateReference(e) {
          return this.reference = this.object !== null ? this.object : e.object, this.reference;
        }
        setup() {
          return this.updateValue(), this.node;
        }
        update() {
          this.updateValue();
        }
        updateValue() {
          this.node === null && this.setNodeType(this.uniformType);
          const e = this.getValueFromReference();
          Array.isArray(e) ? this.node.array = e : this.node.value = e;
        }
      }
      const Se = (s, e, t) => F(new o0(s, e, t)), W_ = (s, e, t, i) => F(new o0(s, e, i, t));
      class wD extends o0 {
        static get type() {
          return "MaterialReferenceNode";
        }
        constructor(e, t, i = null) {
          super(e, t, i), this.material = i, this.isMaterialReferenceNode = true;
        }
        updateReference(e) {
          return this.reference = this.material !== null ? this.material : e.material, this.reference;
        }
      }
      const Nn = (s, e, t = null) => F(new wD(s, e, t)), CM = O((s) => (s.geometry.hasAttribute("tangent") === false && s.geometry.computeTangents(), Qs("tangent", "vec4")))(), l0 = CM.xyz.toVar("tangentLocal"), BM = s0.mul(X(l0, 0)).xyz.varying("v_tangentView").normalize().toVar("tangentView"), ED = (s) => s.mul(CM.w).xyz, RD = sn(ED(Xi.cross(BM)), "v_bitangentView").normalize().toVar("bitangentView"), ml = Gt(BM, RD, Xi), CD = (() => {
        let s = no.cross(Ge);
        return s = s.cross(no).normalize(), s = Ce(s, Qe, hr.mul(Bs.oneMinus()).oneMinus().pow2().pow2()).normalize(), s;
      })(), BD = O((s) => {
        const { eye_pos: e, surf_norm: t, mapN: i, uv: n } = s, r = e.dFdx(), a = e.dFdy(), l = n.dFdx(), o = n.dFdy(), u = t, c = a.cross(u), h = u.cross(r), d = c.mul(l.x).add(h.mul(o.x)), f = c.mul(l.y).add(h.mul(o.y)), p = d.dot(d).max(f.dot(f)), g = Hd.mul(p.inverseSqrt());
        return Pt(d.mul(i.x, g), f.mul(i.y, g), u.mul(i.z)).normalize();
      });
      class DD extends ct {
        static get type() {
          return "NormalMapNode";
        }
        constructor(e, t = null) {
          super("vec3"), this.node = e, this.scaleNode = t, this.normalMapType = Xn;
        }
        setup(e) {
          const { normalMapType: t, scaleNode: i } = this;
          let n = this.node.mul(2).sub(1);
          i !== null && (n = B(n.xy.mul(i), n.z));
          let r = null;
          return t === pR ? r = EM(n) : t === Xn && (e.hasGeometryAttribute("tangent") === true ? r = ml.mul(n).normalize() : r = BD({
            eye_pos: Ke,
            surf_norm: Xi,
            mapN: n,
            uv: Vd()
          })), r;
        }
      }
      const j_ = U(DD), UD = O(({ textureNode: s, bumpScale: e }) => {
        const t = (n) => s.cache().context({
          getUV: (r) => n(r.uvNode || Vd()),
          forceUVContext: true
        }), i = C(t((n) => n));
        return L(C(t((n) => n.add(n.dFdx()))).sub(i), C(t((n) => n.add(n.dFdy()))).sub(i)).mul(e);
      }), FD = O((s) => {
        const { surf_pos: e, surf_norm: t, dHdxy: i } = s, n = e.dFdx().normalize(), r = e.dFdy().normalize(), a = t, l = r.cross(a), o = a.cross(n), u = n.dot(l).mul(Hd), c = u.sign().mul(i.x.mul(l).add(i.y.mul(o)));
        return u.abs().mul(t).sub(c).normalize();
      });
      class OD extends ct {
        static get type() {
          return "BumpMapNode";
        }
        constructor(e, t = null) {
          super("vec3"), this.textureNode = e, this.scaleNode = t;
        }
        setup() {
          const e = this.scaleNode !== null ? this.scaleNode : 1, t = UD({
            textureNode: this.textureNode,
            bumpScale: e
          });
          return FD({
            surf_pos: Ke,
            surf_norm: Xi,
            dHdxy: t
          });
        }
      }
      const zD = U(OD), $_ = /* @__PURE__ */ new Map();
      class E extends Q {
        static get type() {
          return "MaterialNode";
        }
        constructor(e) {
          super(), this.scope = e;
        }
        getCache(e, t) {
          let i = $_.get(e);
          return i === void 0 && (i = Nn(e, t), $_.set(e, i)), i;
        }
        getFloat(e) {
          return this.getCache(e, "float");
        }
        getColor(e) {
          return this.getCache(e, "color");
        }
        getTexture(e) {
          return this.getCache(e === "map" ? "map" : e + "Map", "texture");
        }
        setup(e) {
          const t = e.context.material, i = this.scope;
          let n = null;
          if (i === E.COLOR) {
            const r = t.color !== void 0 ? this.getColor(i) : B();
            t.map && t.map.isTexture === true ? n = r.mul(this.getTexture("map")) : n = r;
          } else if (i === E.OPACITY) {
            const r = this.getFloat(i);
            t.alphaMap && t.alphaMap.isTexture === true ? n = r.mul(this.getTexture("alpha")) : n = r;
          } else if (i === E.SPECULAR_STRENGTH) t.specularMap && t.specularMap.isTexture === true ? n = this.getTexture("specular").r : n = C(1);
          else if (i === E.SPECULAR_INTENSITY) {
            const r = this.getFloat(i);
            t.specularIntensityMap && t.specularIntensityMap.isTexture === true ? n = r.mul(this.getTexture(i).a) : n = r;
          } else if (i === E.SPECULAR_COLOR) {
            const r = this.getColor(i);
            t.specularColorMap && t.specularColorMap.isTexture === true ? n = r.mul(this.getTexture(i).rgb) : n = r;
          } else if (i === E.ROUGHNESS) {
            const r = this.getFloat(i);
            t.roughnessMap && t.roughnessMap.isTexture === true ? n = r.mul(this.getTexture(i).g) : n = r;
          } else if (i === E.METALNESS) {
            const r = this.getFloat(i);
            t.metalnessMap && t.metalnessMap.isTexture === true ? n = r.mul(this.getTexture(i).b) : n = r;
          } else if (i === E.EMISSIVE) {
            const r = this.getFloat("emissiveIntensity"), a = this.getColor(i).mul(r);
            t.emissiveMap && t.emissiveMap.isTexture === true ? n = a.mul(this.getTexture(i)) : n = a;
          } else if (i === E.NORMAL) t.normalMap ? (n = j_(this.getTexture("normal"), this.getCache("normalScale", "vec2")), n.normalMapType = t.normalMapType) : t.bumpMap ? n = zD(this.getTexture("bump").r, this.getFloat("bumpScale")) : n = Xi;
          else if (i === E.CLEARCOAT) {
            const r = this.getFloat(i);
            t.clearcoatMap && t.clearcoatMap.isTexture === true ? n = r.mul(this.getTexture(i).r) : n = r;
          } else if (i === E.CLEARCOAT_ROUGHNESS) {
            const r = this.getFloat(i);
            t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === true ? n = r.mul(this.getTexture(i).r) : n = r;
          } else if (i === E.CLEARCOAT_NORMAL) t.clearcoatNormalMap ? n = j_(this.getTexture(i), this.getCache(i + "Scale", "vec2")) : n = Xi;
          else if (i === E.SHEEN) {
            const r = this.getColor("sheenColor").mul(this.getFloat("sheen"));
            t.sheenColorMap && t.sheenColorMap.isTexture === true ? n = r.mul(this.getTexture("sheenColor").rgb) : n = r;
          } else if (i === E.SHEEN_ROUGHNESS) {
            const r = this.getFloat(i);
            t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === true ? n = r.mul(this.getTexture(i).a) : n = r, n = n.clamp(0.07, 1);
          } else if (i === E.ANISOTROPY) if (t.anisotropyMap && t.anisotropyMap.isTexture === true) {
            const r = this.getTexture(i);
            n = jy(tl.x, tl.y, tl.y.negate(), tl.x).mul(r.rg.mul(2).sub(L(1)).normalize().mul(r.b));
          } else n = tl;
          else if (i === E.IRIDESCENCE_THICKNESS) {
            const r = Se("1", "float", t.iridescenceThicknessRange);
            if (t.iridescenceThicknessMap) {
              const a = Se("0", "float", t.iridescenceThicknessRange);
              n = r.sub(a).mul(this.getTexture(i).g).add(a);
            } else n = r;
          } else if (i === E.TRANSMISSION) {
            const r = this.getFloat(i);
            t.transmissionMap ? n = r.mul(this.getTexture(i).r) : n = r;
          } else if (i === E.THICKNESS) {
            const r = this.getFloat(i);
            t.thicknessMap ? n = r.mul(this.getTexture(i).g) : n = r;
          } else if (i === E.IOR) n = this.getFloat(i);
          else if (i === E.LIGHT_MAP) n = this.getTexture(i).rgb.mul(this.getFloat("lightMapIntensity"));
          else if (i === E.AO) n = this.getTexture(i).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
          else {
            const r = this.getNodeType(e);
            n = this.getCache(i, r);
          }
          return n;
        }
      }
      E.ALPHA_TEST = "alphaTest";
      E.COLOR = "color";
      E.OPACITY = "opacity";
      E.SHININESS = "shininess";
      E.SPECULAR = "specular";
      E.SPECULAR_STRENGTH = "specularStrength";
      E.SPECULAR_INTENSITY = "specularIntensity";
      E.SPECULAR_COLOR = "specularColor";
      E.REFLECTIVITY = "reflectivity";
      E.ROUGHNESS = "roughness";
      E.METALNESS = "metalness";
      E.NORMAL = "normal";
      E.CLEARCOAT = "clearcoat";
      E.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
      E.CLEARCOAT_NORMAL = "clearcoatNormal";
      E.EMISSIVE = "emissive";
      E.ROTATION = "rotation";
      E.SHEEN = "sheen";
      E.SHEEN_ROUGHNESS = "sheenRoughness";
      E.ANISOTROPY = "anisotropy";
      E.IRIDESCENCE = "iridescence";
      E.IRIDESCENCE_IOR = "iridescenceIOR";
      E.IRIDESCENCE_THICKNESS = "iridescenceThickness";
      E.IOR = "ior";
      E.TRANSMISSION = "transmission";
      E.THICKNESS = "thickness";
      E.ATTENUATION_DISTANCE = "attenuationDistance";
      E.ATTENUATION_COLOR = "attenuationColor";
      E.LINE_SCALE = "scale";
      E.LINE_DASH_SIZE = "dashSize";
      E.LINE_GAP_SIZE = "gapSize";
      E.LINE_WIDTH = "linewidth";
      E.LINE_DASH_OFFSET = "dashOffset";
      E.POINT_WIDTH = "pointWidth";
      E.DISPERSION = "dispersion";
      E.LIGHT_MAP = "light";
      E.AO = "ao";
      const LD = z(E, E.ALPHA_TEST), GD = z(E, E.COLOR), PD = z(E, E.SHININESS), kD = z(E, E.EMISSIVE), DM = z(E, E.OPACITY), ID = z(E, E.SPECULAR), X_ = z(E, E.SPECULAR_INTENSITY), VD = z(E, E.SPECULAR_COLOR), ch = z(E, E.SPECULAR_STRENGTH), lp = z(E, E.REFLECTIVITY), HD = z(E, E.ROUGHNESS), qD = z(E, E.METALNESS), YD = z(E, E.NORMAL).context({
        getUV: null
      }), WD = z(E, E.CLEARCOAT), jD = z(E, E.CLEARCOAT_ROUGHNESS), $D = z(E, E.CLEARCOAT_NORMAL).context({
        getUV: null
      }), XD = z(E, E.ROTATION), ZD = z(E, E.SHEEN), QD = z(E, E.SHEEN_ROUGHNESS), KD = z(E, E.ANISOTROPY), JD = z(E, E.IRIDESCENCE), eU = z(E, E.IRIDESCENCE_IOR), tU = z(E, E.IRIDESCENCE_THICKNESS), iU = z(E, E.TRANSMISSION), sU = z(E, E.THICKNESS), nU = z(E, E.IOR), rU = z(E, E.ATTENUATION_DISTANCE), aU = z(E, E.ATTENUATION_COLOR), oU = z(E, E.LINE_SCALE), lU = z(E, E.LINE_DASH_SIZE), uU = z(E, E.LINE_GAP_SIZE);
      E.LINE_WIDTH;
      const cU = z(E, E.LINE_DASH_OFFSET);
      E.POINT_WIDTH;
      const hU = z(E, E.DISPERSION), UM = z(E, E.LIGHT_MAP), dU = z(E, E.AO), tl = Z(new q()).onReference(function(s) {
        return s.material;
      }).onRenderUpdate(function({ material: s }) {
        this.value.set(s.anisotropy * Math.cos(s.anisotropyRotation), s.anisotropy * Math.sin(s.anisotropyRotation));
      }), FM = O((s) => s.context.setupModelViewProjection(), "vec4").once()().varying("v_modelViewProjection");
      class Be extends Q {
        static get type() {
          return "IndexNode";
        }
        constructor(e) {
          super("uint"), this.scope = e, this.isIndexNode = true;
        }
        generate(e) {
          const t = this.getNodeType(e), i = this.scope;
          let n;
          if (i === Be.VERTEX) n = e.getVertexIndex();
          else if (i === Be.INSTANCE) n = e.getInstanceIndex();
          else if (i === Be.DRAW) n = e.getDrawIndex();
          else if (i === Be.INVOCATION_LOCAL) n = e.getInvocationLocalIndex();
          else if (i === Be.INVOCATION_SUBGROUP) n = e.getInvocationSubgroupIndex();
          else if (i === Be.SUBGROUP) n = e.getSubgroupIndex();
          else throw new Error("THREE.IndexNode: Unknown scope: " + i);
          let r;
          return e.shaderStage === "vertex" || e.shaderStage === "compute" ? r = n : r = sn(this).build(e, t), r;
        }
      }
      Be.VERTEX = "vertex";
      Be.INSTANCE = "instance";
      Be.SUBGROUP = "subgroup";
      Be.INVOCATION_LOCAL = "invocationLocal";
      Be.INVOCATION_SUBGROUP = "invocationSubgroup";
      Be.DRAW = "draw";
      const fU = z(Be, Be.VERTEX), u0 = z(Be, Be.INSTANCE);
      Be.SUBGROUP;
      Be.INVOCATION_SUBGROUP;
      Be.INVOCATION_LOCAL;
      const pU = z(Be, Be.DRAW);
      class mU extends Q {
        static get type() {
          return "InstanceNode";
        }
        constructor(e, t, i) {
          super("void"), this.count = e, this.instanceMatrix = t, this.instanceColor = i, this.instanceMatrixNode = null, this.instanceColorNode = null, this.updateType = te.FRAME, this.buffer = null, this.bufferColor = null;
        }
        setup(e) {
          const { count: t, instanceMatrix: i, instanceColor: n } = this;
          let { instanceMatrixNode: r, instanceColorNode: a } = this;
          if (r === null) {
            if (t <= 1e3) r = a0(i.array, "mat4", Math.max(t, 1)).element(u0);
            else {
              const o = new VC(i.array, 16, 1);
              this.buffer = o;
              const u = i.usage === Ga ? q_ : H_, c = [
                u(o, "vec4", 16, 0),
                u(o, "vec4", 16, 4),
                u(o, "vec4", 16, 8),
                u(o, "vec4", 16, 12)
              ];
              r = so(...c);
            }
            this.instanceMatrixNode = r;
          }
          if (n && a === null) {
            const o = new cg(n.array, 3), u = n.usage === Ga ? q_ : H_;
            this.bufferColor = o, a = B(u(o, "vec3", 3, 0)), this.instanceColorNode = a;
          }
          const l = r.mul(Et).xyz;
          if (Et.assign(l), e.hasGeometryAttribute("normal")) {
            const o = yD(ls, r);
            ls.assign(o);
          }
          this.instanceColorNode !== null && td("vec3", "vInstanceColor").assign(this.instanceColorNode);
        }
        update() {
          this.instanceMatrix.usage !== Ga && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version && (this.buffer.version = this.instanceMatrix.version), this.instanceColor && this.instanceColor.usage !== Ga && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version && (this.bufferColor.version = this.instanceColor.version);
        }
      }
      class gU extends mU {
        static get type() {
          return "InstancedMeshNode";
        }
        constructor(e) {
          const { count: t, instanceMatrix: i, instanceColor: n } = e;
          super(t, i, n), this.instancedMesh = e;
        }
      }
      const yU = U(gU);
      class xU extends Q {
        static get type() {
          return "BatchNode";
        }
        constructor(e) {
          super("void"), this.batchMesh = e, this.batchingIdNode = null;
        }
        setup(e) {
          this.batchingIdNode === null && (e.getDrawIndex() === null ? this.batchingIdNode = u0 : this.batchingIdNode = pU);
          const i = O(([p]) => {
            const g = Gl(Pi(this.batchMesh._indirectTexture), 0), _ = He(p).modInt(He(g)), m = He(p).div(He(g));
            return Pi(this.batchMesh._indirectTexture, Ns(_, m)).x;
          }).setLayout({
            name: "getIndirectIndex",
            type: "uint",
            inputs: [
              {
                name: "id",
                type: "int"
              }
            ]
          })(He(this.batchingIdNode)), n = this.batchMesh._matricesTexture, r = Gl(Pi(n), 0), a = C(i).mul(4).toInt().toVar(), l = a.modInt(r), o = a.div(He(r)), u = so(Pi(n, Ns(l, o)), Pi(n, Ns(l.add(1), o)), Pi(n, Ns(l.add(2), o)), Pi(n, Ns(l.add(3), o))), c = this.batchMesh._colorsTexture;
          if (c !== null) {
            const g = O(([_]) => {
              const m = Gl(Pi(c), 0).x, y = _, x = y.modInt(m), b = y.div(m);
              return Pi(c, Ns(x, b)).rgb;
            }).setLayout({
              name: "getBatchingColor",
              type: "vec3",
              inputs: [
                {
                  name: "id",
                  type: "int"
                }
              ]
            })(i);
            td("vec3", "vBatchColor").assign(g);
          }
          const h = Gt(u);
          Et.assign(u.mul(Et));
          const d = ls.div(B(h[0].dot(h[0]), h[1].dot(h[1]), h[2].dot(h[2]))), f = h.mul(d).xyz;
          ls.assign(f), e.hasGeometryAttribute("tangent") && l0.mulAssign(h);
        }
      }
      const _U = U(xU), Z_ = /* @__PURE__ */ new WeakMap();
      class bU extends Q {
        static get type() {
          return "SkinningNode";
        }
        constructor(e, t = false) {
          super("void"), this.skinnedMesh = e, this.useReference = t, this.updateType = te.OBJECT, this.skinIndexNode = Qs("skinIndex", "uvec4"), this.skinWeightNode = Qs("skinWeight", "vec4");
          let i, n, r;
          t ? (i = Se("bindMatrix", "mat4"), n = Se("bindMatrixInverse", "mat4"), r = W_("skeleton.boneMatrices", "mat4", e.skeleton.bones.length)) : (i = Z(e.bindMatrix, "mat4"), n = Z(e.bindMatrixInverse, "mat4"), r = a0(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length)), this.bindMatrixNode = i, this.bindMatrixInverseNode = n, this.boneMatricesNode = r, this.previousBoneMatricesNode = null;
        }
        getSkinnedPosition(e = this.boneMatricesNode, t = Et) {
          const { skinIndexNode: i, skinWeightNode: n, bindMatrixNode: r, bindMatrixInverseNode: a } = this, l = e.element(i.x), o = e.element(i.y), u = e.element(i.z), c = e.element(i.w), h = r.mul(t), d = Pt(l.mul(n.x).mul(h), o.mul(n.y).mul(h), u.mul(n.z).mul(h), c.mul(n.w).mul(h));
          return a.mul(d).xyz;
        }
        getSkinnedNormal(e = this.boneMatricesNode, t = ls) {
          const { skinIndexNode: i, skinWeightNode: n, bindMatrixNode: r, bindMatrixInverseNode: a } = this, l = e.element(i.x), o = e.element(i.y), u = e.element(i.z), c = e.element(i.w);
          let h = Pt(n.x.mul(l), n.y.mul(o), n.z.mul(u), n.w.mul(c));
          return h = a.mul(h).mul(r), h.transformDirection(t).xyz;
        }
        getPreviousSkinnedPosition(e) {
          const t = e.object;
          return this.previousBoneMatricesNode === null && (t.skeleton.previousBoneMatrices = new Float32Array(t.skeleton.boneMatrices), this.previousBoneMatricesNode = W_("skeleton.previousBoneMatrices", "mat4", t.skeleton.bones.length)), this.getSkinnedPosition(this.previousBoneMatricesNode, Y_);
        }
        needsPreviousBoneMatrices(e) {
          const t = e.renderer.getMRT();
          return t && t.has("velocity") || Wv(e.object).useVelocity === true;
        }
        setup(e) {
          this.needsPreviousBoneMatrices(e) && Y_.assign(this.getPreviousSkinnedPosition(e));
          const t = this.getSkinnedPosition();
          if (Et.assign(t), e.hasGeometryAttribute("normal")) {
            const i = this.getSkinnedNormal();
            ls.assign(i), e.hasGeometryAttribute("tangent") && l0.assign(i);
          }
        }
        generate(e, t) {
          if (t !== "void") return Et.build(e, t);
        }
        update(e) {
          const i = (this.useReference ? e.object : this.skinnedMesh).skeleton;
          Z_.get(i) !== e.frameId && (Z_.set(i, e.frameId), this.previousBoneMatricesNode !== null && i.previousBoneMatrices.set(i.boneMatrices), i.update());
        }
      }
      const SU = (s) => F(new bU(s, true));
      class TU extends Q {
        static get type() {
          return "LoopNode";
        }
        constructor(e = []) {
          super(), this.params = e;
        }
        getVarName(e) {
          return String.fromCharCode(105 + e);
        }
        getProperties(e) {
          const t = e.getNodeProperties(this);
          if (t.stackNode !== void 0) return t;
          const i = {};
          for (let r = 0, a = this.params.length - 1; r < a; r++) {
            const l = this.params[r], o = l.isNode !== true && l.name || this.getVarName(r), u = l.isNode !== true && l.type || "int";
            i[o] = pu(o, u);
          }
          const n = e.addStack();
          return t.returnsNode = this.params[this.params.length - 1](i, n, e), t.stackNode = n, e.removeStack(), t;
        }
        getNodeType(e) {
          const { returnsNode: t } = this.getProperties(e);
          return t ? t.getNodeType(e) : "void";
        }
        setup(e) {
          this.getProperties(e);
        }
        generate(e) {
          const t = this.getProperties(e), i = this.params, n = t.stackNode;
          for (let l = 0, o = i.length - 1; l < o; l++) {
            const u = i[l];
            let c = null, h = null, d = null, f = null, p = null, g = null;
            u.isNode ? (f = "int", d = this.getVarName(l), c = "0", h = u.build(e, f), p = "<") : (f = u.type || "int", d = u.name || this.getVarName(l), c = u.start, h = u.end, p = u.condition, g = u.update, typeof c == "number" ? c = e.generateConst(f, c) : c && c.isNode && (c = c.build(e, f)), typeof h == "number" ? h = e.generateConst(f, h) : h && h.isNode && (h = h.build(e, f)), c !== void 0 && h === void 0 ? (c = c + " - 1", h = "0", p = ">=") : h !== void 0 && c === void 0 && (c = "0", p = "<"), p === void 0 && (Number(c) > Number(h) ? p = ">=" : p = "<"));
            const _ = {
              start: c,
              end: h,
              condition: p
            }, m = _.start, y = _.end;
            let x = "", b = "", T = "";
            g || (f === "int" || f === "uint" ? p.includes("<") ? g = "++" : g = "--" : p.includes("<") ? g = "+= 1." : g = "-= 1."), x += e.getVar(f, d) + " = " + m, b += d + " " + p + " " + y, T += d + " " + g;
            const N = `for ( ${x}; ${b}; ${T} )`;
            e.addFlowCode((l === 0 ? `
` : "") + e.tab + N + ` {

`).addFlowTab();
          }
          const r = n.build(e, "void"), a = t.returnsNode ? t.returnsNode.build(e) : "";
          e.removeFlowTab().addFlowCode(`
` + e.tab + r);
          for (let l = 0, o = this.params.length - 1; l < o; l++) e.addFlowCode((l === 0 ? "" : e.tab) + `}

`).removeFlowTab();
          return e.addFlowTab(), a;
        }
      }
      const qi = (...s) => F(new TU(io(s, "int"))).append(), vU = () => pu("break").append(), up = /* @__PURE__ */ new WeakMap(), si = new Te(), Q_ = O(({ bufferMap: s, influence: e, stride: t, width: i, depth: n, offset: r }) => {
        const a = He(fU).mul(t).add(r), l = a.div(i), o = a.sub(l.mul(i));
        return Pi(s, Ns(o, l)).depth(n).mul(e);
      });
      function MU(s) {
        const e = s.morphAttributes.position !== void 0, t = s.morphAttributes.normal !== void 0, i = s.morphAttributes.color !== void 0, n = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color, r = n !== void 0 ? n.length : 0;
        let a = up.get(s);
        if (a === void 0 || a.count !== r) {
          let m = function() {
            g.dispose(), up.delete(s), s.removeEventListener("dispose", m);
          };
          a !== void 0 && a.texture.dispose();
          const l = s.morphAttributes.position || [], o = s.morphAttributes.normal || [], u = s.morphAttributes.color || [];
          let c = 0;
          e === true && (c = 1), t === true && (c = 2), i === true && (c = 3);
          let h = s.attributes.position.count * c, d = 1;
          const f = 4096;
          h > f && (d = Math.ceil(h / f), h = f);
          const p = new Float32Array(h * d * 4 * r), g = new JR(p, h, d, r);
          g.type = Yt, g.needsUpdate = true;
          const _ = c * 4;
          for (let y = 0; y < r; y++) {
            const x = l[y], b = o[y], T = u[y], N = h * d * 4 * y;
            for (let A = 0; A < x.count; A++) {
              const w = A * _;
              e === true && (si.fromBufferAttribute(x, A), p[N + w + 0] = si.x, p[N + w + 1] = si.y, p[N + w + 2] = si.z, p[N + w + 3] = 0), t === true && (si.fromBufferAttribute(b, A), p[N + w + 4] = si.x, p[N + w + 5] = si.y, p[N + w + 6] = si.z, p[N + w + 7] = 0), i === true && (si.fromBufferAttribute(T, A), p[N + w + 8] = si.x, p[N + w + 9] = si.y, p[N + w + 10] = si.z, p[N + w + 11] = T.itemSize === 4 ? si.w : 1);
            }
          }
          a = {
            count: r,
            texture: g,
            stride: c,
            size: new q(h, d)
          }, up.set(s, a), s.addEventListener("dispose", m);
        }
        return a;
      }
      class AU extends Q {
        static get type() {
          return "MorphNode";
        }
        constructor(e) {
          super("void"), this.mesh = e, this.morphBaseInfluence = Z(1), this.updateType = te.OBJECT;
        }
        setup(e) {
          const { geometry: t } = e, i = t.morphAttributes.position !== void 0, n = t.hasAttribute("normal") && t.morphAttributes.normal !== void 0, r = t.morphAttributes.position || t.morphAttributes.normal || t.morphAttributes.color, a = r !== void 0 ? r.length : 0, { texture: l, stride: o, size: u } = MU(t);
          i === true && Et.mulAssign(this.morphBaseInfluence), n === true && ls.mulAssign(this.morphBaseInfluence);
          const c = He(u.width);
          qi(a, ({ i: h }) => {
            const d = C(0).toVar();
            this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0 ? d.assign(Pi(this.mesh.morphTexture, Ns(He(h).add(1), He(u0))).r) : d.assign(Se("morphTargetInfluences", "float").element(h).toVar()), i === true && Et.addAssign(Q_({
              bufferMap: l,
              influence: d,
              stride: o,
              width: c,
              depth: h,
              offset: He(0)
            })), n === true && ls.addAssign(Q_({
              bufferMap: l,
              influence: d,
              stride: o,
              width: c,
              depth: h,
              offset: He(1)
            }));
          });
        }
        update() {
          const e = this.morphBaseInfluence;
          this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((t, i) => t + i, 0);
        }
      }
      const NU = U(AU);
      class Go extends Q {
        static get type() {
          return "LightingNode";
        }
        constructor() {
          super("vec3"), this.isLightingNode = true;
        }
      }
      class wU extends Go {
        static get type() {
          return "AONode";
        }
        constructor(e = null) {
          super(), this.aoNode = e;
        }
        setup(e) {
          e.context.ambientOcclusion.mulAssign(this.aoNode);
        }
      }
      class EU extends bM {
        static get type() {
          return "LightingContextNode";
        }
        constructor(e, t = null, i = null, n = null) {
          super(e), this.lightingModel = t, this.backdropNode = i, this.backdropAlphaNode = n, this._value = null;
        }
        getContext() {
          const { backdropNode: e, backdropAlphaNode: t } = this, i = B().toVar("directDiffuse"), n = B().toVar("directSpecular"), r = B().toVar("indirectDiffuse"), a = B().toVar("indirectSpecular"), l = {
            directDiffuse: i,
            directSpecular: n,
            indirectDiffuse: r,
            indirectSpecular: a
          };
          return {
            radiance: B().toVar("radiance"),
            irradiance: B().toVar("irradiance"),
            iblIrradiance: B().toVar("iblIrradiance"),
            ambientOcclusion: C(1).toVar("ambientOcclusion"),
            reflectedLight: l,
            backdrop: e,
            backdropAlpha: t
          };
        }
        setup(e) {
          return this.value = this._value || (this._value = this.getContext()), this.value.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
        }
      }
      const RU = U(EU);
      class CU extends Go {
        static get type() {
          return "IrradianceNode";
        }
        constructor(e) {
          super(), this.node = e;
        }
        setup(e) {
          e.context.irradiance.addAssign(this.node);
        }
      }
      let il, sl;
      class Ze extends Q {
        static get type() {
          return "ScreenNode";
        }
        constructor(e) {
          super(), this.scope = e, this.isViewportNode = true;
        }
        getNodeType() {
          return this.scope === Ze.VIEWPORT ? "vec4" : "vec2";
        }
        getUpdateType() {
          let e = te.NONE;
          return (this.scope === Ze.SIZE || this.scope === Ze.VIEWPORT) && (e = te.RENDER), this.updateType = e, e;
        }
        update({ renderer: e }) {
          const t = e.getRenderTarget();
          this.scope === Ze.VIEWPORT ? t !== null ? sl.copy(t.viewport) : (e.getViewport(sl), sl.multiplyScalar(e.getPixelRatio())) : t !== null ? (il.width = t.width, il.height = t.height) : e.getDrawingBufferSize(il);
        }
        setup() {
          const e = this.scope;
          let t = null;
          return e === Ze.SIZE ? t = Z(il || (il = new q())) : e === Ze.VIEWPORT ? t = Z(sl || (sl = new Te())) : t = L(qd.div(yg)), t;
        }
        generate(e) {
          if (this.scope === Ze.COORDINATE) {
            let t = e.getFragCoord();
            if (e.isFlipY()) {
              const i = e.getNodeProperties(yg).outputNode.build(e);
              t = `${e.getType("vec2")}( ${t}.x, ${i}.y - ${t}.y )`;
            }
            return t;
          }
          return super.generate(e);
        }
      }
      Ze.COORDINATE = "coordinate";
      Ze.VIEWPORT = "viewport";
      Ze.SIZE = "size";
      Ze.UV = "uv";
      const yu = z(Ze, Ze.UV), yg = z(Ze, Ze.SIZE), qd = z(Ze, Ze.COORDINATE), OM = z(Ze, Ze.VIEWPORT);
      OM.zw;
      OM.xy;
      const nl = new q();
      class zM extends Gu {
        static get type() {
          return "ViewportTextureNode";
        }
        constructor(e = yu, t = null, i = null) {
          i === null && (i = new AC(), i.minFilter = Ps), super(i, e, t), this.generateMipmaps = false, this.isOutputTextureNode = true, this.updateBeforeType = te.FRAME;
        }
        updateBefore(e) {
          const t = e.renderer;
          t.getDrawingBufferSize(nl);
          const i = this.value;
          (i.image.width !== nl.width || i.image.height !== nl.height) && (i.image.width = nl.width, i.image.height = nl.height, i.needsUpdate = true);
          const n = i.generateMipmaps;
          i.generateMipmaps = this.generateMipmaps, t.copyFramebufferToTexture(i), i.generateMipmaps = n;
        }
        clone() {
          const e = new this.constructor(this.uvNode, this.levelNode, this.value);
          return e.generateMipmaps = this.generateMipmaps, e;
        }
      }
      const LM = U(zM, null, null, {
        generateMipmaps: true
      });
      let cp = null;
      class BU extends zM {
        static get type() {
          return "ViewportDepthTextureNode";
        }
        constructor(e = yu, t = null) {
          cp === null && (cp = new zo()), super(e, t, cp);
        }
      }
      const DU = U(BU);
      class jt extends Q {
        static get type() {
          return "ViewportDepthNode";
        }
        constructor(e, t = null) {
          super("float"), this.scope = e, this.valueNode = t, this.isViewportDepthNode = true;
        }
        generate(e) {
          const { scope: t } = this;
          return t === jt.DEPTH_BASE ? e.getFragDepth() : super.generate(e);
        }
        setup({ camera: e }) {
          const { scope: t } = this, i = this.valueNode;
          let n = null;
          if (t === jt.DEPTH_BASE) i !== null && (n = kM().assign(i));
          else if (t === jt.DEPTH) e.isPerspectiveCamera ? n = UU(Ke.z, pr, mr) : n = Pl(Ke.z, pr, mr);
          else if (t === jt.LINEAR_DEPTH) if (i !== null) if (e.isPerspectiveCamera) {
            const r = GM(i, pr, mr);
            n = Pl(r, pr, mr);
          } else n = i;
          else n = Pl(Ke.z, pr, mr);
          return n;
        }
      }
      jt.DEPTH_BASE = "depthBase";
      jt.DEPTH = "depth";
      jt.LINEAR_DEPTH = "linearDepth";
      const Pl = (s, e, t) => s.add(e).div(e.sub(t)), UU = (s, e, t) => e.add(s).mul(t).div(t.sub(e).mul(s)), GM = (s, e, t) => e.mul(t).div(t.sub(e).mul(s).sub(t)), PM = (s, e, t) => {
        e = e.max(1e-6).toVar();
        const i = Hs(s.negate().div(e)), n = Hs(t.div(e));
        return i.div(n);
      }, kM = U(jt, jt.DEPTH_BASE), IM = z(jt, jt.DEPTH), FU = U(jt, jt.LINEAR_DEPTH);
      DU();
      IM.assign = (s) => kM(s);
      class OU extends Q {
        constructor(e) {
          super("float"), this.name = e, this.isBuiltinNode = true;
        }
        generate() {
          return this.name;
        }
      }
      const zU = U(OU);
      class Bi extends Q {
        static get type() {
          return "ClippingNode";
        }
        constructor(e = Bi.DEFAULT) {
          super(), this.scope = e;
        }
        setup(e) {
          super.setup(e);
          const t = e.clippingContext, { intersectionPlanes: i, unionPlanes: n } = t;
          return this.hardwareClipping = e.material.hardwareClipping, this.scope === Bi.ALPHA_TO_COVERAGE ? this.setupAlphaToCoverage(i, n) : this.scope === Bi.HARDWARE ? this.setupHardwareClipping(n, e) : this.setupDefault(i, n);
        }
        setupAlphaToCoverage(e, t) {
          return O(() => {
            const i = C().toVar("distanceToPlane"), n = C().toVar("distanceToGradient"), r = C(1).toVar("clipOpacity"), a = t.length;
            if (this.hardwareClipping === false && a > 0) {
              const o = An(t);
              qi(a, ({ i: u }) => {
                const c = o.element(u);
                i.assign(Ke.dot(c.xyz).negate().add(c.w)), n.assign(i.fwidth().div(2)), r.mulAssign(Gr(n.negate(), n, i));
              });
            }
            const l = e.length;
            if (l > 0) {
              const o = An(e), u = C(1).toVar("intersectionClipOpacity");
              qi(l, ({ i: c }) => {
                const h = o.element(c);
                i.assign(Ke.dot(h.xyz).negate().add(h.w)), n.assign(i.fwidth().div(2)), u.mulAssign(Gr(n.negate(), n, i).oneMinus());
              }), r.mulAssign(u.oneMinus());
            }
            ye.a.mulAssign(r), ye.a.equal(0).discard();
          })();
        }
        setupDefault(e, t) {
          return O(() => {
            const i = t.length;
            if (this.hardwareClipping === false && i > 0) {
              const r = An(t);
              qi(i, ({ i: a }) => {
                const l = r.element(a);
                Ke.dot(l.xyz).greaterThan(l.w).discard();
              });
            }
            const n = e.length;
            if (n > 0) {
              const r = An(e), a = Kv(true).toVar("clipped");
              qi(n, ({ i: l }) => {
                const o = r.element(l);
                a.assign(Ke.dot(o.xyz).greaterThan(o.w).and(a));
              }), a.discard();
            }
          })();
        }
        setupHardwareClipping(e, t) {
          const i = e.length;
          return t.enableHardwareClipping(i), O(() => {
            const n = An(e), r = zU(t.getClipDistance());
            qi(i, ({ i: a }) => {
              const l = n.element(a), o = Ke.dot(l.xyz).sub(l.w).negate();
              r.element(a).assign(o);
            });
          })();
        }
      }
      Bi.ALPHA_TO_COVERAGE = "alphaToCoverage";
      Bi.DEFAULT = "default";
      Bi.HARDWARE = "hardware";
      const LU = () => F(new Bi()), GU = () => F(new Bi(Bi.ALPHA_TO_COVERAGE)), PU = () => F(new Bi(Bi.HARDWARE)), kU = 0.05, K_ = O(([s]) => Jn(ae(1e4, Vi(ae(17, s.x).add(ae(0.1, s.y)))).mul(Pt(0.1, Mi(Vi(ae(13, s.y).add(s.x))))))), J_ = O(([s]) => K_(L(K_(s.xy), s.z))), IU = O(([s]) => {
        const e = Qt(Hn(fM(s.xyz)), Hn(pM(s.xyz))), t = C(1).div(C(kU).mul(e)).toVar("pixScale"), i = L(hu(wr(Hs(t))), hu(Qy(Hs(t)))), n = L(J_(wr(i.x.mul(s.xyz))), J_(wr(i.y.mul(s.xyz)))), r = Jn(Hs(t)), a = Pt(ae(r.oneMinus(), n.x), ae(r, n.y)), l = fu(r, r.oneMinus()), o = B(a.mul(a).div(ae(2, l).mul(qt(1, l))), a.sub(ae(0.5, l)).div(qt(1, l)), qt(1, qt(1, a).mul(qt(1, a)).div(ae(2, l).mul(qt(1, l))))), u = a.lessThan(l.oneMinus()).select(a.lessThan(l).select(o.x, o.y), o.z);
        return Zs(u, 1e-6, 1);
      }).setLayout({
        name: "getAlphaHashThreshold",
        type: "float",
        inputs: [
          {
            name: "position",
            type: "vec3"
          }
        ]
      });
      class tt extends Zt {
        static get type() {
          return "NodeMaterial";
        }
        get type() {
          return this.constructor.type;
        }
        set type(e) {
        }
        constructor() {
          super(), this.isNodeMaterial = true, this.fog = true, this.lights = false, this.hardwareClipping = false, this.lightsNode = null, this.envNode = null, this.aoNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.geometryNode = null, this.depthNode = null, this.shadowPositionNode = null, this.receivedShadowNode = null, this.castShadowNode = null, this.outputNode = null, this.mrtNode = null, this.fragmentNode = null, this.vertexNode = null;
        }
        customProgramCacheKey() {
          return this.type + qv(this);
        }
        build(e) {
          this.setup(e);
        }
        setupObserver(e) {
          return new WC(e);
        }
        setup(e) {
          e.context.setupNormal = () => this.setupNormal(e), e.context.setupPositionView = () => this.setupPositionView(e), e.context.setupModelViewProjection = () => this.setupModelViewProjection(e);
          const t = e.renderer, i = t.getRenderTarget();
          e.addStack();
          const n = this.vertexNode || this.setupVertex(e);
          e.stack.outputNode = n, this.setupHardwareClipping(e), this.geometryNode !== null && (e.stack.outputNode = e.stack.outputNode.bypass(this.geometryNode)), e.addFlow("vertex", e.removeStack()), e.addStack();
          let r;
          const a = this.setupClipping(e);
          if ((this.depthWrite === true || this.depthTest === true) && (i !== null ? i.depthBuffer === true && this.setupDepth(e) : t.depth === true && this.setupDepth(e)), this.fragmentNode === null) {
            this.setupDiffuseColor(e), this.setupVariants(e);
            const l = this.setupLighting(e);
            a !== null && e.stack.add(a);
            const o = X(l, ye.a).max(0);
            if (r = this.setupOutput(e, o), rd.assign(r), this.outputNode !== null && (r = this.outputNode), i !== null) {
              const u = t.getMRT(), c = this.mrtNode;
              u !== null ? (r = u, c !== null && (r = u.merge(c))) : c !== null && (r = c);
            }
          } else {
            let l = this.fragmentNode;
            l.isOutputStructNode !== true && (l = X(l)), r = this.setupOutput(e, l);
          }
          e.stack.outputNode = r, e.addFlow("fragment", e.removeStack()), e.monitor = this.setupObserver(e);
        }
        setupClipping(e) {
          if (e.clippingContext === null) return null;
          const { unionPlanes: t, intersectionPlanes: i } = e.clippingContext;
          let n = null;
          if (t.length > 0 || i.length > 0) {
            const r = e.renderer.samples;
            this.alphaToCoverage && r > 1 ? n = GU() : e.stack.add(LU());
          }
          return n;
        }
        setupHardwareClipping(e) {
          if (this.hardwareClipping = false, e.clippingContext === null) return;
          const t = e.clippingContext.unionPlanes.length;
          t > 0 && t <= 8 && e.isAvailable("clipDistance") && (e.stack.add(PU()), this.hardwareClipping = true);
        }
        setupDepth(e) {
          const { renderer: t, camera: i } = e;
          let n = this.depthNode;
          if (n === null) {
            const r = t.getMRT();
            r && r.has("depth") ? n = r.get("depth") : t.logarithmicDepthBuffer === true && (i.isPerspectiveCamera ? n = PM(Ke.z, pr, mr) : n = Pl(Ke.z, pr, mr));
          }
          n !== null && IM.assign(n).append();
        }
        setupPositionView() {
          return s0.mul(Et).xyz;
        }
        setupModelViewProjection() {
          return i0.mul(Ke);
        }
        setupVertex(e) {
          return e.addStack(), this.setupPosition(e), e.context.vertex = e.removeStack(), FM;
        }
        setupPosition(e) {
          const { object: t, geometry: i } = e;
          if ((i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color) && NU(t).append(), t.isSkinnedMesh === true && SU(t).append(), this.displacementMap) {
            const n = Nn("displacementMap", "texture"), r = Nn("displacementScale", "float"), a = Nn("displacementBias", "float");
            Et.addAssign(ls.normalize().mul(n.x.mul(r).add(a)));
          }
          return t.isBatchedMesh && _U(t).append(), t.isInstancedMesh && t.instanceMatrix && t.instanceMatrix.isInstancedBufferAttribute === true && yU(t).append(), this.positionNode !== null && Et.assign(this.positionNode.context({
            isPositionNodeInput: true
          })), Et;
        }
        setupDiffuseColor({ object: e, geometry: t }) {
          let i = this.colorNode ? X(this.colorNode) : GD;
          this.vertexColors === true && t.hasAttribute("color") && (i = X(i.xyz.mul(Qs("color", "vec3")), i.a)), e.instanceColor && (i = td("vec3", "vInstanceColor").mul(i)), e.isBatchedMesh && e._colorsTexture && (i = td("vec3", "vBatchColor").mul(i)), ye.assign(i);
          const n = this.opacityNode ? C(this.opacityNode) : DM;
          if (ye.a.assign(ye.a.mul(n)), this.alphaTestNode !== null || this.alphaTest > 0) {
            const r = this.alphaTestNode !== null ? C(this.alphaTestNode) : LD;
            ye.a.lessThanEqual(r).discard();
          }
          this.alphaHash === true && ye.a.lessThan(IU(Et)).discard(), this.transparent === false && this.blending === kn && this.alphaToCoverage === false && ye.a.assign(1);
        }
        setupVariants() {
        }
        setupOutgoingLight() {
          return this.lights === true ? B(0) : ye.rgb;
        }
        setupNormal() {
          return this.normalNode ? B(this.normalNode) : YD;
        }
        setupEnvironment() {
          let e = null;
          return this.envNode ? e = this.envNode : this.envMap && (e = this.envMap.isCubeTexture ? Nn("envMap", "cubeTexture") : Nn("envMap", "texture")), e;
        }
        setupLightMap(e) {
          let t = null;
          return e.material.lightMap && (t = new CU(UM)), t;
        }
        setupLights(e) {
          const t = [], i = this.setupEnvironment(e);
          i && i.isLightingNode && t.push(i);
          const n = this.setupLightMap(e);
          if (n && n.isLightingNode && t.push(n), this.aoNode !== null || e.material.aoMap) {
            const a = this.aoNode !== null ? this.aoNode : dU;
            t.push(new wU(a));
          }
          let r = this.lightsNode || e.lightsNode;
          return t.length > 0 && (r = e.renderer.lighting.createNode([
            ...r.getLights(),
            ...t
          ])), r;
        }
        setupLightingModel() {
        }
        setupLighting(e) {
          const { material: t } = e, { backdropNode: i, backdropAlphaNode: n, emissiveNode: r } = this, l = this.lights === true || this.lightsNode !== null ? this.setupLights(e) : null;
          let o = this.setupOutgoingLight(e);
          if (l && l.getScope().hasLights) {
            const u = this.setupLightingModel(e);
            o = RU(l, u, i, n);
          } else i !== null && (o = B(n !== null ? Ce(o, i, n) : i));
          return (r && r.isNode === true || t.emissive && t.emissive.isColor === true) && (I_.assign(B(r || kD)), o = o.add(I_)), o;
        }
        setupOutput(e, t) {
          if (this.fog === true) {
            const i = e.fogNode;
            i && (rd.assign(t), t = X(i));
          }
          return t;
        }
        setDefaultValues(e) {
          for (const i in e) {
            const n = e[i];
            this[i] === void 0 && (this[i] = n, n && n.clone && (this[i] = n.clone()));
          }
          const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
          for (const i in t) Object.getOwnPropertyDescriptor(this.constructor.prototype, i) === void 0 && t[i].get !== void 0 && Object.defineProperty(this.constructor.prototype, i, t[i]);
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = {
            textures: {},
            images: {},
            nodes: {}
          });
          const i = Zt.prototype.toJSON.call(this, e), n = Kh(this);
          i.inputNodes = {};
          for (const { property: a, childNode: l } of n) i.inputNodes[a] = l.toJSON(e).uuid;
          function r(a) {
            const l = [];
            for (const o in a) {
              const u = a[o];
              delete u.metadata, l.push(u);
            }
            return l;
          }
          if (t) {
            const a = r(e.textures), l = r(e.images), o = r(e.nodes);
            a.length > 0 && (i.textures = a), l.length > 0 && (i.images = l), o.length > 0 && (i.nodes = o);
          }
          return i;
        }
        copy(e) {
          return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.positionNode = e.positionNode, this.geometryNode = e.geometryNode, this.depthNode = e.depthNode, this.shadowPositionNode = e.shadowPositionNode, this.receivedShadowNode = e.receivedShadowNode, this.castShadowNode = e.castShadowNode, this.outputNode = e.outputNode, this.mrtNode = e.mrtNode, this.fragmentNode = e.fragmentNode, this.vertexNode = e.vertexNode, super.copy(e);
        }
      }
      const VU = new Od();
      class HU extends tt {
        static get type() {
          return "LineBasicNodeMaterial";
        }
        constructor(e) {
          super(), this.isLineBasicNodeMaterial = true, this.setDefaultValues(VU), this.setValues(e);
        }
      }
      const qU = new UC();
      class YU extends tt {
        static get type() {
          return "LineDashedNodeMaterial";
        }
        constructor(e) {
          super(), this.isLineDashedNodeMaterial = true, this.setDefaultValues(qU), this.dashOffset = 0, this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
        }
        setupVariants() {
          const e = this.offsetNode ? C(this.offsetNode) : cU, t = this.dashScaleNode ? C(this.dashScaleNode) : oU, i = this.dashSizeNode ? C(this.dashSizeNode) : lU, n = this.gapSizeNode ? C(this.gapSizeNode) : uU;
          op.assign(i), V_.assign(n);
          const r = sn(Qs("lineDistance").mul(t));
          (e ? r.add(e) : r).mod(op.add(V_)).greaterThan(op).discard();
        }
      }
      const WU = (s) => F(s).mul(0.5).add(0.5), jU = new CC();
      class $U extends tt {
        static get type() {
          return "MeshNormalNodeMaterial";
        }
        constructor(e) {
          super(), this.isMeshNormalNodeMaterial = true, this.setDefaultValues(jU), this.setValues(e);
        }
        setupDiffuseColor() {
          const e = this.opacityNode ? C(this.opacityNode) : DM;
          ye.assign(X(WU(Qe), e));
        }
      }
      class XU extends ct {
        static get type() {
          return "EquirectUVNode";
        }
        constructor(e = AM) {
          super("vec2"), this.dirNode = e;
        }
        setup() {
          const e = this.dirNode, t = e.z.atan(e.x).mul(1 / (Math.PI * 2)).add(0.5), i = e.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
          return L(t, i);
        }
      }
      const VM = U(XU);
      class HM extends gC {
        constructor(e = 1, t = {}) {
          super(e, t), this.isCubeRenderTarget = true;
        }
        fromEquirectangularTexture(e, t) {
          const i = t.minFilter, n = t.generateMipmaps;
          t.generateMipmaps = true, this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
          const r = new Oo(5, 5, 5), a = VM(AM), l = new tt();
          l.colorNode = fe(t, a, 0), l.side = Fi, l.blending = xo;
          const o = new as(r, l), u = new zy();
          u.add(o), t.minFilter === Ps && (t.minFilter = pi);
          const c = new Lv(1, 10, this), h = e.getMRT();
          return e.setMRT(null), c.update(e, u), e.setMRT(h), t.minFilter = i, t.currentGenerateMipmaps = n, o.geometry.dispose(), o.material.dispose(), this;
        }
      }
      const kl = /* @__PURE__ */ new WeakMap();
      class ZU extends ct {
        static get type() {
          return "CubeMapNode";
        }
        constructor(e) {
          super("vec3"), this.envNode = e, this._cubeTexture = null, this._cubeTextureNode = gu();
          const t = new Oy();
          t.isRenderTargetTexture = true, this._defaultTexture = t, this.updateBeforeType = te.RENDER;
        }
        updateBefore(e) {
          const { renderer: t, material: i } = e, n = this.envNode;
          if (n.isTextureNode || n.isMaterialReferenceNode) {
            const r = n.isTextureNode ? n.value : i[n.property];
            if (r && r.isTexture) {
              const a = r.mapping;
              if (a === Du || a === Uu) {
                if (kl.has(r)) {
                  const l = kl.get(r);
                  eb(l, r.mapping), this._cubeTexture = l;
                } else {
                  const l = r.image;
                  if (QU(l)) {
                    const o = new HM(l.height);
                    o.fromEquirectangularTexture(t, r), eb(o.texture, r.mapping), this._cubeTexture = o.texture, kl.set(r, o.texture), r.addEventListener("dispose", qM);
                  } else this._cubeTexture = this._defaultTexture;
                }
                this._cubeTextureNode.value = this._cubeTexture;
              } else this._cubeTextureNode = this.envNode;
            }
          }
        }
        setup(e) {
          return this.updateBefore(e), this._cubeTextureNode;
        }
      }
      function QU(s) {
        return s == null ? false : s.height > 0;
      }
      function qM(s) {
        const e = s.target;
        e.removeEventListener("dispose", qM);
        const t = kl.get(e);
        t !== void 0 && (kl.delete(e), t.dispose());
      }
      function eb(s, e) {
        e === Du ? s.mapping = Fr : e === Uu && (s.mapping = _o);
      }
      const YM = U(ZU);
      class c0 extends Go {
        static get type() {
          return "BasicEnvironmentNode";
        }
        constructor(e = null) {
          super(), this.envNode = e;
        }
        setup(e) {
          e.context.environment = YM(this.envNode);
        }
      }
      class KU extends Go {
        static get type() {
          return "BasicLightMapNode";
        }
        constructor(e = null) {
          super(), this.lightMapNode = e;
        }
        setup(e) {
          const t = C(1 / Math.PI);
          e.context.irradianceLightMap = this.lightMapNode.mul(t);
        }
      }
      class Yd {
        start() {
        }
        finish() {
        }
        direct() {
        }
        directRectArea() {
        }
        indirect() {
        }
        ambientOcclusion() {
        }
      }
      class WM extends Yd {
        constructor() {
          super();
        }
        indirect(e, t, i) {
          const n = e.ambientOcclusion, r = e.reflectedLight, a = i.context.irradianceLightMap;
          r.indirectDiffuse.assign(X(0)), a ? r.indirectDiffuse.addAssign(a) : r.indirectDiffuse.addAssign(X(1, 1, 1, 0)), r.indirectDiffuse.mulAssign(n), r.indirectDiffuse.mulAssign(ye.rgb);
        }
        finish(e, t, i) {
          const n = i.material, r = e.outgoingLight, a = i.context.environment;
          if (a) switch (n.combine) {
            case Bd:
              r.rgb.assign(Ce(r.rgb, r.rgb.mul(a.rgb), ch.mul(lp)));
              break;
            case J2:
              r.rgb.assign(Ce(r.rgb, a.rgb, ch.mul(lp)));
              break;
            case eR:
              r.rgb.addAssign(a.rgb.mul(ch.mul(lp)));
              break;
            default:
              console.warn("THREE.BasicLightingModel: Unsupported .combine value:", n.combine);
              break;
          }
        }
      }
      const JU = new Fy();
      class eF extends tt {
        static get type() {
          return "MeshBasicNodeMaterial";
        }
        constructor(e) {
          super(), this.isMeshBasicNodeMaterial = true, this.lights = true, this.setDefaultValues(JU), this.setValues(e);
        }
        setupNormal() {
          return Xi;
        }
        setupEnvironment(e) {
          const t = super.setupEnvironment(e);
          return t ? new c0(t) : null;
        }
        setupLightMap(e) {
          let t = null;
          return e.material.lightMap && (t = new KU(UM)), t;
        }
        setupOutgoingLight() {
          return ye.rgb;
        }
        setupLightingModel() {
          return new WM();
        }
      }
      const xu = O(({ f0: s, f90: e, dotVH: t }) => {
        const i = t.mul(-5.55473).sub(6.98316).mul(t).exp2();
        return s.mul(i.oneMinus()).add(e.mul(i));
      }), Mo = O((s) => s.diffuseColor.mul(1 / Math.PI)), tF = () => C(0.25), iF = O(({ dotNH: s }) => mg.mul(C(0.5)).add(1).mul(C(1 / Math.PI)).mul(s.pow(mg))), sF = O(({ lightDirection: s }) => {
        const e = s.add(Ge).normalize(), t = Qe.dot(e).clamp(), i = Ge.dot(e).clamp(), n = xu({
          f0: ri,
          f90: 1,
          dotVH: i
        }), r = tF(), a = iF({
          dotNH: t
        });
        return n.mul(r).mul(a);
      });
      class jM extends WM {
        constructor(e = true) {
          super(), this.specular = e;
        }
        direct({ lightDirection: e, lightColor: t, reflectedLight: i }) {
          const r = Qe.dot(e).clamp().mul(t);
          i.directDiffuse.addAssign(r.mul(Mo({
            diffuseColor: ye.rgb
          }))), this.specular === true && i.directSpecular.addAssign(r.mul(sF({
            lightDirection: e
          })).mul(ch));
        }
        indirect({ ambientOcclusion: e, irradiance: t, reflectedLight: i }) {
          i.indirectDiffuse.addAssign(t.mul(Mo({
            diffuseColor: ye
          }))), i.indirectDiffuse.mulAssign(e);
        }
      }
      const nF = new BC();
      class rF extends tt {
        static get type() {
          return "MeshLambertNodeMaterial";
        }
        constructor(e) {
          super(), this.isMeshLambertNodeMaterial = true, this.lights = true, this.setDefaultValues(nF), this.setValues(e);
        }
        setupEnvironment(e) {
          const t = super.setupEnvironment(e);
          return t ? new c0(t) : null;
        }
        setupLightingModel() {
          return new jM(false);
        }
      }
      const aF = new EC();
      class oF extends tt {
        static get type() {
          return "MeshPhongNodeMaterial";
        }
        constructor(e) {
          super(), this.isMeshPhongNodeMaterial = true, this.lights = true, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(aF), this.setValues(e);
        }
        setupEnvironment(e) {
          const t = super.setupEnvironment(e);
          return t ? new c0(t) : null;
        }
        setupLightingModel() {
          return new jM();
        }
        setupVariants() {
          const e = (this.shininessNode ? C(this.shininessNode) : PD).max(1e-4);
          mg.assign(e);
          const t = this.specularNode || ID;
          ri.assign(t);
        }
        copy(e) {
          return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
        }
      }
      const lF = O((s) => {
        if (s.geometry.hasAttribute("normal") === false) return C(0);
        const e = Xi.dFdx().abs().max(Xi.dFdy().abs());
        return e.x.max(e.y).max(e.z);
      }), $M = O((s) => {
        const { roughness: e } = s, t = lF();
        let i = e.max(0.0525);
        return i = i.add(t), i = i.min(1), i;
      }), uF = O(({ alpha: s, dotNL: e, dotNV: t }) => {
        const i = s.pow2(), n = e.mul(i.add(i.oneMinus().mul(t.pow2())).sqrt()), r = t.mul(i.add(i.oneMinus().mul(e.pow2())).sqrt());
        return Xs(0.5, n.add(r).max(JB));
      }).setLayout({
        name: "V_GGX_SmithCorrelated",
        type: "float",
        inputs: [
          {
            name: "alpha",
            type: "float"
          },
          {
            name: "dotNL",
            type: "float"
          },
          {
            name: "dotNV",
            type: "float"
          }
        ]
      }), cF = O(({ alphaT: s, alphaB: e, dotTV: t, dotBV: i, dotTL: n, dotBL: r, dotNV: a, dotNL: l }) => {
        const o = l.mul(B(s.mul(t), e.mul(i), a).length()), u = a.mul(B(s.mul(n), e.mul(r), l).length());
        return Xs(0.5, o.add(u)).saturate();
      }).setLayout({
        name: "V_GGX_SmithCorrelated_Anisotropic",
        type: "float",
        inputs: [
          {
            name: "alphaT",
            type: "float",
            qualifier: "in"
          },
          {
            name: "alphaB",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotTV",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotBV",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotTL",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotBL",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotNV",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotNL",
            type: "float",
            qualifier: "in"
          }
        ]
      }), hF = O(({ alpha: s, dotNH: e }) => {
        const t = s.pow2(), i = e.pow2().mul(t.oneMinus()).oneMinus();
        return t.div(i.pow2()).mul(1 / Math.PI);
      }).setLayout({
        name: "D_GGX",
        type: "float",
        inputs: [
          {
            name: "alpha",
            type: "float"
          },
          {
            name: "dotNH",
            type: "float"
          }
        ]
      }), dF = C(1 / Math.PI), fF = O(({ alphaT: s, alphaB: e, dotNH: t, dotTH: i, dotBH: n }) => {
        const r = s.mul(e), a = B(e.mul(i), s.mul(n), r.mul(t)), l = a.dot(a), o = r.div(l);
        return dF.mul(r.mul(o.pow2()));
      }).setLayout({
        name: "D_GGX_Anisotropic",
        type: "float",
        inputs: [
          {
            name: "alphaT",
            type: "float",
            qualifier: "in"
          },
          {
            name: "alphaB",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotNH",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotTH",
            type: "float",
            qualifier: "in"
          },
          {
            name: "dotBH",
            type: "float",
            qualifier: "in"
          }
        ]
      }), tb = O((s) => {
        const { lightDirection: e, f0: t, f90: i, roughness: n, f: r, USE_IRIDESCENCE: a, USE_ANISOTROPY: l } = s, o = s.normalView || Qe, u = n.pow2(), c = e.add(Ge).normalize(), h = o.dot(e).clamp(), d = o.dot(Ge).clamp(), f = o.dot(c).clamp(), p = Ge.dot(c).clamp();
        let g = xu({
          f0: t,
          f90: i,
          dotVH: p
        }), _, m;
        if (k_(a) && (g = Xy.mix(g, r)), k_(l)) {
          const y = rh.dot(e), x = rh.dot(Ge), b = rh.dot(c), T = no.dot(e), N = no.dot(Ge), A = no.dot(c);
          _ = cF({
            alphaT: pg,
            alphaB: u,
            dotTV: x,
            dotBV: N,
            dotTL: y,
            dotBL: T,
            dotNV: d,
            dotNL: h
          }), m = fF({
            alphaT: pg,
            alphaB: u,
            dotNH: f,
            dotTH: b,
            dotBH: A
          });
        } else _ = uF({
          alpha: u,
          dotNL: h,
          dotNV: d
        }), m = hF({
          alpha: u,
          dotNH: f
        });
        return g.mul(_).mul(m);
      }), XM = O(({ roughness: s, dotNV: e }) => {
        const t = X(-1, -0.0275, -0.572, 0.022), i = X(1, 0.0425, 1.04, -0.04), n = s.mul(t).add(i), r = n.x.mul(n.x).min(e.mul(-9.28).exp2()).mul(n.x).add(n.y);
        return L(-1.04, 1.04).mul(r).add(n.zw);
      }).setLayout({
        name: "DFGApprox",
        type: "vec2",
        inputs: [
          {
            name: "roughness",
            type: "float"
          },
          {
            name: "dotNV",
            type: "vec3"
          }
        ]
      }), ZM = O((s) => {
        const { dotNV: e, specularColor: t, specularF90: i, roughness: n } = s, r = XM({
          dotNV: e,
          roughness: n
        });
        return t.mul(r.x).add(i.mul(r.y));
      }), pF = O(({ f: s, f90: e, dotVH: t }) => {
        const i = t.oneMinus().saturate(), n = i.mul(i), r = i.mul(n, n).clamp(0, 0.9999);
        return s.sub(B(e).mul(r)).div(r.oneMinus());
      }).setLayout({
        name: "Schlick_to_F0",
        type: "vec3",
        inputs: [
          {
            name: "f",
            type: "vec3"
          },
          {
            name: "f90",
            type: "float"
          },
          {
            name: "dotVH",
            type: "float"
          }
        ]
      }), mF = O(({ roughness: s, dotNH: e }) => {
        const t = s.pow2(), i = C(1).div(t), r = e.pow2().oneMinus().max(78125e-7);
        return C(2).add(i).mul(r.pow(i.mul(0.5))).div(2 * Math.PI);
      }).setLayout({
        name: "D_Charlie",
        type: "float",
        inputs: [
          {
            name: "roughness",
            type: "float"
          },
          {
            name: "dotNH",
            type: "float"
          }
        ]
      }), gF = O(({ dotNV: s, dotNL: e }) => C(1).div(C(4).mul(e.add(s).sub(e.mul(s))))).setLayout({
        name: "V_Neubelt",
        type: "float",
        inputs: [
          {
            name: "dotNV",
            type: "float"
          },
          {
            name: "dotNL",
            type: "float"
          }
        ]
      }), yF = O(({ lightDirection: s }) => {
        const e = s.add(Ge).normalize(), t = Qe.dot(s).clamp(), i = Qe.dot(Ge).clamp(), n = Qe.dot(e).clamp(), r = mF({
          roughness: $y,
          dotNH: n
        }), a = gF({
          dotNV: i,
          dotNL: t
        });
        return ka.mul(r).mul(a);
      }), xF = O(({ N: s, V: e, roughness: t }) => {
        const r = 78125e-7, a = s.dot(e).saturate(), l = L(t, a.oneMinus().sqrt());
        return l.assign(l.mul(0.984375).add(r)), l;
      }).setLayout({
        name: "LTC_Uv",
        type: "vec2",
        inputs: [
          {
            name: "N",
            type: "vec3"
          },
          {
            name: "V",
            type: "vec3"
          },
          {
            name: "roughness",
            type: "float"
          }
        ]
      }), _F = O(({ f: s }) => {
        const e = s.length();
        return Qt(e.mul(e).add(s.z).div(e.add(1)), 0);
      }).setLayout({
        name: "LTC_ClippedSphereFormFactor",
        type: "float",
        inputs: [
          {
            name: "f",
            type: "vec3"
          }
        ]
      }), Ac = O(({ v1: s, v2: e }) => {
        const t = s.dot(e), i = t.abs().toVar(), n = i.mul(0.0145206).add(0.4965155).mul(i).add(0.8543985).toVar(), r = i.add(4.1616724).mul(i).add(3.417594).toVar(), a = n.div(r), l = t.greaterThan(0).select(a, Qt(t.mul(t).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(a));
        return s.cross(e).mul(l);
      }).setLayout({
        name: "LTC_EdgeVectorFormFactor",
        type: "vec3",
        inputs: [
          {
            name: "v1",
            type: "vec3"
          },
          {
            name: "v2",
            type: "vec3"
          }
        ]
      }), ib = O(({ N: s, V: e, P: t, mInv: i, p0: n, p1: r, p2: a, p3: l }) => {
        const o = r.sub(n).toVar(), u = l.sub(n).toVar(), c = o.cross(u), h = B().toVar();
        return et(c.dot(t.sub(n)).greaterThanEqual(0), () => {
          const d = e.sub(s.mul(e.dot(s))).normalize(), f = s.cross(d).negate(), p = i.mul(Gt(d, f, s).transpose()).toVar(), g = p.mul(n.sub(t)).normalize().toVar(), _ = p.mul(r.sub(t)).normalize().toVar(), m = p.mul(a.sub(t)).normalize().toVar(), y = p.mul(l.sub(t)).normalize().toVar(), x = B(0).toVar();
          x.addAssign(Ac({
            v1: g,
            v2: _
          })), x.addAssign(Ac({
            v1: _,
            v2: m
          })), x.addAssign(Ac({
            v1: m,
            v2: y
          })), x.addAssign(Ac({
            v1: y,
            v2: g
          })), h.assign(B(_F({
            f: x
          })));
        }), h;
      }).setLayout({
        name: "LTC_Evaluate",
        type: "vec3",
        inputs: [
          {
            name: "N",
            type: "vec3"
          },
          {
            name: "V",
            type: "vec3"
          },
          {
            name: "P",
            type: "vec3"
          },
          {
            name: "mInv",
            type: "mat3"
          },
          {
            name: "p0",
            type: "vec3"
          },
          {
            name: "p1",
            type: "vec3"
          },
          {
            name: "p2",
            type: "vec3"
          },
          {
            name: "p3",
            type: "vec3"
          }
        ]
      }), Wd = 1 / 6, QM = (s) => ae(Wd, ae(s, ae(s, s.negate().add(3)).sub(3)).add(1)), xg = (s) => ae(Wd, ae(s, ae(s, ae(3, s).sub(6))).add(4)), KM = (s) => ae(Wd, ae(s, ae(s, ae(-3, s).add(3)).add(3)).add(1)), _g = (s) => ae(Wd, kd(s, 3)), sb = (s) => QM(s).add(xg(s)), nb = (s) => KM(s).add(_g(s)), rb = (s) => Pt(-1, xg(s).div(QM(s).add(xg(s)))), ab = (s) => Pt(1, _g(s).div(KM(s).add(_g(s)))), ob = (s, e, t) => {
        const i = s.uvNode, n = ae(i, e.zw).add(0.5), r = wr(n), a = Jn(n), l = sb(a.x), o = nb(a.x), u = rb(a.x), c = ab(a.x), h = rb(a.y), d = ab(a.y), f = L(r.x.add(u), r.y.add(h)).sub(0.5).mul(e.xy), p = L(r.x.add(c), r.y.add(h)).sub(0.5).mul(e.xy), g = L(r.x.add(u), r.y.add(d)).sub(0.5).mul(e.xy), _ = L(r.x.add(c), r.y.add(d)).sub(0.5).mul(e.xy), m = sb(a.y).mul(Pt(l.mul(s.sample(f).level(t)), o.mul(s.sample(p).level(t)))), y = nb(a.y).mul(Pt(l.mul(s.sample(g).level(t)), o.mul(s.sample(_).level(t))));
        return m.add(y);
      }, bF = O(([s, e = C(3)]) => {
        const t = L(s.size(He(e))), i = L(s.size(He(e.add(1)))), n = Xs(1, t), r = Xs(1, i), a = ob(s, X(n, t), wr(e)), l = ob(s, X(r, i), Qy(e));
        return Jn(e).mix(a, l);
      }), lb = O(([s, e, t, i, n]) => {
        const r = B(_M(e.negate(), du(s), Xs(1, i))), a = B(Hn(n[0].xyz), Hn(n[1].xyz), Hn(n[2].xyz));
        return du(r).mul(t.mul(a));
      }).setLayout({
        name: "getVolumeTransmissionRay",
        type: "vec3",
        inputs: [
          {
            name: "n",
            type: "vec3"
          },
          {
            name: "v",
            type: "vec3"
          },
          {
            name: "thickness",
            type: "float"
          },
          {
            name: "ior",
            type: "float"
          },
          {
            name: "modelMatrix",
            type: "mat4"
          }
        ]
      }), SF = O(([s, e]) => s.mul(Zs(e.mul(2).sub(2), 0, 1))).setLayout({
        name: "applyIorToRoughness",
        type: "float",
        inputs: [
          {
            name: "roughness",
            type: "float"
          },
          {
            name: "ior",
            type: "float"
          }
        ]
      }), TF = LM(), vF = LM(), ub = O(([s, e, t], { material: i }) => {
        const r = (i.side === Fi ? TF : vF).sample(s), a = Hs(yg.x).mul(SF(e, t));
        return bF(r, a);
      }), cb = O(([s, e, t]) => (et(t.notEqual(0), () => {
        const i = hM(e).negate().div(t);
        return cM(i.negate().mul(s));
      }), B(1))).setLayout({
        name: "volumeAttenuation",
        type: "vec3",
        inputs: [
          {
            name: "transmissionDistance",
            type: "float"
          },
          {
            name: "attenuationColor",
            type: "vec3"
          },
          {
            name: "attenuationDistance",
            type: "float"
          }
        ]
      }), MF = O(([s, e, t, i, n, r, a, l, o, u, c, h, d, f, p]) => {
        let g, _;
        if (p) {
          g = X().toVar(), _ = B().toVar();
          const T = c.sub(1).mul(p.mul(0.025)), N = B(c.sub(T), c, c.add(T));
          qi({
            start: 0,
            end: 3
          }, ({ i: A }) => {
            const w = N.element(A), k = lb(s, e, h, w, l), G = a.add(k), I = u.mul(o.mul(X(G, 1))), be = L(I.xy.div(I.w)).toVar();
            be.addAssign(1), be.divAssign(2), be.assign(L(be.x, be.y.oneMinus()));
            const ce = ub(be, t, w);
            g.element(A).assign(ce.element(A)), g.a.addAssign(ce.a), _.element(A).assign(i.element(A).mul(cb(Hn(k), d, f).element(A)));
          }), g.a.divAssign(3);
        } else {
          const T = lb(s, e, h, c, l), N = a.add(T), A = u.mul(o.mul(X(N, 1))), w = L(A.xy.div(A.w)).toVar();
          w.addAssign(1), w.divAssign(2), w.assign(L(w.x, w.y.oneMinus())), g = ub(w, t, c), _ = i.mul(cb(Hn(T), d, f));
        }
        const m = _.rgb.mul(g.rgb), y = s.dot(e).clamp(), x = B(ZM({
          dotNV: y,
          specularColor: n,
          specularF90: r,
          roughness: t
        })), b = _.r.add(_.g, _.b).div(3);
        return X(x.oneMinus().mul(m), g.a.oneMinus().mul(b).oneMinus());
      }), AF = Gt(3.2404542, -0.969266, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.041556, 1.0572252), NF = (s) => {
        const e = s.sqrt();
        return B(1).add(e).div(B(1).sub(e));
      }, hb = (s, e) => s.sub(e).div(s.add(e)).pow2(), wF = (s, e) => {
        const t = s.mul(2 * Math.PI * 1e-9), i = B(54856e-17, 44201e-17, 52481e-17), n = B(1681e3, 1795300, 2208400), r = B(43278e5, 93046e5, 66121e5), a = C(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());
        let l = i.mul(r.mul(2 * Math.PI).sqrt()).mul(n.mul(t).add(e).cos()).mul(t.pow2().negate().mul(r).exp());
        return l = B(l.x.add(a), l.y, l.z).div(10685e-11), AF.mul(l);
      }, EF = O(({ outsideIOR: s, eta2: e, cosTheta1: t, thinFilmThickness: i, baseF0: n }) => {
        const r = Ce(s, e, Gr(0, 0.03, i)), l = s.div(r).pow2().mul(t.pow2().oneMinus()).oneMinus();
        et(l.lessThan(0), () => B(1));
        const o = l.sqrt(), u = hb(r, s), c = xu({
          f0: u,
          f90: 1,
          dotVH: t
        }), h = c.oneMinus(), d = r.lessThan(s).select(Math.PI, 0), f = C(Math.PI).sub(d), p = NF(n.clamp(0, 0.9999)), g = hb(p, r.toVec3()), _ = xu({
          f0: g,
          f90: 1,
          dotVH: o
        }), m = B(p.x.lessThan(r).select(Math.PI, 0), p.y.lessThan(r).select(Math.PI, 0), p.z.lessThan(r).select(Math.PI, 0)), y = r.mul(i, o, 2), x = B(f).add(m), b = c.mul(_).clamp(1e-5, 0.9999), T = b.sqrt(), N = h.pow2().mul(_).div(B(1).sub(b)), w = c.add(N).toVar(), k = N.sub(h).toVar();
        return qi({
          start: 1,
          end: 2,
          condition: "<=",
          name: "m"
        }, ({ m: G }) => {
          k.mulAssign(T);
          const I = wF(C(G).mul(y), C(G).mul(x)).mul(2);
          w.addAssign(k.mul(I));
        }), w.max(B(0));
      }).setLayout({
        name: "evalIridescence",
        type: "vec3",
        inputs: [
          {
            name: "outsideIOR",
            type: "float"
          },
          {
            name: "eta2",
            type: "float"
          },
          {
            name: "cosTheta1",
            type: "float"
          },
          {
            name: "thinFilmThickness",
            type: "float"
          },
          {
            name: "baseF0",
            type: "vec3"
          }
        ]
      }), RF = O(({ normal: s, viewDir: e, roughness: t }) => {
        const i = s.dot(e).saturate(), n = t.pow2(), r = Wt(t.lessThan(0.25), C(-339.2).mul(n).add(C(161.4).mul(t)).sub(25.9), C(-8.48).mul(n).add(C(14.3).mul(t)).sub(9.95)), a = Wt(t.lessThan(0.25), C(44).mul(n).sub(C(23.7).mul(t)).add(3.26), C(1.97).mul(n).sub(C(3.27).mul(t)).add(0.72));
        return Wt(t.lessThan(0.25), 0, C(0.1).mul(t).sub(0.025)).add(r.mul(i).add(a).exp()).mul(1 / Math.PI).saturate();
      }), hp = B(0.04), dp = C(1);
      class JM extends Yd {
        constructor(e = false, t = false, i = false, n = false, r = false, a = false) {
          super(), this.clearcoat = e, this.sheen = t, this.iridescence = i, this.anisotropy = n, this.transmission = r, this.dispersion = a, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
        }
        start(e) {
          if (this.clearcoat === true && (this.clearcoatRadiance = B().toVar("clearcoatRadiance"), this.clearcoatSpecularDirect = B().toVar("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = B().toVar("clearcoatSpecularIndirect")), this.sheen === true && (this.sheenSpecularDirect = B().toVar("sheenSpecularDirect"), this.sheenSpecularIndirect = B().toVar("sheenSpecularIndirect")), this.iridescence === true) {
            const t = Qe.dot(Ge).clamp();
            this.iridescenceFresnel = EF({
              outsideIOR: C(1),
              eta2: iM,
              cosTheta1: t,
              thinFilmThickness: sM,
              baseF0: ri
            }), this.iridescenceF0 = pF({
              f: this.iridescenceFresnel,
              f90: 1,
              dotVH: t
            });
          }
          if (this.transmission === true) {
            const t = mu, i = cD.sub(mu).normalize(), n = r0;
            e.backdrop = MF(n, i, Bs, ye, ri, nd, t, Pr, nn, i0, ah, nM, aM, rM, this.dispersion ? oM : null), e.backdropAlpha = gg, ye.a.mulAssign(Ce(1, e.backdrop.a, gg));
          }
        }
        computeMultiscattering(e, t, i) {
          const n = Qe.dot(Ge).clamp(), r = XM({
            roughness: Bs,
            dotNV: n
          }), l = (this.iridescenceF0 ? Xy.mix(ri, this.iridescenceF0) : ri).mul(r.x).add(i.mul(r.y)), u = r.x.add(r.y).oneMinus(), c = ri.add(ri.oneMinus().mul(0.047619)), h = l.mul(c).div(u.mul(c).oneMinus());
          e.addAssign(l), t.addAssign(h.mul(u));
        }
        direct({ lightDirection: e, lightColor: t, reflectedLight: i }) {
          const r = Qe.dot(e).clamp().mul(t);
          if (this.sheen === true && this.sheenSpecularDirect.addAssign(r.mul(yF({
            lightDirection: e
          }))), this.clearcoat === true) {
            const l = pl.dot(e).clamp().mul(t);
            this.clearcoatSpecularDirect.addAssign(l.mul(tb({
              lightDirection: e,
              f0: hp,
              f90: dp,
              roughness: sd,
              normalView: pl
            })));
          }
          i.directDiffuse.addAssign(r.mul(Mo({
            diffuseColor: ye.rgb
          }))), i.directSpecular.addAssign(r.mul(tb({
            lightDirection: e,
            f0: ri,
            f90: 1,
            roughness: Bs,
            iridescence: this.iridescence,
            f: this.iridescenceFresnel,
            USE_IRIDESCENCE: this.iridescence,
            USE_ANISOTROPY: this.anisotropy
          })));
        }
        directRectArea({ lightColor: e, lightPosition: t, halfWidth: i, halfHeight: n, reflectedLight: r, ltc_1: a, ltc_2: l }) {
          const o = t.add(i).sub(n), u = t.sub(i).sub(n), c = t.sub(i).add(n), h = t.add(i).add(n), d = Qe, f = Ge, p = Ke.toVar(), g = xF({
            N: d,
            V: f,
            roughness: Bs
          }), _ = a.sample(g).toVar(), m = l.sample(g).toVar(), y = Gt(B(_.x, 0, _.y), B(0, 1, 0), B(_.z, 0, _.w)).toVar(), x = ri.mul(m.x).add(ri.oneMinus().mul(m.y)).toVar();
          r.directSpecular.addAssign(e.mul(x).mul(ib({
            N: d,
            V: f,
            P: p,
            mInv: y,
            p0: o,
            p1: u,
            p2: c,
            p3: h
          }))), r.directDiffuse.addAssign(e.mul(ye).mul(ib({
            N: d,
            V: f,
            P: p,
            mInv: Gt(1, 0, 0, 0, 1, 0, 0, 0, 1),
            p0: o,
            p1: u,
            p2: c,
            p3: h
          })));
        }
        indirect(e, t, i) {
          this.indirectDiffuse(e, t, i), this.indirectSpecular(e, t, i), this.ambientOcclusion(e, t, i);
        }
        indirectDiffuse({ irradiance: e, reflectedLight: t }) {
          t.indirectDiffuse.addAssign(e.mul(Mo({
            diffuseColor: ye
          })));
        }
        indirectSpecular({ radiance: e, iblIrradiance: t, reflectedLight: i }) {
          if (this.sheen === true && this.sheenSpecularIndirect.addAssign(t.mul(ka, RF({
            normal: Qe,
            viewDir: Ge,
            roughness: $y
          }))), this.clearcoat === true) {
            const u = pl.dot(Ge).clamp(), c = ZM({
              dotNV: u,
              specularColor: hp,
              specularF90: dp,
              roughness: sd
            });
            this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(c));
          }
          const n = B().toVar("singleScattering"), r = B().toVar("multiScattering"), a = t.mul(1 / Math.PI);
          this.computeMultiscattering(n, r, nd);
          const l = n.add(r), o = ye.mul(l.r.max(l.g).max(l.b).oneMinus());
          i.indirectSpecular.addAssign(e.mul(n)), i.indirectSpecular.addAssign(r.mul(a)), i.indirectDiffuse.addAssign(o.mul(a));
        }
        ambientOcclusion({ ambientOcclusion: e, reflectedLight: t }) {
          const n = Qe.dot(Ge).clamp().add(e), r = Bs.mul(-16).oneMinus().negate().exp2(), a = e.sub(n.pow(r).oneMinus()).clamp();
          this.clearcoat === true && this.clearcoatSpecularIndirect.mulAssign(e), this.sheen === true && this.sheenSpecularIndirect.mulAssign(e), t.indirectDiffuse.mulAssign(e), t.indirectSpecular.mulAssign(a);
        }
        finish(e) {
          const { outgoingLight: t } = e;
          if (this.clearcoat === true) {
            const i = pl.dot(Ge).clamp(), n = xu({
              dotVH: i,
              f0: hp,
              f90: dp
            }), r = t.mul(fg.mul(n).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(fg));
            t.assign(r);
          }
          if (this.sheen === true) {
            const i = ka.r.max(ka.g).max(ka.b).mul(0.157).oneMinus(), n = t.mul(i).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
            t.assign(n);
          }
        }
      }
      const db = C(1), bg = C(-2), Nc = C(0.8), fp = C(-1), wc = C(0.4), pp = C(2), Ec = C(0.305), mp = C(3), fb = C(0.21), CF = C(4), pb = C(4), BF = C(16), DF = O(([s]) => {
        const e = B(Mi(s)).toVar(), t = C(-1).toVar();
        return et(e.x.greaterThan(e.z), () => {
          et(e.x.greaterThan(e.y), () => {
            t.assign(Wt(s.x.greaterThan(0), 0, 3));
          }).Else(() => {
            t.assign(Wt(s.y.greaterThan(0), 1, 4));
          });
        }).Else(() => {
          et(e.z.greaterThan(e.y), () => {
            t.assign(Wt(s.z.greaterThan(0), 2, 5));
          }).Else(() => {
            t.assign(Wt(s.y.greaterThan(0), 1, 4));
          });
        }), t;
      }).setLayout({
        name: "getFace",
        type: "float",
        inputs: [
          {
            name: "direction",
            type: "vec3"
          }
        ]
      }), UF = O(([s, e]) => {
        const t = L().toVar();
        return et(e.equal(0), () => {
          t.assign(L(s.z, s.y).div(Mi(s.x)));
        }).ElseIf(e.equal(1), () => {
          t.assign(L(s.x.negate(), s.z.negate()).div(Mi(s.y)));
        }).ElseIf(e.equal(2), () => {
          t.assign(L(s.x.negate(), s.y).div(Mi(s.z)));
        }).ElseIf(e.equal(3), () => {
          t.assign(L(s.z.negate(), s.y).div(Mi(s.x)));
        }).ElseIf(e.equal(4), () => {
          t.assign(L(s.x.negate(), s.z).div(Mi(s.y)));
        }).Else(() => {
          t.assign(L(s.x, s.y).div(Mi(s.z)));
        }), ae(0.5, t.add(1));
      }).setLayout({
        name: "getUV",
        type: "vec2",
        inputs: [
          {
            name: "direction",
            type: "vec3"
          },
          {
            name: "face",
            type: "float"
          }
        ]
      }), FF = O(([s]) => {
        const e = C(0).toVar();
        return et(s.greaterThanEqual(Nc), () => {
          e.assign(db.sub(s).mul(fp.sub(bg)).div(db.sub(Nc)).add(bg));
        }).ElseIf(s.greaterThanEqual(wc), () => {
          e.assign(Nc.sub(s).mul(pp.sub(fp)).div(Nc.sub(wc)).add(fp));
        }).ElseIf(s.greaterThanEqual(Ec), () => {
          e.assign(wc.sub(s).mul(mp.sub(pp)).div(wc.sub(Ec)).add(pp));
        }).ElseIf(s.greaterThanEqual(fb), () => {
          e.assign(Ec.sub(s).mul(CF.sub(mp)).div(Ec.sub(fb)).add(mp));
        }).Else(() => {
          e.assign(C(-2).mul(Hs(ae(1.16, s))));
        }), e;
      }).setLayout({
        name: "roughnessToMip",
        type: "float",
        inputs: [
          {
            name: "roughness",
            type: "float"
          }
        ]
      }), OF = O(([s, e]) => {
        const t = s.toVar();
        t.assign(ae(2, t).sub(1));
        const i = B(t, 1).toVar();
        return et(e.equal(0), () => {
          i.assign(i.zyx);
        }).ElseIf(e.equal(1), () => {
          i.assign(i.xzy), i.xz.mulAssign(-1);
        }).ElseIf(e.equal(2), () => {
          i.x.mulAssign(-1);
        }).ElseIf(e.equal(3), () => {
          i.assign(i.zyx), i.xz.mulAssign(-1);
        }).ElseIf(e.equal(4), () => {
          i.assign(i.xzy), i.xy.mulAssign(-1);
        }).ElseIf(e.equal(5), () => {
          i.z.mulAssign(-1);
        }), i;
      }).setLayout({
        name: "getDirection",
        type: "vec3",
        inputs: [
          {
            name: "uv",
            type: "vec2"
          },
          {
            name: "face",
            type: "float"
          }
        ]
      }), zF = O(([s, e, t, i, n, r]) => {
        const a = C(t), l = B(e), o = Zs(FF(a), bg, r), u = Jn(o), c = wr(o), h = B(Sg(s, l, c, i, n, r)).toVar();
        return et(u.notEqual(0), () => {
          const d = B(Sg(s, l, c.add(1), i, n, r)).toVar();
          h.assign(Ce(h, d, u));
        }), h;
      }), Sg = O(([s, e, t, i, n, r]) => {
        const a = C(t).toVar(), l = B(e), o = C(DF(l)).toVar(), u = C(Qt(pb.sub(a), 0)).toVar();
        a.assign(Qt(a, pb));
        const c = C(hu(a)).toVar(), h = L(UF(l, o).mul(c.sub(2)).add(1)).toVar();
        return et(o.greaterThan(2), () => {
          h.y.addAssign(c), o.subAssign(3);
        }), h.x.addAssign(o.mul(c)), h.x.addAssign(u.mul(ae(3, BF))), h.y.addAssign(ae(4, hu(r).sub(c))), h.x.mulAssign(i), h.y.mulAssign(n), s.sample(h).grad(L(), L());
      }), gp = O(({ envMap: s, mipInt: e, outputDirection: t, theta: i, axis: n, CUBEUV_TEXEL_WIDTH: r, CUBEUV_TEXEL_HEIGHT: a, CUBEUV_MAX_MIP: l }) => {
        const o = _n(i), u = t.mul(o).add(n.cross(t).mul(Vi(i))).add(n.mul(n.dot(t).mul(o.oneMinus())));
        return Sg(s, u, e, r, a, l);
      }), LF = O(({ n: s, latitudinal: e, poleAxis: t, outputDirection: i, weights: n, samples: r, dTheta: a, mipInt: l, envMap: o, CUBEUV_TEXEL_WIDTH: u, CUBEUV_TEXEL_HEIGHT: c, CUBEUV_MAX_MIP: h }) => {
        const d = B(Wt(e, t, yM(t, i))).toVar();
        et(uM(d.equals(B(0))), () => {
          d.assign(B(i.z, 0, i.x.negate()));
        }), d.assign(du(d));
        const f = B().toVar();
        return f.addAssign(n.element(He(0)).mul(gp({
          theta: 0,
          axis: d,
          outputDirection: i,
          mipInt: l,
          envMap: o,
          CUBEUV_TEXEL_WIDTH: u,
          CUBEUV_TEXEL_HEIGHT: c,
          CUBEUV_MAX_MIP: h
        }))), qi({
          start: He(1),
          end: s
        }, ({ i: p }) => {
          et(p.greaterThanEqual(r), () => {
            vU();
          });
          const g = C(a.mul(C(p))).toVar();
          f.addAssign(n.element(p).mul(gp({
            theta: g.mul(-1),
            axis: d,
            outputDirection: i,
            mipInt: l,
            envMap: o,
            CUBEUV_TEXEL_WIDTH: u,
            CUBEUV_TEXEL_HEIGHT: c,
            CUBEUV_MAX_MIP: h
          }))), f.addAssign(n.element(p).mul(gp({
            theta: g,
            axis: d,
            outputDirection: i,
            mipInt: l,
            envMap: o,
            CUBEUV_TEXEL_WIDTH: u,
            CUBEUV_TEXEL_HEIGHT: c,
            CUBEUV_MAX_MIP: h
          })));
        }), X(f, 1);
      });
      let od = null;
      const mb = /* @__PURE__ */ new WeakMap();
      function GF(s) {
        const e = Math.log2(s) - 2, t = 1 / s;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
          texelHeight: t,
          maxMip: e
        };
      }
      function PF(s) {
        let e = mb.get(s);
        if ((e !== void 0 ? e.pmremVersion : -1) !== s.pmremVersion) {
          const i = s.image;
          if (s.isCubeTexture) if (IF(i)) e = od.fromCubemap(s, e);
          else return null;
          else if (VF(i)) e = od.fromEquirectangular(s, e);
          else return null;
          e.pmremVersion = s.pmremVersion, mb.set(s, e);
        }
        return e.texture;
      }
      class kF extends ct {
        static get type() {
          return "PMREMNode";
        }
        constructor(e, t = null, i = null) {
          super("vec3"), this._value = e, this._pmrem = null, this.uvNode = t, this.levelNode = i, this._generator = null;
          const n = new Lt();
          n.isRenderTargetTexture = true, this._texture = fe(n), this._width = Z(0), this._height = Z(0), this._maxMip = Z(0), this.updateBeforeType = te.RENDER;
        }
        set value(e) {
          this._value = e, this._pmrem = null;
        }
        get value() {
          return this._value;
        }
        updateFromTexture(e) {
          const t = GF(e.image.height);
          this._texture.value = e, this._width.value = t.texelWidth, this._height.value = t.texelHeight, this._maxMip.value = t.maxMip;
        }
        updateBefore() {
          let e = this._pmrem;
          const t = e ? e.pmremVersion : -1, i = this._value;
          t !== i.pmremVersion && (i.isPMREMTexture === true ? e = i : e = PF(i), e !== null && (this._pmrem = e, this.updateFromTexture(e)));
        }
        setup(e) {
          od === null && (od = e.createPMREMGenerator()), this.updateBefore(e);
          let t = this.uvNode;
          t === null && e.context.getUV && (t = e.context.getUV(this));
          const i = this.value;
          e.renderer.coordinateSystem === li && i.isPMREMTexture !== true && i.isRenderTargetTexture === true && (t = B(t.x.negate(), t.yz)), t = B(t.x, t.y.negate(), t.z);
          let n = this.levelNode;
          return n === null && e.context.getTextureLevel && (n = e.context.getTextureLevel(this)), zF(this._texture, t, n, this._width, this._height, this._maxMip);
        }
      }
      function IF(s) {
        if (s == null) return false;
        let e = 0;
        const t = 6;
        for (let i = 0; i < t; i++) s[i] !== void 0 && e++;
        return e === t;
      }
      function VF(s) {
        return s == null ? false : s.height > 0;
      }
      const eA = U(kF), gb = /* @__PURE__ */ new WeakMap();
      class HF extends Go {
        static get type() {
          return "EnvironmentNode";
        }
        constructor(e = null) {
          super(), this.envNode = e;
        }
        setup(e) {
          const { material: t } = e;
          let i = this.envNode;
          if (i.isTextureNode || i.isMaterialReferenceNode) {
            const f = i.isTextureNode ? i.value : t[i.property];
            let p = gb.get(f);
            p === void 0 && (p = eA(f), gb.set(f, p)), i = p;
          }
          const r = t.envMap ? Se("envMapIntensity", "float", e.material) : Se("environmentIntensity", "float", e.scene), l = t.useAnisotropy === true || t.anisotropy > 0 ? CD : Qe, o = i.context(yb(Bs, l)).mul(r), u = i.context(qF(r0)).mul(Math.PI).mul(r), c = lh(o), h = lh(u);
          e.context.radiance.addAssign(c), e.context.iblIrradiance.addAssign(h);
          const d = e.context.lightingModel.clearcoatRadiance;
          if (d) {
            const f = i.context(yb(sd, pl)).mul(r), p = lh(f);
            d.addAssign(p);
          }
        }
      }
      const yb = (s, e) => {
        let t = null;
        return {
          getUV: () => (t === null && (t = Ge.negate().reflect(e), t = s.mul(s).mix(t, e).normalize(), t = t.transformDirection(nn)), t),
          getTextureLevel: () => s
        };
      }, qF = (s) => ({
        getUV: () => s,
        getTextureLevel: () => C(1)
      }), YF = new Gy();
      class tA extends tt {
        static get type() {
          return "MeshStandardNodeMaterial";
        }
        constructor(e) {
          super(), this.isMeshStandardNodeMaterial = true, this.lights = true, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(YF), this.setValues(e);
        }
        setupEnvironment(e) {
          let t = super.setupEnvironment(e);
          return t === null && e.environmentNode && (t = e.environmentNode), t ? new HF(t) : null;
        }
        setupLightingModel() {
          return new JM();
        }
        setupSpecular() {
          const e = Ce(B(0.04), ye.rgb, id);
          ri.assign(e), nd.assign(1);
        }
        setupVariants() {
          const e = this.metalnessNode ? C(this.metalnessNode) : qD;
          id.assign(e);
          let t = this.roughnessNode ? C(this.roughnessNode) : HD;
          t = $M({
            roughness: t
          }), Bs.assign(t), this.setupSpecular(), ye.assign(X(ye.rgb.mul(e.oneMinus()), ye.a));
        }
        copy(e) {
          return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
        }
      }
      const WF = new wC();
      class jF extends tA {
        static get type() {
          return "MeshPhysicalNodeMaterial";
        }
        constructor(e) {
          super(), this.isMeshPhysicalNodeMaterial = true, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.iorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.dispersionNode = null, this.anisotropyNode = null, this.setDefaultValues(WF), this.setValues(e);
        }
        get useClearcoat() {
          return this.clearcoat > 0 || this.clearcoatNode !== null;
        }
        get useIridescence() {
          return this.iridescence > 0 || this.iridescenceNode !== null;
        }
        get useSheen() {
          return this.sheen > 0 || this.sheenNode !== null;
        }
        get useAnisotropy() {
          return this.anisotropy > 0 || this.anisotropyNode !== null;
        }
        get useTransmission() {
          return this.transmission > 0 || this.transmissionNode !== null;
        }
        get useDispersion() {
          return this.dispersion > 0 || this.dispersionNode !== null;
        }
        setupSpecular() {
          const e = this.iorNode ? C(this.iorNode) : nU;
          ah.assign(e), ri.assign(Ce(fu(xM(ah.sub(1).div(ah.add(1))).mul(VD), B(1)).mul(X_), ye.rgb, id)), nd.assign(Ce(X_, 1, id));
        }
        setupLightingModel() {
          return new JM(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
        }
        setupVariants(e) {
          if (super.setupVariants(e), this.useClearcoat) {
            const t = this.clearcoatNode ? C(this.clearcoatNode) : WD, i = this.clearcoatRoughnessNode ? C(this.clearcoatRoughnessNode) : jD;
            fg.assign(t), sd.assign($M({
              roughness: i
            }));
          }
          if (this.useSheen) {
            const t = this.sheenNode ? B(this.sheenNode) : ZD, i = this.sheenRoughnessNode ? C(this.sheenRoughnessNode) : QD;
            ka.assign(t), $y.assign(i);
          }
          if (this.useIridescence) {
            const t = this.iridescenceNode ? C(this.iridescenceNode) : JD, i = this.iridescenceIORNode ? C(this.iridescenceIORNode) : eU, n = this.iridescenceThicknessNode ? C(this.iridescenceThicknessNode) : tU;
            Xy.assign(t), iM.assign(i), sM.assign(n);
          }
          if (this.useAnisotropy) {
            const t = (this.anisotropyNode ? L(this.anisotropyNode) : KD).toVar();
            hr.assign(t.length()), et(hr.equal(0), () => {
              t.assign(L(1, 0));
            }).Else(() => {
              t.divAssign(L(hr)), hr.assign(hr.saturate());
            }), pg.assign(hr.pow2().mix(Bs.pow2(), 1)), rh.assign(ml[0].mul(t.x).add(ml[1].mul(t.y))), no.assign(ml[1].mul(t.x).sub(ml[0].mul(t.y)));
          }
          if (this.useTransmission) {
            const t = this.transmissionNode ? C(this.transmissionNode) : iU, i = this.thicknessNode ? C(this.thicknessNode) : sU, n = this.attenuationDistanceNode ? C(this.attenuationDistanceNode) : rU, r = this.attenuationColorNode ? B(this.attenuationColorNode) : aU;
            if (gg.assign(t), nM.assign(i), rM.assign(n), aM.assign(r), this.useDispersion) {
              const a = this.dispersionNode ? C(this.dispersionNode) : hU;
              oM.assign(a);
            }
          }
        }
        setupClearcoatNormal() {
          return this.clearcoatNormalNode ? B(this.clearcoatNormalNode) : $D;
        }
        setup(e) {
          e.context.setupClearcoatNormal = () => this.setupClearcoatNormal(e), super.setup(e);
        }
        copy(e) {
          return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, this.dispersionNode = e.dispersionNode, this.anisotropyNode = e.anisotropyNode, super.copy(e);
        }
      }
      const $F = O(({ normal: s, lightDirection: e, builder: t }) => {
        const i = s.dot(e), n = L(i.mul(0.5).add(0.5), 0);
        if (t.material.gradientMap) {
          const r = Nn("gradientMap", "texture").context({
            getUV: () => n
          });
          return B(r.r);
        } else {
          const r = n.fwidth().mul(0.5);
          return Ce(B(0.7), B(1), Gr(C(0.7).sub(r.x), C(0.7).add(r.x), n.x));
        }
      });
      class XF extends Yd {
        direct({ lightDirection: e, lightColor: t, reflectedLight: i }, n, r) {
          const a = $F({
            normal: NM,
            lightDirection: e,
            builder: r
          }).mul(t);
          i.directDiffuse.addAssign(a.mul(Mo({
            diffuseColor: ye.rgb
          })));
        }
        indirect({ ambientOcclusion: e, irradiance: t, reflectedLight: i }) {
          i.indirectDiffuse.addAssign(t.mul(Mo({
            diffuseColor: ye
          }))), i.indirectDiffuse.mulAssign(e);
        }
      }
      const ZF = new RC();
      class QF extends tt {
        static get type() {
          return "MeshToonNodeMaterial";
        }
        constructor(e) {
          super(), this.isMeshToonNodeMaterial = true, this.lights = true, this.setDefaultValues(ZF), this.setValues(e);
        }
        setupLightingModel() {
          return new XF();
        }
      }
      class KF extends ct {
        static get type() {
          return "MatcapUVNode";
        }
        constructor() {
          super("vec2");
        }
        setup() {
          const e = B(Ge.z, 0, Ge.x.negate()).normalize(), t = Ge.cross(e);
          return L(e.dot(Qe), t.dot(Qe)).mul(0.495).add(0.5);
        }
      }
      const JF = z(KF), eO = new DC();
      class tO extends tt {
        static get type() {
          return "MeshMatcapNodeMaterial";
        }
        constructor(e) {
          super(), this.isMeshMatcapNodeMaterial = true, this.setDefaultValues(eO), this.setValues(e);
        }
        setupVariants(e) {
          const t = JF;
          let i;
          e.material.matcap ? i = Nn("matcap", "texture").context({
            getUV: () => t
          }) : i = B(Ce(0.2, 0.8, t.y)), ye.rgb.mulAssign(i.rgb);
        }
      }
      const iO = new MC();
      class sO extends tt {
        static get type() {
          return "PointsNodeMaterial";
        }
        constructor(e) {
          super(), this.isPointsNodeMaterial = true, this.setDefaultValues(iO), this.setValues(e);
        }
      }
      class nO extends ct {
        static get type() {
          return "RotateNode";
        }
        constructor(e, t) {
          super(), this.positionNode = e, this.rotationNode = t;
        }
        getNodeType(e) {
          return this.positionNode.getNodeType(e);
        }
        setup(e) {
          const { rotationNode: t, positionNode: i } = this;
          if (this.getNodeType(e) === "vec2") {
            const r = t.cos(), a = t.sin();
            return jy(r, a, a.negate(), r).mul(i);
          } else {
            const r = t, a = so(X(1, 0, 0, 0), X(0, _n(r.x), Vi(r.x).negate(), 0), X(0, Vi(r.x), _n(r.x), 0), X(0, 0, 0, 1)), l = so(X(_n(r.y), 0, Vi(r.y), 0), X(0, 1, 0, 0), X(Vi(r.y).negate(), 0, _n(r.y), 0), X(0, 0, 0, 1)), o = so(X(_n(r.z), Vi(r.z).negate(), 0, 0), X(Vi(r.z), _n(r.z), 0, 0), X(0, 0, 1, 0), X(0, 0, 0, 1));
            return a.mul(l).mul(o).mul(X(i, 1)).xyz;
          }
        }
      }
      const rO = U(nO), aO = new yC();
      class oO extends tt {
        static get type() {
          return "SpriteNodeMaterial";
        }
        constructor(e) {
          super(), this.isSpriteNodeMaterial = true, this._useSizeAttenuation = true, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.setDefaultValues(aO), this.setValues(e);
        }
        setupPositionView(e) {
          const { object: t, camera: i } = e, n = this.sizeAttenuation, { positionNode: r, rotationNode: a, scaleNode: l } = this, o = s0.mul(B(r || 0));
          let u = L(Pr[0].xyz.length(), Pr[1].xyz.length());
          if (l !== null && (u = u.mul(l)), n === false) if (i.isPerspectiveCamera) u = u.mul(o.z.negate());
          else {
            const f = C(2).div(i0.element(1).element(1));
            u = u.mul(f.mul(2));
          }
          let c = n0.xy;
          if (t.center && t.center.isVector2 === true) {
            const f = V3("center", "vec2", t);
            c = c.sub(f.sub(0.5));
          }
          c = c.mul(u);
          const h = C(a || XD), d = rO(c, h);
          return X(o.xy.add(d), o.zw);
        }
        copy(e) {
          return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
        }
        get sizeAttenuation() {
          return this._useSizeAttenuation;
        }
        set sizeAttenuation(e) {
          this._useSizeAttenuation !== e && (this._useSizeAttenuation = e, this.needsUpdate = true);
        }
      }
      class lO extends Yd {
        constructor() {
          super(), this.shadowNode = C(1).toVar("shadowMask");
        }
        direct({ shadowMask: e }) {
          this.shadowNode.mulAssign(e);
        }
        finish(e) {
          ye.a.mulAssign(this.shadowNode.oneMinus()), e.outgoingLight.rgb.assign(ye.rgb);
        }
      }
      const uO = new NC();
      class cO extends tt {
        static get type() {
          return "ShadowNodeMaterial";
        }
        constructor(e) {
          super(), this.isShadowNodeMaterial = true, this.lights = true, this.setDefaultValues(uO), this.setValues(e);
        }
        setupLightingModel() {
          return new lO();
        }
      }
      O(({ texture: s, uv: e }) => {
        const i = B().toVar();
        return et(e.x.lessThan(1e-4), () => {
          i.assign(B(1, 0, 0));
        }).ElseIf(e.y.lessThan(1e-4), () => {
          i.assign(B(0, 1, 0));
        }).ElseIf(e.z.lessThan(1e-4), () => {
          i.assign(B(0, 0, 1));
        }).ElseIf(e.x.greaterThan(1 - 1e-4), () => {
          i.assign(B(-1, 0, 0));
        }).ElseIf(e.y.greaterThan(1 - 1e-4), () => {
          i.assign(B(0, -1, 0));
        }).ElseIf(e.z.greaterThan(1 - 1e-4), () => {
          i.assign(B(0, 0, -1));
        }).Else(() => {
          const r = s.sample(e.add(B(-0.01, 0, 0))).r.sub(s.sample(e.add(B(0.01, 0, 0))).r), a = s.sample(e.add(B(0, -0.01, 0))).r.sub(s.sample(e.add(B(0, 0.01, 0))).r), l = s.sample(e.add(B(0, 0, -0.01))).r.sub(s.sample(e.add(B(0, 0, 0.01))).r);
          i.assign(B(r, a, l));
        }), i.normalize();
      });
      class hO {
        constructor(e, t) {
          this.nodes = e, this.info = t, this._context = self, this._animationLoop = null, this._requestId = null;
        }
        start() {
          const e = (t, i) => {
            this._requestId = this._context.requestAnimationFrame(e), this.info.autoReset === true && this.info.reset(), this.nodes.nodeFrame.update(), this.info.frame = this.nodes.nodeFrame.frameId, this._animationLoop !== null && this._animationLoop(t, i);
          };
          e();
        }
        stop() {
          this._context.cancelAnimationFrame(this._requestId), this._requestId = null;
        }
        setAnimationLoop(e) {
          this._animationLoop = e;
        }
        setContext(e) {
          this._context = e;
        }
        dispose() {
          this.stop();
        }
      }
      class us {
        constructor() {
          this.weakMap = /* @__PURE__ */ new WeakMap();
        }
        get(e) {
          let t = this.weakMap;
          for (let i = 0; i < e.length; i++) if (t = t.get(e[i]), t === void 0) return;
          return t.get(e[e.length - 1]);
        }
        set(e, t) {
          let i = this.weakMap;
          for (let n = 0; n < e.length; n++) {
            const r = e[n];
            i.has(r) === false && i.set(r, /* @__PURE__ */ new WeakMap()), i = i.get(r);
          }
          return i.set(e[e.length - 1], t), this;
        }
        delete(e) {
          let t = this.weakMap;
          for (let i = 0; i < e.length; i++) if (t = t.get(e[i]), t === void 0) return false;
          return t.delete(e[e.length - 1]);
        }
      }
      let dO = 0;
      function fO(s) {
        const e = Object.keys(s);
        let t = Object.getPrototypeOf(s);
        for (; t; ) {
          const i = Object.getOwnPropertyDescriptors(t);
          for (const n in i) if (i[n] !== void 0) {
            const r = i[n];
            r && typeof r.get == "function" && e.push(n);
          }
          t = Object.getPrototypeOf(t);
        }
        return e;
      }
      class pO {
        constructor(e, t, i, n, r, a, l, o, u, c) {
          this.id = dO++, this._nodes = e, this._geometries = t, this.renderer = i, this.object = n, this.material = r, this.scene = a, this.camera = l, this.lightsNode = o, this.context = u, this.geometry = n.geometry, this.version = r.version, this.drawRange = null, this.attributes = null, this.pipeline = null, this.vertexBuffers = null, this.drawParams = null, this.bundle = null, this.clippingContext = c, this.clippingContextCacheKey = c !== null ? c.cacheKey : "", this.initialNodesCacheKey = this.getDynamicCacheKey(), this.initialCacheKey = this.getCacheKey(), this._nodeBuilderState = null, this._bindings = null, this._monitor = null, this.onDispose = null, this.isRenderObject = true, this.onMaterialDispose = () => {
            this.dispose();
          }, this.material.addEventListener("dispose", this.onMaterialDispose);
        }
        updateClipping(e) {
          this.clippingContext = e;
        }
        get clippingNeedsUpdate() {
          return this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ? false : (this.clippingContextCacheKey = this.clippingContext.cacheKey, true);
        }
        get hardwareClippingPlanes() {
          return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;
        }
        getNodeBuilderState() {
          return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
        }
        getMonitor() {
          return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);
        }
        getBindings() {
          return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
        }
        getIndex() {
          return this._geometries.getIndex(this);
        }
        getIndirect() {
          return this._geometries.getIndirect(this);
        }
        getChainArray() {
          return [
            this.object,
            this.material,
            this.context,
            this.lightsNode
          ];
        }
        setGeometry(e) {
          this.geometry = e, this.attributes = null;
        }
        getAttributes() {
          if (this.attributes !== null) return this.attributes;
          const e = this.getNodeBuilderState().nodeAttributes, t = this.geometry, i = [], n = /* @__PURE__ */ new Set();
          for (const r of e) {
            const a = r.node && r.node.attribute ? r.node.attribute : t.getAttribute(r.name);
            if (a === void 0) continue;
            i.push(a);
            const l = a.isInterleavedBufferAttribute ? a.data : a;
            n.add(l);
          }
          return this.attributes = i, this.vertexBuffers = Array.from(n.values()), i;
        }
        getVertexBuffers() {
          return this.vertexBuffers === null && this.getAttributes(), this.vertexBuffers;
        }
        getDrawParameters() {
          const { object: e, material: t, geometry: i, group: n, drawRange: r } = this, a = this.drawParams || (this.drawParams = {
            vertexCount: 0,
            firstVertex: 0,
            instanceCount: 0,
            firstInstance: 0
          }), l = this.getIndex(), o = l !== null, u = i.isInstancedBufferGeometry ? i.instanceCount : e.count > 1 ? e.count : 1;
          if (u === 0) return null;
          if (a.instanceCount = u, e.isBatchedMesh === true) return a;
          let c = 1;
          t.wireframe === true && !e.isPoints && !e.isLineSegments && !e.isLine && !e.isLineLoop && (c = 2);
          let h = r.start * c, d = (r.start + r.count) * c;
          n !== null && (h = Math.max(h, n.start * c), d = Math.min(d, (n.start + n.count) * c));
          const f = i.attributes.position;
          let p = 1 / 0;
          o ? p = l.count : f != null && (p = f.count), h = Math.max(h, 0), d = Math.min(d, p);
          const g = d - h;
          return g < 0 || g === 1 / 0 ? null : (a.vertexCount = g, a.firstVertex = h, a);
        }
        getGeometryCacheKey() {
          const { geometry: e } = this;
          let t = "";
          for (const i of Object.keys(e.attributes).sort()) {
            const n = e.attributes[i];
            t += i + ",", n.data && (t += n.data.stride + ","), n.offset && (t += n.offset + ","), n.itemSize && (t += n.itemSize + ","), n.normalized && (t += "n,");
          }
          return e.index && (t += "index,"), t;
        }
        getMaterialCacheKey() {
          const { object: e, material: t } = this;
          let i = t.customProgramCacheKey();
          for (const n of fO(t)) {
            if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(n)) continue;
            const r = t[n];
            let a;
            if (r !== null) {
              const l = typeof r;
              l === "number" ? a = r !== 0 ? "1" : "0" : l === "object" ? (a = "{", r.isTexture && (a += r.mapping), a += "}") : a = String(r);
            } else a = String(r);
            i += a + ",";
          }
          return i += this.clippingContextCacheKey + ",", e.geometry && (i += this.getGeometryCacheKey()), e.skeleton && (i += e.skeleton.bones.length + ","), e.morphTargetInfluences && (i += e.morphTargetInfluences.length + ","), e.isBatchedMesh && (i += e._matricesTexture.uuid + ",", e._colorsTexture !== null && (i += e._colorsTexture.uuid + ",")), e.count > 1 && (i += e.uuid + ","), i += e.receiveShadow + ",", jC(i);
        }
        get needsGeometryUpdate() {
          return this.geometry.id !== this.object.geometry.id;
        }
        get needsUpdate() {
          return this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate;
        }
        getDynamicCacheKey() {
          let e = this._nodes.getCacheKey(this.scene, this.lightsNode);
          return this.object.receiveShadow && (e += 1), e;
        }
        getCacheKey() {
          return this.getMaterialCacheKey() + this.getDynamicCacheKey();
        }
        dispose() {
          this.material.removeEventListener("dispose", this.onMaterialDispose), this.onDispose();
        }
      }
      const pa = [];
      class mO {
        constructor(e, t, i, n, r, a) {
          this.renderer = e, this.nodes = t, this.geometries = i, this.pipelines = n, this.bindings = r, this.info = a, this.chainMaps = {};
        }
        get(e, t, i, n, r, a, l, o) {
          const u = this.getChainMap(o);
          pa[0] = e, pa[1] = t, pa[2] = a, pa[3] = r;
          let c = u.get(pa);
          return c === void 0 ? (c = this.createRenderObject(this.nodes, this.geometries, this.renderer, e, t, i, n, r, a, l, o), u.set(pa, c)) : (c.updateClipping(l), c.needsGeometryUpdate && c.setGeometry(e.geometry), (c.version !== t.version || c.needsUpdate) && (c.initialCacheKey !== c.getCacheKey() ? (c.dispose(), c = this.get(e, t, i, n, r, a, l, o)) : c.version = t.version)), c;
        }
        getChainMap(e = "default") {
          return this.chainMaps[e] || (this.chainMaps[e] = new us());
        }
        dispose() {
          this.chainMaps = {};
        }
        createRenderObject(e, t, i, n, r, a, l, o, u, c, h) {
          const d = this.getChainMap(h), f = new pO(e, t, i, n, r, a, l, o, u, c);
          return f.onDispose = () => {
            this.pipelines.delete(f), this.bindings.delete(f), this.nodes.delete(f), d.delete(f.getChainArray());
          }, f;
        }
      }
      class er {
        constructor() {
          this.data = /* @__PURE__ */ new WeakMap();
        }
        get(e) {
          let t = this.data.get(e);
          return t === void 0 && (t = {}, this.data.set(e, t)), t;
        }
        delete(e) {
          let t = null;
          return this.data.has(e) && (t = this.data.get(e), this.data.delete(e)), t;
        }
        has(e) {
          return this.data.has(e);
        }
        dispose() {
          this.data = /* @__PURE__ */ new WeakMap();
        }
      }
      const ts = {
        VERTEX: 1,
        INDEX: 2,
        STORAGE: 3,
        INDIRECT: 4
      }, wn = 16, gO = 211, yO = 212;
      class xO extends er {
        constructor(e) {
          super(), this.backend = e;
        }
        delete(e) {
          const t = super.delete(e);
          return t !== void 0 && this.backend.destroyAttribute(e), t;
        }
        update(e, t) {
          const i = this.get(e);
          if (i.version === void 0) t === ts.VERTEX ? this.backend.createAttribute(e) : t === ts.INDEX ? this.backend.createIndexAttribute(e) : t === ts.STORAGE ? this.backend.createStorageAttribute(e) : t === ts.INDIRECT && this.backend.createIndirectStorageAttribute(e), i.version = this._getBufferAttribute(e).version;
          else {
            const n = this._getBufferAttribute(e);
            (i.version < n.version || n.usage === Ga) && (this.backend.updateAttribute(e), i.version = n.version);
          }
        }
        _getBufferAttribute(e) {
          return e.isInterleavedBufferAttribute && (e = e.data), e;
        }
      }
      function _O(s) {
        for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return true;
        return false;
      }
      function iA(s) {
        return s.index !== null ? s.index.version : s.attributes.position.version;
      }
      function xb(s) {
        const e = [], t = s.index, i = s.attributes.position;
        if (t !== null) {
          const r = t.array;
          for (let a = 0, l = r.length; a < l; a += 3) {
            const o = r[a + 0], u = r[a + 1], c = r[a + 2];
            e.push(o, u, u, c, c, o);
          }
        } else {
          const r = i.array;
          for (let a = 0, l = r.length / 3 - 1; a < l; a += 3) {
            const o = a + 0, u = a + 1, c = a + 2;
            e.push(o, u, u, c, c, o);
          }
        }
        const n = new (_O(e) ? Uv : Dv)(e, 1);
        return n.version = iA(s), n;
      }
      class bO extends er {
        constructor(e, t) {
          super(), this.attributes = e, this.info = t, this.wireframes = /* @__PURE__ */ new WeakMap(), this.attributeCall = /* @__PURE__ */ new WeakMap();
        }
        has(e) {
          const t = e.geometry;
          return super.has(t) && this.get(t).initialized === true;
        }
        updateForRender(e) {
          this.has(e) === false && this.initGeometry(e), this.updateAttributes(e);
        }
        initGeometry(e) {
          const t = e.geometry, i = this.get(t);
          i.initialized = true, this.info.memory.geometries++;
          const n = () => {
            this.info.memory.geometries--;
            const r = t.index, a = e.getAttributes();
            r !== null && this.attributes.delete(r);
            for (const o of a) this.attributes.delete(o);
            const l = this.wireframes.get(t);
            l !== void 0 && this.attributes.delete(l), t.removeEventListener("dispose", n);
          };
          t.addEventListener("dispose", n);
        }
        updateAttributes(e) {
          const t = e.getAttributes();
          for (const r of t) r.isStorageBufferAttribute || r.isStorageInstancedBufferAttribute ? this.updateAttribute(r, ts.STORAGE) : this.updateAttribute(r, ts.VERTEX);
          const i = this.getIndex(e);
          i !== null && this.updateAttribute(i, ts.INDEX);
          const n = e.geometry.indirect;
          n !== null && this.updateAttribute(n, ts.INDIRECT);
        }
        updateAttribute(e, t) {
          const i = this.info.render.calls;
          e.isInterleavedBufferAttribute ? this.attributeCall.get(e) === void 0 ? (this.attributes.update(e, t), this.attributeCall.set(e, i)) : this.attributeCall.get(e.data) !== i && (this.attributes.update(e, t), this.attributeCall.set(e.data, i), this.attributeCall.set(e, i)) : this.attributeCall.get(e) !== i && (this.attributes.update(e, t), this.attributeCall.set(e, i));
        }
        getIndirect(e) {
          return e.geometry.indirect;
        }
        getIndex(e) {
          const { geometry: t, material: i } = e;
          let n = t.index;
          if (i.wireframe === true) {
            const r = this.wireframes;
            let a = r.get(t);
            a === void 0 ? (a = xb(t), r.set(t, a)) : a.version !== iA(t) && (this.attributes.delete(a), a = xb(t), r.set(t, a)), n = a;
          }
          return n;
        }
      }
      class SO {
        constructor() {
          this.autoReset = true, this.frame = 0, this.calls = 0, this.render = {
            calls: 0,
            frameCalls: 0,
            drawCalls: 0,
            triangles: 0,
            points: 0,
            lines: 0,
            timestamp: 0,
            previousFrameCalls: 0,
            timestampCalls: 0
          }, this.compute = {
            calls: 0,
            frameCalls: 0,
            timestamp: 0,
            previousFrameCalls: 0,
            timestampCalls: 0
          }, this.memory = {
            geometries: 0,
            textures: 0
          };
        }
        update(e, t, i) {
          this.render.drawCalls++, e.isMesh || e.isSprite ? this.render.triangles += i * (t / 3) : e.isPoints ? this.render.points += i * t : e.isLineSegments ? this.render.lines += i * (t / 2) : e.isLine ? this.render.lines += i * (t - 1) : console.error("THREE.WebGPUInfo: Unknown object type.");
        }
        updateTimestamp(e, t) {
          this[e].timestampCalls === 0 && (this[e].timestamp = 0), this[e].timestamp += t, this[e].timestampCalls++, this[e].timestampCalls >= this[e].previousFrameCalls && (this[e].timestampCalls = 0);
        }
        reset() {
          const e = this.render.frameCalls;
          this.render.previousFrameCalls = e;
          const t = this.compute.frameCalls;
          this.compute.previousFrameCalls = t, this.render.drawCalls = 0, this.render.frameCalls = 0, this.compute.frameCalls = 0, this.render.triangles = 0, this.render.points = 0, this.render.lines = 0;
        }
        dispose() {
          this.reset(), this.calls = 0, this.render.calls = 0, this.compute.calls = 0, this.render.timestamp = 0, this.compute.timestamp = 0, this.memory.geometries = 0, this.memory.textures = 0;
        }
      }
      class sA {
        constructor(e) {
          this.cacheKey = e, this.usedTimes = 0;
        }
      }
      class TO extends sA {
        constructor(e, t, i) {
          super(e), this.vertexProgram = t, this.fragmentProgram = i;
        }
      }
      class vO extends sA {
        constructor(e, t) {
          super(e), this.computeProgram = t, this.isComputePipeline = true;
        }
      }
      let MO = 0;
      class yp {
        constructor(e, t, i, n = null, r = null) {
          this.id = MO++, this.code = e, this.stage = t, this.name = i, this.transforms = n, this.attributes = r, this.usedTimes = 0;
        }
      }
      class AO extends er {
        constructor(e, t) {
          super(), this.backend = e, this.nodes = t, this.bindings = null, this.caches = /* @__PURE__ */ new Map(), this.programs = {
            vertex: /* @__PURE__ */ new Map(),
            fragment: /* @__PURE__ */ new Map(),
            compute: /* @__PURE__ */ new Map()
          };
        }
        getForCompute(e, t) {
          const { backend: i } = this, n = this.get(e);
          if (this._needsComputeUpdate(e)) {
            const r = n.pipeline;
            r && (r.usedTimes--, r.computeProgram.usedTimes--);
            const a = this.nodes.getForCompute(e);
            let l = this.programs.compute.get(a.computeShader);
            l === void 0 && (r && r.computeProgram.usedTimes === 0 && this._releaseProgram(r.computeProgram), l = new yp(a.computeShader, "compute", e.name, a.transforms, a.nodeAttributes), this.programs.compute.set(a.computeShader, l), i.createProgram(l));
            const o = this._getComputeCacheKey(e, l);
            let u = this.caches.get(o);
            u === void 0 && (r && r.usedTimes === 0 && this._releasePipeline(r), u = this._getComputePipeline(e, l, o, t)), u.usedTimes++, l.usedTimes++, n.version = e.version, n.pipeline = u;
          }
          return n.pipeline;
        }
        getForRender(e, t = null) {
          const { backend: i } = this, n = this.get(e);
          if (this._needsRenderUpdate(e)) {
            const r = n.pipeline;
            r && (r.usedTimes--, r.vertexProgram.usedTimes--, r.fragmentProgram.usedTimes--);
            const a = e.getNodeBuilderState(), l = e.material ? e.material.name : "";
            let o = this.programs.vertex.get(a.vertexShader);
            o === void 0 && (r && r.vertexProgram.usedTimes === 0 && this._releaseProgram(r.vertexProgram), o = new yp(a.vertexShader, "vertex", l), this.programs.vertex.set(a.vertexShader, o), i.createProgram(o));
            let u = this.programs.fragment.get(a.fragmentShader);
            u === void 0 && (r && r.fragmentProgram.usedTimes === 0 && this._releaseProgram(r.fragmentProgram), u = new yp(a.fragmentShader, "fragment", l), this.programs.fragment.set(a.fragmentShader, u), i.createProgram(u));
            const c = this._getRenderCacheKey(e, o, u);
            let h = this.caches.get(c);
            h === void 0 ? (r && r.usedTimes === 0 && this._releasePipeline(r), h = this._getRenderPipeline(e, o, u, c, t)) : e.pipeline = h, h.usedTimes++, o.usedTimes++, u.usedTimes++, n.pipeline = h;
          }
          return n.pipeline;
        }
        delete(e) {
          const t = this.get(e).pipeline;
          return t && (t.usedTimes--, t.usedTimes === 0 && this._releasePipeline(t), t.isComputePipeline ? (t.computeProgram.usedTimes--, t.computeProgram.usedTimes === 0 && this._releaseProgram(t.computeProgram)) : (t.fragmentProgram.usedTimes--, t.vertexProgram.usedTimes--, t.vertexProgram.usedTimes === 0 && this._releaseProgram(t.vertexProgram), t.fragmentProgram.usedTimes === 0 && this._releaseProgram(t.fragmentProgram))), super.delete(e);
        }
        dispose() {
          super.dispose(), this.caches = /* @__PURE__ */ new Map(), this.programs = {
            vertex: /* @__PURE__ */ new Map(),
            fragment: /* @__PURE__ */ new Map(),
            compute: /* @__PURE__ */ new Map()
          };
        }
        updateForRender(e) {
          this.getForRender(e);
        }
        _getComputePipeline(e, t, i, n) {
          i = i || this._getComputeCacheKey(e, t);
          let r = this.caches.get(i);
          return r === void 0 && (r = new vO(i, t), this.caches.set(i, r), this.backend.createComputePipeline(r, n)), r;
        }
        _getRenderPipeline(e, t, i, n, r) {
          n = n || this._getRenderCacheKey(e, t, i);
          let a = this.caches.get(n);
          return a === void 0 && (a = new TO(n, t, i), this.caches.set(n, a), e.pipeline = a, this.backend.createRenderPipeline(e, r)), a;
        }
        _getComputeCacheKey(e, t) {
          return e.id + "," + t.id;
        }
        _getRenderCacheKey(e, t, i) {
          return t.id + "," + i.id + "," + this.backend.getRenderCacheKey(e);
        }
        _releasePipeline(e) {
          this.caches.delete(e.cacheKey);
        }
        _releaseProgram(e) {
          const t = e.code, i = e.stage;
          this.programs[i].delete(t);
        }
        _needsComputeUpdate(e) {
          const t = this.get(e);
          return t.pipeline === void 0 || t.version !== e.version;
        }
        _needsRenderUpdate(e) {
          return this.get(e).pipeline === void 0 || this.backend.needsRenderUpdate(e);
        }
      }
      class NO extends er {
        constructor(e, t, i, n, r, a) {
          super(), this.backend = e, this.textures = i, this.pipelines = r, this.attributes = n, this.nodes = t, this.info = a, this.pipelines.bindings = this;
        }
        getForRender(e) {
          const t = e.getBindings();
          for (const i of t) {
            const n = this.get(i);
            n.bindGroup === void 0 && (this._init(i), this.backend.createBindings(i, t, 0), n.bindGroup = i);
          }
          return t;
        }
        getForCompute(e) {
          const t = this.nodes.getForCompute(e).bindings;
          for (const i of t) {
            const n = this.get(i);
            n.bindGroup === void 0 && (this._init(i), this.backend.createBindings(i, t, 0), n.bindGroup = i);
          }
          return t;
        }
        updateForCompute(e) {
          this._updateBindings(this.getForCompute(e));
        }
        updateForRender(e) {
          this._updateBindings(this.getForRender(e));
        }
        _updateBindings(e) {
          for (const t of e) this._update(t, e);
        }
        _init(e) {
          for (const t of e.bindings) if (t.isSampledTexture) this.textures.updateTexture(t.texture);
          else if (t.isStorageBuffer) {
            const i = t.attribute, n = i.isIndirectStorageBufferAttribute ? ts.INDIRECT : ts.STORAGE;
            this.attributes.update(i, n);
          }
        }
        _update(e, t) {
          const { backend: i } = this;
          let n = false, r = true, a = 0, l = 0;
          for (const o of e.bindings) if (!(o.isNodeUniformsGroup && this.nodes.updateGroup(o) === false)) {
            if (o.isUniformBuffer) o.update() && i.updateBinding(o);
            else if (o.isSampler) o.update();
            else if (o.isSampledTexture) {
              const u = this.textures.get(o.texture);
              o.needsBindingsUpdate(u.generation) && (n = true);
              const c = o.update(), h = o.texture;
              c && this.textures.updateTexture(h);
              const d = i.get(h);
              if (d.externalTexture !== void 0 || u.isDefaultTexture ? r = false : (a = a * 10 + h.id, l += h.version), i.isWebGPUBackend === true && d.texture === void 0 && d.externalTexture === void 0 && (console.error("Bindings._update: binding should be available:", o, c, h, o.textureNode.value, n), this.textures.updateTexture(h), n = true), h.isStorageTexture === true) {
                const f = this.get(h);
                o.store === true ? f.needsMipmap = true : this.textures.needsMipmaps(h) && f.needsMipmap === true && (this.backend.generateMipmaps(h), f.needsMipmap = false);
              }
            }
          }
          n === true && this.backend.updateBindings(e, t, r ? a : 0, l);
        }
      }
      function wO(s, e) {
        return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
      }
      function _b(s, e) {
        return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
      }
      function bb(s) {
        return (s.transmission > 0 || s.transmissionNode) && s.side === Ka && s.forceSinglePass === false;
      }
      class EO {
        constructor(e, t, i) {
          this.renderItems = [], this.renderItemsIndex = 0, this.opaque = [], this.transparentDoublePass = [], this.transparent = [], this.bundles = [], this.lightsNode = e.getNode(t, i), this.lightsArray = [], this.scene = t, this.camera = i, this.occlusionQueryCount = 0;
        }
        begin() {
          return this.renderItemsIndex = 0, this.opaque.length = 0, this.transparentDoublePass.length = 0, this.transparent.length = 0, this.bundles.length = 0, this.lightsArray.length = 0, this.occlusionQueryCount = 0, this;
        }
        getNextRenderItem(e, t, i, n, r, a, l) {
          let o = this.renderItems[this.renderItemsIndex];
          return o === void 0 ? (o = {
            id: e.id,
            object: e,
            geometry: t,
            material: i,
            groupOrder: n,
            renderOrder: e.renderOrder,
            z: r,
            group: a,
            clippingContext: l
          }, this.renderItems[this.renderItemsIndex] = o) : (o.id = e.id, o.object = e, o.geometry = t, o.material = i, o.groupOrder = n, o.renderOrder = e.renderOrder, o.z = r, o.group = a, o.clippingContext = l), this.renderItemsIndex++, o;
        }
        push(e, t, i, n, r, a, l) {
          const o = this.getNextRenderItem(e, t, i, n, r, a, l);
          e.occlusionTest === true && this.occlusionQueryCount++, i.transparent === true || i.transmission > 0 ? (bb(i) && this.transparentDoublePass.push(o), this.transparent.push(o)) : this.opaque.push(o);
        }
        unshift(e, t, i, n, r, a, l) {
          const o = this.getNextRenderItem(e, t, i, n, r, a, l);
          i.transparent === true || i.transmission > 0 ? (bb(i) && this.transparentDoublePass.unshift(o), this.transparent.unshift(o)) : this.opaque.unshift(o);
        }
        pushBundle(e) {
          this.bundles.push(e);
        }
        pushLight(e) {
          this.lightsArray.push(e);
        }
        sort(e, t) {
          this.opaque.length > 1 && this.opaque.sort(e || wO), this.transparentDoublePass.length > 1 && this.transparentDoublePass.sort(t || _b), this.transparent.length > 1 && this.transparent.sort(t || _b);
        }
        finish() {
          this.lightsNode.setLights(this.lightsArray);
          for (let e = this.renderItemsIndex, t = this.renderItems.length; e < t; e++) {
            const i = this.renderItems[e];
            if (i.id === null) break;
            i.id = null, i.object = null, i.geometry = null, i.material = null, i.groupOrder = null, i.renderOrder = null, i.z = null, i.group = null, i.clippingContext = null;
          }
        }
      }
      class RO {
        constructor(e) {
          this.lighting = e, this.lists = new us();
        }
        get(e, t) {
          const i = this.lists, n = [
            e,
            t
          ];
          let r = i.get(n);
          return r === void 0 && (r = new EO(this.lighting, e, t), i.set(n, r)), r;
        }
        dispose() {
          this.lists = new us();
        }
      }
      let CO = 0;
      class BO {
        constructor() {
          this.id = CO++, this.color = true, this.clearColor = true, this.clearColorValue = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
          }, this.depth = true, this.clearDepth = true, this.clearDepthValue = 1, this.stencil = false, this.clearStencil = true, this.clearStencilValue = 1, this.viewport = false, this.viewportValue = new Te(), this.scissor = false, this.scissorValue = new Te(), this.textures = null, this.depthTexture = null, this.activeCubeFace = 0, this.sampleCount = 1, this.width = 0, this.height = 0, this.isRenderContext = true;
        }
        getCacheKey() {
          return nA(this);
        }
      }
      function nA(s) {
        const { textures: e, activeCubeFace: t } = s, i = [
          t
        ];
        for (const n of e) i.push(n.id);
        return Iy(i);
      }
      class DO {
        constructor() {
          this.chainMaps = {};
        }
        get(e = null, t = null, i = null) {
          const n = [];
          e !== null && n.push(e), t !== null && n.push(t), n.length === 0 && n.push({
            id: "default"
          });
          let r;
          if (i === null) r = "default";
          else {
            const o = i.texture.format;
            r = `${i.textures.length}:${o}:${i.samples}:${i.depthBuffer}:${i.stencilBuffer}`;
          }
          const a = this.getChainMap(r);
          let l = a.get(n);
          return l === void 0 && (l = new BO(), a.set(n, l)), i !== null && (l.sampleCount = i.samples === 0 ? 1 : i.samples), l;
        }
        getChainMap(e) {
          return this.chainMaps[e] || (this.chainMaps[e] = new us());
        }
        dispose() {
          this.chainMaps = {};
        }
      }
      const UO = new v();
      class FO extends er {
        constructor(e, t, i) {
          super(), this.renderer = e, this.backend = t, this.info = i;
        }
        updateRenderTarget(e, t = 0) {
          const i = this.get(e), n = e.samples === 0 ? 1 : e.samples, r = i.depthTextureMips || (i.depthTextureMips = {}), a = e.textures, l = this.getSize(a[0]), o = l.width >> t, u = l.height >> t;
          let c = e.depthTexture || r[t];
          const h = e.depthBuffer === true || e.stencilBuffer === true;
          let d = false;
          c === void 0 && h && (c = new zo(), c.format = e.stencilBuffer ? To : Nr, c.type = e.stencilBuffer ? Fu : Tt, c.image.width = o, c.image.height = u, r[t] = c), (i.width !== l.width || l.height !== i.height) && (d = true, c && (c.needsUpdate = true, c.image.width = o, c.image.height = u)), i.width = l.width, i.height = l.height, i.textures = a, i.depthTexture = c || null, i.depth = e.depthBuffer, i.stencil = e.stencilBuffer, i.renderTarget = e, i.sampleCount !== n && (d = true, c && (c.needsUpdate = true), i.sampleCount = n);
          const f = {
            sampleCount: n
          };
          for (let p = 0; p < a.length; p++) {
            const g = a[p];
            d && (g.needsUpdate = true), this.updateTexture(g, f);
          }
          if (c && this.updateTexture(c, f), i.initialized !== true) {
            i.initialized = true;
            const p = () => {
              e.removeEventListener("dispose", p);
              for (let g = 0; g < a.length; g++) this._destroyTexture(a[g]);
              c && this._destroyTexture(c), this.delete(e);
            };
            e.addEventListener("dispose", p);
          }
        }
        updateTexture(e, t = {}) {
          const i = this.get(e);
          if (i.initialized === true && i.version === e.version) return;
          const n = e.isRenderTargetTexture || e.isDepthTexture || e.isFramebufferTexture, r = this.backend;
          if (n && i.initialized === true && (r.destroySampler(e), r.destroyTexture(e)), e.isFramebufferTexture) {
            const u = this.renderer.getRenderTarget();
            u ? e.type = u.texture.type : e.type = In;
          }
          const { width: a, height: l, depth: o } = this.getSize(e);
          if (t.width = a, t.height = l, t.depth = o, t.needsMipmaps = this.needsMipmaps(e), t.levels = t.needsMipmaps ? this.getMipLevels(e, a, l) : 1, n || e.isStorageTexture === true) r.createSampler(e), r.createTexture(e, t), i.generation = e.version;
          else if (i.initialized !== true && r.createSampler(e), e.version > 0) {
            const c = e.image;
            if (c === void 0) console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
            else if (c.complete === false) console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
            else {
              if (e.images) {
                const h = [];
                for (const d of e.images) h.push(d);
                t.images = h;
              } else t.image = c;
              (i.isDefaultTexture === void 0 || i.isDefaultTexture === true) && (r.createTexture(e, t), i.isDefaultTexture = false, i.generation = e.version), e.source.dataReady === true && r.updateTexture(e, t), t.needsMipmaps && e.mipmaps.length === 0 && r.generateMipmaps(e);
            }
          } else r.createDefaultTexture(e), i.isDefaultTexture = true, i.generation = e.version;
          if (i.initialized !== true) {
            i.initialized = true, i.generation = e.version, this.info.memory.textures++;
            const u = () => {
              e.removeEventListener("dispose", u), this._destroyTexture(e), this.info.memory.textures--;
            };
            e.addEventListener("dispose", u);
          }
          i.version = e.version;
        }
        getSize(e, t = UO) {
          let i = e.images ? e.images[0] : e.image;
          return i ? (i.image !== void 0 && (i = i.image), t.width = i.width || 1, t.height = i.height || 1, t.depth = e.isCubeTexture ? 6 : i.depth || 1) : t.width = t.height = t.depth = 1, t;
        }
        getMipLevels(e, t, i) {
          let n;
          return e.isCompressedTexture ? e.mipmaps ? n = e.mipmaps.length : n = 1 : n = Math.floor(Math.log2(Math.max(t, i))) + 1, n;
        }
        needsMipmaps(e) {
          return this.isEnvironmentTexture(e) || e.isCompressedTexture === true || e.generateMipmaps;
        }
        isEnvironmentTexture(e) {
          const t = e.mapping;
          return t === Du || t === Uu || t === Fr || t === _o;
        }
        _destroyTexture(e) {
          this.backend.destroySampler(e), this.backend.destroyTexture(e), this.delete(e);
        }
      }
      class h0 extends ie {
        constructor(e, t, i, n = 1) {
          super(e, t, i), this.a = n;
        }
        set(e, t, i, n = 1) {
          return this.a = n, super.set(e, t, i);
        }
        copy(e) {
          return e.a !== void 0 && (this.a = e.a), super.copy(e);
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b, this.a);
        }
      }
      class OO extends _e {
        static get type() {
          return "ParameterNode";
        }
        constructor(e, t = null) {
          super(e, t), this.isParameterNode = true;
        }
        getHash() {
          return this.uuid;
        }
        generate() {
          return this.name;
        }
      }
      class zO extends Q {
        static get type() {
          return "StackNode";
        }
        constructor(e = null) {
          super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this.isStackNode = true;
        }
        getNodeType(e) {
          return this.outputNode ? this.outputNode.getNodeType(e) : "void";
        }
        add(e) {
          return this.nodes.push(e), this;
        }
        If(e, t) {
          const i = new nh(t);
          return this._currentCond = Wt(e, i), this.add(this._currentCond);
        }
        ElseIf(e, t) {
          const i = new nh(t), n = Wt(e, i);
          return this._currentCond.elseNode = n, this._currentCond = n, this;
        }
        Else(e) {
          return this._currentCond.elseNode = new nh(e), this;
        }
        build(e, ...t) {
          const i = Qv();
          ed(this);
          for (const n of this.nodes) n.build(e, "void");
          return ed(i), this.outputNode ? this.outputNode.build(e, ...t) : super.build(e, ...t);
        }
        else(...e) {
          return console.warn("TSL.StackNode: .else() has been renamed to .Else()."), this.Else(...e);
        }
        elseif(...e) {
          return console.warn("TSL.StackNode: .elseif() has been renamed to .ElseIf()."), this.ElseIf(...e);
        }
      }
      const xp = U(zO);
      new As();
      new v();
      new v();
      new v();
      new pe();
      new v(0, 0, -1);
      new Te();
      new v();
      new v();
      new Te();
      new q();
      const LO = new Uo();
      yu.flipX();
      LO.depthTexture = new zo(1, 1);
      const _p = new ky(-1, 1, 1, -1, 0, 1);
      class GO extends en {
        constructor(e = false) {
          super();
          const t = e === false ? [
            0,
            -1,
            0,
            1,
            2,
            1
          ] : [
            0,
            2,
            0,
            0,
            2,
            0
          ];
          this.setAttribute("position", new Wi([
            -1,
            3,
            0,
            -1,
            -1,
            0,
            3,
            -1,
            0
          ], 3)), this.setAttribute("uv", new Wi(t, 2));
        }
      }
      const PO = new GO();
      class rA extends as {
        constructor(e = null) {
          super(PO, e), this.camera = _p, this.isQuadMesh = true;
        }
        async renderAsync(e) {
          return e.renderAsync(this, _p);
        }
        render(e) {
          e.render(this, _p);
        }
      }
      const rl = new $i(), bp = new pe();
      class $t extends Q {
        static get type() {
          return "SceneNode";
        }
        constructor(e = $t.BACKGROUND_BLURRINESS, t = null) {
          super(), this.scope = e, this.scene = t;
        }
        setup(e) {
          const t = this.scope, i = this.scene !== null ? this.scene : e.scene;
          let n;
          return t === $t.BACKGROUND_BLURRINESS ? n = Se("backgroundBlurriness", "float", i) : t === $t.BACKGROUND_INTENSITY ? n = Se("backgroundIntensity", "float", i) : t === $t.BACKGROUND_ROTATION ? n = Z("mat4").label("backgroundRotation").setGroup($).onRenderUpdate(() => {
            const r = i.background;
            return r !== null && r.isTexture && r.mapping !== wy ? (rl.copy(i.backgroundRotation), rl.x *= -1, rl.y *= -1, rl.z *= -1, bp.makeRotationFromEuler(rl)) : bp.identity(), bp;
          }) : console.error("THREE.SceneNode: Unknown scope:", t), n;
        }
      }
      $t.BACKGROUND_BLURRINESS = "backgroundBlurriness";
      $t.BACKGROUND_INTENSITY = "backgroundIntensity";
      $t.BACKGROUND_ROTATION = "backgroundRotation";
      const kO = z($t, $t.BACKGROUND_BLURRINESS), Sb = z($t, $t.BACKGROUND_INTENSITY), IO = z($t, $t.BACKGROUND_ROTATION), VO = new q();
      class HO extends Gu {
        static get type() {
          return "PassTextureNode";
        }
        constructor(e, t) {
          super(t), this.passNode = e, this.setUpdateMatrix(false);
        }
        setup(e) {
          return e.object.isQuadMesh && this.passNode.build(e), super.setup(e);
        }
        clone() {
          return new this.constructor(this.passNode, this.value);
        }
      }
      class Tb extends HO {
        static get type() {
          return "PassMultipleTextureNode";
        }
        constructor(e, t, i = false) {
          super(e, null), this.textureName = t, this.previousTexture = i;
        }
        updateTexture() {
          this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
        }
        setup(e) {
          return this.updateTexture(), super.setup(e);
        }
        clone() {
          return new this.constructor(this.passNode, this.textureName, this.previousTexture);
        }
      }
      class jd extends ct {
        static get type() {
          return "PassNode";
        }
        constructor(e, t, i, n = {}) {
          super("vec4"), this.scope = e, this.scene = t, this.camera = i, this.options = n, this._pixelRatio = 1, this._width = 1, this._height = 1;
          const r = new zo();
          r.isRenderTargetTexture = true, r.name = "depth";
          const a = new Uo(this._width * this._pixelRatio, this._height * this._pixelRatio, {
            type: ks,
            ...n
          });
          a.texture.name = "output", a.depthTexture = r, this.renderTarget = a, this._textures = {
            output: a.texture,
            depth: r
          }, this._textureNodes = {}, this._linearDepthNodes = {}, this._viewZNodes = {}, this._previousTextures = {}, this._previousTextureNodes = {}, this._cameraNear = Z(0), this._cameraFar = Z(0), this._mrt = null, this.isPassNode = true, this.updateBeforeType = te.FRAME;
        }
        setMRT(e) {
          return this._mrt = e, this;
        }
        getMRT() {
          return this._mrt;
        }
        isGlobal() {
          return true;
        }
        getTexture(e) {
          let t = this._textures[e];
          return t === void 0 && (t = this.renderTarget.texture.clone(), t.name = e, this._textures[e] = t, this.renderTarget.textures.push(t)), t;
        }
        getPreviousTexture(e) {
          let t = this._previousTextures[e];
          return t === void 0 && (t = this.getTexture(e).clone(), this._previousTextures[e] = t), t;
        }
        toggleTexture(e) {
          const t = this._previousTextures[e];
          if (t !== void 0) {
            const i = this._textures[e], n = this.renderTarget.textures.indexOf(i);
            this.renderTarget.textures[n] = t, this._textures[e] = t, this._previousTextures[e] = i, this._textureNodes[e].updateTexture(), this._previousTextureNodes[e].updateTexture();
          }
        }
        getTextureNode(e = "output") {
          let t = this._textureNodes[e];
          return t === void 0 && (t = F(new Tb(this, e)), t.updateTexture(), this._textureNodes[e] = t), t;
        }
        getPreviousTextureNode(e = "output") {
          let t = this._previousTextureNodes[e];
          return t === void 0 && (this._textureNodes[e] === void 0 && this.getTextureNode(e), t = F(new Tb(this, e, true)), t.updateTexture(), this._previousTextureNodes[e] = t), t;
        }
        getViewZNode(e = "depth") {
          let t = this._viewZNodes[e];
          if (t === void 0) {
            const i = this._cameraNear, n = this._cameraFar;
            this._viewZNodes[e] = t = GM(this.getTextureNode(e), i, n);
          }
          return t;
        }
        getLinearDepthNode(e = "depth") {
          let t = this._linearDepthNodes[e];
          if (t === void 0) {
            const i = this._cameraNear, n = this._cameraFar, r = this.getViewZNode(e);
            this._linearDepthNodes[e] = t = Pl(r, i, n);
          }
          return t;
        }
        setup({ renderer: e }) {
          return this.renderTarget.samples = this.options.samples === void 0 ? e.samples : this.options.samples, e.backend.isWebGLBackend === true && (this.renderTarget.samples = 0), this.scope === jd.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
        }
        updateBefore(e) {
          const { renderer: t } = e, { scene: i, camera: n } = this;
          this._pixelRatio = t.getPixelRatio();
          const r = t.getSize(VO);
          this.setSize(r.width, r.height);
          const a = t.getRenderTarget(), l = t.getMRT();
          this._cameraNear.value = n.near, this._cameraFar.value = n.far;
          for (const o in this._previousTextures) this.toggleTexture(o);
          t.setRenderTarget(this.renderTarget), t.setMRT(this._mrt), t.render(i, n), t.setRenderTarget(a), t.setMRT(l);
        }
        setSize(e, t) {
          this._width = e, this._height = t;
          const i = this._width * this._pixelRatio, n = this._height * this._pixelRatio;
          this.renderTarget.setSize(i, n);
        }
        setPixelRatio(e) {
          this._pixelRatio = e, this.setSize(this._width, this._height);
        }
        dispose() {
          this.renderTarget.dispose();
        }
      }
      jd.COLOR = "color";
      jd.DEPTH = "depth";
      const qO = O(([s, e]) => s.mul(e).clamp()).setLayout({
        name: "linearToneMapping",
        type: "vec3",
        inputs: [
          {
            name: "color",
            type: "vec3"
          },
          {
            name: "exposure",
            type: "float"
          }
        ]
      }), YO = O(([s, e]) => (s = s.mul(e), s.div(s.add(1)).clamp())).setLayout({
        name: "reinhardToneMapping",
        type: "vec3",
        inputs: [
          {
            name: "color",
            type: "vec3"
          },
          {
            name: "exposure",
            type: "float"
          }
        ]
      }), WO = O(([s, e]) => {
        s = s.mul(e), s = s.sub(4e-3).max(0);
        const t = s.mul(s.mul(6.2).add(0.5)), i = s.mul(s.mul(6.2).add(1.7)).add(0.06);
        return t.div(i).pow(2.2);
      }).setLayout({
        name: "cineonToneMapping",
        type: "vec3",
        inputs: [
          {
            name: "color",
            type: "vec3"
          },
          {
            name: "exposure",
            type: "float"
          }
        ]
      }), jO = O(([s]) => {
        const e = s.mul(s.add(0.0245786)).sub(90537e-9), t = s.mul(s.add(0.432951).mul(0.983729)).add(0.238081);
        return e.div(t);
      }), $O = O(([s, e]) => {
        const t = Gt(0.59719, 0.35458, 0.04823, 0.076, 0.90834, 0.01566, 0.0284, 0.13383, 0.83777), i = Gt(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -605e-5, -327e-5, -0.07276, 1.07602);
        return s = s.mul(e).div(0.6), s = t.mul(s), s = jO(s), s = i.mul(s), s.clamp();
      }).setLayout({
        name: "acesFilmicToneMapping",
        type: "vec3",
        inputs: [
          {
            name: "color",
            type: "vec3"
          },
          {
            name: "exposure",
            type: "float"
          }
        ]
      }), XO = Gt(B(1.6605, -0.1246, -0.0182), B(-0.5876, 1.1329, -0.1006), B(-0.0728, -83e-4, 1.1187)), ZO = Gt(B(0.6274, 0.0691, 0.0164), B(0.3293, 0.9195, 0.088), B(0.0433, 0.0113, 0.8956)), QO = O(([s]) => {
        const e = B(s).toVar(), t = B(e.mul(e)).toVar(), i = B(t.mul(t)).toVar();
        return C(15.5).mul(i.mul(t)).sub(ae(40.14, i.mul(e))).add(ae(31.96, i).sub(ae(6.868, t.mul(e))).add(ae(0.4298, t).add(ae(0.1191, e).sub(232e-5))));
      }), KO = O(([s, e]) => {
        const t = B(s).toVar(), i = Gt(B(0.856627153315983, 0.137318972929847, 0.11189821299995), B(0.0951212405381588, 0.761241990602591, 0.0767994186031903), B(0.0482516061458583, 0.101439036467562, 0.811302368396859)), n = Gt(B(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), B(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), B(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)), r = C(-12.47393), a = C(4.026069);
        return t.mulAssign(e), t.assign(ZO.mul(t)), t.assign(i.mul(t)), t.assign(Qt(t, 1e-10)), t.assign(Hs(t)), t.assign(t.sub(r).div(a.sub(r))), t.assign(Zs(t, 0, 1)), t.assign(QO(t)), t.assign(n.mul(t)), t.assign(kd(Qt(B(0), t), B(2.2))), t.assign(XO.mul(t)), t.assign(Zs(t, 0, 1)), t;
      }).setLayout({
        name: "agxToneMapping",
        type: "vec3",
        inputs: [
          {
            name: "color",
            type: "vec3"
          },
          {
            name: "exposure",
            type: "float"
          }
        ]
      }), JO = O(([s, e]) => {
        const t = C(0.76), i = C(0.15);
        s = s.mul(e);
        const n = fu(s.r, fu(s.g, s.b)), r = Wt(n.lessThan(0.08), n.sub(ae(6.25, n.mul(n))), 0.04);
        s.subAssign(r);
        const a = Qt(s.r, Qt(s.g, s.b));
        et(a.lessThan(t), () => s);
        const l = qt(1, t), o = qt(1, l.mul(l).div(a.add(l.sub(t))));
        s.mulAssign(o.div(a));
        const u = qt(1, Xs(1, i.mul(a.sub(o)).add(1)));
        return Ce(s, B(o), u);
      }).setLayout({
        name: "neutralToneMapping",
        type: "vec3",
        inputs: [
          {
            name: "color",
            type: "vec3"
          },
          {
            name: "exposure",
            type: "float"
          }
        ]
      });
      class nt extends Q {
        static get type() {
          return "CodeNode";
        }
        constructor(e = "", t = [], i = "") {
          super("code"), this.isCodeNode = true, this.code = e, this.includes = t, this.language = i;
        }
        isGlobal() {
          return true;
        }
        setIncludes(e) {
          return this.includes = e, this;
        }
        getIncludes() {
          return this.includes;
        }
        generate(e) {
          const t = this.getIncludes(e);
          for (const n of t) n.build(e);
          const i = e.getCodeFromNode(this, this.getNodeType(e));
          return i.code = this.code, i.code;
        }
        serialize(e) {
          super.serialize(e), e.code = this.code, e.language = this.language;
        }
        deserialize(e) {
          super.deserialize(e), this.code = e.code, this.language = e.language;
        }
      }
      class ez extends nt {
        static get type() {
          return "FunctionNode";
        }
        constructor(e = "", t = [], i = "") {
          super(e, t, i);
        }
        getNodeType(e) {
          return this.getNodeFunction(e).type;
        }
        getInputs(e) {
          return this.getNodeFunction(e).inputs;
        }
        getNodeFunction(e) {
          const t = e.getDataFromNode(this);
          let i = t.nodeFunction;
          return i === void 0 && (i = e.parser.parseFunction(this.code), t.nodeFunction = i), i;
        }
        generate(e, t) {
          super.generate(e);
          const i = this.getNodeFunction(e), n = i.name, r = i.type, a = e.getCodeFromNode(this, r);
          n !== "" && (a.name = n);
          const l = e.getPropertyName(a), o = this.getNodeFunction(e).getCode(l);
          return a.code = o + `
`, t === "property" ? l : e.format(`${l}()`, r, t);
        }
      }
      function aA(s) {
        let e;
        const t = s.context.getViewZ;
        return t !== void 0 && (e = t(this)), (e || Ke.z).negate();
      }
      const tz = O(([s, e], t) => {
        const i = aA(t);
        return Gr(s, e, i);
      }), iz = O(([s], e) => {
        const t = aA(e);
        return s.mul(s, t, t).negate().exp().oneMinus();
      }), vb = O(([s, e]) => X(e.toFloat().mix(rd.rgb, s.toVec3()), rd.a));
      class sz extends Q {
        constructor(e) {
          super(), this.scope = e;
        }
        generate(e) {
          const { scope: t } = this, { renderer: i } = e;
          i.backend.isWebGLBackend === true ? e.addFlowCode(`	// ${t}Barrier 
`) : e.addLineFlowCode(`${t}Barrier()`, this);
        }
      }
      U(sz);
      class ds extends ct {
        static get type() {
          return "AtomicFunctionNode";
        }
        constructor(e, t, i, n = null) {
          super("uint"), this.method = e, this.pointerNode = t, this.valueNode = i, this.storeNode = n;
        }
        getInputType(e) {
          return this.pointerNode.getNodeType(e);
        }
        getNodeType(e) {
          return this.getInputType(e);
        }
        generate(e) {
          const t = this.method, i = this.getNodeType(e), n = this.getInputType(e), r = this.pointerNode, a = this.valueNode, l = [];
          l.push(`&${r.build(e, n)}`), l.push(a.build(e, n));
          const o = `${e.getMethod(t, i)}( ${l.join(", ")} )`;
          if (this.storeNode !== null) {
            const u = this.storeNode.build(e, n);
            e.addLineFlowCode(`${u} = ${o}`, this);
          } else e.addLineFlowCode(o, this);
        }
      }
      ds.ATOMIC_LOAD = "atomicLoad";
      ds.ATOMIC_STORE = "atomicStore";
      ds.ATOMIC_ADD = "atomicAdd";
      ds.ATOMIC_SUB = "atomicSub";
      ds.ATOMIC_MAX = "atomicMax";
      ds.ATOMIC_MIN = "atomicMin";
      ds.ATOMIC_AND = "atomicAnd";
      ds.ATOMIC_OR = "atomicOr";
      ds.ATOMIC_XOR = "atomicXor";
      U(ds);
      let Rc;
      function Pu(s) {
        Rc = Rc || /* @__PURE__ */ new WeakMap();
        let e = Rc.get(s);
        return e === void 0 && Rc.set(s, e = {}), e;
      }
      function oA(s) {
        const e = Pu(s);
        return e.shadowMatrix || (e.shadowMatrix = Z("mat4").setGroup($).onRenderUpdate(() => (s.castShadow !== true && s.shadow.updateMatrices(s), s.shadow.matrix)));
      }
      function nz(s) {
        const e = Pu(s);
        if (e.projectionUV === void 0) {
          const t = oA(s).mul(mu);
          e.projectionUV = t.xyz.div(t.w);
        }
        return e.projectionUV;
      }
      function lA(s) {
        const e = Pu(s);
        return e.position || (e.position = Z(new v()).setGroup($).onRenderUpdate((t, i) => i.value.setFromMatrixPosition(s.matrixWorld)));
      }
      function rz(s) {
        const e = Pu(s);
        return e.targetPosition || (e.targetPosition = Z(new v()).setGroup($).onRenderUpdate((t, i) => i.value.setFromMatrixPosition(s.target.matrixWorld)));
      }
      function d0(s) {
        const e = Pu(s);
        return e.viewPosition || (e.viewPosition = Z(new v()).setGroup($).onRenderUpdate(({ camera: t }, i) => {
          i.value = i.value || new v(), i.value.setFromMatrixPosition(s.matrixWorld), i.value.applyMatrix4(t.matrixWorldInverse);
        }));
      }
      const uA = (s) => nn.transformDirection(lA(s).sub(rz(s))), az = (s) => s.sort((e, t) => e.id - t.id), oz = (s, e) => {
        for (const t of e) if (t.isAnalyticLightNode && t.light.id === s) return t;
        return null;
      }, Sp = /* @__PURE__ */ new WeakMap();
      class cA extends Q {
        static get type() {
          return "LightsNode";
        }
        constructor() {
          super("vec3"), this.totalDiffuseNode = B().toVar("totalDiffuse"), this.totalSpecularNode = B().toVar("totalSpecular"), this.outgoingLightNode = B().toVar("outgoingLight"), this._lights = [], this._lightNodes = null, this._lightNodesHash = null, this.global = true;
        }
        customCacheKey() {
          const e = [], t = this._lights;
          for (let i = 0; i < t.length; i++) e.push(t[i].id);
          return Iy(e);
        }
        getHash(e) {
          if (this._lightNodesHash === null) {
            this._lightNodes === null && this.setupLightsNode(e);
            const t = [];
            for (const i of this._lightNodes) t.push(i.getSelf().getHash());
            this._lightNodesHash = "lights-" + t.join(",");
          }
          return this._lightNodesHash;
        }
        analyze(e) {
          const t = e.getDataFromNode(this);
          for (const i of t.nodes) i.build(e);
        }
        setupLightsNode(e) {
          const t = [], i = this._lightNodes, n = az(this._lights), r = e.renderer.library;
          for (const a of n) if (a.isNode) t.push(F(a));
          else {
            let l = null;
            if (i !== null && (l = oz(a.id, i)), l === null) {
              const o = r.getLightNodeClass(a.constructor);
              if (o === null) {
                console.warn(`LightsNode.setupNodeLights: Light node not found for ${a.constructor.name}`);
                continue;
              }
              let u = null;
              Sp.has(a) ? u = Sp.get(a) : (u = F(new o(a)), Sp.set(a, u)), t.push(u);
            }
          }
          this._lightNodes = t;
        }
        setupLights(e, t) {
          for (const i of t) i.build(e);
        }
        setup(e) {
          this._lightNodes === null && this.setupLightsNode(e);
          const t = e.context, i = t.lightingModel;
          let n = this.outgoingLightNode;
          if (i) {
            const { _lightNodes: r, totalDiffuseNode: a, totalSpecularNode: l } = this;
            t.outgoingLight = n;
            const o = e.addStack(), u = e.getDataFromNode(this);
            u.nodes = o.nodes, i.start(t, o, e), this.setupLights(e, r), i.indirect(t, o, e);
            const { backdrop: c, backdropAlpha: h } = t, { directDiffuse: d, directSpecular: f, indirectDiffuse: p, indirectSpecular: g } = t.reflectedLight;
            let _ = d.add(p);
            c !== null && (h !== null ? _ = B(h.mix(_, c)) : _ = B(c), t.material.transparent = true), a.assign(_), l.assign(f.add(g)), n.assign(a.add(l)), i.finish(t, o, e), n = n.bypass(e.removeStack());
          }
          return n;
        }
        setLights(e) {
          return this._lights = e, this._lightNodes = null, this._lightNodesHash = null, this;
        }
        getLights() {
          return this._lights;
        }
        get hasLights() {
          return this._lights.length > 0;
        }
      }
      class lz extends Q {
        static get type() {
          return "ShadowBaseNode";
        }
        constructor(e) {
          super(), this.light = e, this.updateBeforeType = te.RENDER, this.isShadowBaseNode = true;
        }
        setupShadowPosition({ material: e }) {
          hA.assign(e.shadowPositionNode || mu);
        }
        dispose() {
          this.updateBeforeType = te.NONE;
        }
      }
      const hA = B().toVar("shadowPositionWorld");
      function uz(s, e = {}) {
        return e.toneMapping = s.toneMapping, e.toneMappingExposure = s.toneMappingExposure, e.outputColorSpace = s.outputColorSpace, e.renderTarget = s.getRenderTarget(), e.activeCubeFace = s.getActiveCubeFace(), e.activeMipmapLevel = s.getActiveMipmapLevel(), e.renderObjectFunction = s.getRenderObjectFunction(), e.pixelRatio = s.getPixelRatio(), e.mrt = s.getMRT(), e.clearColor = s.getClearColor(e.clearColor || new ie()), e.clearAlpha = s.getClearAlpha(), e.autoClear = s.autoClear, e.scissorTest = s.getScissorTest(), e;
      }
      function cz(s, e) {
        return e = uz(s, e), s.setMRT(null), s.setRenderObjectFunction(null), s.setClearColor(0, 1), s.autoClear = true, e;
      }
      function hz(s, e) {
        s.toneMapping = e.toneMapping, s.toneMappingExposure = e.toneMappingExposure, s.outputColorSpace = e.outputColorSpace, s.setRenderTarget(e.renderTarget, e.activeCubeFace, e.activeMipmapLevel), s.setRenderObjectFunction(e.renderObjectFunction), s.setPixelRatio(e.pixelRatio), s.setMRT(e.mrt), s.setClearColor(e.clearColor, e.clearAlpha), s.autoClear = e.autoClear, s.setScissorTest(e.scissorTest);
      }
      function dz(s, e = {}) {
        return e.background = s.background, e.backgroundNode = s.backgroundNode, e.overrideMaterial = s.overrideMaterial, e;
      }
      function fz(s, e) {
        return e = dz(s, e), s.background = null, s.backgroundNode = null, s.overrideMaterial = null, e;
      }
      function pz(s, e) {
        s.background = e.background, s.backgroundNode = e.backgroundNode, s.overrideMaterial = e.overrideMaterial;
      }
      function mz(s, e, t) {
        return t = cz(s, t), t = fz(e, t), t;
      }
      function gz(s, e, t) {
        hz(s, t), pz(e, t);
      }
      const Mb = /* @__PURE__ */ new WeakMap(), yz = O(([s, e, t]) => {
        let i = mu.sub(s).length();
        return i = i.sub(e).div(t.sub(e)), i = i.saturate(), i;
      }), xz = (s) => {
        const e = s.shadow.camera, t = Se("near", "float", e).setGroup($), i = Se("far", "float", e).setGroup($), n = hD(s);
        return yz(n, t, i);
      }, _z = (s) => {
        let e = Mb.get(s);
        if (e === void 0) {
          const t = s.isPointLight ? xz(s) : null;
          e = new tt(), e.colorNode = X(0, 0, 0, 1), e.depthNode = t, e.isShadowNodeMaterial = true, e.name = "ShadowMaterial", e.fog = false, Mb.set(s, e);
        }
        return e;
      }, bz = O(({ depthTexture: s, shadowCoord: e }) => fe(s, e.xy).compare(e.z)), Sz = O(({ depthTexture: s, shadowCoord: e, shadow: t }) => {
        const i = (g, _) => fe(s, g).compare(_), n = Se("mapSize", "vec2", t).setGroup($), r = Se("radius", "float", t).setGroup($), a = L(1).div(n), l = a.x.negate().mul(r), o = a.y.negate().mul(r), u = a.x.mul(r), c = a.y.mul(r), h = l.div(2), d = o.div(2), f = u.div(2), p = c.div(2);
        return Pt(i(e.xy.add(L(l, o)), e.z), i(e.xy.add(L(0, o)), e.z), i(e.xy.add(L(u, o)), e.z), i(e.xy.add(L(h, d)), e.z), i(e.xy.add(L(0, d)), e.z), i(e.xy.add(L(f, d)), e.z), i(e.xy.add(L(l, 0)), e.z), i(e.xy.add(L(h, 0)), e.z), i(e.xy, e.z), i(e.xy.add(L(f, 0)), e.z), i(e.xy.add(L(u, 0)), e.z), i(e.xy.add(L(h, p)), e.z), i(e.xy.add(L(0, p)), e.z), i(e.xy.add(L(f, p)), e.z), i(e.xy.add(L(l, c)), e.z), i(e.xy.add(L(0, c)), e.z), i(e.xy.add(L(u, c)), e.z)).mul(1 / 17);
      }), Tz = O(({ depthTexture: s, shadowCoord: e, shadow: t }) => {
        const i = (c, h) => fe(s, c).compare(h), n = Se("mapSize", "vec2", t).setGroup($), r = L(1).div(n), a = r.x, l = r.y, o = e.xy, u = Jn(o.mul(n).add(0.5));
        return o.subAssign(u.mul(r)), Pt(i(o, e.z), i(o.add(L(a, 0)), e.z), i(o.add(L(0, l)), e.z), i(o.add(r), e.z), Ce(i(o.add(L(a.negate(), 0)), e.z), i(o.add(L(a.mul(2), 0)), e.z), u.x), Ce(i(o.add(L(a.negate(), l)), e.z), i(o.add(L(a.mul(2), l)), e.z), u.x), Ce(i(o.add(L(0, l.negate())), e.z), i(o.add(L(0, l.mul(2))), e.z), u.y), Ce(i(o.add(L(a, l.negate())), e.z), i(o.add(L(a, l.mul(2))), e.z), u.y), Ce(Ce(i(o.add(L(a.negate(), l.negate())), e.z), i(o.add(L(a.mul(2), l.negate())), e.z), u.x), Ce(i(o.add(L(a.negate(), l.mul(2))), e.z), i(o.add(L(a.mul(2), l.mul(2))), e.z), u.x), u.y)).mul(1 / 9);
      }), vz = O(({ depthTexture: s, shadowCoord: e }) => {
        const t = C(1).toVar(), i = fe(s).sample(e.xy).rg, n = gM(e.z, i.x);
        return et(n.notEqual(C(1)), () => {
          const r = e.z.sub(i.x), a = Qt(0, i.y.mul(i.y));
          let l = a.div(a.add(r.mul(r)));
          l = Zs(qt(l, 0.3).div(0.95 - 0.3)), t.assign(Zs(Qt(n, l)));
        }), t;
      }), Mz = O(({ samples: s, radius: e, size: t, shadowPass: i }) => {
        const n = C(0).toVar(), r = C(0).toVar(), a = s.lessThanEqual(C(1)).select(C(0), C(2).div(s.sub(1))), l = s.lessThanEqual(C(1)).select(C(0), C(-1));
        qi({
          start: He(0),
          end: He(s),
          type: "int",
          condition: "<"
        }, ({ i: u }) => {
          const c = l.add(C(u).mul(a)), h = i.sample(Pt(qd.xy, L(0, c).mul(e)).div(t)).x;
          n.addAssign(h), r.addAssign(h.mul(h));
        }), n.divAssign(s), r.divAssign(s);
        const o = Zy(r.sub(n.mul(n)));
        return L(n, o);
      }), Az = O(({ samples: s, radius: e, size: t, shadowPass: i }) => {
        const n = C(0).toVar(), r = C(0).toVar(), a = s.lessThanEqual(C(1)).select(C(0), C(2).div(s.sub(1))), l = s.lessThanEqual(C(1)).select(C(0), C(-1));
        qi({
          start: He(0),
          end: He(s),
          type: "int",
          condition: "<"
        }, ({ i: u }) => {
          const c = l.add(C(u).mul(a)), h = i.sample(Pt(qd.xy, L(c, 0).mul(e)).div(t));
          n.addAssign(h.x), r.addAssign(Pt(h.y.mul(h.y), h.x.mul(h.x)));
        }), n.divAssign(s), r.divAssign(s);
        const o = Zy(r.sub(n.mul(n)));
        return L(n, o);
      }), Nz = [
        bz,
        Sz,
        Tz,
        vz
      ];
      let Tp;
      const Cc = new rA();
      class dA extends lz {
        static get type() {
          return "ShadowNode";
        }
        constructor(e, t = null) {
          super(e), this.shadow = t || e.shadow, this.shadowMap = null, this.vsmShadowMapVertical = null, this.vsmShadowMapHorizontal = null, this.vsmMaterialVertical = null, this.vsmMaterialHorizontal = null, this._node = null, this.isShadowNode = true;
        }
        setupShadowFilter(e, { filterFn: t, depthTexture: i, shadowCoord: n, shadow: r }) {
          const a = n.x.greaterThanEqual(0).and(n.x.lessThanEqual(1)).and(n.y.greaterThanEqual(0)).and(n.y.lessThanEqual(1)).and(n.z.lessThanEqual(1)), l = t({
            depthTexture: i,
            shadowCoord: n,
            shadow: r
          });
          return a.select(l, C(1));
        }
        setupShadowCoord(e, t) {
          const { shadow: i } = this, { renderer: n } = e, r = Se("bias", "float", i).setGroup($);
          let a = t, l;
          if (i.camera.isOrthographicCamera || n.logarithmicDepthBuffer !== true) a = a.xyz.div(a.w), l = a.z, n.coordinateSystem === Zn && (l = l.mul(2).sub(1));
          else {
            const o = a.w;
            a = a.xy.div(o);
            const u = Se("near", "float", i.camera).setGroup($), c = Se("far", "float", i.camera).setGroup($);
            l = PM(o.negate(), u, c);
          }
          return a = B(a.x, a.y.oneMinus(), l.add(r)), a;
        }
        getShadowFilterFn(e) {
          return Nz[e];
        }
        setupShadow(e) {
          const { renderer: t } = e, { light: i, shadow: n } = this, r = t.shadowMap.type, a = new zo(n.mapSize.width, n.mapSize.height);
          a.compareFunction = Dy;
          const l = e.createRenderTarget(n.mapSize.width, n.mapSize.height);
          if (l.depthTexture = a, n.camera.updateProjectionMatrix(), r === sc) {
            a.compareFunction = null, this.vsmShadowMapVertical = e.createRenderTarget(n.mapSize.width, n.mapSize.height, {
              format: lu,
              type: ks
            }), this.vsmShadowMapHorizontal = e.createRenderTarget(n.mapSize.width, n.mapSize.height, {
              format: lu,
              type: ks
            });
            const m = fe(a), y = fe(this.vsmShadowMapVertical.texture), x = Se("blurSamples", "float", n).setGroup($), b = Se("radius", "float", n).setGroup($), T = Se("mapSize", "vec2", n).setGroup($);
            let N = this.vsmMaterialVertical || (this.vsmMaterialVertical = new tt());
            N.fragmentNode = Mz({
              samples: x,
              radius: b,
              size: T,
              shadowPass: m
            }).context(e.getSharedContext()), N.name = "VSMVertical", N = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new tt()), N.fragmentNode = Az({
              samples: x,
              radius: b,
              size: T,
              shadowPass: y
            }).context(e.getSharedContext()), N.name = "VSMHorizontal";
          }
          const o = Se("intensity", "float", n).setGroup($), u = Se("normalBias", "float", n).setGroup($), c = oA(i).mul(hA.add(r0.mul(u))), h = this.setupShadowCoord(e, c), d = n.filterNode || this.getShadowFilterFn(t.shadowMap.type) || null;
          if (d === null) throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
          const f = r === sc ? this.vsmShadowMapHorizontal.texture : a, p = this.setupShadowFilter(e, {
            filterFn: d,
            shadowTexture: l.texture,
            depthTexture: f,
            shadowCoord: h,
            shadow: n
          }), g = fe(l.texture, h), _ = Ce(1, p.rgb.mix(g, 1), o.mul(g.a)).toVar();
          return this.shadowMap = l, this.shadow.map = l, _;
        }
        setup(e) {
          if (e.renderer.shadowMap.enabled !== false) return O(() => {
            let t = this._node;
            return this.setupShadowPosition(e), t === null && (this._node = t = this.setupShadow(e)), e.material.shadowNode && console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'), e.material.receivedShadowNode && (t = e.material.receivedShadowNode(t)), t;
          })();
        }
        renderShadow(e) {
          const { shadow: t, shadowMap: i, light: n } = this, { renderer: r, scene: a } = e;
          t.updateMatrices(n), i.setSize(t.mapSize.width, t.mapSize.height), r.render(a, t.camera);
        }
        updateShadow(e) {
          const { shadowMap: t, light: i, shadow: n } = this, { renderer: r, scene: a, camera: l } = e, o = r.shadowMap.type, u = t.depthTexture.version;
          this._depthVersionCached = u, n.camera.layers.mask = l.layers.mask;
          const c = r.getRenderObjectFunction(), h = r.getMRT(), d = h ? h.has("velocity") : false;
          Tp = mz(r, a, Tp), a.overrideMaterial = _z(i), r.setRenderObjectFunction((f, p, g, _, m, y, ...x) => {
            (f.castShadow === true || f.receiveShadow && o === sc) && (d && (Wv(f).useVelocity = true), f.onBeforeShadow(r, f, l, n.camera, _, p.overrideMaterial, y), r.renderObject(f, p, g, _, m, y, ...x), f.onAfterShadow(r, f, l, n.camera, _, p.overrideMaterial, y));
          }), r.setRenderTarget(t), this.renderShadow(e), r.setRenderObjectFunction(c), i.isPointLight !== true && o === sc && this.vsmPass(r), gz(r, a, Tp);
        }
        vsmPass(e) {
          const { shadow: t } = this;
          this.vsmShadowMapVertical.setSize(t.mapSize.width, t.mapSize.height), this.vsmShadowMapHorizontal.setSize(t.mapSize.width, t.mapSize.height), e.setRenderTarget(this.vsmShadowMapVertical), Cc.material = this.vsmMaterialVertical, Cc.render(e), e.setRenderTarget(this.vsmShadowMapHorizontal), Cc.material = this.vsmMaterialHorizontal, Cc.render(e);
        }
        dispose() {
          this.shadowMap.dispose(), this.shadowMap = null, this.vsmShadowMapVertical !== null && (this.vsmShadowMapVertical.dispose(), this.vsmShadowMapVertical = null, this.vsmMaterialVertical.dispose(), this.vsmMaterialVertical = null), this.vsmShadowMapHorizontal !== null && (this.vsmShadowMapHorizontal.dispose(), this.vsmShadowMapHorizontal = null, this.vsmMaterialHorizontal.dispose(), this.vsmMaterialHorizontal = null), super.dispose();
        }
        updateBefore(e) {
          const { shadow: t } = this;
          (t.needsUpdate || t.autoUpdate) && (this.updateShadow(e), this.shadowMap.depthTexture.version === this._depthVersionCached && (t.needsUpdate = false));
        }
      }
      const wz = (s, e) => F(new dA(s, e));
      class Zr extends Go {
        static get type() {
          return "AnalyticLightNode";
        }
        constructor(e = null) {
          super(), this.light = e, this.color = new ie(), this.colorNode = e && e.colorNode || Z(this.color).setGroup($), this.baseColorNode = null, this.shadowNode = null, this.shadowColorNode = null, this.isAnalyticLightNode = true, this.updateType = te.FRAME;
        }
        customCacheKey() {
          return Vy(this.light.id, this.light.castShadow ? 1 : 0);
        }
        getHash() {
          return this.light.uuid;
        }
        setupShadowNode() {
          return wz(this.light);
        }
        setupShadow(e) {
          const { renderer: t } = e;
          if (t.shadowMap.enabled === false) return;
          let i = this.shadowColorNode;
          if (i === null) {
            const n = this.light.shadow.shadowNode;
            let r;
            n !== void 0 ? r = F(n) : r = this.setupShadowNode(e), this.shadowNode = r, this.shadowColorNode = i = this.colorNode.mul(r), this.baseColorNode = this.colorNode;
          }
          this.colorNode = i;
        }
        setup(e) {
          this.colorNode = this.baseColorNode || this.colorNode, this.light.castShadow ? e.object.receiveShadow && this.setupShadow(e) : this.shadowNode !== null && (this.shadowNode.dispose(), this.shadowNode = null, this.shadowColorNode = null);
        }
        update() {
          const { light: e } = this;
          this.color.copy(e.color).multiplyScalar(e.intensity);
        }
      }
      const fA = O((s) => {
        const { lightDistance: e, cutoffDistance: t, decayExponent: i } = s, n = e.pow(i).max(0.01).reciprocal();
        return t.greaterThan(0).select(n.mul(e.div(t).pow4().oneMinus().clamp().pow2()), n);
      }), Ez = new ie(), Qi = O(([s, e]) => {
        const t = s.toVar(), i = Mi(t), n = Xs(1, Qt(i.x, Qt(i.y, i.z)));
        i.mulAssign(n), t.mulAssign(n.mul(e.mul(2).oneMinus()));
        const r = L(t.xy).toVar(), l = e.mul(1.5).oneMinus();
        return et(i.z.greaterThanEqual(l), () => {
          et(t.z.greaterThan(0), () => {
            r.x.assign(qt(4, t.x));
          });
        }).ElseIf(i.x.greaterThanEqual(l), () => {
          const o = ad(t.x);
          r.x.assign(t.z.mul(o).add(o.mul(2)));
        }).ElseIf(i.y.greaterThanEqual(l), () => {
          const o = ad(t.y);
          r.x.assign(t.x.add(o.mul(2)).add(2)), r.y.assign(t.z.mul(o).sub(2));
        }), L(0.125, 0.25).mul(r).add(L(0.375, 0.75)).flipY();
      }).setLayout({
        name: "cubeToUV",
        type: "vec2",
        inputs: [
          {
            name: "pos",
            type: "vec3"
          },
          {
            name: "texelSizeY",
            type: "float"
          }
        ]
      }), Rz = O(({ depthTexture: s, bd3D: e, dp: t, texelSize: i }) => fe(s, Qi(e, i.y)).compare(t)), Cz = O(({ depthTexture: s, bd3D: e, dp: t, texelSize: i, shadow: n }) => {
        const r = Se("radius", "float", n).setGroup($), a = L(-1, 1).mul(r).mul(i.y);
        return fe(s, Qi(e.add(a.xyy), i.y)).compare(t).add(fe(s, Qi(e.add(a.yyy), i.y)).compare(t)).add(fe(s, Qi(e.add(a.xyx), i.y)).compare(t)).add(fe(s, Qi(e.add(a.yyx), i.y)).compare(t)).add(fe(s, Qi(e, i.y)).compare(t)).add(fe(s, Qi(e.add(a.xxy), i.y)).compare(t)).add(fe(s, Qi(e.add(a.yxy), i.y)).compare(t)).add(fe(s, Qi(e.add(a.xxx), i.y)).compare(t)).add(fe(s, Qi(e.add(a.yxx), i.y)).compare(t)).mul(1 / 9);
      }), Bz = O(({ filterFn: s, depthTexture: e, shadowCoord: t, shadow: i }) => {
        const n = t.xyz.toVar(), r = n.length(), a = Z("float").setGroup($).onRenderUpdate(() => i.camera.near), l = Z("float").setGroup($).onRenderUpdate(() => i.camera.far), o = Se("bias", "float", i).setGroup($), u = Z(i.mapSize).setGroup($), c = C(1).toVar();
        return et(r.sub(l).lessThanEqual(0).and(r.sub(a).greaterThanEqual(0)), () => {
          const h = r.sub(a).div(l.sub(a)).toVar();
          h.addAssign(o);
          const d = n.normalize(), f = L(1).div(u.mul(L(4, 2)));
          c.assign(s({
            depthTexture: e,
            bd3D: d,
            dp: h,
            texelSize: f,
            shadow: i
          }));
        }), c;
      }), Ab = new Te(), ma = new q(), al = new q();
      class Dz extends dA {
        static get type() {
          return "PointShadowNode";
        }
        constructor(e, t = null) {
          super(e, t);
        }
        getShadowFilterFn(e) {
          return e === X2 ? Rz : Cz;
        }
        setupShadowCoord(e, t) {
          return t;
        }
        setupShadowFilter(e, { filterFn: t, shadowTexture: i, depthTexture: n, shadowCoord: r, shadow: a }) {
          return Bz({
            filterFn: t,
            shadowTexture: i,
            depthTexture: n,
            shadowCoord: r,
            shadow: a
          });
        }
        renderShadow(e) {
          const { shadow: t, shadowMap: i, light: n } = this, { renderer: r, scene: a } = e, l = t.getFrameExtents();
          al.copy(t.mapSize), al.multiply(l), i.setSize(al.width, al.height), ma.copy(t.mapSize);
          const o = r.autoClear, u = r.getClearColor(Ez), c = r.getClearAlpha();
          r.autoClear = false, r.setClearColor(t.clearColor, t.clearAlpha), r.clear();
          const h = t.getViewportCount();
          for (let d = 0; d < h; d++) {
            const f = t.getViewport(d), p = ma.x * f.x, g = al.y - ma.y - ma.y * f.y;
            Ab.set(p, g, ma.x * f.z, ma.y * f.w), i.viewport.copy(Ab), t.updateMatrices(n, d), r.render(a, t.camera);
          }
          r.autoClear = o, r.setClearColor(u, c);
        }
      }
      const Uz = (s, e) => F(new Dz(s, e)), Fz = O(({ color: s, lightViewPosition: e, cutoffDistance: t, decayExponent: i }, n) => {
        const r = n.context.lightingModel, a = e.sub(Ke), l = a.normalize(), o = a.length(), u = fA({
          lightDistance: o,
          cutoffDistance: t,
          decayExponent: i
        }), c = s.mul(u), h = n.context.reflectedLight;
        r.direct({
          lightDirection: l,
          lightColor: c,
          reflectedLight: h
        }, n.stack, n);
      });
      class Oz extends Zr {
        static get type() {
          return "PointLightNode";
        }
        constructor(e = null) {
          super(e), this.cutoffDistanceNode = Z(0).setGroup($), this.decayExponentNode = Z(2).setGroup($);
        }
        update(e) {
          const { light: t } = this;
          super.update(e), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
        }
        setupShadowNode() {
          return Uz(this.light);
        }
        setup(e) {
          super.setup(e), Fz({
            color: this.colorNode,
            lightViewPosition: d0(this.light),
            cutoffDistance: this.cutoffDistanceNode,
            decayExponent: this.decayExponentNode
          }).append();
        }
      }
      const zz = O(([s, e]) => {
        const t = s.x, i = s.y, n = s.z;
        let r = e.element(0).mul(0.886227);
        return r = r.add(e.element(1).mul(2 * 0.511664).mul(i)), r = r.add(e.element(2).mul(2 * 0.511664).mul(n)), r = r.add(e.element(3).mul(2 * 0.511664).mul(t)), r = r.add(e.element(4).mul(2 * 0.429043).mul(t).mul(i)), r = r.add(e.element(5).mul(2 * 0.429043).mul(i).mul(n)), r = r.add(e.element(6).mul(n.mul(n).mul(0.743125).sub(0.247708))), r = r.add(e.element(7).mul(2 * 0.429043).mul(t).mul(n)), r = r.add(e.element(8).mul(0.429043).mul(ae(t, t).sub(ae(i, i)))), r;
      }), vs = new h0();
      class Lz extends er {
        constructor(e, t) {
          super(), this.renderer = e, this.nodes = t;
        }
        update(e, t, i) {
          const n = this.renderer, r = this.nodes.getBackgroundNode(e) || e.background;
          let a = false;
          if (r === null) n._clearColor.getRGB(vs, Vn), vs.a = n._clearColor.a;
          else if (r.isColor === true) r.getRGB(vs, Vn), vs.a = 1, a = true;
          else if (r.isNode === true) {
            const l = this.get(e), o = r;
            vs.copy(n._clearColor);
            let u = l.backgroundMesh;
            if (u === void 0) {
              const h = Jy(X(o).mul(Sb), {
                getUV: () => IO.mul(wM),
                getTextureLevel: () => kO
              });
              let d = FM;
              d = d.setZ(d.w);
              const f = new tt();
              f.name = "Background.material", f.side = Fi, f.depthTest = false, f.depthWrite = false, f.fog = false, f.lights = false, f.vertexNode = d, f.colorNode = h, l.backgroundMeshNode = h, l.backgroundMesh = u = new as(new zd(1, 32, 32), f), u.frustumCulled = false, u.name = "Background.mesh", u.onBeforeRender = function(p, g, _) {
                this.matrixWorld.copyPosition(_.matrixWorld);
              };
            }
            const c = o.getCacheKey();
            l.backgroundCacheKey !== c && (l.backgroundMeshNode.node = X(o).mul(Sb), l.backgroundMeshNode.needsUpdate = true, u.material.needsUpdate = true, l.backgroundCacheKey = c), t.unshift(u, u.geometry, u.material, 0, 0, null, null);
          } else console.error("THREE.Renderer: Unsupported background configuration.", r);
          if (n.autoClear === true || a === true) {
            const l = i.clearColorValue;
            l.r = vs.r, l.g = vs.g, l.b = vs.b, l.a = vs.a, (n.backend.isWebGLBackend === true || n.alpha === true) && (l.r *= l.a, l.g *= l.a, l.b *= l.a), i.depthClearValue = n._clearDepth, i.stencilClearValue = n._clearStencil, i.clearColor = n.autoClearColor === true, i.clearDepth = n.autoClearDepth === true, i.clearStencil = n.autoClearStencil === true;
          } else i.clearColor = false, i.clearDepth = false, i.clearStencil = false;
        }
      }
      let Gz = 0;
      class Tg {
        constructor(e = "", t = [], i = 0, n = []) {
          this.name = e, this.bindings = t, this.index = i, this.bindingsReference = n, this.id = Gz++;
        }
      }
      class Pz {
        constructor(e, t, i, n, r, a, l, o, u, c = []) {
          this.vertexShader = e, this.fragmentShader = t, this.computeShader = i, this.transforms = c, this.nodeAttributes = n, this.bindings = r, this.updateNodes = a, this.updateBeforeNodes = l, this.updateAfterNodes = o, this.monitor = u, this.usedTimes = 0;
        }
        createBindings() {
          const e = [];
          for (const t of this.bindings) if (t.bindings[0].groupNode.shared !== true) {
            const n = new Tg(t.name, [], t.index, t);
            e.push(n);
            for (const r of t.bindings) n.bindings.push(r.clone());
          } else e.push(t);
          return e;
        }
      }
      class Nb {
        constructor(e, t, i = null) {
          this.isNodeAttribute = true, this.name = e, this.type = t, this.node = i;
        }
      }
      class kz {
        constructor(e, t, i) {
          this.isNodeUniform = true, this.name = e, this.type = t, this.node = i.getSelf();
        }
        get value() {
          return this.node.value;
        }
        set value(e) {
          this.node.value = e;
        }
        get id() {
          return this.node.id;
        }
        get groupNode() {
          return this.node.groupNode;
        }
      }
      class pA {
        constructor(e, t) {
          this.isNodeVar = true, this.name = e, this.type = t;
        }
      }
      class Iz extends pA {
        constructor(e, t) {
          super(e, t), this.needsInterpolation = false, this.isNodeVarying = true;
        }
      }
      class Vz {
        constructor(e, t, i = "") {
          this.name = e, this.type = t, this.code = i, Object.defineProperty(this, "isNodeCode", {
            value: true
          });
        }
      }
      let Hz = 0;
      class vp {
        constructor(e = null) {
          this.id = Hz++, this.nodesData = /* @__PURE__ */ new WeakMap(), this.parent = e;
        }
        getData(e) {
          let t = this.nodesData.get(e);
          return t === void 0 && this.parent !== null && (t = this.parent.getData(e)), t;
        }
        setData(e, t) {
          this.nodesData.set(e, t);
        }
      }
      class qz extends Q {
        static get type() {
          return "StructTypeNode";
        }
        constructor(e, t) {
          super(), this.name = e, this.types = t, this.isStructTypeNode = true;
        }
        getMemberTypes() {
          return this.types;
        }
      }
      class Qr {
        constructor(e, t) {
          this.name = e, this.value = t, this.boundary = 0, this.itemSize = 0, this.offset = 0;
        }
        setValue(e) {
          this.value = e;
        }
        getValue() {
          return this.value;
        }
      }
      class Yz extends Qr {
        constructor(e, t = 0) {
          super(e, t), this.isNumberUniform = true, this.boundary = 4, this.itemSize = 1;
        }
      }
      class Wz extends Qr {
        constructor(e, t = new q()) {
          super(e, t), this.isVector2Uniform = true, this.boundary = 8, this.itemSize = 2;
        }
      }
      class jz extends Qr {
        constructor(e, t = new v()) {
          super(e, t), this.isVector3Uniform = true, this.boundary = 16, this.itemSize = 3;
        }
      }
      class $z extends Qr {
        constructor(e, t = new Te()) {
          super(e, t), this.isVector4Uniform = true, this.boundary = 16, this.itemSize = 4;
        }
      }
      class Xz extends Qr {
        constructor(e, t = new ie()) {
          super(e, t), this.isColorUniform = true, this.boundary = 16, this.itemSize = 3;
        }
      }
      class Zz extends Qr {
        constructor(e, t = new Jt()) {
          super(e, t), this.isMatrix3Uniform = true, this.boundary = 48, this.itemSize = 12;
        }
      }
      class Qz extends Qr {
        constructor(e, t = new pe()) {
          super(e, t), this.isMatrix4Uniform = true, this.boundary = 64, this.itemSize = 16;
        }
      }
      class Kz extends Yz {
        constructor(e) {
          super(e.name, e.value), this.nodeUniform = e;
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class Jz extends Wz {
        constructor(e) {
          super(e.name, e.value), this.nodeUniform = e;
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class eL extends jz {
        constructor(e) {
          super(e.name, e.value), this.nodeUniform = e;
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class tL extends $z {
        constructor(e) {
          super(e.name, e.value), this.nodeUniform = e;
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class iL extends Xz {
        constructor(e) {
          super(e.name, e.value), this.nodeUniform = e;
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class sL extends Zz {
        constructor(e) {
          super(e.name, e.value), this.nodeUniform = e;
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      class nL extends Qz {
        constructor(e) {
          super(e.name, e.value), this.nodeUniform = e;
        }
        getValue() {
          return this.nodeUniform.value;
        }
        getType() {
          return this.nodeUniform.type;
        }
      }
      const Ia = 4, wb = [
        0.125,
        0.215,
        0.35,
        0.446,
        0.526,
        0.582
      ], gr = 20, Mp = new ky(-1, 1, 1, -1, 0, 1), rL = new Ki(90, 1), Eb = new ie();
      let Ap = null, Np = 0, wp = 0;
      const dr = (1 + Math.sqrt(5)) / 2, ga = 1 / dr, Rb = [
        new v(-dr, ga, 0),
        new v(dr, ga, 0),
        new v(-ga, 0, dr),
        new v(ga, 0, dr),
        new v(0, dr, -ga),
        new v(0, dr, ga),
        new v(-1, 1, -1),
        new v(1, 1, -1),
        new v(-1, 1, 1),
        new v(1, 1, 1)
      ], aL = [
        3,
        1,
        5,
        0,
        4,
        2
      ], Ep = OF(Vd(), Qs("faceIndex")).normalize(), f0 = B(Ep.x, Ep.y, Ep.z);
      class oL {
        constructor(e) {
          this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._lodMeshes = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._backgroundBox = null;
        }
        get _hasInitialized() {
          return this._renderer.hasInitialized();
        }
        fromScene(e, t = 0, i = 0.1, n = 100, r = null) {
          if (this._setSize(256), this._hasInitialized === false) {
            console.warn("THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.");
            const l = r || this._allocateTargets();
            return this.fromSceneAsync(e, t, i, n, l), l;
          }
          Ap = this._renderer.getRenderTarget(), Np = this._renderer.getActiveCubeFace(), wp = this._renderer.getActiveMipmapLevel();
          const a = r || this._allocateTargets();
          return a.depthBuffer = true, this._sceneToCubeUV(e, i, n, a), t > 0 && this._blur(a, 0, 0, t), this._applyPMREM(a), this._cleanup(a), a;
        }
        async fromSceneAsync(e, t = 0, i = 0.1, n = 100, r = null) {
          return this._hasInitialized === false && await this._renderer.init(), this.fromScene(e, t, i, n, r);
        }
        fromEquirectangular(e, t = null) {
          if (this._hasInitialized === false) {
            console.warn("THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead."), this._setSizeFromTexture(e);
            const i = t || this._allocateTargets();
            return this.fromEquirectangularAsync(e, i), i;
          }
          return this._fromTexture(e, t);
        }
        async fromEquirectangularAsync(e, t = null) {
          return this._hasInitialized === false && await this._renderer.init(), this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          if (this._hasInitialized === false) {
            console.warn("THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."), this._setSizeFromTexture(e);
            const i = t || this._allocateTargets();
            return this.fromCubemapAsync(e, t), i;
          }
          return this._fromTexture(e, t);
        }
        async fromCubemapAsync(e, t = null) {
          return this._hasInitialized === false && await this._renderer.init(), this._fromTexture(e, t);
        }
        async compileCubemapShader() {
          this._cubemapMaterial === null && (this._cubemapMaterial = Bb(), await this._compileMaterial(this._cubemapMaterial));
        }
        async compileEquirectangularShader() {
          this._equirectMaterial === null && (this._equirectMaterial = Db(), await this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose(), this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(), this._backgroundBox.material.dispose());
        }
        _setSizeFromTexture(e) {
          e.mapping === Fr || e.mapping === _o ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4);
        }
        _setSize(e) {
          this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(Ap, Np, wp), e.scissorTest = false, Bc(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          this._setSizeFromTexture(e), Ap = this._renderer.getRenderTarget(), Np = this._renderer.getActiveCubeFace(), wp = this._renderer.getActiveMipmapLevel();
          const i = t || this._allocateTargets();
          return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
            magFilter: pi,
            minFilter: pi,
            generateMipmaps: false,
            type: ks,
            format: Or,
            colorSpace: Vn
          }, n = Cb(e, t, i);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Cb(e, t, i);
            const { _lodMax: r } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = lL(r)), this._blurMaterial = uL(r, e, t);
          }
          return n;
        }
        async _compileMaterial(e) {
          const t = new as(this._lodPlanes[0], e);
          await this._renderer.compile(t, Mp);
        }
        _sceneToCubeUV(e, t, i, n) {
          const r = rL;
          r.near = t, r.far = i;
          const a = [
            1,
            1,
            1,
            1,
            -1,
            1
          ], l = [
            1,
            -1,
            1,
            -1,
            1,
            -1
          ], o = this._renderer, u = o.autoClear;
          o.getClearColor(Eb), o.autoClear = false;
          let c = this._backgroundBox;
          if (c === null) {
            const f = new Fy({
              name: "PMREM.Background",
              side: Fi,
              depthWrite: false,
              depthTest: false
            });
            c = new as(new Oo(), f);
          }
          let h = false;
          const d = e.background;
          d ? d.isColor && (c.material.color.copy(d), e.background = null, h = true) : (c.material.color.copy(Eb), h = true), o.setRenderTarget(n), o.clear(), h && o.render(c, r);
          for (let f = 0; f < 6; f++) {
            const p = f % 3;
            p === 0 ? (r.up.set(0, a[f], 0), r.lookAt(l[f], 0, 0)) : p === 1 ? (r.up.set(0, 0, a[f]), r.lookAt(0, l[f], 0)) : (r.up.set(0, a[f], 0), r.lookAt(0, 0, l[f]));
            const g = this._cubeSize;
            Bc(n, p * g, f > 2 ? g : 0, g, g), o.render(e, r);
          }
          o.autoClear = u, e.background = d;
        }
        _textureToCubeUV(e, t) {
          const i = this._renderer, n = e.mapping === Fr || e.mapping === _o;
          n ? this._cubemapMaterial === null && (this._cubemapMaterial = Bb(e)) : this._equirectMaterial === null && (this._equirectMaterial = Db(e));
          const r = n ? this._cubemapMaterial : this._equirectMaterial;
          r.fragmentNode.value = e;
          const a = this._lodMeshes[0];
          a.material = r;
          const l = this._cubeSize;
          Bc(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(a, Mp);
        }
        _applyPMREM(e) {
          const t = this._renderer, i = t.autoClear;
          t.autoClear = false;
          const n = this._lodPlanes.length;
          for (let r = 1; r < n; r++) {
            const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), l = Rb[(n - r - 1) % Rb.length];
            this._blur(e, r - 1, r, a, l);
          }
          t.autoClear = i;
        }
        _blur(e, t, i, n, r) {
          const a = this._pingPongRenderTarget;
          this._halfBlur(e, a, t, i, n, "latitudinal", r), this._halfBlur(a, e, i, i, n, "longitudinal", r);
        }
        _halfBlur(e, t, i, n, r, a, l) {
          const o = this._renderer, u = this._blurMaterial;
          a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
          const c = 3, h = this._lodMeshes[n];
          h.material = u;
          const d = u.uniforms, f = this._sizeLods[i] - 1, p = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * gr - 1), g = r / p, _ = isFinite(r) ? 1 + Math.floor(c * g) : gr;
          _ > gr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${gr}`);
          const m = [];
          let y = 0;
          for (let A = 0; A < gr; ++A) {
            const w = A / g, k = Math.exp(-w * w / 2);
            m.push(k), A === 0 ? y += k : A < _ && (y += 2 * k);
          }
          for (let A = 0; A < m.length; A++) m[A] = m[A] / y;
          e.texture.frame = (e.texture.frame || 0) + 1, d.envMap.value = e.texture, d.samples.value = _, d.weights.array = m, d.latitudinal.value = a === "latitudinal" ? 1 : 0, l && (d.poleAxis.value = l);
          const { _lodMax: x } = this;
          d.dTheta.value = p, d.mipInt.value = x - i;
          const b = this._sizeLods[n], T = 3 * b * (n > x - Ia ? n - x + Ia : 0), N = 4 * (this._cubeSize - b);
          Bc(t, T, N, 3 * b, 2 * b), o.setRenderTarget(t), o.render(h, Mp);
        }
      }
      function lL(s) {
        const e = [], t = [], i = [], n = [];
        let r = s;
        const a = s - Ia + 1 + wb.length;
        for (let l = 0; l < a; l++) {
          const o = Math.pow(2, r);
          t.push(o);
          let u = 1 / o;
          l > s - Ia ? u = wb[l - s + Ia - 1] : l === 0 && (u = 0), i.push(u);
          const c = 1 / (o - 2), h = -c, d = 1 + c, f = [
            h,
            h,
            d,
            h,
            d,
            d,
            h,
            h,
            d,
            d,
            h,
            d
          ], p = 6, g = 6, _ = 3, m = 2, y = 1, x = new Float32Array(_ * g * p), b = new Float32Array(m * g * p), T = new Float32Array(y * g * p);
          for (let A = 0; A < p; A++) {
            const w = A % 3 * 2 / 3 - 1, k = A > 2 ? 0 : -1, G = [
              w,
              k,
              0,
              w + 2 / 3,
              k,
              0,
              w + 2 / 3,
              k + 1,
              0,
              w,
              k,
              0,
              w + 2 / 3,
              k + 1,
              0,
              w,
              k + 1,
              0
            ], I = aL[A];
            x.set(G, _ * g * I), b.set(f, m * g * I);
            const be = [
              I,
              I,
              I,
              I,
              I,
              I
            ];
            T.set(be, y * g * I);
          }
          const N = new en();
          N.setAttribute("position", new Ci(x, _)), N.setAttribute("uv", new Ci(b, m)), N.setAttribute("faceIndex", new Ci(T, y)), e.push(N), n.push(new as(N, null)), r > Ia && r--;
        }
        return {
          lodPlanes: e,
          sizeLods: t,
          sigmas: i,
          lodMeshes: n
        };
      }
      function Cb(s, e, t) {
        const i = new Uo(s, e, t);
        return i.texture.mapping = Hm, i.texture.name = "PMREM.cubeUv", i.texture.isPMREMTexture = true, i.scissorTest = true, i;
      }
      function Bc(s, e, t, i, n) {
        s.viewport.set(e, t, i, n), s.scissor.set(e, t, i, n);
      }
      function p0(s) {
        const e = new tt();
        return e.depthTest = false, e.depthWrite = false, e.blending = xo, e.name = `PMREM_${s}`, e;
      }
      function uL(s, e, t) {
        const i = An(new Array(gr).fill(0)), n = Z(new v(0, 1, 0)), r = Z(0), a = C(gr), l = Z(0), o = Z(1), u = fe(null), c = Z(0), h = C(1 / e), d = C(1 / t), f = C(s), p = {
          n: a,
          latitudinal: l,
          weights: i,
          poleAxis: n,
          outputDirection: f0,
          dTheta: r,
          samples: o,
          envMap: u,
          mipInt: c,
          CUBEUV_TEXEL_WIDTH: h,
          CUBEUV_TEXEL_HEIGHT: d,
          CUBEUV_MAX_MIP: f
        }, g = p0("blur");
        return g.uniforms = p, g.fragmentNode = LF({
          ...p,
          latitudinal: l.equal(1)
        }), g;
      }
      function Bb(s) {
        const e = p0("cubemap");
        return e.fragmentNode = gu(s, f0), e;
      }
      function Db(s) {
        const e = p0("equirect");
        return e.fragmentNode = fe(s, VM(f0), 0), e;
      }
      const Ub = /* @__PURE__ */ new WeakMap(), cL = /* @__PURE__ */ new Map([
        [
          Int8Array,
          "int"
        ],
        [
          Int16Array,
          "int"
        ],
        [
          Int32Array,
          "int"
        ],
        [
          Uint8Array,
          "uint"
        ],
        [
          Uint16Array,
          "uint"
        ],
        [
          Uint32Array,
          "uint"
        ],
        [
          Float32Array,
          "float"
        ]
      ]), Dc = (s) => /e/g.test(s) ? String(s).replace(/\+/g, "") : (s = Number(s), s + (s % 1 ? "" : ".0"));
      class mA {
        constructor(e, t, i) {
          this.object = e, this.material = e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = t, this.parser = i, this.scene = null, this.camera = null, this.nodes = [], this.sequentialNodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.updateAfterNodes = [], this.hashNodes = {}, this.monitor = null, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.clippingContext = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = {
            vertex: [],
            fragment: [],
            compute: []
          }, this.flowCode = {
            vertex: "",
            fragment: "",
            compute: ""
          }, this.uniforms = {
            vertex: [],
            fragment: [],
            compute: [],
            index: 0
          }, this.structs = {
            vertex: [],
            fragment: [],
            compute: [],
            index: 0
          }, this.bindings = {
            vertex: {},
            fragment: {},
            compute: {}
          }, this.bindingsIndexes = {}, this.bindGroups = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.flow = {
            code: ""
          }, this.chaining = [], this.stack = xp(), this.stacks = [], this.tab = "	", this.currentFunctionNode = null, this.context = {
            material: this.material
          }, this.cache = new vp(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null, this.useComparisonMethod = false;
        }
        getBindGroupsCache() {
          let e = Ub.get(this.renderer);
          return e === void 0 && (e = new us(), Ub.set(this.renderer, e)), e;
        }
        createRenderTarget(e, t, i) {
          return new Uo(e, t, i);
        }
        createCubeRenderTarget(e, t) {
          return new HM(e, t);
        }
        createPMREMGenerator() {
          return new oL(this.renderer);
        }
        includes(e) {
          return this.nodes.includes(e);
        }
        _getBindGroup(e, t) {
          const i = this.getBindGroupsCache(), n = [];
          let r = true;
          for (const l of t) n.push(l), r = r && l.groupNode.shared !== true;
          let a;
          return r ? (a = i.get(n), a === void 0 && (a = new Tg(e, n, this.bindingsIndexes[e].group, n), i.set(n, a))) : a = new Tg(e, n, this.bindingsIndexes[e].group, n), a;
        }
        getBindGroupArray(e, t) {
          const i = this.bindings[t];
          let n = i[e];
          return n === void 0 && (this.bindingsIndexes[e] === void 0 && (this.bindingsIndexes[e] = {
            binding: 0,
            group: Object.keys(this.bindingsIndexes).length
          }), i[e] = n = []), n;
        }
        getBindings() {
          let e = this.bindGroups;
          if (e === null) {
            const t = {}, i = this.bindings;
            for (const n of O_) for (const r in i[n]) {
              const a = i[n][r];
              (t[r] || (t[r] = [])).push(...a);
            }
            e = [];
            for (const n in t) {
              const r = t[n], a = this._getBindGroup(n, r);
              e.push(a);
            }
            this.bindGroups = e;
          }
          return e;
        }
        sortBindingGroups() {
          const e = this.getBindings();
          e.sort((t, i) => t.bindings[0].groupNode.order - i.bindings[0].groupNode.order);
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            this.bindingsIndexes[i.name].group = t, i.index = t;
          }
        }
        setHashNode(e, t) {
          this.hashNodes[t] = e;
        }
        addNode(e) {
          this.nodes.includes(e) === false && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
        }
        addSequentialNode(e) {
          this.sequentialNodes.includes(e) === false && this.sequentialNodes.push(e);
        }
        buildUpdateNodes() {
          for (const e of this.nodes) e.getUpdateType() !== te.NONE && this.updateNodes.push(e.getSelf());
          for (const e of this.sequentialNodes) {
            const t = e.getUpdateBeforeType(), i = e.getUpdateAfterType();
            t !== te.NONE && this.updateBeforeNodes.push(e.getSelf()), i !== te.NONE && this.updateAfterNodes.push(e.getSelf());
          }
        }
        get currentNode() {
          return this.chaining[this.chaining.length - 1];
        }
        isFilteredTexture(e) {
          return e.magFilter === pi || e.magFilter === Ym || e.magFilter === eo || e.magFilter === Ps || e.minFilter === pi || e.minFilter === Ym || e.minFilter === eo || e.minFilter === Ps;
        }
        addChain(e) {
          this.chaining.push(e);
        }
        removeChain(e) {
          if (this.chaining.pop() !== e) throw new Error("NodeBuilder: Invalid node chaining!");
        }
        getMethod(e) {
          return e;
        }
        getNodeFromHash(e) {
          return this.hashNodes[e];
        }
        addFlow(e, t) {
          return this.flowNodes[e].push(t), t;
        }
        setContext(e) {
          this.context = e;
        }
        getContext() {
          return this.context;
        }
        getSharedContext() {
          return {
            ...this.context
          }, this.context;
        }
        setCache(e) {
          this.cache = e;
        }
        getCache() {
          return this.cache;
        }
        getCacheFromNode(e, t = true) {
          const i = this.getDataFromNode(e);
          return i.cache === void 0 && (i.cache = new vp(t ? this.getCache() : null)), i.cache;
        }
        isAvailable() {
          return false;
        }
        getVertexIndex() {
          console.warn("Abstract function.");
        }
        getInstanceIndex() {
          console.warn("Abstract function.");
        }
        getDrawIndex() {
          console.warn("Abstract function.");
        }
        getFrontFacing() {
          console.warn("Abstract function.");
        }
        getFragCoord() {
          console.warn("Abstract function.");
        }
        isFlipY() {
          return false;
        }
        increaseUsage(e) {
          const t = this.getDataFromNode(e);
          return t.usageCount = t.usageCount === void 0 ? 1 : t.usageCount + 1, t.usageCount;
        }
        generateTexture() {
          console.warn("Abstract function.");
        }
        generateTextureLod() {
          console.warn("Abstract function.");
        }
        generateConst(e, t = null) {
          if (t === null && (e === "float" || e === "int" || e === "uint" ? t = 0 : e === "bool" ? t = false : e === "color" ? t = new ie() : e === "vec2" ? t = new q() : e === "vec3" ? t = new v() : e === "vec4" && (t = new Te())), e === "float") return Dc(t);
          if (e === "int") return `${Math.round(t)}`;
          if (e === "uint") return t >= 0 ? `${Math.round(t)}u` : "0u";
          if (e === "bool") return t ? "true" : "false";
          if (e === "color") return `${this.getType("vec3")}( ${Dc(t.r)}, ${Dc(t.g)}, ${Dc(t.b)} )`;
          const i = this.getTypeLength(e), n = this.getComponentType(e), r = (a) => this.generateConst(n, a);
          if (i === 2) return `${this.getType(e)}( ${r(t.x)}, ${r(t.y)} )`;
          if (i === 3) return `${this.getType(e)}( ${r(t.x)}, ${r(t.y)}, ${r(t.z)} )`;
          if (i === 4) return `${this.getType(e)}( ${r(t.x)}, ${r(t.y)}, ${r(t.z)}, ${r(t.w)} )`;
          if (i > 4 && t && (t.isMatrix3 || t.isMatrix4)) return `${this.getType(e)}( ${t.elements.map(r).join(", ")} )`;
          if (i > 4) return `${this.getType(e)}()`;
          throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
        }
        getType(e) {
          return e === "color" ? "vec3" : e;
        }
        hasGeometryAttribute(e) {
          return this.geometry && this.geometry.getAttribute(e) !== void 0;
        }
        getAttribute(e, t) {
          const i = this.attributes;
          for (const r of i) if (r.name === e) return r;
          const n = new Nb(e, t);
          return i.push(n), n;
        }
        getPropertyName(e) {
          return e.name;
        }
        isVector(e) {
          return /vec\d/.test(e);
        }
        isMatrix(e) {
          return /mat\d/.test(e);
        }
        isReference(e) {
          return e === "void" || e === "property" || e === "sampler" || e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "depthTexture" || e === "texture3D";
        }
        needsToWorkingColorSpace() {
          return false;
        }
        getComponentTypeFromTexture(e) {
          const t = e.type;
          if (e.isDataTexture) {
            if (t === Dt) return "int";
            if (t === Tt) return "uint";
          }
          return "float";
        }
        getElementType(e) {
          return e === "mat2" ? "vec2" : e === "mat3" ? "vec3" : e === "mat4" ? "vec4" : this.getComponentType(e);
        }
        getComponentType(e) {
          if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint") return e;
          const t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
          return t === null ? null : t[1] === "b" ? "bool" : t[1] === "i" ? "int" : t[1] === "u" ? "uint" : "float";
        }
        getVectorType(e) {
          return e === "color" ? "vec3" : e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "texture3D" ? "vec4" : e;
        }
        getTypeFromLength(e, t = "float") {
          if (e === 1) return t;
          const i = XC(e);
          return (t === "float" ? "" : t[0]) + i;
        }
        getTypeFromArray(e) {
          return cL.get(e.constructor);
        }
        getTypeFromAttribute(e) {
          let t = e;
          e.isInterleavedBufferAttribute && (t = e.data);
          const i = t.array, n = e.itemSize, r = e.normalized;
          let a;
          return !(e instanceof Fv) && r !== true && (a = this.getTypeFromArray(i)), this.getTypeFromLength(n, a);
        }
        getTypeLength(e) {
          const t = this.getVectorType(e), i = /vec([2-4])/.exec(t);
          return i !== null ? Number(i[1]) : t === "float" || t === "bool" || t === "int" || t === "uint" ? 1 : /mat2/.test(e) === true ? 4 : /mat3/.test(e) === true ? 9 : /mat4/.test(e) === true ? 16 : 0;
        }
        getVectorFromMatrix(e) {
          return e.replace("mat", "vec");
        }
        changeComponentType(e, t) {
          return this.getTypeFromLength(this.getTypeLength(e), t);
        }
        getIntegerType(e) {
          const t = this.getComponentType(e);
          return t === "int" || t === "uint" ? e : this.changeComponentType(e, "int");
        }
        addStack() {
          return this.stack = xp(this.stack), this.stacks.push(Qv() || this.stack), ed(this.stack), this.stack;
        }
        removeStack() {
          const e = this.stack;
          return this.stack = e.parent, ed(this.stacks.pop()), e;
        }
        getDataFromNode(e, t = this.shaderStage, i = null) {
          i = i === null ? e.isGlobal(this) ? this.globalCache : this.cache : i;
          let n = i.getData(e);
          return n === void 0 && (n = {}, i.setData(e, n)), n[t] === void 0 && (n[t] = {}), n[t];
        }
        getNodeProperties(e, t = "any") {
          const i = this.getDataFromNode(e, t);
          return i.properties || (i.properties = {
            outputNode: null
          });
        }
        getBufferAttributeFromNode(e, t) {
          const i = this.getDataFromNode(e);
          let n = i.bufferAttribute;
          if (n === void 0) {
            const r = this.uniforms.index++;
            n = new Nb("nodeAttribute" + r, t, e), this.bufferAttributes.push(n), i.bufferAttribute = n;
          }
          return n;
        }
        getStructTypeFromNode(e, t, i = this.shaderStage) {
          const n = this.getDataFromNode(e, i);
          let r = n.structType;
          if (r === void 0) {
            const a = this.structs.index++;
            r = new qz("StructType" + a, t), this.structs[i].push(r), n.structType = r;
          }
          return r;
        }
        getUniformFromNode(e, t, i = this.shaderStage, n = null) {
          const r = this.getDataFromNode(e, i, this.globalCache);
          let a = r.uniform;
          if (a === void 0) {
            const l = this.uniforms.index++;
            a = new kz(n || "nodeUniform" + l, t, e), this.uniforms[i].push(a), r.uniform = a;
          }
          return a;
        }
        getVarFromNode(e, t = null, i = e.getNodeType(this), n = this.shaderStage) {
          const r = this.getDataFromNode(e, n);
          let a = r.variable;
          if (a === void 0) {
            const l = this.vars[n] || (this.vars[n] = []);
            t === null && (t = "nodeVar" + l.length), a = new pA(t, i), l.push(a), r.variable = a;
          }
          return a;
        }
        getVaryingFromNode(e, t = null, i = e.getNodeType(this)) {
          const n = this.getDataFromNode(e, "any");
          let r = n.varying;
          if (r === void 0) {
            const a = this.varyings, l = a.length;
            t === null && (t = "nodeVarying" + l), r = new Iz(t, i), a.push(r), n.varying = r;
          }
          return r;
        }
        getCodeFromNode(e, t, i = this.shaderStage) {
          const n = this.getDataFromNode(e);
          let r = n.code;
          if (r === void 0) {
            const a = this.codes[i] || (this.codes[i] = []), l = a.length;
            r = new Vz("nodeCode" + l, t), a.push(r), n.code = r;
          }
          return r;
        }
        addFlowCodeHierarchy(e, t) {
          const { flowCodes: i, flowCodeBlock: n } = this.getDataFromNode(e);
          let r = true, a = t;
          for (; a; ) {
            if (n.get(a) === true) {
              r = false;
              break;
            }
            a = this.getDataFromNode(a).parentNodeBlock;
          }
          if (r) for (const l of i) this.addLineFlowCode(l);
        }
        addLineFlowCodeBlock(e, t, i) {
          const n = this.getDataFromNode(e), r = n.flowCodes || (n.flowCodes = []), a = n.flowCodeBlock || (n.flowCodeBlock = /* @__PURE__ */ new WeakMap());
          r.push(t), a.set(i, true);
        }
        addLineFlowCode(e, t = null) {
          return e === "" ? this : (t !== null && this.context.nodeBlock && this.addLineFlowCodeBlock(t, e, this.context.nodeBlock), e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
        }
        addFlowCode(e) {
          return this.flow.code += e, this;
        }
        addFlowTab() {
          return this.tab += "	", this;
        }
        removeFlowTab() {
          return this.tab = this.tab.slice(0, -1), this;
        }
        getFlowData(e) {
          return this.flowsData.get(e);
        }
        flowNode(e) {
          const t = e.getNodeType(this), i = this.flowChildNode(e, t);
          return this.flowsData.set(e, i), i;
        }
        buildFunctionNode(e) {
          const t = new ez(), i = this.currentFunctionNode;
          return this.currentFunctionNode = t, t.code = this.buildFunctionCode(e), this.currentFunctionNode = i, t;
        }
        flowShaderNode(e) {
          const t = e.layout, i = {
            [Symbol.iterator]() {
              let a = 0;
              const l = Object.values(this);
              return {
                next: () => ({
                  value: l[a],
                  done: a++ >= l.length
                })
              };
            }
          };
          for (const a of t.inputs) i[a.name] = new OO(a.type, a.name);
          e.layout = null;
          const n = e.call(i), r = this.flowStagesNode(n, t.type);
          return e.layout = t, r;
        }
        flowStagesNode(e, t = null) {
          const i = this.flow, n = this.vars, r = this.cache, a = this.buildStage, l = this.stack, o = {
            code: ""
          };
          this.flow = o, this.vars = {}, this.cache = new vp(), this.stack = xp();
          for (const u of F_) this.setBuildStage(u), o.result = e.build(this, t);
          return o.vars = this.getVars(this.shaderStage), this.flow = i, this.vars = n, this.cache = r, this.stack = l, this.setBuildStage(a), o;
        }
        getFunctionOperator() {
          return null;
        }
        flowChildNode(e, t = null) {
          const i = this.flow, n = {
            code: ""
          };
          return this.flow = n, n.result = e.build(this, t), this.flow = i, n;
        }
        flowNodeFromShaderStage(e, t, i = null, n = null) {
          const r = this.shaderStage;
          this.setShaderStage(e);
          const a = this.flowChildNode(t, i);
          return n !== null && (a.code += `${this.tab + n} = ${a.result};
`), this.flowCode[e] = this.flowCode[e] + a.code, this.setShaderStage(r), a;
        }
        getAttributesArray() {
          return this.attributes.concat(this.bufferAttributes);
        }
        getAttributes() {
          console.warn("Abstract function.");
        }
        getVaryings() {
          console.warn("Abstract function.");
        }
        getVar(e, t) {
          return `${this.getType(e)} ${t}`;
        }
        getVars(e) {
          let t = "";
          const i = this.vars[e];
          if (i !== void 0) for (const n of i) t += `${this.getVar(n.type, n.name)}; `;
          return t;
        }
        getUniforms() {
          console.warn("Abstract function.");
        }
        getCodes(e) {
          const t = this.codes[e];
          let i = "";
          if (t !== void 0) for (const n of t) i += n.code + `
`;
          return i;
        }
        getHash() {
          return this.vertexShader + this.fragmentShader + this.computeShader;
        }
        setShaderStage(e) {
          this.shaderStage = e;
        }
        getShaderStage() {
          return this.shaderStage;
        }
        setBuildStage(e) {
          this.buildStage = e;
        }
        getBuildStage() {
          return this.buildStage;
        }
        buildCode() {
          console.warn("Abstract function.");
        }
        build() {
          const { object: e, material: t, renderer: i } = this;
          if (t !== null) {
            let n = i.library.fromMaterial(t);
            n === null && (console.error(`NodeMaterial: Material "${t.type}" is not compatible.`), n = new tt()), n.build(this);
          } else this.addFlow("compute", e);
          for (const n of F_) {
            this.setBuildStage(n), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
            for (const r of O_) {
              this.setShaderStage(r);
              const a = this.flowNodes[r];
              for (const l of a) n === "generate" ? this.flowNode(l) : l.build(this);
            }
          }
          return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
        }
        getNodeUniform(e, t) {
          if (t === "float" || t === "int" || t === "uint") return new Kz(e);
          if (t === "vec2" || t === "ivec2" || t === "uvec2") return new Jz(e);
          if (t === "vec3" || t === "ivec3" || t === "uvec3") return new eL(e);
          if (t === "vec4" || t === "ivec4" || t === "uvec4") return new tL(e);
          if (t === "color") return new iL(e);
          if (t === "mat3") return new sL(e);
          if (t === "mat4") return new nL(e);
          throw new Error(`Uniform "${t}" not declared.`);
        }
        format(e, t, i) {
          if (t = this.getVectorType(t), i = this.getVectorType(i), t === i || i === null || this.isReference(i)) return e;
          const n = this.getTypeLength(t), r = this.getTypeLength(i);
          return n === 16 && r === 9 ? `${this.getType(i)}(${e}[0].xyz, ${e}[1].xyz, ${e}[2].xyz)` : n === 9 && r === 4 ? `${this.getType(i)}(${e}[0].xy, ${e}[1].xy)` : n > 4 || r > 4 || r === 0 ? e : n === r ? `${this.getType(i)}( ${e} )` : n > r ? this.format(`${e}.${"xyz".slice(0, r)}`, this.getTypeFromLength(r, this.getComponentType(t)), i) : r === 4 && n > 1 ? `${this.getType(i)}( ${this.format(e, t, "vec3")}, 1.0 )` : n === 2 ? `${this.getType(i)}( ${this.format(e, t, "vec2")}, 0.0 )` : (n === 1 && r > 1 && t !== this.getComponentType(i) && (e = `${this.getType(this.getComponentType(i))}( ${e} )`), `${this.getType(i)}( ${e} )`);
        }
        getSignature() {
          return `// Three.js r${Cd} - Node System
`;
        }
        createNodeMaterial(e = "NodeMaterial") {
          throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${e}() instead.`);
        }
      }
      class Fb {
        constructor() {
          this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.updateAfterMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
        }
        _getMaps(e, t) {
          let i = e.get(t);
          return i === void 0 && (i = {
            renderMap: /* @__PURE__ */ new WeakMap(),
            frameMap: /* @__PURE__ */ new WeakMap()
          }, e.set(t, i)), i;
        }
        updateBeforeNode(e) {
          const t = e.getUpdateBeforeType(), i = e.updateReference(this);
          if (t === te.FRAME) {
            const { frameMap: n } = this._getMaps(this.updateBeforeMap, i);
            n.get(i) !== this.frameId && e.updateBefore(this) !== false && n.set(i, this.frameId);
          } else if (t === te.RENDER) {
            const { renderMap: n } = this._getMaps(this.updateBeforeMap, i);
            n.get(i) !== this.renderId && e.updateBefore(this) !== false && n.set(i, this.renderId);
          } else t === te.OBJECT && e.updateBefore(this);
        }
        updateAfterNode(e) {
          const t = e.getUpdateAfterType(), i = e.updateReference(this);
          if (t === te.FRAME) {
            const { frameMap: n } = this._getMaps(this.updateAfterMap, i);
            n.get(i) !== this.frameId && e.updateAfter(this) !== false && n.set(i, this.frameId);
          } else if (t === te.RENDER) {
            const { renderMap: n } = this._getMaps(this.updateAfterMap, i);
            n.get(i) !== this.renderId && e.updateAfter(this) !== false && n.set(i, this.renderId);
          } else t === te.OBJECT && e.updateAfter(this);
        }
        updateNode(e) {
          const t = e.getUpdateType(), i = e.updateReference(this);
          if (t === te.FRAME) {
            const { frameMap: n } = this._getMaps(this.updateMap, i);
            n.get(i) !== this.frameId && e.update(this) !== false && n.set(i, this.frameId);
          } else if (t === te.RENDER) {
            const { renderMap: n } = this._getMaps(this.updateMap, i);
            n.get(i) !== this.renderId && e.update(this) !== false && n.set(i, this.renderId);
          } else t === te.OBJECT && e.update(this);
        }
        update() {
          this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
        }
      }
      class m0 {
        constructor(e, t, i = null, n = "", r = false) {
          this.type = e, this.name = t, this.count = i, this.qualifier = n, this.isConst = r;
        }
      }
      m0.isNodeFunctionInput = true;
      class hL extends Zr {
        static get type() {
          return "DirectionalLightNode";
        }
        constructor(e = null) {
          super(e);
        }
        setup(e) {
          super.setup(e);
          const t = e.context.lightingModel, i = this.colorNode, n = uA(this.light), r = e.context.reflectedLight;
          t.direct({
            lightDirection: n,
            lightColor: i,
            reflectedLight: r
          }, e.stack, e);
        }
      }
      const Rp = new pe(), Uc = new pe();
      let ol = null;
      class dL extends Zr {
        static get type() {
          return "RectAreaLightNode";
        }
        constructor(e = null) {
          super(e), this.halfHeight = Z(new v()).setGroup($), this.halfWidth = Z(new v()).setGroup($), this.updateType = te.RENDER;
        }
        update(e) {
          super.update(e);
          const { light: t } = this, i = e.camera.matrixWorldInverse;
          Uc.identity(), Rp.copy(t.matrixWorld), Rp.premultiply(i), Uc.extractRotation(Rp), this.halfWidth.value.set(t.width * 0.5, 0, 0), this.halfHeight.value.set(0, t.height * 0.5, 0), this.halfWidth.value.applyMatrix4(Uc), this.halfHeight.value.applyMatrix4(Uc);
        }
        setup(e) {
          super.setup(e);
          let t, i;
          e.isAvailable("float32Filterable") ? (t = fe(ol.LTC_FLOAT_1), i = fe(ol.LTC_FLOAT_2)) : (t = fe(ol.LTC_HALF_1), i = fe(ol.LTC_HALF_2));
          const { colorNode: n, light: r } = this, a = e.context.lightingModel, l = d0(r), o = e.context.reflectedLight;
          a.directRectArea({
            lightColor: n,
            lightPosition: l,
            halfWidth: this.halfWidth,
            halfHeight: this.halfHeight,
            reflectedLight: o,
            ltc_1: t,
            ltc_2: i
          }, e.stack, e);
        }
        static setLTC(e) {
          ol = e;
        }
      }
      class gA extends Zr {
        static get type() {
          return "SpotLightNode";
        }
        constructor(e = null) {
          super(e), this.coneCosNode = Z(0).setGroup($), this.penumbraCosNode = Z(0).setGroup($), this.cutoffDistanceNode = Z(0).setGroup($), this.decayExponentNode = Z(0).setGroup($);
        }
        update(e) {
          super.update(e);
          const { light: t } = this;
          this.coneCosNode.value = Math.cos(t.angle), this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra)), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
        }
        getSpotAttenuation(e) {
          const { coneCosNode: t, penumbraCosNode: i } = this;
          return Gr(t, i, e);
        }
        setup(e) {
          super.setup(e);
          const t = e.context.lightingModel, { colorNode: i, cutoffDistanceNode: n, decayExponentNode: r, light: a } = this, l = d0(a).sub(Ke), o = l.normalize(), u = o.dot(uA(a)), c = this.getSpotAttenuation(u), h = l.length(), d = fA({
            lightDistance: h,
            cutoffDistance: n,
            decayExponent: r
          });
          let f = i.mul(c).mul(d);
          if (a.map) {
            const g = nz(a), _ = fe(a.map, g.xy).onRenderUpdate(() => a.map);
            f = g.mul(2).sub(1).abs().lessThan(1).all().select(f.mul(_), f);
          }
          const p = e.context.reflectedLight;
          t.direct({
            lightDirection: o,
            lightColor: f,
            reflectedLight: p
          }, e.stack, e);
        }
      }
      class fL extends gA {
        static get type() {
          return "IESSpotLightNode";
        }
        getSpotAttenuation(e) {
          const t = this.light.iesMap;
          let i = null;
          if (t && t.isTexture === true) {
            const n = e.acos().mul(1 / Math.PI);
            i = fe(t, L(n, 0), 0).r;
          } else i = super.getSpotAttenuation(e);
          return i;
        }
      }
      class pL extends Zr {
        static get type() {
          return "AmbientLightNode";
        }
        constructor(e = null) {
          super(e);
        }
        setup({ context: e }) {
          e.irradiance.addAssign(this.colorNode);
        }
      }
      class mL extends Zr {
        static get type() {
          return "HemisphereLightNode";
        }
        constructor(e = null) {
          super(e), this.lightPositionNode = lA(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = Z(new ie()).setGroup($);
        }
        update(e) {
          const { light: t } = this;
          super.update(e), this.lightPositionNode.object3d = t, this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity);
        }
        setup(e) {
          const { colorNode: t, groundColorNode: i, lightDirectionNode: n } = this, a = Xi.dot(n).mul(0.5).add(0.5), l = Ce(i, t, a);
          e.context.irradiance.addAssign(l);
        }
      }
      class gL extends Zr {
        static get type() {
          return "LightProbeNode";
        }
        constructor(e = null) {
          super(e);
          const t = [];
          for (let i = 0; i < 9; i++) t.push(new v());
          this.lightProbe = An(t);
        }
        update(e) {
          const { light: t } = this;
          super.update(e);
          for (let i = 0; i < 9; i++) this.lightProbe.array[i].copy(t.sh.coefficients[i]).multiplyScalar(t.intensity);
        }
        setup(e) {
          const t = zz(wM, this.lightProbe);
          e.context.irradiance.addAssign(t);
        }
      }
      class yA {
        parseFunction() {
          console.warn("Abstract function.");
        }
      }
      class g0 {
        constructor(e, t, i = "", n = "") {
          this.type = e, this.inputs = t, this.name = i, this.precision = n;
        }
        getCode() {
          console.warn("Abstract function.");
        }
      }
      g0.isNodeFunction = true;
      const yL = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, xL = /[a-z_0-9]+/ig, Ob = "#pragma main", _L = (s) => {
        s = s.trim();
        const e = s.indexOf(Ob), t = e !== -1 ? s.slice(e + Ob.length) : s, i = t.match(yL);
        if (i !== null && i.length === 5) {
          const n = i[4], r = [];
          let a = null;
          for (; (a = xL.exec(n)) !== null; ) r.push(a);
          const l = [];
          let o = 0;
          for (; o < r.length; ) {
            const p = r[o][0] === "const";
            p === true && o++;
            let g = r[o][0];
            g === "in" || g === "out" || g === "inout" ? o++ : g = "";
            const _ = r[o++][0];
            let m = Number.parseInt(r[o][0]);
            Number.isNaN(m) === false ? o++ : m = null;
            const y = r[o++][0];
            l.push(new m0(_, y, m, g, p));
          }
          const u = t.substring(i[0].length), c = i[3] !== void 0 ? i[3] : "", h = i[2], d = i[1] !== void 0 ? i[1] : "", f = e !== -1 ? s.slice(0, e) : "";
          return {
            type: h,
            inputs: l,
            name: c,
            precision: d,
            inputsCode: n,
            blockCode: u,
            headerCode: f
          };
        } else throw new Error("FunctionNode: Function is not a GLSL code.");
      };
      class bL extends g0 {
        constructor(e) {
          const { type: t, inputs: i, name: n, precision: r, inputsCode: a, blockCode: l, headerCode: o } = _L(e);
          super(t, i, n, r), this.inputsCode = a, this.blockCode = l, this.headerCode = o;
        }
        getCode(e = this.name) {
          let t;
          const i = this.blockCode;
          if (i !== "") {
            const { type: n, inputsCode: r, headerCode: a, precision: l } = this;
            let o = `${n} ${e} ( ${r.trim()} )`;
            l !== "" && (o = `${l} ${o}`), t = a + o + i;
          } else t = "";
          return t;
        }
      }
      class SL extends yA {
        parseFunction(e) {
          return new bL(e);
        }
      }
      const zb = /* @__PURE__ */ new WeakMap();
      class TL extends er {
        constructor(e, t) {
          super(), this.renderer = e, this.backend = t, this.nodeFrame = new Fb(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.callHashCache = new us(), this.groupsData = new us(), this.cacheLib = {};
        }
        updateGroup(e) {
          const t = e.groupNode, i = t.name;
          if (i === tM.name) return true;
          if (i === $.name) {
            const a = this.get(e), l = this.nodeFrame.renderId;
            return a.renderId !== l ? (a.renderId = l, true) : false;
          }
          if (i === CB.name) {
            const a = this.get(e), l = this.nodeFrame.frameId;
            return a.frameId !== l ? (a.frameId = l, true) : false;
          }
          const n = [
            t,
            e
          ];
          let r = this.groupsData.get(n);
          return r === void 0 && this.groupsData.set(n, r = {}), r.version !== t.version ? (r.version = t.version, true) : false;
        }
        getForRenderCacheKey(e) {
          return e.initialCacheKey;
        }
        getForRender(e) {
          const t = this.get(e);
          let i = t.nodeBuilderState;
          if (i === void 0) {
            const { nodeBuilderCache: n } = this, r = this.getForRenderCacheKey(e);
            if (i = n.get(r), i === void 0) {
              const a = this.backend.createNodeBuilder(e.object, this.renderer);
              a.scene = e.scene, a.material = e.material, a.camera = e.camera, a.context.material = e.material, a.lightsNode = e.lightsNode, a.environmentNode = this.getEnvironmentNode(e.scene), a.fogNode = this.getFogNode(e.scene), a.clippingContext = e.clippingContext, a.build(), i = this._createNodeBuilderState(a), n.set(r, i);
            }
            i.usedTimes++, t.nodeBuilderState = i;
          }
          return i;
        }
        delete(e) {
          if (e.isRenderObject) {
            const t = this.get(e).nodeBuilderState;
            t.usedTimes--, t.usedTimes === 0 && this.nodeBuilderCache.delete(this.getForRenderCacheKey(e));
          }
          return super.delete(e);
        }
        getForCompute(e) {
          const t = this.get(e);
          let i = t.nodeBuilderState;
          if (i === void 0) {
            const n = this.backend.createNodeBuilder(e, this.renderer);
            n.build(), i = this._createNodeBuilderState(n), t.nodeBuilderState = i;
          }
          return i;
        }
        _createNodeBuilderState(e) {
          return new Pz(e.vertexShader, e.fragmentShader, e.computeShader, e.getAttributesArray(), e.getBindings(), e.updateNodes, e.updateBeforeNodes, e.updateAfterNodes, e.monitor, e.transforms);
        }
        getEnvironmentNode(e) {
          this.updateEnvironment(e);
          let t = null;
          if (e.environmentNode && e.environmentNode.isNode) t = e.environmentNode;
          else {
            const i = this.get(e);
            i.environmentNode && (t = i.environmentNode);
          }
          return t;
        }
        getBackgroundNode(e) {
          this.updateBackground(e);
          let t = null;
          if (e.backgroundNode && e.backgroundNode.isNode) t = e.backgroundNode;
          else {
            const i = this.get(e);
            i.backgroundNode && (t = i.backgroundNode);
          }
          return t;
        }
        getFogNode(e) {
          return this.updateFog(e), e.fogNode || this.get(e).fogNode || null;
        }
        getCacheKey(e, t) {
          const i = [
            e,
            t
          ], n = this.renderer.info.calls;
          let r = this.callHashCache.get(i);
          if (r === void 0 || r.callId !== n) {
            const a = this.getEnvironmentNode(e), l = this.getFogNode(e), o = [];
            t && o.push(t.getCacheKey(true)), a && o.push(a.getCacheKey()), l && o.push(l.getCacheKey()), o.push(this.renderer.shadowMap.enabled ? 1 : 0), r = {
              callId: n,
              cacheKey: Iy(o)
            }, this.callHashCache.set(i, r);
          }
          return r.cacheKey;
        }
        get isToneMappingState() {
          return !this.renderer.getRenderTarget();
        }
        updateBackground(e) {
          const t = this.get(e), i = e.background;
          if (i) {
            const n = e.backgroundBlurriness === 0 && t.backgroundBlurriness > 0 || e.backgroundBlurriness > 0 && t.backgroundBlurriness === 0;
            if (t.background !== i || n) {
              const r = this.getCacheNode("background", i, () => {
                if (i.isCubeTexture === true || i.mapping === Du || i.mapping === Uu || i.mapping === Hm) {
                  if (e.backgroundBlurriness > 0 || i.mapping === Hm) return eA(i);
                  {
                    let a;
                    return i.isCubeTexture === true ? a = gu(i) : a = fe(i), YM(a);
                  }
                } else {
                  if (i.isTexture === true) return fe(i, yu.flipY()).setUpdateMatrix(true);
                  i.isColor !== true && console.error("WebGPUNodes: Unsupported background configuration.", i);
                }
              }, n);
              t.backgroundNode = r, t.background = i, t.backgroundBlurriness = e.backgroundBlurriness;
            }
          } else t.backgroundNode && (delete t.backgroundNode, delete t.background);
        }
        getCacheNode(e, t, i, n = false) {
          const r = this.cacheLib[e] || (this.cacheLib[e] = /* @__PURE__ */ new WeakMap());
          let a = r.get(t);
          return (a === void 0 || n) && (a = i(), r.set(t, a)), a;
        }
        updateFog(e) {
          const t = this.get(e), i = e.fog;
          if (i) {
            if (t.fog !== i) {
              const n = this.getCacheNode("fog", i, () => {
                if (i.isFogExp2) {
                  const r = Se("color", "color", i).setGroup($), a = Se("density", "float", i).setGroup($);
                  return vb(r, iz(a));
                } else if (i.isFog) {
                  const r = Se("color", "color", i).setGroup($), a = Se("near", "float", i).setGroup($), l = Se("far", "float", i).setGroup($);
                  return vb(r, tz(a, l));
                } else console.error("THREE.Renderer: Unsupported fog configuration.", i);
              });
              t.fogNode = n, t.fog = i;
            }
          } else delete t.fogNode, delete t.fog;
        }
        updateEnvironment(e) {
          const t = this.get(e), i = e.environment;
          if (i) {
            if (t.environment !== i) {
              const n = this.getCacheNode("environment", i, () => {
                if (i.isCubeTexture === true) return gu(i);
                if (i.isTexture === true) return fe(i);
                console.error("Nodes: Unsupported environment configuration.", i);
              });
              t.environmentNode = n, t.environment = i;
            }
          } else t.environmentNode && (delete t.environmentNode, delete t.environment);
        }
        getNodeFrame(e = this.renderer, t = null, i = null, n = null, r = null) {
          const a = this.nodeFrame;
          return a.renderer = e, a.scene = t, a.object = i, a.camera = n, a.material = r, a;
        }
        getNodeFrameForRender(e) {
          return this.getNodeFrame(e.renderer, e.scene, e.object, e.camera, e.material);
        }
        getOutputCacheKey() {
          const e = this.renderer;
          return e.toneMapping + "," + e.currentColorSpace;
        }
        hasOutputChange(e) {
          return zb.get(e) !== this.getOutputCacheKey();
        }
        getOutputNode(e) {
          const t = this.renderer, i = this.getOutputCacheKey(), n = fe(e, yu).renderOutput(t.toneMapping, t.currentColorSpace);
          return zb.set(e, i), n;
        }
        updateBefore(e) {
          const t = e.getNodeBuilderState();
          for (const i of t.updateBeforeNodes) this.getNodeFrameForRender(e).updateBeforeNode(i);
        }
        updateAfter(e) {
          const t = e.getNodeBuilderState();
          for (const i of t.updateAfterNodes) this.getNodeFrameForRender(e).updateAfterNode(i);
        }
        updateForCompute(e) {
          const t = this.getNodeFrame(), i = this.getForCompute(e);
          for (const n of i.updateNodes) t.updateNode(n);
        }
        updateForRender(e) {
          const t = this.getNodeFrameForRender(e), i = e.getNodeBuilderState();
          for (const n of i.updateNodes) t.updateNode(n);
        }
        needsRefresh(e) {
          const t = this.getNodeFrameForRender(e);
          return e.getMonitor().needsRefresh(e, t);
        }
        dispose() {
          super.dispose(), this.nodeFrame = new Fb(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.cacheLib = {};
        }
      }
      const Cp = new As();
      class ld {
        constructor(e = null) {
          this.version = 0, this.clipIntersection = null, this.cacheKey = "", this.shadowPass = false, this.viewNormalMatrix = new Jt(), this.clippingGroupContexts = /* @__PURE__ */ new WeakMap(), this.intersectionPlanes = [], this.unionPlanes = [], this.parentVersion = null, e !== null && (this.viewNormalMatrix = e.viewNormalMatrix, this.clippingGroupContexts = e.clippingGroupContexts, this.shadowPass = e.shadowPass, this.viewMatrix = e.viewMatrix);
        }
        projectPlanes(e, t, i) {
          const n = e.length;
          for (let r = 0; r < n; r++) {
            Cp.copy(e[r]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
            const a = t[i + r], l = Cp.normal;
            a.x = -l.x, a.y = -l.y, a.z = -l.z, a.w = Cp.constant;
          }
        }
        updateGlobal(e, t) {
          this.shadowPass = e.overrideMaterial !== null && e.overrideMaterial.isShadowNodeMaterial, this.viewMatrix = t.matrixWorldInverse, this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
        }
        update(e, t) {
          let i = false;
          e.version !== this.parentVersion && (this.intersectionPlanes = Array.from(e.intersectionPlanes), this.unionPlanes = Array.from(e.unionPlanes), this.parentVersion = e.version), this.clipIntersection !== t.clipIntersection && (this.clipIntersection = t.clipIntersection, this.clipIntersection ? this.unionPlanes.length = e.unionPlanes.length : this.intersectionPlanes.length = e.intersectionPlanes.length);
          const n = t.clippingPlanes, r = n.length;
          let a, l;
          if (this.clipIntersection ? (a = this.intersectionPlanes, l = e.intersectionPlanes.length) : (a = this.unionPlanes, l = e.unionPlanes.length), a.length !== l + r) {
            a.length = l + r;
            for (let o = 0; o < r; o++) a[l + o] = new Te();
            i = true;
          }
          this.projectPlanes(n, a, l), i && (this.version++, this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`);
        }
        getGroupContext(e) {
          if (this.shadowPass && !e.clipShadows) return this;
          let t = this.clippingGroupContexts.get(e);
          return t === void 0 && (t = new ld(this), this.clippingGroupContexts.set(e, t)), t.update(this, e), t;
        }
        get unionClippingCount() {
          return this.unionPlanes.length;
        }
      }
      class vL {
        constructor(e, t) {
          this.bundleGroup = e, this.camera = t;
        }
      }
      class ML {
        constructor() {
          this.bundles = new us();
        }
        get(e, t) {
          const i = this.bundles, n = [
            e,
            t
          ];
          let r = i.get(n);
          return r === void 0 && (r = new vL(e, t), i.set(n, r)), r;
        }
        dispose() {
          this.bundles = new us();
        }
      }
      class xA {
        constructor() {
          this.lightNodes = /* @__PURE__ */ new WeakMap(), this.materialNodes = /* @__PURE__ */ new Map(), this.toneMappingNodes = /* @__PURE__ */ new Map();
        }
        fromMaterial(e) {
          if (e.isNodeMaterial) return e;
          let t = null;
          const i = this.getMaterialNodeClass(e.type);
          if (i !== null) {
            t = new i();
            for (const n in e) t[n] = e[n];
          }
          return t;
        }
        addToneMapping(e, t) {
          this.addType(e, t, this.toneMappingNodes);
        }
        getToneMappingFunction(e) {
          return this.toneMappingNodes.get(e) || null;
        }
        getMaterialNodeClass(e) {
          return this.materialNodes.get(e) || null;
        }
        addMaterial(e, t) {
          this.addType(e, t, this.materialNodes);
        }
        getLightNodeClass(e) {
          return this.lightNodes.get(e) || null;
        }
        addLight(e, t) {
          this.addClass(e, t, this.lightNodes);
        }
        addType(e, t, i) {
          if (i.has(t)) {
            console.warn(`Redefinition of node ${t}`);
            return;
          }
          if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
          if (typeof t == "function" || typeof t == "object") throw new Error(`Base class ${t} is not a class.`);
          i.set(t, e);
        }
        addClass(e, t, i) {
          if (i.has(t)) {
            console.warn(`Redefinition of node ${t.name}`);
            return;
          }
          if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
          if (typeof t != "function") throw new Error(`Base class ${t.name} is not a class.`);
          i.set(t, e);
        }
      }
      const AL = new cA();
      class NL extends us {
        constructor() {
          super();
        }
        createNode(e = []) {
          return new cA().setLights(e);
        }
        getNode(e, t) {
          if (e.isQuadMesh) return AL;
          const i = [
            e,
            t
          ];
          let n = this.get(i);
          return n === void 0 && (n = this.createNode(), this.set(i, n)), n;
        }
      }
      const Lb = new zy(), Fc = new q(), Bp = new Te(), Dp = new kv(), Oc = new pe(), pn = new Te();
      class wL {
        constructor(e, t = {}) {
          this.isRenderer = true;
          const { logarithmicDepthBuffer: i = false, alpha: n = true, depth: r = true, stencil: a = false, antialias: l = false, samples: o = 0, getFallback: u = null } = t;
          this.domElement = e.getDomElement(), this.backend = e, this.samples = o || l === true ? 4 : 0, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.alpha = n, this.logarithmicDepthBuffer = i, this.outputColorSpace = H, this.toneMapping = Ja, this.toneMappingExposure = 1, this.sortObjects = true, this.depth = r, this.stencil = a, this.info = new SO(), this.nodes = {
            modelViewMatrix: null,
            modelNormalViewMatrix: null
          }, this.library = new xA(), this.lighting = new NL(), this._getFallback = u, this._pixelRatio = 1, this._width = this.domElement.width, this._height = this.domElement.height, this._viewport = new Te(0, 0, this._width, this._height), this._scissor = new Te(0, 0, this._width, this._height), this._scissorTest = false, this._attributes = null, this._geometries = null, this._nodes = null, this._animation = null, this._bindings = null, this._objects = null, this._pipelines = null, this._bundles = null, this._renderLists = null, this._renderContexts = null, this._textures = null, this._background = null, this._quad = new rA(new tt()), this._quad.material.name = "Renderer_output", this._currentRenderContext = null, this._opaqueSort = null, this._transparentSort = null, this._frameBufferTarget = null;
          const c = this.alpha === true ? 0 : 1;
          this._clearColor = new h0(0, 0, 0, c), this._clearDepth = 1, this._clearStencil = 0, this._renderTarget = null, this._activeCubeFace = 0, this._activeMipmapLevel = 0, this._mrt = null, this._renderObjectFunction = null, this._currentRenderObjectFunction = null, this._currentRenderBundle = null, this._handleObjectFunction = this._renderObjectDirect, this._isDeviceLost = false, this.onDeviceLost = this._onDeviceLost, this._initialized = false, this._initPromise = null, this._compilationPromises = null, this.transparent = true, this.opaque = true, this.shadowMap = {
            enabled: false,
            type: Z2
          }, this.xr = {
            enabled: false
          }, this.debug = {
            checkShaderErrors: true,
            onShaderError: null,
            getShaderAsync: async (h, d, f) => {
              await this.compileAsync(h, d);
              const p = this._renderLists.get(h, d), g = this._renderContexts.get(h, d, this._renderTarget), _ = h.overrideMaterial || f.material, m = this._objects.get(f, _, h, d, p.lightsNode, g, g.clippingContext), { fragmentShader: y, vertexShader: x } = m.getNodeBuilderState();
              return {
                fragmentShader: y,
                vertexShader: x
              };
            }
          };
        }
        async init() {
          if (this._initialized) throw new Error("Renderer: Backend has already been initialized.");
          return this._initPromise !== null ? this._initPromise : (this._initPromise = new Promise(async (e, t) => {
            let i = this.backend;
            try {
              await i.init(this);
            } catch (n) {
              if (this._getFallback !== null) try {
                this.backend = i = this._getFallback(n), await i.init(this);
              } catch (r) {
                t(r);
                return;
              }
              else {
                t(n);
                return;
              }
            }
            this._nodes = new TL(this, i), this._animation = new hO(this._nodes, this.info), this._attributes = new xO(i), this._background = new Lz(this, this._nodes), this._geometries = new bO(this._attributes, this.info), this._textures = new FO(this, i, this.info), this._pipelines = new AO(i, this._nodes), this._bindings = new NO(i, this._nodes, this._textures, this._attributes, this._pipelines, this.info), this._objects = new mO(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info), this._renderLists = new RO(this.lighting), this._bundles = new ML(), this._renderContexts = new DO(), this._animation.start(), this._initialized = true, e();
          }), this._initPromise);
        }
        get coordinateSystem() {
          return this.backend.coordinateSystem;
        }
        async compileAsync(e, t, i = null) {
          if (this._isDeviceLost === true) return;
          this._initialized === false && await this.init();
          const n = this._nodes.nodeFrame, r = n.renderId, a = this._currentRenderContext, l = this._currentRenderObjectFunction, o = this._compilationPromises, u = e.isScene === true ? e : Lb;
          i === null && (i = e);
          const c = this._renderTarget, h = this._renderContexts.get(i, t, c), d = this._activeMipmapLevel, f = [];
          this._currentRenderContext = h, this._currentRenderObjectFunction = this.renderObject, this._handleObjectFunction = this._createObjectPipeline, this._compilationPromises = f, n.renderId++, n.update(), h.depth = this.depth, h.stencil = this.stencil, h.clippingContext || (h.clippingContext = new ld()), h.clippingContext.updateGlobal(u, t), u.onBeforeRender(this, e, t, c);
          const p = this._renderLists.get(e, t);
          if (p.begin(), this._projectObject(e, t, 0, p, h.clippingContext), i !== e && i.traverseVisible(function(x) {
            x.isLight && x.layers.test(t.layers) && p.pushLight(x);
          }), p.finish(), c !== null) {
            this._textures.updateRenderTarget(c, d);
            const x = this._textures.get(c);
            h.textures = x.textures, h.depthTexture = x.depthTexture;
          } else h.textures = null, h.depthTexture = null;
          this._background.update(u, p, h);
          const g = p.opaque, _ = p.transparent, m = p.transparentDoublePass, y = p.lightsNode;
          this.opaque === true && g.length > 0 && this._renderObjects(g, t, u, y), this.transparent === true && _.length > 0 && this._renderTransparents(_, m, t, u, y), n.renderId = r, this._currentRenderContext = a, this._currentRenderObjectFunction = l, this._compilationPromises = o, this._handleObjectFunction = this._renderObjectDirect, await Promise.all(f);
        }
        async renderAsync(e, t) {
          this._initialized === false && await this.init();
          const i = this._renderScene(e, t);
          await this.backend.resolveTimestampAsync(i, "render");
        }
        async waitForGPU() {
          await this.backend.waitForGPU();
        }
        setMRT(e) {
          return this._mrt = e, this;
        }
        getMRT() {
          return this._mrt;
        }
        _onDeviceLost(e) {
          let t = `THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;
          e.reason && (t += `
Reason: ${e.reason}`), console.error(t), this._isDeviceLost = true;
        }
        _renderBundle(e, t, i) {
          const { bundleGroup: n, camera: r, renderList: a } = e, l = this._currentRenderContext, o = this._bundles.get(n, r), u = this.backend.get(o);
          u.renderContexts === void 0 && (u.renderContexts = /* @__PURE__ */ new Set());
          const c = n.version !== u.version, h = u.renderContexts.has(l) === false || c;
          if (u.renderContexts.add(l), h) {
            this.backend.beginBundle(l), (u.renderObjects === void 0 || c) && (u.renderObjects = []), this._currentRenderBundle = o;
            const d = a.opaque;
            this.opaque === true && d.length > 0 && this._renderObjects(d, r, t, i), this._currentRenderBundle = null, this.backend.finishBundle(l, o), u.version = n.version;
          } else {
            const { renderObjects: d } = u;
            for (let f = 0, p = d.length; f < p; f++) {
              const g = d[f];
              this._nodes.needsRefresh(g) && (this._nodes.updateBefore(g), this._nodes.updateForRender(g), this._bindings.updateForRender(g), this._nodes.updateAfter(g));
            }
          }
          this.backend.addBundle(l, o);
        }
        render(e, t) {
          if (this._initialized === false) return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."), this.renderAsync(e, t);
          this._renderScene(e, t);
        }
        _getFrameBufferTarget() {
          const { currentToneMapping: e, currentColorSpace: t } = this;
          if (e !== Ja === false && t !== Vn === false) return null;
          const { width: r, height: a } = this.getDrawingBufferSize(Fc), { depth: l, stencil: o } = this;
          let u = this._frameBufferTarget;
          return u === null && (u = new Uo(r, a, {
            depthBuffer: l,
            stencilBuffer: o,
            type: ks,
            format: Or,
            colorSpace: Vn,
            generateMipmaps: false,
            minFilter: pi,
            magFilter: pi,
            samples: this.samples
          }), u.isPostProcessingRenderTarget = true, this._frameBufferTarget = u), u.depthBuffer = l, u.stencilBuffer = o, u.setSize(r, a), u.viewport.copy(this._viewport), u.scissor.copy(this._scissor), u.viewport.multiplyScalar(this._pixelRatio), u.scissor.multiplyScalar(this._pixelRatio), u.scissorTest = this._scissorTest, u;
        }
        _renderScene(e, t, i = true) {
          if (this._isDeviceLost === true) return;
          const n = i ? this._getFrameBufferTarget() : null, r = this._nodes.nodeFrame, a = r.renderId, l = this._currentRenderContext, o = this._currentRenderObjectFunction, u = e.isScene === true ? e : Lb, c = this._renderTarget, h = this._activeCubeFace, d = this._activeMipmapLevel;
          let f;
          n !== null ? (f = n, this.setRenderTarget(f)) : f = c;
          const p = this._renderContexts.get(e, t, f);
          this._currentRenderContext = p, this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject, this.info.calls++, this.info.render.calls++, this.info.render.frameCalls++, r.renderId = this.info.calls;
          const g = this.coordinateSystem;
          t.coordinateSystem !== g && (t.coordinateSystem = g, t.updateProjectionMatrix()), e.matrixWorldAutoUpdate === true && e.updateMatrixWorld(), t.parent === null && t.matrixWorldAutoUpdate === true && t.updateMatrixWorld();
          let _ = this._viewport, m = this._scissor, y = this._pixelRatio;
          f !== null && (_ = f.viewport, m = f.scissor, y = 1), this.getDrawingBufferSize(Fc), Bp.set(0, 0, Fc.width, Fc.height);
          const x = _.minDepth === void 0 ? 0 : _.minDepth, b = _.maxDepth === void 0 ? 1 : _.maxDepth;
          p.viewportValue.copy(_).multiplyScalar(y).floor(), p.viewportValue.width >>= d, p.viewportValue.height >>= d, p.viewportValue.minDepth = x, p.viewportValue.maxDepth = b, p.viewport = p.viewportValue.equals(Bp) === false, p.scissorValue.copy(m).multiplyScalar(y).floor(), p.scissor = this._scissorTest && p.scissorValue.equals(Bp) === false, p.scissorValue.width >>= d, p.scissorValue.height >>= d, p.clippingContext || (p.clippingContext = new ld()), p.clippingContext.updateGlobal(u, t), u.onBeforeRender(this, e, t, f), Oc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), Dp.setFromProjectionMatrix(Oc, g);
          const T = this._renderLists.get(e, t);
          if (T.begin(), this._projectObject(e, t, 0, T, p.clippingContext), T.finish(), this.sortObjects === true && T.sort(this._opaqueSort, this._transparentSort), f !== null) {
            this._textures.updateRenderTarget(f, d);
            const I = this._textures.get(f);
            p.textures = I.textures, p.depthTexture = I.depthTexture, p.width = I.width, p.height = I.height, p.renderTarget = f, p.depth = f.depthBuffer, p.stencil = f.stencilBuffer;
          } else p.textures = null, p.depthTexture = null, p.width = this.domElement.width, p.height = this.domElement.height, p.depth = this.depth, p.stencil = this.stencil;
          p.width >>= d, p.height >>= d, p.activeCubeFace = h, p.activeMipmapLevel = d, p.occlusionQueryCount = T.occlusionQueryCount, this._background.update(u, T, p), this.backend.beginRender(p);
          const { bundles: N, lightsNode: A, transparentDoublePass: w, transparent: k, opaque: G } = T;
          if (N.length > 0 && this._renderBundles(N, u, A), this.opaque === true && G.length > 0 && this._renderObjects(G, t, u, A), this.transparent === true && k.length > 0 && this._renderTransparents(k, w, t, u, A), this.backend.finishRender(p), r.renderId = a, this._currentRenderContext = l, this._currentRenderObjectFunction = o, n !== null) {
            this.setRenderTarget(c, h, d);
            const I = this._quad;
            this._nodes.hasOutputChange(f.texture) && (I.material.fragmentNode = this._nodes.getOutputNode(f.texture), I.material.needsUpdate = true), this._renderScene(I, I.camera, false);
          }
          return u.onAfterRender(this, e, t, f), p;
        }
        getMaxAnisotropy() {
          return this.backend.getMaxAnisotropy();
        }
        getActiveCubeFace() {
          return this._activeCubeFace;
        }
        getActiveMipmapLevel() {
          return this._activeMipmapLevel;
        }
        async setAnimationLoop(e) {
          this._initialized === false && await this.init(), this._animation.setAnimationLoop(e);
        }
        async getArrayBufferAsync(e) {
          return await this.backend.getArrayBufferAsync(e);
        }
        getContext() {
          return this.backend.getContext();
        }
        getPixelRatio() {
          return this._pixelRatio;
        }
        getDrawingBufferSize(e) {
          return e.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
        }
        getSize(e) {
          return e.set(this._width, this._height);
        }
        setPixelRatio(e = 1) {
          this._pixelRatio !== e && (this._pixelRatio = e, this.setSize(this._width, this._height, false));
        }
        setDrawingBufferSize(e, t, i) {
          this._width = e, this._height = t, this._pixelRatio = i, this.domElement.width = Math.floor(e * i), this.domElement.height = Math.floor(t * i), this.setViewport(0, 0, e, t), this._initialized && this.backend.updateSize();
        }
        setSize(e, t, i = true) {
          this._width = e, this._height = t, this.domElement.width = Math.floor(e * this._pixelRatio), this.domElement.height = Math.floor(t * this._pixelRatio), i === true && (this.domElement.style.width = e + "px", this.domElement.style.height = t + "px"), this.setViewport(0, 0, e, t), this._initialized && this.backend.updateSize();
        }
        setOpaqueSort(e) {
          this._opaqueSort = e;
        }
        setTransparentSort(e) {
          this._transparentSort = e;
        }
        getScissor(e) {
          const t = this._scissor;
          return e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, e;
        }
        setScissor(e, t, i, n) {
          const r = this._scissor;
          e.isVector4 ? r.copy(e) : r.set(e, t, i, n);
        }
        getScissorTest() {
          return this._scissorTest;
        }
        setScissorTest(e) {
          this._scissorTest = e, this.backend.setScissorTest(e);
        }
        getViewport(e) {
          return e.copy(this._viewport);
        }
        setViewport(e, t, i, n, r = 0, a = 1) {
          const l = this._viewport;
          e.isVector4 ? l.copy(e) : l.set(e, t, i, n), l.minDepth = r, l.maxDepth = a;
        }
        getClearColor(e) {
          return e.copy(this._clearColor);
        }
        setClearColor(e, t = 1) {
          this._clearColor.set(e), this._clearColor.a = t;
        }
        getClearAlpha() {
          return this._clearColor.a;
        }
        setClearAlpha(e) {
          this._clearColor.a = e;
        }
        getClearDepth() {
          return this._clearDepth;
        }
        setClearDepth(e) {
          this._clearDepth = e;
        }
        getClearStencil() {
          return this._clearStencil;
        }
        setClearStencil(e) {
          this._clearStencil = e;
        }
        isOccluded(e) {
          const t = this._currentRenderContext;
          return t && this.backend.isOccluded(t, e);
        }
        clear(e = true, t = true, i = true) {
          if (this._initialized === false) return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."), this.clearAsync(e, t, i);
          const n = this._renderTarget || this._getFrameBufferTarget();
          let r = null;
          if (n !== null) {
            this._textures.updateRenderTarget(n);
            const a = this._textures.get(n);
            r = this._renderContexts.get(null, null, n), r.textures = a.textures, r.depthTexture = a.depthTexture, r.width = a.width, r.height = a.height, r.renderTarget = n, r.depth = n.depthBuffer, r.stencil = n.stencilBuffer;
          }
          if (this.backend.clear(e, t, i, r), n !== null && this._renderTarget === null) {
            const a = this._quad;
            this._nodes.hasOutputChange(n.texture) && (a.material.fragmentNode = this._nodes.getOutputNode(n.texture), a.material.needsUpdate = true), this._renderScene(a, a.camera, false);
          }
        }
        clearColor() {
          return this.clear(true, false, false);
        }
        clearDepth() {
          return this.clear(false, true, false);
        }
        clearStencil() {
          return this.clear(false, false, true);
        }
        async clearAsync(e = true, t = true, i = true) {
          this._initialized === false && await this.init(), this.clear(e, t, i);
        }
        async clearColorAsync() {
          this.clearAsync(true, false, false);
        }
        async clearDepthAsync() {
          this.clearAsync(false, true, false);
        }
        async clearStencilAsync() {
          this.clearAsync(false, false, true);
        }
        get currentToneMapping() {
          return this._renderTarget !== null ? Ja : this.toneMapping;
        }
        get currentColorSpace() {
          return this._renderTarget !== null ? Vn : this.outputColorSpace;
        }
        dispose() {
          this.info.dispose(), this.backend.dispose(), this._animation.dispose(), this._objects.dispose(), this._pipelines.dispose(), this._nodes.dispose(), this._bindings.dispose(), this._renderLists.dispose(), this._renderContexts.dispose(), this._textures.dispose(), this.setRenderTarget(null), this.setAnimationLoop(null);
        }
        setRenderTarget(e, t = 0, i = 0) {
          this._renderTarget = e, this._activeCubeFace = t, this._activeMipmapLevel = i;
        }
        getRenderTarget() {
          return this._renderTarget;
        }
        setRenderObjectFunction(e) {
          this._renderObjectFunction = e;
        }
        getRenderObjectFunction() {
          return this._renderObjectFunction;
        }
        compute(e) {
          if (this.isDeviceLost === true) return;
          if (this._initialized === false) return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."), this.computeAsync(e);
          const t = this._nodes.nodeFrame, i = t.renderId;
          this.info.calls++, this.info.compute.calls++, this.info.compute.frameCalls++, t.renderId = this.info.calls;
          const n = this.backend, r = this._pipelines, a = this._bindings, l = this._nodes, o = Array.isArray(e) ? e : [
            e
          ];
          if (o[0] === void 0 || o[0].isComputeNode !== true) throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
          n.beginCompute(e);
          for (const u of o) {
            if (r.has(u) === false) {
              const d = () => {
                u.removeEventListener("dispose", d), r.delete(u), a.delete(u), l.delete(u);
              };
              u.addEventListener("dispose", d);
              const f = u.onInitFunction;
              f !== null && f.call(u, {
                renderer: this
              });
            }
            l.updateForCompute(u), a.updateForCompute(u);
            const c = a.getForCompute(u), h = r.getForCompute(u, c);
            n.compute(e, u, c, h);
          }
          n.finishCompute(e), t.renderId = i;
        }
        async computeAsync(e) {
          this._initialized === false && await this.init(), this.compute(e), await this.backend.resolveTimestampAsync(e, "compute");
        }
        async hasFeatureAsync(e) {
          return this._initialized === false && await this.init(), this.backend.hasFeature(e);
        }
        hasFeature(e) {
          return this._initialized === false ? (console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."), false) : this.backend.hasFeature(e);
        }
        hasInitialized() {
          return this._initialized;
        }
        async initTextureAsync(e) {
          this._initialized === false && await this.init(), this._textures.updateTexture(e);
        }
        initTexture(e) {
          this._initialized === false && console.warn("THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead."), this._textures.updateTexture(e);
        }
        copyFramebufferToTexture(e, t = null) {
          if (t !== null) if (t.isVector2) t = pn.set(t.x, t.y, e.image.width, e.image.height).floor();
          else if (t.isVector4) t = pn.copy(t).floor();
          else {
            console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");
            return;
          }
          else t = pn.set(0, 0, e.image.width, e.image.height);
          let i = this._currentRenderContext, n;
          i !== null ? n = i.renderTarget : (n = this._renderTarget || this._getFrameBufferTarget(), n !== null && (this._textures.updateRenderTarget(n), i = this._textures.get(n))), this._textures.updateTexture(e, {
            renderTarget: n
          }), this.backend.copyFramebufferToTexture(e, i, t);
        }
        copyTextureToTexture(e, t, i = null, n = null, r = 0) {
          this._textures.updateTexture(e), this._textures.updateTexture(t), this.backend.copyTextureToTexture(e, t, i, n, r);
        }
        async readRenderTargetPixelsAsync(e, t, i, n, r, a = 0, l = 0) {
          return this.backend.copyTextureToBuffer(e.textures[a], t, i, n, r, l);
        }
        _projectObject(e, t, i, n, r) {
          if (e.visible === false) return;
          if (e.layers.test(t.layers)) {
            if (e.isGroup) i = e.renderOrder, e.isClippingGroup && e.enabled && (r = r.getGroupContext(e));
            else if (e.isLOD) e.autoUpdate === true && e.update(t);
            else if (e.isLight) n.pushLight(e);
            else if (e.isSprite) {
              if (!e.frustumCulled || Dp.intersectsSprite(e)) {
                this.sortObjects === true && pn.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Oc);
                const { geometry: o, material: u } = e;
                u.visible && n.push(e, o, u, i, pn.z, null, r);
              }
            } else if (e.isLineLoop) console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
            else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || Dp.intersectsObject(e))) {
              const { geometry: o, material: u } = e;
              if (this.sortObjects === true && (o.boundingSphere === null && o.computeBoundingSphere(), pn.copy(o.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(Oc)), Array.isArray(u)) {
                const c = o.groups;
                for (let h = 0, d = c.length; h < d; h++) {
                  const f = c[h], p = u[f.materialIndex];
                  p && p.visible && n.push(e, o, p, i, pn.z, f, r);
                }
              } else u.visible && n.push(e, o, u, i, pn.z, null, r);
            }
          }
          if (e.isBundleGroup === true && this.backend.beginBundle !== void 0) {
            const o = n;
            n = this._renderLists.get(e, t), n.begin(), o.pushBundle({
              bundleGroup: e,
              camera: t,
              renderList: n
            }), n.finish();
          }
          const l = e.children;
          for (let o = 0, u = l.length; o < u; o++) this._projectObject(l[o], t, i, n, r);
        }
        _renderBundles(e, t, i) {
          for (const n of e) this._renderBundle(n, t, i);
        }
        _renderTransparents(e, t, i, n, r) {
          if (t.length > 0) {
            for (const { material: a } of t) a.side = Fi;
            this._renderObjects(t, i, n, r, "backSide");
            for (const { material: a } of t) a.side = yo;
            this._renderObjects(e, i, n, r);
            for (const { material: a } of t) a.side = Ka;
          } else this._renderObjects(e, i, n, r);
        }
        _renderObjects(e, t, i, n, r = null) {
          for (let a = 0, l = e.length; a < l; a++) {
            const o = e[a], { object: u, geometry: c, material: h, group: d, clippingContext: f } = o;
            if (t.isArrayCamera) {
              const p = t.cameras;
              for (let g = 0, _ = p.length; g < _; g++) {
                const m = p[g];
                if (u.layers.test(m.layers)) {
                  const y = m.viewport, x = y.minDepth === void 0 ? 0 : y.minDepth, b = y.maxDepth === void 0 ? 1 : y.maxDepth, T = this._currentRenderContext.viewportValue;
                  T.copy(y).multiplyScalar(this._pixelRatio).floor(), T.minDepth = x, T.maxDepth = b, this.backend.updateViewport(this._currentRenderContext), this._currentRenderObjectFunction(u, i, m, c, h, d, n, f, r);
                }
              }
            } else this._currentRenderObjectFunction(u, i, t, c, h, d, n, f, r);
          }
        }
        renderObject(e, t, i, n, r, a, l, o = null, u = null) {
          let c, h, d;
          if (e.onBeforeRender(this, t, i, n, r, a), t.overrideMaterial !== null) {
            const f = t.overrideMaterial;
            r.positionNode && r.positionNode.isNode && (c = f.positionNode, f.positionNode = r.positionNode), f.alphaTest = r.alphaTest, f.alphaMap = r.alphaMap, f.transparent = r.transparent || r.transmission > 0, f.isShadowNodeMaterial && (f.side = r.shadowSide === null ? r.side : r.shadowSide, r.depthNode && r.depthNode.isNode && (d = f.depthNode, f.depthNode = r.depthNode), r.castShadowNode && r.castShadowNode.isNode && (h = f.colorNode, f.colorNode = r.castShadowNode)), r = f;
          }
          r.transparent === true && r.side === Ka && r.forceSinglePass === false ? (r.side = Fi, this._handleObjectFunction(e, r, t, i, l, a, o, "backSide"), r.side = yo, this._handleObjectFunction(e, r, t, i, l, a, o, u), r.side = Ka) : this._handleObjectFunction(e, r, t, i, l, a, o, u), c !== void 0 && (t.overrideMaterial.positionNode = c), d !== void 0 && (t.overrideMaterial.depthNode = d), h !== void 0 && (t.overrideMaterial.colorNode = h), e.onAfterRender(this, t, i, n, r, a);
        }
        _renderObjectDirect(e, t, i, n, r, a, l, o) {
          const u = this._objects.get(e, t, i, n, r, this._currentRenderContext, l, o);
          u.drawRange = e.geometry.drawRange, u.group = a;
          const c = this._nodes.needsRefresh(u);
          c && (this._nodes.updateBefore(u), this._geometries.updateForRender(u), this._nodes.updateForRender(u), this._bindings.updateForRender(u)), this._pipelines.updateForRender(u), this._currentRenderBundle !== null && (this.backend.get(this._currentRenderBundle).renderObjects.push(u), u.bundle = this._currentRenderBundle.bundleGroup), this.backend.draw(u, this.info), c && this._nodes.updateAfter(u);
        }
        _createObjectPipeline(e, t, i, n, r, a, l, o) {
          const u = this._objects.get(e, t, i, n, r, this._currentRenderContext, l, o);
          u.drawRange = e.geometry.drawRange, u.group = a, this._nodes.updateBefore(u), this._geometries.updateForRender(u), this._nodes.updateForRender(u), this._bindings.updateForRender(u), this._pipelines.getForRender(u, this._compilationPromises), this._nodes.updateAfter(u);
        }
        get compile() {
          return this.compileAsync;
        }
      }
      class y0 {
        constructor(e = "") {
          this.name = e, this.visibility = 0;
        }
        setVisibility(e) {
          this.visibility |= e;
        }
        clone() {
          return Object.assign(new this.constructor(), this);
        }
      }
      function EL(s) {
        return s + (wn - s % wn) % wn;
      }
      let _A = class extends y0 {
        constructor(e, t = null) {
          super(e), this.isBuffer = true, this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT, this._buffer = t;
        }
        get byteLength() {
          return EL(this._buffer.byteLength);
        }
        get buffer() {
          return this._buffer;
        }
        update() {
          return true;
        }
      };
      class bA extends _A {
        constructor(e, t = null) {
          super(e, t), this.isUniformBuffer = true;
        }
      }
      let RL = 0;
      class SA extends bA {
        constructor(e, t) {
          super("UniformBuffer_" + RL++, e ? e.value : null), this.nodeUniform = e, this.groupNode = t;
        }
        get buffer() {
          return this.nodeUniform.value;
        }
      }
      class CL extends bA {
        constructor(e) {
          super(e), this.isUniformsGroup = true, this._values = null, this.uniforms = [];
        }
        addUniform(e) {
          return this.uniforms.push(e), this;
        }
        removeUniform(e) {
          const t = this.uniforms.indexOf(e);
          return t !== -1 && this.uniforms.splice(t, 1), this;
        }
        get values() {
          return this._values === null && (this._values = Array.from(this.buffer)), this._values;
        }
        get buffer() {
          let e = this._buffer;
          if (e === null) {
            const t = this.byteLength;
            e = new Float32Array(new ArrayBuffer(t)), this._buffer = e;
          }
          return e;
        }
        get byteLength() {
          let e = 0;
          for (let t = 0, i = this.uniforms.length; t < i; t++) {
            const n = this.uniforms[t], { boundary: r, itemSize: a } = n, l = e % wn, o = wn - l;
            l !== 0 && o - r < 0 ? e += wn - l : l % r !== 0 && (e += l % r), n.offset = e / this.bytesPerElement, e += a * this.bytesPerElement;
          }
          return Math.ceil(e / wn) * wn;
        }
        update() {
          let e = false;
          for (const t of this.uniforms) this.updateByType(t) === true && (e = true);
          return e;
        }
        updateByType(e) {
          if (e.isNumberUniform) return this.updateNumber(e);
          if (e.isVector2Uniform) return this.updateVector2(e);
          if (e.isVector3Uniform) return this.updateVector3(e);
          if (e.isVector4Uniform) return this.updateVector4(e);
          if (e.isColorUniform) return this.updateColor(e);
          if (e.isMatrix3Uniform) return this.updateMatrix3(e);
          if (e.isMatrix4Uniform) return this.updateMatrix4(e);
          console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", e);
        }
        updateNumber(e) {
          let t = false;
          const i = this.values, n = e.getValue(), r = e.offset, a = e.getType();
          if (i[r] !== n) {
            const l = this._getBufferForType(a);
            l[r] = i[r] = n, t = true;
          }
          return t;
        }
        updateVector2(e) {
          let t = false;
          const i = this.values, n = e.getValue(), r = e.offset, a = e.getType();
          if (i[r + 0] !== n.x || i[r + 1] !== n.y) {
            const l = this._getBufferForType(a);
            l[r + 0] = i[r + 0] = n.x, l[r + 1] = i[r + 1] = n.y, t = true;
          }
          return t;
        }
        updateVector3(e) {
          let t = false;
          const i = this.values, n = e.getValue(), r = e.offset, a = e.getType();
          if (i[r + 0] !== n.x || i[r + 1] !== n.y || i[r + 2] !== n.z) {
            const l = this._getBufferForType(a);
            l[r + 0] = i[r + 0] = n.x, l[r + 1] = i[r + 1] = n.y, l[r + 2] = i[r + 2] = n.z, t = true;
          }
          return t;
        }
        updateVector4(e) {
          let t = false;
          const i = this.values, n = e.getValue(), r = e.offset, a = e.getType();
          if (i[r + 0] !== n.x || i[r + 1] !== n.y || i[r + 2] !== n.z || i[r + 4] !== n.w) {
            const l = this._getBufferForType(a);
            l[r + 0] = i[r + 0] = n.x, l[r + 1] = i[r + 1] = n.y, l[r + 2] = i[r + 2] = n.z, l[r + 3] = i[r + 3] = n.w, t = true;
          }
          return t;
        }
        updateColor(e) {
          let t = false;
          const i = this.values, n = e.getValue(), r = e.offset;
          if (i[r + 0] !== n.r || i[r + 1] !== n.g || i[r + 2] !== n.b) {
            const a = this.buffer;
            a[r + 0] = i[r + 0] = n.r, a[r + 1] = i[r + 1] = n.g, a[r + 2] = i[r + 2] = n.b, t = true;
          }
          return t;
        }
        updateMatrix3(e) {
          let t = false;
          const i = this.values, n = e.getValue().elements, r = e.offset;
          if (i[r + 0] !== n[0] || i[r + 1] !== n[1] || i[r + 2] !== n[2] || i[r + 4] !== n[3] || i[r + 5] !== n[4] || i[r + 6] !== n[5] || i[r + 8] !== n[6] || i[r + 9] !== n[7] || i[r + 10] !== n[8]) {
            const a = this.buffer;
            a[r + 0] = i[r + 0] = n[0], a[r + 1] = i[r + 1] = n[1], a[r + 2] = i[r + 2] = n[2], a[r + 4] = i[r + 4] = n[3], a[r + 5] = i[r + 5] = n[4], a[r + 6] = i[r + 6] = n[5], a[r + 8] = i[r + 8] = n[6], a[r + 9] = i[r + 9] = n[7], a[r + 10] = i[r + 10] = n[8], t = true;
          }
          return t;
        }
        updateMatrix4(e) {
          let t = false;
          const i = this.values, n = e.getValue().elements, r = e.offset;
          return DL(i, n, r) === false && (this.buffer.set(n, r), BL(i, n, r), t = true), t;
        }
        _getBufferForType(e) {
          return e === "int" || e === "ivec2" || e === "ivec3" || e === "ivec4" ? new Int32Array(this.buffer.buffer) : e === "uint" || e === "uvec2" || e === "uvec3" || e === "uvec4" ? new Uint32Array(this.buffer.buffer) : this.buffer;
        }
      }
      function BL(s, e, t) {
        for (let i = 0, n = e.length; i < n; i++) s[t + i] = e[i];
      }
      function DL(s, e, t) {
        for (let i = 0, n = e.length; i < n; i++) if (s[t + i] !== e[i]) return false;
        return true;
      }
      let UL = 0;
      class TA extends CL {
        constructor(e, t) {
          super(e), this.id = UL++, this.groupNode = t, this.isNodeUniformsGroup = true;
        }
      }
      let FL = 0;
      class OL extends y0 {
        constructor(e, t) {
          super(e), this.id = FL++, this.texture = t, this.version = t ? t.version : 0, this.store = false, this.generation = null, this.isSampledTexture = true;
        }
        needsBindingsUpdate(e) {
          const { texture: t } = this;
          return e !== this.generation ? (this.generation = e, true) : t.isVideoTexture;
        }
        update() {
          const { texture: e, version: t } = this;
          return t !== e.version ? (this.version = e.version, true) : false;
        }
      }
      class $d extends OL {
        constructor(e, t, i, n = null) {
          super(e, t ? t.value : null), this.textureNode = t, this.groupNode = i, this.access = n;
        }
        needsBindingsUpdate(e) {
          return this.textureNode.value !== this.texture || super.needsBindingsUpdate(e);
        }
        update() {
          const { textureNode: e } = this;
          return this.texture !== e.value ? (this.texture = e.value, true) : super.update();
        }
      }
      class vA extends $d {
        constructor(e, t, i, n = null) {
          super(e, t, i, n), this.isSampledCubeTexture = true;
        }
      }
      class MA extends $d {
        constructor(e, t, i, n = null) {
          super(e, t, i, n), this.isSampledTexture3D = true;
        }
      }
      const zL = {
        textureDimensions: "textureSize",
        equals: "equal"
      }, LL = {
        low: "lowp",
        medium: "mediump",
        high: "highp"
      }, Gb = {
        swizzleAssign: true,
        storageBuffer: false
      }, Pb = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;
      class GL extends mA {
        constructor(e, t) {
          super(e, t, new SL()), this.uniformGroups = {}, this.transforms = [], this.extensions = {}, this.builtins = {
            vertex: [],
            fragment: [],
            compute: []
          }, this.useComparisonMethod = true;
        }
        needsToWorkingColorSpace(e) {
          return e.isVideoTexture === true && e.colorSpace !== zr;
        }
        getMethod(e) {
          return zL[e] || e;
        }
        getOutputStructName() {
          return "";
        }
        buildFunctionCode(e) {
          const t = e.layout, i = this.flowShaderNode(e), n = [];
          for (const a of t.inputs) n.push(this.getType(a.type) + " " + a.name);
          return `${this.getType(t.type)} ${t.name}( ${n.join(", ")} ) {

	${i.vars}

${i.code}
	return ${i.result};

}`;
        }
        setupPBO(e) {
          const t = e.value;
          if (t.pbo === void 0) {
            const i = t.array, n = t.count * t.itemSize, { itemSize: r } = t, a = t.array.constructor.name.toLowerCase().includes("int");
            let l = a ? Ry : Dd;
            r === 2 ? l = a ? Cy : lu : r === 3 ? l = a ? dR : Ey : r === 4 && (l = a ? By : Or);
            const o = {
              Float32Array: Yt,
              Uint8Array: In,
              Uint16Array: La,
              Uint32Array: Tt,
              Int8Array: Ul,
              Int16Array: Fl,
              Int32Array: Dt,
              Uint8ClampedArray: In
            }, u = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(n / r))));
            let c = Math.ceil(n / r / u);
            u * c * r < n && c++;
            const h = u * c * r, d = new i.constructor(h);
            d.set(i, 0), t.array = d;
            const f = new Pv(t.array, u, c, l, o[t.array.constructor.name] || Yt);
            f.needsUpdate = true, f.isPBOTexture = true;
            const p = new Gu(f, null, null);
            p.setPrecision("high"), t.pboNode = p, t.pbo = p.value, this.getUniformFromNode(t.pboNode, "texture", this.shaderStage, this.context.label);
          }
        }
        getPropertyName(e, t = this.shaderStage) {
          return e.isNodeUniform && e.node.isTextureNode !== true && e.node.isBufferNode !== true ? t.charAt(0) + "_" + e.name : super.getPropertyName(e, t);
        }
        generatePBO(e) {
          const { node: t, indexNode: i } = e, n = t.value;
          if (this.renderer.backend.has(n)) {
            const c = this.renderer.backend.get(n);
            c.pbo = n.pbo;
          }
          const r = this.getUniformFromNode(n.pboNode, "texture", this.shaderStage, this.context.label), a = this.getPropertyName(r);
          this.increaseUsage(i);
          const l = i.build(this, "uint"), o = this.getDataFromNode(e);
          let u = o.propertyName;
          if (u === void 0) {
            const c = this.getVarFromNode(e);
            u = this.getPropertyName(c);
            const h = this.getDataFromNode(t);
            let d = h.propertySizeName;
            d === void 0 && (d = u + "Size", this.getVarFromNode(t, d, "uint"), this.addLineFlowCode(`${d} = uint( textureSize( ${a}, 0 ).x )`, e), h.propertySizeName = d);
            const { itemSize: f } = n, p = "." + Lo.join("").slice(0, f), g = `ivec2(${l} % ${d}, ${l} / ${d})`, _ = this.generateTextureLoad(null, a, g, null, "0");
            let m = "vec4";
            n.pbo.type === Tt ? m = "uvec4" : n.pbo.type === Dt && (m = "ivec4"), this.addLineFlowCode(`${u} = ${m}(${_})${p}`, e), o.propertyName = u;
          }
          return u;
        }
        generateTextureLoad(e, t, i, n, r = "0") {
          return n ? `texelFetch( ${t}, ivec3( ${i}, ${n} ), ${r} )` : `texelFetch( ${t}, ${i}, ${r} )`;
        }
        generateTexture(e, t, i, n) {
          return e.isDepthTexture ? `texture( ${t}, ${i} ).x` : (n && (i = `vec3( ${i}, ${n} )`), `texture( ${t}, ${i} )`);
        }
        generateTextureLevel(e, t, i, n) {
          return `textureLod( ${t}, ${i}, ${n} )`;
        }
        generateTextureBias(e, t, i, n) {
          return `texture( ${t}, ${i}, ${n} )`;
        }
        generateTextureGrad(e, t, i, n) {
          return `textureGrad( ${t}, ${i}, ${n[0]}, ${n[1]} )`;
        }
        generateTextureCompare(e, t, i, n, r, a = this.shaderStage) {
          if (a === "fragment") return `texture( ${t}, vec3( ${i}, ${n} ) )`;
          console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${a} shader.`);
        }
        getVars(e) {
          const t = [], i = this.vars[e];
          if (i !== void 0) for (const n of i) t.push(`${this.getVar(n.type, n.name)};`);
          return t.join(`
	`);
        }
        getUniforms(e) {
          const t = this.uniforms[e], i = [], n = {};
          for (const a of t) {
            let l = null, o = false;
            if (a.type === "texture") {
              const c = a.node.value;
              let h = "";
              c.isDataTexture === true && (c.type === Tt ? h = "u" : c.type === Dt && (h = "i")), c.compareFunction ? l = `sampler2DShadow ${a.name};` : c.isDataArrayTexture === true || c.isCompressedArrayTexture === true ? l = `${h}sampler2DArray ${a.name};` : l = `${h}sampler2D ${a.name};`;
            } else if (a.type === "cubeTexture") l = `samplerCube ${a.name};`;
            else if (a.type === "texture3D") l = `sampler3D ${a.name};`;
            else if (a.type === "buffer") {
              const c = a.node, h = this.getType(c.bufferType), d = c.bufferCount, f = d > 0 ? d : "";
              l = `${c.name} {
	${h} ${a.name}[${f}];
};
`;
            } else l = `${this.getVectorType(a.type)} ${this.getPropertyName(a, e)};`, o = true;
            const u = a.node.precision;
            if (u !== null && (l = LL[u] + " " + l), o) {
              l = "	" + l;
              const c = a.groupNode.name;
              (n[c] || (n[c] = [])).push(l);
            } else l = "uniform " + l, i.push(l);
          }
          let r = "";
          for (const a in n) {
            const l = n[a];
            r += this._getGLSLUniformStruct(e + "_" + a, l.join(`
`)) + `
`;
          }
          return r += i.join(`
`), r;
        }
        getTypeFromAttribute(e) {
          let t = super.getTypeFromAttribute(e);
          if (/^[iu]/.test(t) && e.gpuType !== Dt) {
            let i = e;
            e.isInterleavedBufferAttribute && (i = e.data);
            const n = i.array;
            n instanceof Uint32Array || n instanceof Int32Array || (t = t.slice(1));
          }
          return t;
        }
        getAttributes(e) {
          let t = "";
          if (e === "vertex" || e === "compute") {
            const i = this.getAttributesArray();
            let n = 0;
            for (const r of i) t += `layout( location = ${n++} ) in ${r.type} ${r.name};
`;
          }
          return t;
        }
        getStructMembers(e) {
          const t = [], i = e.getMemberTypes();
          for (let n = 0; n < i.length; n++) {
            const r = i[n];
            t.push(`layout( location = ${n} ) out ${r} m${n};`);
          }
          return t.join(`
`);
        }
        getStructs(e) {
          const t = [], i = this.structs[e];
          if (i.length === 0) return `layout( location = 0 ) out vec4 fragColor;
`;
          for (let n = 0, r = i.length; n < r; n++) {
            const a = i[n];
            let l = `
`;
            l += this.getStructMembers(a), l += `
`, t.push(l);
          }
          return t.join(`

`);
        }
        getVaryings(e) {
          let t = "";
          const i = this.varyings;
          if (e === "vertex" || e === "compute") for (const n of i) {
            e === "compute" && (n.needsInterpolation = true);
            const r = this.getType(n.type), a = r.includes("int") || r.includes("uv") || r.includes("iv") ? "flat " : "";
            t += `${a}${n.needsInterpolation ? "out" : "/*out*/"} ${r} ${n.name};
`;
          }
          else if (e === "fragment") {
            for (const n of i) if (n.needsInterpolation) {
              const r = this.getType(n.type), a = r.includes("int") || r.includes("uv") || r.includes("iv") ? "flat " : "";
              t += `${a}in ${r} ${n.name};
`;
            }
          }
          for (const n of this.builtins[e]) t += `${n};
`;
          return t;
        }
        getVertexIndex() {
          return "uint( gl_VertexID )";
        }
        getInstanceIndex() {
          return "uint( gl_InstanceID )";
        }
        getInvocationLocalIndex() {
          return `uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((i, n) => i * n, 1)}u`;
        }
        getDrawIndex() {
          return this.renderer.backend.extensions.has("WEBGL_multi_draw") ? "uint( gl_DrawID )" : null;
        }
        getFrontFacing() {
          return "gl_FrontFacing";
        }
        getFragCoord() {
          return "gl_FragCoord.xy";
        }
        getFragDepth() {
          return "gl_FragDepth";
        }
        enableExtension(e, t, i = this.shaderStage) {
          const n = this.extensions[i] || (this.extensions[i] = /* @__PURE__ */ new Map());
          n.has(e) === false && n.set(e, {
            name: e,
            behavior: t
          });
        }
        getExtensions(e) {
          const t = [];
          if (e === "vertex") {
            const n = this.renderer.backend.extensions;
            this.object.isBatchedMesh && n.has("WEBGL_multi_draw") && this.enableExtension("GL_ANGLE_multi_draw", "require", e);
          }
          const i = this.extensions[e];
          if (i !== void 0) for (const { name: n, behavior: r } of i.values()) t.push(`#extension ${n} : ${r}`);
          return t.join(`
`);
        }
        getClipDistance() {
          return "gl_ClipDistance";
        }
        isAvailable(e) {
          let t = Gb[e];
          if (t === void 0) {
            let i;
            switch (t = false, e) {
              case "float32Filterable":
                i = "OES_texture_float_linear";
                break;
              case "clipDistance":
                i = "WEBGL_clip_cull_distance";
                break;
            }
            if (i !== void 0) {
              const n = this.renderer.backend.extensions;
              n.has(i) && (n.get(i), t = true);
            }
            Gb[e] = t;
          }
          return t;
        }
        isFlipY() {
          return true;
        }
        enableHardwareClipping(e) {
          this.enableExtension("GL_ANGLE_clip_cull_distance", "require"), this.builtins.vertex.push(`out float gl_ClipDistance[ ${e} ]`);
        }
        registerTransform(e, t) {
          this.transforms.push({
            varyingName: e,
            attributeNode: t
          });
        }
        getTransforms() {
          const e = this.transforms;
          let t = "";
          for (let i = 0; i < e.length; i++) {
            const n = e[i], r = this.getPropertyName(n.attributeNode);
            t += `${n.varyingName} = ${r};
	`;
          }
          return t;
        }
        _getGLSLUniformStruct(e, t) {
          return `
layout( std140 ) uniform ${e} {
${t}
};`;
        }
        _getGLSLVertexCode(e) {
          return `#version 300 es

${this.getSignature()}

// extensions 
${e.extensions}

// precision
${Pb}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`;
        }
        _getGLSLFragmentCode(e) {
          return `#version 300 es

${this.getSignature()}

// precision
${Pb}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

${e.structs}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
        }
        buildCode() {
          const e = this.material !== null ? {
            fragment: {},
            vertex: {}
          } : {
            compute: {}
          };
          this.sortBindingGroups();
          for (const t in e) {
            let i = `// code

`;
            i += this.flowCode[t];
            const n = this.flowNodes[t], r = n[n.length - 1];
            for (const l of n) {
              const o = this.getFlowData(l), u = l.name;
              u && (i.length > 0 && (i += `
`), i += `	// flow -> ${u}
	`), i += `${o.code}
	`, l === r && t !== "compute" && (i += `// result
	`, t === "vertex" ? (i += "gl_Position = ", i += `${o.result};`) : t === "fragment" && (l.outputNode.isOutputStructNode || (i += "fragColor = ", i += `${o.result};`)));
            }
            const a = e[t];
            a.extensions = this.getExtensions(t), a.uniforms = this.getUniforms(t), a.attributes = this.getAttributes(t), a.varyings = this.getVaryings(t), a.vars = this.getVars(t), a.structs = this.getStructs(t), a.codes = this.getCodes(t), a.transforms = this.getTransforms(t), a.flow = i;
          }
          this.material !== null ? (this.vertexShader = this._getGLSLVertexCode(e.vertex), this.fragmentShader = this._getGLSLFragmentCode(e.fragment)) : this.computeShader = this._getGLSLVertexCode(e.compute);
        }
        getUniformFromNode(e, t, i, n = null) {
          const r = super.getUniformFromNode(e, t, i, n), a = this.getDataFromNode(e, i, this.globalCache);
          let l = a.uniformGPU;
          if (l === void 0) {
            const o = e.groupNode, u = o.name, c = this.getBindGroupArray(u, i);
            if (t === "texture") l = new $d(r.name, r.node, o), c.push(l);
            else if (t === "cubeTexture") l = new vA(r.name, r.node, o), c.push(l);
            else if (t === "texture3D") l = new MA(r.name, r.node, o), c.push(l);
            else if (t === "buffer") {
              e.name = `NodeBuffer_${e.id}`, r.name = `buffer${e.id}`;
              const h = new SA(e, o);
              h.name = e.name, c.push(h), l = h;
            } else {
              const h = this.uniformGroups[i] || (this.uniformGroups[i] = {});
              let d = h[u];
              d === void 0 && (d = new TA(i + "_" + u, o), h[u] = d, c.push(d)), l = this.getNodeUniform(r, t), d.addUniform(l);
            }
            a.uniformGPU = l;
          }
          return r;
        }
      }
      let Up = null, ya = null;
      class AA {
        constructor(e = {}) {
          this.parameters = Object.assign({}, e), this.data = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.domElement = null;
        }
        async init(e) {
          this.renderer = e;
        }
        get coordinateSystem() {
        }
        beginRender() {
        }
        finishRender() {
        }
        beginCompute() {
        }
        finishCompute() {
        }
        draw() {
        }
        compute() {
        }
        createProgram() {
        }
        destroyProgram() {
        }
        createBindings() {
        }
        updateBindings() {
        }
        updateBinding() {
        }
        createRenderPipeline() {
        }
        createComputePipeline() {
        }
        needsRenderUpdate() {
        }
        getRenderCacheKey() {
        }
        createNodeBuilder() {
        }
        createSampler() {
        }
        destroySampler() {
        }
        createDefaultTexture() {
        }
        createTexture() {
        }
        updateTexture() {
        }
        generateMipmaps() {
        }
        destroyTexture() {
        }
        copyTextureToBuffer() {
        }
        copyTextureToTexture() {
        }
        copyFramebufferToTexture() {
        }
        createAttribute() {
        }
        createIndexAttribute() {
        }
        createStorageAttribute() {
        }
        updateAttribute() {
        }
        destroyAttribute() {
        }
        getContext() {
        }
        updateSize() {
        }
        updateViewport() {
        }
        isOccluded() {
        }
        async resolveTimestampAsync() {
        }
        async waitForGPU() {
        }
        async hasFeatureAsync() {
        }
        hasFeature() {
        }
        getMaxAnisotropy() {
        }
        getDrawingBufferSize() {
          return Up = Up || new q(), this.renderer.getDrawingBufferSize(Up);
        }
        setScissorTest() {
        }
        getClearColor() {
          const e = this.renderer;
          return ya = ya || new h0(), e.getClearColor(ya), ya.getRGB(ya, this.renderer.currentColorSpace), ya;
        }
        getDomElement() {
          let e = this.domElement;
          return e === null && (e = this.parameters.canvas !== void 0 ? this.parameters.canvas : WR(), "setAttribute" in e && e.setAttribute("data-engine", `three.js r${Cd} webgpu`), this.domElement = e), e;
        }
        set(e, t) {
          this.data.set(e, t);
        }
        get(e) {
          let t = this.data.get(e);
          return t === void 0 && (t = {}, this.data.set(e, t)), t;
        }
        has(e) {
          return this.data.has(e);
        }
        delete(e) {
          this.data.delete(e);
        }
        dispose() {
        }
      }
      let PL = 0;
      class kL {
        constructor(e, t) {
          this.buffers = [
            e.bufferGPU,
            t
          ], this.type = e.type, this.bufferType = e.bufferType, this.pbo = e.pbo, this.byteLength = e.byteLength, this.bytesPerElement = e.BYTES_PER_ELEMENT, this.version = e.version, this.isInteger = e.isInteger, this.activeBufferIndex = 0, this.baseId = e.id;
        }
        get id() {
          return `${this.baseId}|${this.activeBufferIndex}`;
        }
        get bufferGPU() {
          return this.buffers[this.activeBufferIndex];
        }
        get transformBuffer() {
          return this.buffers[this.activeBufferIndex ^ 1];
        }
        switchBuffers() {
          this.activeBufferIndex ^= 1;
        }
      }
      class IL {
        constructor(e) {
          this.backend = e;
        }
        createAttribute(e, t) {
          const i = this.backend, { gl: n } = i, r = e.array, a = e.usage || n.STATIC_DRAW, l = e.isInterleavedBufferAttribute ? e.data : e, o = i.get(l);
          let u = o.bufferGPU;
          u === void 0 && (u = this._createBuffer(n, t, r, a), o.bufferGPU = u, o.bufferType = t, o.version = l.version);
          let c;
          if (r instanceof Float32Array) c = n.FLOAT;
          else if (r instanceof Uint16Array) e.isFloat16BufferAttribute ? c = n.HALF_FLOAT : c = n.UNSIGNED_SHORT;
          else if (r instanceof Int16Array) c = n.SHORT;
          else if (r instanceof Uint32Array) c = n.UNSIGNED_INT;
          else if (r instanceof Int32Array) c = n.INT;
          else if (r instanceof Int8Array) c = n.BYTE;
          else if (r instanceof Uint8Array) c = n.UNSIGNED_BYTE;
          else if (r instanceof Uint8ClampedArray) c = n.UNSIGNED_BYTE;
          else throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + r);
          let h = {
            bufferGPU: u,
            bufferType: t,
            type: c,
            byteLength: r.byteLength,
            bytesPerElement: r.BYTES_PER_ELEMENT,
            version: e.version,
            pbo: e.pbo,
            isInteger: c === n.INT || c === n.UNSIGNED_INT || e.gpuType === Dt,
            id: PL++
          };
          if (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) {
            const d = this._createBuffer(n, t, r, a);
            h = new kL(h, d);
          }
          i.set(e, h);
        }
        updateAttribute(e) {
          const t = this.backend, { gl: i } = t, n = e.array, r = e.isInterleavedBufferAttribute ? e.data : e, a = t.get(r), l = a.bufferType, o = e.isInterleavedBufferAttribute ? e.data.updateRanges : e.updateRanges;
          if (i.bindBuffer(l, a.bufferGPU), o.length === 0) i.bufferSubData(l, 0, n);
          else {
            for (let u = 0, c = o.length; u < c; u++) {
              const h = o[u];
              i.bufferSubData(l, h.start * n.BYTES_PER_ELEMENT, n, h.start, h.count);
            }
            r.clearUpdateRanges();
          }
          i.bindBuffer(l, null), a.version = r.version;
        }
        destroyAttribute(e) {
          const t = this.backend, { gl: i } = t;
          e.isInterleavedBufferAttribute && t.delete(e.data);
          const n = t.get(e);
          i.deleteBuffer(n.bufferGPU), t.delete(e);
        }
        async getArrayBufferAsync(e) {
          const t = this.backend, { gl: i } = t, n = e.isInterleavedBufferAttribute ? e.data : e, { bufferGPU: r } = t.get(n), a = e.array, l = a.byteLength;
          i.bindBuffer(i.COPY_READ_BUFFER, r);
          const o = i.createBuffer();
          i.bindBuffer(i.COPY_WRITE_BUFFER, o), i.bufferData(i.COPY_WRITE_BUFFER, l, i.STREAM_READ), i.copyBufferSubData(i.COPY_READ_BUFFER, i.COPY_WRITE_BUFFER, 0, 0, l), await t.utils._clientWaitAsync();
          const u = new e.array.constructor(a.length);
          return i.bindBuffer(i.COPY_WRITE_BUFFER, o), i.getBufferSubData(i.COPY_WRITE_BUFFER, 0, u), i.deleteBuffer(o), i.bindBuffer(i.COPY_READ_BUFFER, null), i.bindBuffer(i.COPY_WRITE_BUFFER, null), u.buffer;
        }
        _createBuffer(e, t, i, n) {
          const r = e.createBuffer();
          return e.bindBuffer(t, r), e.bufferData(t, i, n), e.bindBuffer(t, null), r;
        }
      }
      let kb = false, Fp, ll;
      class VL {
        constructor(e) {
          this.backend = e, this.gl = this.backend.gl, this.enabled = {}, this.currentFlipSided = null, this.currentCullFace = null, this.currentProgram = null, this.currentBlendingEnabled = false, this.currentBlending = null, this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentPremultipledAlpha = null, this.currentPolygonOffsetFactor = null, this.currentPolygonOffsetUnits = null, this.currentColorMask = null, this.currentDepthFunc = null, this.currentDepthMask = null, this.currentStencilFunc = null, this.currentStencilRef = null, this.currentStencilFuncMask = null, this.currentStencilFail = null, this.currentStencilZFail = null, this.currentStencilZPass = null, this.currentStencilMask = null, this.currentLineWidth = null, this.currentClippingPlanes = 0, this.currentBoundFramebuffers = {}, this.currentDrawbuffers = /* @__PURE__ */ new WeakMap(), this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), this.currentTextureSlot = null, this.currentBoundTextures = {}, this.currentBoundBufferBases = {}, kb === false && (this._init(this.gl), kb = true);
        }
        _init(e) {
          Fp = {
            [Mn]: e.FUNC_ADD,
            [iv]: e.FUNC_SUBTRACT,
            [sv]: e.FUNC_REVERSE_SUBTRACT
          }, ll = {
            [nv]: e.ZERO,
            [rv]: e.ONE,
            [av]: e.SRC_COLOR,
            [Wh]: e.SRC_ALPHA,
            [dv]: e.SRC_ALPHA_SATURATE,
            [cv]: e.DST_COLOR,
            [lv]: e.DST_ALPHA,
            [ov]: e.ONE_MINUS_SRC_COLOR,
            [jh]: e.ONE_MINUS_SRC_ALPHA,
            [hv]: e.ONE_MINUS_DST_COLOR,
            [uv]: e.ONE_MINUS_DST_ALPHA
          };
        }
        enable(e) {
          const { enabled: t } = this;
          t[e] !== true && (this.gl.enable(e), t[e] = true);
        }
        disable(e) {
          const { enabled: t } = this;
          t[e] !== false && (this.gl.disable(e), t[e] = false);
        }
        setFlipSided(e) {
          if (this.currentFlipSided !== e) {
            const { gl: t } = this;
            e ? t.frontFace(t.CW) : t.frontFace(t.CCW), this.currentFlipSided = e;
          }
        }
        setCullFace(e) {
          const { gl: t } = this;
          e !== W2 ? (this.enable(t.CULL_FACE), e !== this.currentCullFace && (e === j2 ? t.cullFace(t.BACK) : e === $2 ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : this.disable(t.CULL_FACE), this.currentCullFace = e;
        }
        setLineWidth(e) {
          const { currentLineWidth: t, gl: i } = this;
          e !== t && (i.lineWidth(e), this.currentLineWidth = e);
        }
        setBlending(e, t, i, n, r, a, l, o) {
          const { gl: u } = this;
          if (e === xo) {
            this.currentBlendingEnabled === true && (this.disable(u.BLEND), this.currentBlendingEnabled = false);
            return;
          }
          if (this.currentBlendingEnabled === false && (this.enable(u.BLEND), this.currentBlendingEnabled = true), e !== tv) {
            if (e !== this.currentBlending || o !== this.currentPremultipledAlpha) {
              if ((this.currentBlendEquation !== Mn || this.currentBlendEquationAlpha !== Mn) && (u.blendEquation(u.FUNC_ADD), this.currentBlendEquation = Mn, this.currentBlendEquationAlpha = Mn), o) switch (e) {
                case kn:
                  u.blendFuncSeparate(u.ONE, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA);
                  break;
                case Hh:
                  u.blendFunc(u.ONE, u.ONE);
                  break;
                case qh:
                  u.blendFuncSeparate(u.ZERO, u.ONE_MINUS_SRC_COLOR, u.ZERO, u.ONE);
                  break;
                case Yh:
                  u.blendFuncSeparate(u.ZERO, u.SRC_COLOR, u.ZERO, u.SRC_ALPHA);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
                  break;
              }
              else switch (e) {
                case kn:
                  u.blendFuncSeparate(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA);
                  break;
                case Hh:
                  u.blendFunc(u.SRC_ALPHA, u.ONE);
                  break;
                case qh:
                  u.blendFuncSeparate(u.ZERO, u.ONE_MINUS_SRC_COLOR, u.ZERO, u.ONE);
                  break;
                case Yh:
                  u.blendFunc(u.ZERO, u.SRC_COLOR);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
                  break;
              }
              this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentBlending = e, this.currentPremultipledAlpha = o;
            }
            return;
          }
          r = r || t, a = a || i, l = l || n, (t !== this.currentBlendEquation || r !== this.currentBlendEquationAlpha) && (u.blendEquationSeparate(Fp[t], Fp[r]), this.currentBlendEquation = t, this.currentBlendEquationAlpha = r), (i !== this.currentBlendSrc || n !== this.currentBlendDst || a !== this.currentBlendSrcAlpha || l !== this.currentBlendDstAlpha) && (u.blendFuncSeparate(ll[i], ll[n], ll[a], ll[l]), this.currentBlendSrc = i, this.currentBlendDst = n, this.currentBlendSrcAlpha = a, this.currentBlendDstAlpha = l), this.currentBlending = e, this.currentPremultipledAlpha = false;
        }
        setColorMask(e) {
          this.currentColorMask !== e && (this.gl.colorMask(e, e, e, e), this.currentColorMask = e);
        }
        setDepthTest(e) {
          const { gl: t } = this;
          e ? this.enable(t.DEPTH_TEST) : this.disable(t.DEPTH_TEST);
        }
        setDepthMask(e) {
          this.currentDepthMask !== e && (this.gl.depthMask(e), this.currentDepthMask = e);
        }
        setDepthFunc(e) {
          if (this.currentDepthFunc !== e) {
            const { gl: t } = this;
            switch (e) {
              case fv:
                t.depthFunc(t.NEVER);
                break;
              case pv:
                t.depthFunc(t.ALWAYS);
                break;
              case mv:
                t.depthFunc(t.LESS);
                break;
              case $h:
                t.depthFunc(t.LEQUAL);
                break;
              case gv:
                t.depthFunc(t.EQUAL);
                break;
              case yv:
                t.depthFunc(t.GEQUAL);
                break;
              case xv:
                t.depthFunc(t.GREATER);
                break;
              case _v:
                t.depthFunc(t.NOTEQUAL);
                break;
              default:
                t.depthFunc(t.LEQUAL);
            }
            this.currentDepthFunc = e;
          }
        }
        setStencilTest(e) {
          const { gl: t } = this;
          e ? this.enable(t.STENCIL_TEST) : this.disable(t.STENCIL_TEST);
        }
        setStencilMask(e) {
          this.currentStencilMask !== e && (this.gl.stencilMask(e), this.currentStencilMask = e);
        }
        setStencilFunc(e, t, i) {
          (this.currentStencilFunc !== e || this.currentStencilRef !== t || this.currentStencilFuncMask !== i) && (this.gl.stencilFunc(e, t, i), this.currentStencilFunc = e, this.currentStencilRef = t, this.currentStencilFuncMask = i);
        }
        setStencilOp(e, t, i) {
          (this.currentStencilFail !== e || this.currentStencilZFail !== t || this.currentStencilZPass !== i) && (this.gl.stencilOp(e, t, i), this.currentStencilFail = e, this.currentStencilZFail = t, this.currentStencilZPass = i);
        }
        setMaterial(e, t, i) {
          const { gl: n } = this;
          e.side === Ka ? this.disable(n.CULL_FACE) : this.enable(n.CULL_FACE);
          let r = e.side === Fi;
          t && (r = !r), this.setFlipSided(r), e.blending === kn && e.transparent === false ? this.setBlending(xo) : this.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), this.setDepthFunc(e.depthFunc), this.setDepthTest(e.depthTest), this.setDepthMask(e.depthWrite), this.setColorMask(e.colorWrite);
          const a = e.stencilWrite;
          if (this.setStencilTest(a), a && (this.setStencilMask(e.stencilWriteMask), this.setStencilFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), this.setStencilOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), this.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), e.alphaToCoverage === true && this.backend.renderer.samples > 1 ? this.enable(n.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(n.SAMPLE_ALPHA_TO_COVERAGE), i > 0 && this.currentClippingPlanes !== i) for (let o = 0; o < 8; o++) o < i ? this.enable(12288 + o) : this.disable(12288 + o);
        }
        setPolygonOffset(e, t, i) {
          const { gl: n } = this;
          e ? (this.enable(n.POLYGON_OFFSET_FILL), (this.currentPolygonOffsetFactor !== t || this.currentPolygonOffsetUnits !== i) && (n.polygonOffset(t, i), this.currentPolygonOffsetFactor = t, this.currentPolygonOffsetUnits = i)) : this.disable(n.POLYGON_OFFSET_FILL);
        }
        useProgram(e) {
          return this.currentProgram !== e ? (this.gl.useProgram(e), this.currentProgram = e, true) : false;
        }
        bindFramebuffer(e, t) {
          const { gl: i, currentBoundFramebuffers: n } = this;
          return n[e] !== t ? (i.bindFramebuffer(e, t), n[e] = t, e === i.DRAW_FRAMEBUFFER && (n[i.FRAMEBUFFER] = t), e === i.FRAMEBUFFER && (n[i.DRAW_FRAMEBUFFER] = t), true) : false;
        }
        drawBuffers(e, t) {
          const { gl: i } = this;
          let n = [], r = false;
          if (e.textures !== null) {
            n = this.currentDrawbuffers.get(t), n === void 0 && (n = [], this.currentDrawbuffers.set(t, n));
            const a = e.textures;
            if (n.length !== a.length || n[0] !== i.COLOR_ATTACHMENT0) {
              for (let l = 0, o = a.length; l < o; l++) n[l] = i.COLOR_ATTACHMENT0 + l;
              n.length = a.length, r = true;
            }
          } else n[0] !== i.BACK && (n[0] = i.BACK, r = true);
          r && i.drawBuffers(n);
        }
        activeTexture(e) {
          const { gl: t, currentTextureSlot: i, maxTextures: n } = this;
          e === void 0 && (e = t.TEXTURE0 + n - 1), i !== e && (t.activeTexture(e), this.currentTextureSlot = e);
        }
        bindTexture(e, t, i) {
          const { gl: n, currentTextureSlot: r, currentBoundTextures: a, maxTextures: l } = this;
          i === void 0 && (r === null ? i = n.TEXTURE0 + l - 1 : i = r);
          let o = a[i];
          o === void 0 && (o = {
            type: void 0,
            texture: void 0
          }, a[i] = o), (o.type !== e || o.texture !== t) && (r !== i && (n.activeTexture(i), this.currentTextureSlot = i), n.bindTexture(e, t), o.type = e, o.texture = t);
        }
        bindBufferBase(e, t, i) {
          const { gl: n } = this, r = `${e}-${t}`;
          return this.currentBoundBufferBases[r] !== i ? (n.bindBufferBase(e, t, i), this.currentBoundBufferBases[r] = i, true) : false;
        }
        unbindTexture() {
          const { gl: e, currentTextureSlot: t, currentBoundTextures: i } = this, n = i[t];
          n !== void 0 && n.type !== void 0 && (e.bindTexture(n.type, null), n.type = void 0, n.texture = void 0);
        }
      }
      class HL {
        constructor(e) {
          this.backend = e, this.gl = this.backend.gl, this.extensions = e.extensions;
        }
        convert(e, t = zr) {
          const { gl: i, extensions: n } = this;
          let r;
          if (e === In) return i.UNSIGNED_BYTE;
          if (e === oR) return i.UNSIGNED_SHORT_4_4_4_4;
          if (e === lR) return i.UNSIGNED_SHORT_5_5_5_1;
          if (e === bv) return i.UNSIGNED_INT_5_9_9_9_REV;
          if (e === Ul) return i.BYTE;
          if (e === Fl) return i.SHORT;
          if (e === La) return i.UNSIGNED_SHORT;
          if (e === Dt) return i.INT;
          if (e === Tt) return i.UNSIGNED_INT;
          if (e === Yt) return i.FLOAT;
          if (e === ks) return i.HALF_FLOAT;
          if (e === uR) return i.ALPHA;
          if (e === Ey) return i.RGB;
          if (e === Or) return i.RGBA;
          if (e === cR) return i.LUMINANCE;
          if (e === hR) return i.LUMINANCE_ALPHA;
          if (e === Nr) return i.DEPTH_COMPONENT;
          if (e === To) return i.DEPTH_STENCIL;
          if (e === Dd) return i.RED;
          if (e === Ry) return i.RED_INTEGER;
          if (e === lu) return i.RG;
          if (e === Cy) return i.RG_INTEGER;
          if (e === By) return i.RGBA_INTEGER;
          if (e === Of || e === th || e === ih || e === sh) if (t === H) if (r = n.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
            if (e === Of) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (e === th) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (e === ih) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (e === sh) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else return null;
          else if (r = n.get("WEBGL_compressed_texture_s3tc"), r !== null) {
            if (e === Of) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (e === th) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (e === ih) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (e === sh) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else return null;
          if (e === jx || e === $x || e === Xx || e === Zx) if (r = n.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
            if (e === jx) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (e === $x) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (e === Xx) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (e === Zx) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else return null;
          if (e === Qx || e === Wm || e === jm) if (r = n.get("WEBGL_compressed_texture_etc"), r !== null) {
            if (e === Qx || e === Wm) return t === H ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
            if (e === jm) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
          } else return null;
          if (e === $m || e === Xm || e === Zm || e === Qm || e === Km || e === Jm || e === eg || e === tg || e === ig || e === sg || e === ng || e === rg || e === ag || e === og) if (r = n.get("WEBGL_compressed_texture_astc"), r !== null) {
            if (e === $m) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (e === Xm) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (e === Zm) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (e === Qm) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (e === Km) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (e === Jm) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (e === eg) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (e === tg) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (e === ig) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (e === sg) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (e === ng) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (e === rg) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (e === ag) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (e === og) return t === H ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
          } else return null;
          if (e === zf) if (r = n.get("EXT_texture_compression_bptc"), r !== null) {
            if (e === zf) return t === H ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          } else return null;
          if (e === fR || e === Kx || e === Jx || e === e_) if (r = n.get("EXT_texture_compression_rgtc"), r !== null) {
            if (e === zf) return r.COMPRESSED_RED_RGTC1_EXT;
            if (e === Kx) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (e === Jx) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (e === e_) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          } else return null;
          return e === Fu ? i.UNSIGNED_INT_24_8 : i[e] !== void 0 ? i[e] : null;
        }
        _clientWaitAsync() {
          const { gl: e } = this, t = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return e.flush(), new Promise((i, n) => {
            function r() {
              const a = e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0);
              if (a === e.WAIT_FAILED) {
                e.deleteSync(t), n();
                return;
              }
              if (a === e.TIMEOUT_EXPIRED) {
                requestAnimationFrame(r);
                return;
              }
              e.deleteSync(t), i();
            }
            r();
          });
        }
      }
      let Ib = false, zc, Op, Vb;
      class qL {
        constructor(e) {
          this.backend = e, this.gl = e.gl, this.extensions = e.extensions, this.defaultTextures = {}, Ib === false && (this._init(this.gl), Ib = true);
        }
        _init(e) {
          zc = {
            [bo]: e.REPEAT,
            [Cn]: e.CLAMP_TO_EDGE,
            [So]: e.MIRRORED_REPEAT
          }, Op = {
            [gt]: e.NEAREST,
            [qm]: e.NEAREST_MIPMAP_NEAREST,
            [eo]: e.NEAREST_MIPMAP_LINEAR,
            [pi]: e.LINEAR,
            [Ym]: e.LINEAR_MIPMAP_NEAREST,
            [Ps]: e.LINEAR_MIPMAP_LINEAR
          }, Vb = {
            [Sv]: e.NEVER,
            [wv]: e.ALWAYS,
            [Dy]: e.LESS,
            [vv]: e.LEQUAL,
            [Tv]: e.EQUAL,
            [Nv]: e.GEQUAL,
            [Mv]: e.GREATER,
            [Av]: e.NOTEQUAL
          };
        }
        filterFallback(e) {
          const { gl: t } = this;
          return e === gt || e === qm || e === eo ? t.NEAREST : t.LINEAR;
        }
        getGLTextureType(e) {
          const { gl: t } = this;
          let i;
          return e.isCubeTexture === true ? i = t.TEXTURE_CUBE_MAP : e.isDataArrayTexture === true || e.isCompressedArrayTexture === true ? i = t.TEXTURE_2D_ARRAY : e.isData3DTexture === true ? i = t.TEXTURE_3D : i = t.TEXTURE_2D, i;
        }
        getInternalFormat(e, t, i, n, r = false) {
          const { gl: a, extensions: l } = this;
          if (e !== null) {
            if (a[e] !== void 0) return a[e];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'");
          }
          let o = t;
          return t === a.RED && (i === a.FLOAT && (o = a.R32F), i === a.HALF_FLOAT && (o = a.R16F), i === a.UNSIGNED_BYTE && (o = a.R8), i === a.UNSIGNED_SHORT && (o = a.R16), i === a.UNSIGNED_INT && (o = a.R32UI), i === a.BYTE && (o = a.R8I), i === a.SHORT && (o = a.R16I), i === a.INT && (o = a.R32I)), t === a.RED_INTEGER && (i === a.UNSIGNED_BYTE && (o = a.R8UI), i === a.UNSIGNED_SHORT && (o = a.R16UI), i === a.UNSIGNED_INT && (o = a.R32UI), i === a.BYTE && (o = a.R8I), i === a.SHORT && (o = a.R16I), i === a.INT && (o = a.R32I)), t === a.RG && (i === a.FLOAT && (o = a.RG32F), i === a.HALF_FLOAT && (o = a.RG16F), i === a.UNSIGNED_BYTE && (o = a.RG8), i === a.UNSIGNED_SHORT && (o = a.RG16), i === a.UNSIGNED_INT && (o = a.RG32UI), i === a.BYTE && (o = a.RG8I), i === a.SHORT && (o = a.RG16I), i === a.INT && (o = a.RG32I)), t === a.RG_INTEGER && (i === a.UNSIGNED_BYTE && (o = a.RG8UI), i === a.UNSIGNED_SHORT && (o = a.RG16UI), i === a.UNSIGNED_INT && (o = a.RG32UI), i === a.BYTE && (o = a.RG8I), i === a.SHORT && (o = a.RG16I), i === a.INT && (o = a.RG32I)), t === a.RGB && (i === a.FLOAT && (o = a.RGB32F), i === a.HALF_FLOAT && (o = a.RGB16F), i === a.UNSIGNED_BYTE && (o = a.RGB8), i === a.UNSIGNED_SHORT && (o = a.RGB16), i === a.UNSIGNED_INT && (o = a.RGB32UI), i === a.BYTE && (o = a.RGB8I), i === a.SHORT && (o = a.RGB16I), i === a.INT && (o = a.RGB32I), i === a.UNSIGNED_BYTE && (o = n === H && r === false ? a.SRGB8 : a.RGB8), i === a.UNSIGNED_SHORT_5_6_5 && (o = a.RGB565), i === a.UNSIGNED_SHORT_5_5_5_1 && (o = a.RGB5_A1), i === a.UNSIGNED_SHORT_4_4_4_4 && (o = a.RGB4), i === a.UNSIGNED_INT_5_9_9_9_REV && (o = a.RGB9_E5)), t === a.RGB_INTEGER && (i === a.UNSIGNED_BYTE && (o = a.RGB8UI), i === a.UNSIGNED_SHORT && (o = a.RGB16UI), i === a.UNSIGNED_INT && (o = a.RGB32UI), i === a.BYTE && (o = a.RGB8I), i === a.SHORT && (o = a.RGB16I), i === a.INT && (o = a.RGB32I)), t === a.RGBA && (i === a.FLOAT && (o = a.RGBA32F), i === a.HALF_FLOAT && (o = a.RGBA16F), i === a.UNSIGNED_BYTE && (o = a.RGBA8), i === a.UNSIGNED_SHORT && (o = a.RGBA16), i === a.UNSIGNED_INT && (o = a.RGBA32UI), i === a.BYTE && (o = a.RGBA8I), i === a.SHORT && (o = a.RGBA16I), i === a.INT && (o = a.RGBA32I), i === a.UNSIGNED_BYTE && (o = n === H && r === false ? a.SRGB8_ALPHA8 : a.RGBA8), i === a.UNSIGNED_SHORT_4_4_4_4 && (o = a.RGBA4), i === a.UNSIGNED_SHORT_5_5_5_1 && (o = a.RGB5_A1)), t === a.RGBA_INTEGER && (i === a.UNSIGNED_BYTE && (o = a.RGBA8UI), i === a.UNSIGNED_SHORT && (o = a.RGBA16UI), i === a.UNSIGNED_INT && (o = a.RGBA32UI), i === a.BYTE && (o = a.RGBA8I), i === a.SHORT && (o = a.RGBA16I), i === a.INT && (o = a.RGBA32I)), t === a.DEPTH_COMPONENT && (i === a.UNSIGNED_INT && (o = a.DEPTH24_STENCIL8), i === a.FLOAT && (o = a.DEPTH_COMPONENT32F)), t === a.DEPTH_STENCIL && i === a.UNSIGNED_INT_24_8 && (o = a.DEPTH24_STENCIL8), (o === a.R16F || o === a.R32F || o === a.RG16F || o === a.RG32F || o === a.RGBA16F || o === a.RGBA32F) && l.get("EXT_color_buffer_float"), o;
        }
        setTextureParameters(e, t) {
          const { gl: i, extensions: n, backend: r } = this;
          i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, t.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, t.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, i.NONE), i.texParameteri(e, i.TEXTURE_WRAP_S, zc[t.wrapS]), i.texParameteri(e, i.TEXTURE_WRAP_T, zc[t.wrapT]), (e === i.TEXTURE_3D || e === i.TEXTURE_2D_ARRAY) && i.texParameteri(e, i.TEXTURE_WRAP_R, zc[t.wrapR]), i.texParameteri(e, i.TEXTURE_MAG_FILTER, Op[t.magFilter]);
          const a = t.mipmaps !== void 0 && t.mipmaps.length > 0, l = t.minFilter === pi && a ? Ps : t.minFilter;
          if (i.texParameteri(e, i.TEXTURE_MIN_FILTER, Op[l]), t.compareFunction && (i.texParameteri(e, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(e, i.TEXTURE_COMPARE_FUNC, Vb[t.compareFunction])), n.has("EXT_texture_filter_anisotropic") === true) {
            if (t.magFilter === gt || t.minFilter !== eo && t.minFilter !== Ps || t.type === Yt && n.has("OES_texture_float_linear") === false) return;
            if (t.anisotropy > 1) {
              const o = n.get("EXT_texture_filter_anisotropic");
              i.texParameterf(e, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, r.getMaxAnisotropy()));
            }
          }
        }
        createDefaultTexture(e) {
          const { gl: t, backend: i, defaultTextures: n } = this, r = this.getGLTextureType(e);
          let a = n[r];
          a === void 0 && (a = t.createTexture(), i.state.bindTexture(r, a), t.texParameteri(r, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(r, t.TEXTURE_MAG_FILTER, t.NEAREST), n[r] = a), i.set(e, {
            textureGPU: a,
            glTextureType: r,
            isDefault: true
          });
        }
        createTexture(e, t) {
          const { gl: i, backend: n } = this, { levels: r, width: a, height: l, depth: o } = t, u = n.utils.convert(e.format, e.colorSpace), c = n.utils.convert(e.type), h = this.getInternalFormat(e.internalFormat, u, c, e.colorSpace, e.isVideoTexture), d = i.createTexture(), f = this.getGLTextureType(e);
          n.state.bindTexture(f, d), this.setTextureParameters(f, e), e.isDataArrayTexture || e.isCompressedArrayTexture ? i.texStorage3D(i.TEXTURE_2D_ARRAY, r, h, a, l, o) : e.isData3DTexture ? i.texStorage3D(i.TEXTURE_3D, r, h, a, l, o) : e.isVideoTexture || i.texStorage2D(f, r, h, a, l), n.set(e, {
            textureGPU: d,
            glTextureType: f,
            glFormat: u,
            glType: c,
            glInternalFormat: h
          });
        }
        copyBufferToTexture(e, t) {
          const { gl: i, backend: n } = this, { textureGPU: r, glTextureType: a, glFormat: l, glType: o } = n.get(t), { width: u, height: c } = t.source.data;
          i.bindBuffer(i.PIXEL_UNPACK_BUFFER, e), n.state.bindTexture(a, r), i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, false), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), i.texSubImage2D(a, 0, 0, 0, u, c, l, o, 0), i.bindBuffer(i.PIXEL_UNPACK_BUFFER, null), n.state.unbindTexture();
        }
        updateTexture(e, t) {
          const { gl: i } = this, { width: n, height: r } = t, { textureGPU: a, glTextureType: l, glFormat: o, glType: u, glInternalFormat: c } = this.backend.get(e);
          if (e.isRenderTargetTexture || a === void 0) return;
          const h = (d) => d.isDataTexture ? d.image.data : typeof HTMLImageElement < "u" && d instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && d instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && d instanceof ImageBitmap || d instanceof OffscreenCanvas ? d : d.data;
          if (this.backend.state.bindTexture(l, a), this.setTextureParameters(l, e), e.isCompressedTexture) {
            const d = e.mipmaps, f = t.image;
            for (let p = 0; p < d.length; p++) {
              const g = d[p];
              e.isCompressedArrayTexture ? e.format !== i.RGBA ? o !== null ? i.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, p, 0, 0, 0, g.width, g.height, f.depth, o, g.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texSubImage3D(i.TEXTURE_2D_ARRAY, p, 0, 0, 0, g.width, g.height, f.depth, o, u, g.data) : o !== null ? i.compressedTexSubImage2D(i.TEXTURE_2D, p, 0, 0, g.width, g.height, o, g.data) : console.warn("Unsupported compressed texture format");
            }
          } else if (e.isCubeTexture) {
            const d = t.images;
            for (let f = 0; f < 6; f++) {
              const p = h(d[f]);
              i.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, 0, 0, n, r, o, u, p);
            }
          } else if (e.isDataArrayTexture) {
            const d = t.image;
            i.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, d.width, d.height, d.depth, o, u, d.data);
          } else if (e.isData3DTexture) {
            const d = t.image;
            i.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, d.width, d.height, d.depth, o, u, d.data);
          } else if (e.isVideoTexture) e.update(), i.texImage2D(l, 0, c, o, u, t.image);
          else {
            const d = h(t.image);
            i.texSubImage2D(l, 0, 0, 0, n, r, o, u, d);
          }
        }
        generateMipmaps(e) {
          const { gl: t, backend: i } = this, { textureGPU: n, glTextureType: r } = i.get(e);
          i.state.bindTexture(r, n), t.generateMipmap(r);
        }
        deallocateRenderBuffers(e) {
          const { gl: t, backend: i } = this;
          if (e) {
            const n = i.get(e);
            if (n.renderBufferStorageSetup = void 0, n.framebuffers) {
              for (const r in n.framebuffers) t.deleteFramebuffer(n.framebuffers[r]);
              delete n.framebuffers;
            }
            if (n.depthRenderbuffer && (t.deleteRenderbuffer(n.depthRenderbuffer), delete n.depthRenderbuffer), n.stencilRenderbuffer && (t.deleteRenderbuffer(n.stencilRenderbuffer), delete n.stencilRenderbuffer), n.msaaFrameBuffer && (t.deleteFramebuffer(n.msaaFrameBuffer), delete n.msaaFrameBuffer), n.msaaRenderbuffers) {
              for (let r = 0; r < n.msaaRenderbuffers.length; r++) t.deleteRenderbuffer(n.msaaRenderbuffers[r]);
              delete n.msaaRenderbuffers;
            }
          }
        }
        destroyTexture(e) {
          const { gl: t, backend: i } = this, { textureGPU: n, renderTarget: r } = i.get(e);
          this.deallocateRenderBuffers(r), t.deleteTexture(n), i.delete(e);
        }
        copyTextureToTexture(e, t, i = null, n = null, r = 0) {
          const { gl: a, backend: l } = this, { state: o } = this.backend, { textureGPU: u, glTextureType: c, glType: h, glFormat: d } = l.get(t);
          let f, p, g, _, m, y;
          i !== null ? (f = i.max.x - i.min.x, p = i.max.y - i.min.y, g = i.min.x, _ = i.min.y) : (f = e.image.width, p = e.image.height, g = 0, _ = 0), n !== null ? (m = n.x, y = n.y) : (m = 0, y = 0), o.bindTexture(c, u), a.pixelStorei(a.UNPACK_ALIGNMENT, t.unpackAlignment), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, t.flipY), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), a.pixelStorei(a.UNPACK_ALIGNMENT, t.unpackAlignment);
          const x = a.getParameter(a.UNPACK_ROW_LENGTH), b = a.getParameter(a.UNPACK_IMAGE_HEIGHT), T = a.getParameter(a.UNPACK_SKIP_PIXELS), N = a.getParameter(a.UNPACK_SKIP_ROWS), A = a.getParameter(a.UNPACK_SKIP_IMAGES), w = e.isCompressedTexture ? e.mipmaps[r] : e.image;
          if (a.pixelStorei(a.UNPACK_ROW_LENGTH, w.width), a.pixelStorei(a.UNPACK_IMAGE_HEIGHT, w.height), a.pixelStorei(a.UNPACK_SKIP_PIXELS, g), a.pixelStorei(a.UNPACK_SKIP_ROWS, _), e.isRenderTargetTexture || e.isDepthTexture) {
            const k = l.get(e), G = l.get(t), I = l.get(k.renderTarget), be = l.get(G.renderTarget), ce = I.framebuffers[k.cacheKey], Fe = be.framebuffers[G.cacheKey];
            o.bindFramebuffer(a.READ_FRAMEBUFFER, ce), o.bindFramebuffer(a.DRAW_FRAMEBUFFER, Fe);
            let qe = a.COLOR_BUFFER_BIT;
            e.isDepthTexture && (qe = a.DEPTH_BUFFER_BIT), a.blitFramebuffer(g, _, f, p, m, y, f, p, qe, a.NEAREST), o.bindFramebuffer(a.READ_FRAMEBUFFER, null), o.bindFramebuffer(a.DRAW_FRAMEBUFFER, null);
          } else e.isDataTexture ? a.texSubImage2D(a.TEXTURE_2D, r, m, y, f, p, d, h, w.data) : e.isCompressedTexture ? a.compressedTexSubImage2D(a.TEXTURE_2D, r, m, y, w.width, w.height, d, w.data) : a.texSubImage2D(a.TEXTURE_2D, r, m, y, f, p, d, h, w);
          a.pixelStorei(a.UNPACK_ROW_LENGTH, x), a.pixelStorei(a.UNPACK_IMAGE_HEIGHT, b), a.pixelStorei(a.UNPACK_SKIP_PIXELS, T), a.pixelStorei(a.UNPACK_SKIP_ROWS, N), a.pixelStorei(a.UNPACK_SKIP_IMAGES, A), r === 0 && t.generateMipmaps && a.generateMipmap(a.TEXTURE_2D), o.unbindTexture();
        }
        copyFramebufferToTexture(e, t, i) {
          const { gl: n } = this, { state: r } = this.backend, { textureGPU: a } = this.backend.get(e), { x: l, y: o, z: u, w: c } = i, h = e.isDepthTexture === true || t.renderTarget && t.renderTarget.samples > 0, d = t.renderTarget ? t.renderTarget.height : this.backend.getDrawingBufferSize().y;
          if (h) {
            const f = l !== 0 || o !== 0;
            let p, g;
            if (e.isDepthTexture === true ? (p = n.DEPTH_BUFFER_BIT, g = n.DEPTH_ATTACHMENT, t.stencil && (p |= n.STENCIL_BUFFER_BIT)) : (p = n.COLOR_BUFFER_BIT, g = n.COLOR_ATTACHMENT0), f) {
              const _ = this.backend.get(t.renderTarget), m = _.framebuffers[t.getCacheKey()], y = _.msaaFrameBuffer;
              r.bindFramebuffer(n.DRAW_FRAMEBUFFER, m), r.bindFramebuffer(n.READ_FRAMEBUFFER, y);
              const x = d - o - c;
              n.blitFramebuffer(l, x, l + u, x + c, l, x, l + u, x + c, p, n.NEAREST), r.bindFramebuffer(n.READ_FRAMEBUFFER, m), r.bindTexture(n.TEXTURE_2D, a), n.copyTexSubImage2D(n.TEXTURE_2D, 0, 0, 0, l, x, u, c), r.unbindTexture();
            } else {
              const _ = n.createFramebuffer();
              r.bindFramebuffer(n.DRAW_FRAMEBUFFER, _), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, g, n.TEXTURE_2D, a, 0), n.blitFramebuffer(0, 0, u, c, 0, 0, u, c, p, n.NEAREST), n.deleteFramebuffer(_);
            }
          } else r.bindTexture(n.TEXTURE_2D, a), n.copyTexSubImage2D(n.TEXTURE_2D, 0, 0, 0, l, d - c - o, u, c), r.unbindTexture();
          e.generateMipmaps && this.generateMipmaps(e), this.backend._setFramebuffer(t);
        }
        setupRenderBufferStorage(e, t) {
          const { gl: i } = this, n = t.renderTarget, { samples: r, depthTexture: a, depthBuffer: l, stencilBuffer: o, width: u, height: c } = n;
          if (i.bindRenderbuffer(i.RENDERBUFFER, e), l && !o) {
            let h = i.DEPTH_COMPONENT24;
            r > 0 ? (a && a.isDepthTexture && a.type === i.FLOAT && (h = i.DEPTH_COMPONENT32F), i.renderbufferStorageMultisample(i.RENDERBUFFER, r, h, u, c)) : i.renderbufferStorage(i.RENDERBUFFER, h, u, c), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e);
          } else l && o && (r > 0 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, r, i.DEPTH24_STENCIL8, u, c) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, u, c), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e));
        }
        async copyTextureToBuffer(e, t, i, n, r, a) {
          const { backend: l, gl: o } = this, { textureGPU: u, glFormat: c, glType: h } = this.backend.get(e), d = o.createFramebuffer();
          o.bindFramebuffer(o.READ_FRAMEBUFFER, d);
          const f = e.isCubeTexture ? o.TEXTURE_CUBE_MAP_POSITIVE_X + a : o.TEXTURE_2D;
          o.framebufferTexture2D(o.READ_FRAMEBUFFER, o.COLOR_ATTACHMENT0, f, u, 0);
          const p = this._getTypedArrayType(h), g = this._getBytesPerTexel(h, c), m = n * r * g, y = o.createBuffer();
          o.bindBuffer(o.PIXEL_PACK_BUFFER, y), o.bufferData(o.PIXEL_PACK_BUFFER, m, o.STREAM_READ), o.readPixels(t, i, n, r, c, h, 0), o.bindBuffer(o.PIXEL_PACK_BUFFER, null), await l.utils._clientWaitAsync();
          const x = new p(m / p.BYTES_PER_ELEMENT);
          return o.bindBuffer(o.PIXEL_PACK_BUFFER, y), o.getBufferSubData(o.PIXEL_PACK_BUFFER, 0, x), o.bindBuffer(o.PIXEL_PACK_BUFFER, null), o.deleteFramebuffer(d), x;
        }
        _getTypedArrayType(e) {
          const { gl: t } = this;
          if (e === t.UNSIGNED_BYTE) return Uint8Array;
          if (e === t.UNSIGNED_SHORT_4_4_4_4 || e === t.UNSIGNED_SHORT_5_5_5_1 || e === t.UNSIGNED_SHORT_5_6_5 || e === t.UNSIGNED_SHORT) return Uint16Array;
          if (e === t.UNSIGNED_INT) return Uint32Array;
          if (e === t.HALF_FLOAT) return Uint16Array;
          if (e === t.FLOAT) return Float32Array;
          throw new Error(`Unsupported WebGL type: ${e}`);
        }
        _getBytesPerTexel(e, t) {
          const { gl: i } = this;
          let n = 0;
          if (e === i.UNSIGNED_BYTE && (n = 1), (e === i.UNSIGNED_SHORT_4_4_4_4 || e === i.UNSIGNED_SHORT_5_5_5_1 || e === i.UNSIGNED_SHORT_5_6_5 || e === i.UNSIGNED_SHORT || e === i.HALF_FLOAT) && (n = 2), (e === i.UNSIGNED_INT || e === i.FLOAT) && (n = 4), t === i.RGBA) return n * 4;
          if (t === i.RGB) return n * 3;
          if (t === i.ALPHA) return n;
        }
      }
      class YL {
        constructor(e) {
          this.backend = e, this.gl = this.backend.gl, this.availableExtensions = this.gl.getSupportedExtensions(), this.extensions = {};
        }
        get(e) {
          let t = this.extensions[e];
          return t === void 0 && (t = this.gl.getExtension(e), this.extensions[e] = t), t;
        }
        has(e) {
          return this.availableExtensions.includes(e);
        }
      }
      class WL {
        constructor(e) {
          this.backend = e, this.maxAnisotropy = null;
        }
        getMaxAnisotropy() {
          if (this.maxAnisotropy !== null) return this.maxAnisotropy;
          const e = this.backend.gl, t = this.backend.extensions;
          if (t.has("EXT_texture_filter_anisotropic") === true) {
            const i = t.get("EXT_texture_filter_anisotropic");
            this.maxAnisotropy = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else this.maxAnisotropy = 0;
          return this.maxAnisotropy;
        }
      }
      const Hb = {
        WEBGL_multi_draw: "WEBGL_multi_draw",
        WEBGL_compressed_texture_astc: "texture-compression-astc",
        WEBGL_compressed_texture_etc: "texture-compression-etc2",
        WEBGL_compressed_texture_etc1: "texture-compression-etc1",
        WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
        WEBKIT_WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
        WEBGL_compressed_texture_s3tc: "texture-compression-bc",
        EXT_texture_compression_bptc: "texture-compression-bptc",
        EXT_disjoint_timer_query_webgl2: "timestamp-query"
      };
      class jL {
        constructor(e) {
          this.gl = e.gl, this.extensions = e.extensions, this.info = e.renderer.info, this.mode = null, this.index = 0, this.type = null, this.object = null;
        }
        render(e, t) {
          const { gl: i, mode: n, object: r, type: a, info: l, index: o } = this;
          o !== 0 ? i.drawElements(n, t, a, e) : i.drawArrays(n, e, t), l.update(r, t, n, 1);
        }
        renderInstances(e, t, i) {
          const { gl: n, mode: r, type: a, index: l, object: o, info: u } = this;
          i !== 0 && (l !== 0 ? n.drawElementsInstanced(r, t, a, e, i) : n.drawArraysInstanced(r, e, t, i), u.update(o, t, r, i));
        }
        renderMultiDraw(e, t, i) {
          const { extensions: n, mode: r, object: a, info: l } = this;
          if (i === 0) return;
          const o = n.get("WEBGL_multi_draw");
          if (o === null) for (let u = 0; u < i; u++) this.render(e[u], t[u]);
          else {
            this.index !== 0 ? o.multiDrawElementsWEBGL(r, t, 0, this.type, e, 0, i) : o.multiDrawArraysWEBGL(r, e, 0, t, 0, i);
            let u = 0;
            for (let c = 0; c < i; c++) u += t[c];
            l.update(a, u, r, 1);
          }
        }
        renderMultiDrawInstances(e, t, i, n) {
          const { extensions: r, mode: a, object: l, info: o } = this;
          if (i === 0) return;
          const u = r.get("WEBGL_multi_draw");
          if (u === null) for (let c = 0; c < i; c++) this.renderInstances(e[c], t[c], n[c]);
          else {
            this.index !== 0 ? u.multiDrawElementsInstancedWEBGL(a, t, 0, this.type, e, 0, n, 0, i) : u.multiDrawArraysInstancedWEBGL(a, e, 0, t, 0, n, 0, i);
            let c = 0;
            for (let h = 0; h < i; h++) c += t[h] * n[h];
            o.update(l, c, a, 1);
          }
        }
      }
      class qb extends AA {
        constructor(e = {}) {
          super(e), this.isWebGLBackend = true, this.attributeUtils = null, this.extensions = null, this.capabilities = null, this.textureUtils = null, this.bufferRenderer = null, this.gl = null, this.state = null, this.utils = null, this.vaoCache = {}, this.transformFeedbackCache = {}, this.discard = false, this.disjoint = null, this.parallel = null, this.trackTimestamp = e.trackTimestamp === true, this._currentContext = null, this._knownBindings = /* @__PURE__ */ new WeakSet();
        }
        init(e) {
          super.init(e);
          const t = this.parameters, i = t.context !== void 0 ? t.context : e.domElement.getContext("webgl2");
          function n(r) {
            r.preventDefault();
            const a = {
              api: "WebGL",
              message: r.statusMessage || "Unknown reason",
              reason: null,
              originalEvent: r
            };
            e.onDeviceLost(a);
          }
          this._onContextLost = n, e.domElement.addEventListener("webglcontextlost", n, false), this.gl = i, this.extensions = new YL(this), this.capabilities = new WL(this), this.attributeUtils = new IL(this), this.textureUtils = new qL(this), this.bufferRenderer = new jL(this), this.state = new VL(this), this.utils = new HL(this), this.extensions.get("EXT_color_buffer_float"), this.extensions.get("WEBGL_clip_cull_distance"), this.extensions.get("OES_texture_float_linear"), this.extensions.get("EXT_color_buffer_half_float"), this.extensions.get("WEBGL_multisampled_render_to_texture"), this.extensions.get("WEBGL_render_shared_exponent"), this.extensions.get("WEBGL_multi_draw"), this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2"), this.parallel = this.extensions.get("KHR_parallel_shader_compile");
        }
        get coordinateSystem() {
          return li;
        }
        async getArrayBufferAsync(e) {
          return await this.attributeUtils.getArrayBufferAsync(e);
        }
        async waitForGPU() {
          await this.utils._clientWaitAsync();
        }
        initTimestampQuery(e) {
          if (!this.disjoint || !this.trackTimestamp) return;
          const t = this.get(e);
          if (this.queryRunning) {
            t.queryQueue || (t.queryQueue = []), t.queryQueue.push(e);
            return;
          }
          t.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), t.activeQuery = null), t.activeQuery = this.gl.createQuery(), t.activeQuery !== null && (this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, t.activeQuery), this.queryRunning = true);
        }
        prepareTimestampBuffer(e) {
          if (!this.disjoint || !this.trackTimestamp) return;
          const t = this.get(e);
          if (t.activeQuery && (this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT), t.gpuQueries || (t.gpuQueries = []), t.gpuQueries.push({
            query: t.activeQuery
          }), t.activeQuery = null, this.queryRunning = false, t.queryQueue && t.queryQueue.length > 0)) {
            const i = t.queryQueue.shift();
            this.initTimestampQuery(i);
          }
        }
        async resolveTimestampAsync(e, t = "render") {
          if (!this.disjoint || !this.trackTimestamp) return;
          const i = this.get(e);
          i.gpuQueries || (i.gpuQueries = []);
          for (let n = 0; n < i.gpuQueries.length; n++) {
            const r = i.gpuQueries[n], a = this.gl.getQueryParameter(r.query, this.gl.QUERY_RESULT_AVAILABLE), l = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);
            if (a && !l) {
              const o = this.gl.getQueryParameter(r.query, this.gl.QUERY_RESULT), u = Number(o) / 1e6;
              this.gl.deleteQuery(r.query), i.gpuQueries.splice(n, 1), n--, this.renderer.info.updateTimestamp(t, u);
            }
          }
        }
        getContext() {
          return this.gl;
        }
        beginRender(e) {
          const { gl: t } = this, i = this.get(e);
          if (this.initTimestampQuery(e), i.previousContext = this._currentContext, this._currentContext = e, this._setFramebuffer(e), this.clear(e.clearColor, e.clearDepth, e.clearStencil, e, false), e.viewport ? this.updateViewport(e) : t.viewport(0, 0, t.drawingBufferWidth, t.drawingBufferHeight), e.scissor) {
            const { x: r, y: a, width: l, height: o } = e.scissorValue;
            t.scissor(r, e.height - o - a, l, o);
          }
          const n = e.occlusionQueryCount;
          n > 0 && (i.currentOcclusionQueries = i.occlusionQueries, i.currentOcclusionQueryObjects = i.occlusionQueryObjects, i.lastOcclusionObject = null, i.occlusionQueries = new Array(n), i.occlusionQueryObjects = new Array(n), i.occlusionQueryIndex = 0);
        }
        finishRender(e) {
          const { gl: t, state: i } = this, n = this.get(e), r = n.previousContext, a = e.occlusionQueryCount;
          a > 0 && (a > n.occlusionQueryIndex && t.endQuery(t.ANY_SAMPLES_PASSED), this.resolveOccludedAsync(e));
          const l = e.textures;
          if (l !== null) for (let o = 0; o < l.length; o++) {
            const u = l[o];
            u.generateMipmaps && this.generateMipmaps(u);
          }
          if (this._currentContext = r, e.textures !== null && e.renderTarget) {
            const o = this.get(e.renderTarget), { samples: u } = e.renderTarget;
            if (u > 0) {
              const c = o.framebuffers[e.getCacheKey()], h = t.COLOR_BUFFER_BIT, d = o.msaaFrameBuffer, f = e.textures;
              i.bindFramebuffer(t.READ_FRAMEBUFFER, d), i.bindFramebuffer(t.DRAW_FRAMEBUFFER, c);
              for (let p = 0; p < f.length; p++) if (e.scissor) {
                const { x: g, y: _, width: m, height: y } = e.scissorValue, x = e.height - y - _;
                t.blitFramebuffer(g, x, g + m, x + y, g, x, g + m, x + y, h, t.NEAREST), t.invalidateSubFramebuffer(t.READ_FRAMEBUFFER, o.invalidationArray, g, x, m, y);
              } else t.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, h, t.NEAREST), t.invalidateFramebuffer(t.READ_FRAMEBUFFER, o.invalidationArray);
            }
          }
          r !== null && (this._setFramebuffer(r), r.viewport ? this.updateViewport(r) : t.viewport(0, 0, t.drawingBufferWidth, t.drawingBufferHeight)), this.prepareTimestampBuffer(e);
        }
        resolveOccludedAsync(e) {
          const t = this.get(e), { currentOcclusionQueries: i, currentOcclusionQueryObjects: n } = t;
          if (i && n) {
            const r = /* @__PURE__ */ new WeakSet(), { gl: a } = this;
            t.currentOcclusionQueryObjects = null, t.currentOcclusionQueries = null;
            const l = () => {
              let o = 0;
              for (let u = 0; u < i.length; u++) {
                const c = i[u];
                c !== null && a.getQueryParameter(c, a.QUERY_RESULT_AVAILABLE) && (a.getQueryParameter(c, a.QUERY_RESULT) > 0 && r.add(n[u]), i[u] = null, a.deleteQuery(c), o++);
              }
              o < i.length ? requestAnimationFrame(l) : t.occluded = r;
            };
            l();
          }
        }
        isOccluded(e, t) {
          const i = this.get(e);
          return i.occluded && i.occluded.has(t);
        }
        updateViewport(e) {
          const t = this.gl, { x: i, y: n, width: r, height: a } = e.viewportValue;
          t.viewport(i, e.height - a - n, r, a);
        }
        setScissorTest(e) {
          const t = this.gl;
          e ? t.enable(t.SCISSOR_TEST) : t.disable(t.SCISSOR_TEST);
        }
        clear(e, t, i, n = null, r = true) {
          const { gl: a } = this;
          if (n === null) {
            const o = this.getClearColor();
            o.r *= o.a, o.g *= o.a, o.b *= o.a, n = {
              textures: null,
              clearColorValue: o
            };
          }
          let l = 0;
          if (e && (l |= a.COLOR_BUFFER_BIT), t && (l |= a.DEPTH_BUFFER_BIT), i && (l |= a.STENCIL_BUFFER_BIT), l !== 0) {
            let o;
            if (n.clearColorValue ? o = n.clearColorValue : (o = this.getClearColor(), o.r *= o.a, o.g *= o.a, o.b *= o.a), t && this.state.setDepthMask(true), n.textures === null) a.clearColor(o.r, o.g, o.b, o.a), a.clear(l);
            else {
              if (r && this._setFramebuffer(n), e) for (let u = 0; u < n.textures.length; u++) a.clearBufferfv(a.COLOR, u, [
                o.r,
                o.g,
                o.b,
                o.a
              ]);
              t && i ? a.clearBufferfi(a.DEPTH_STENCIL, 0, 1, 0) : t ? a.clearBufferfv(a.DEPTH, 0, [
                1
              ]) : i && a.clearBufferiv(a.STENCIL, 0, [
                0
              ]);
            }
          }
        }
        beginCompute(e) {
          const { state: t, gl: i } = this;
          t.bindFramebuffer(i.FRAMEBUFFER, null), this.initTimestampQuery(e);
        }
        compute(e, t, i, n) {
          const { state: r, gl: a } = this;
          this.discard === false && (a.enable(a.RASTERIZER_DISCARD), this.discard = true);
          const { programGPU: l, transformBuffers: o, attributes: u } = this.get(n), c = this._getVaoKey(null, u), h = this.vaoCache[c];
          h === void 0 ? this._createVao(null, u) : a.bindVertexArray(h), r.useProgram(l), this._bindUniforms(i);
          const d = this._getTransformFeedback(o);
          a.bindTransformFeedback(a.TRANSFORM_FEEDBACK, d), a.beginTransformFeedback(a.POINTS), u[0].isStorageInstancedBufferAttribute ? a.drawArraysInstanced(a.POINTS, 0, 1, t.count) : a.drawArrays(a.POINTS, 0, t.count), a.endTransformFeedback(), a.bindTransformFeedback(a.TRANSFORM_FEEDBACK, null);
          for (let f = 0; f < o.length; f++) {
            const p = o[f];
            p.pbo && this.textureUtils.copyBufferToTexture(p.transformBuffer, p.pbo), p.switchBuffers();
          }
        }
        finishCompute(e) {
          const t = this.gl;
          this.discard = false, t.disable(t.RASTERIZER_DISCARD), this.prepareTimestampBuffer(e), this._currentContext && this._setFramebuffer(this._currentContext);
        }
        draw(e) {
          const { object: t, pipeline: i, material: n, context: r, hardwareClippingPlanes: a } = e, { programGPU: l } = this.get(i), { gl: o, state: u } = this, c = this.get(r), h = e.getDrawParameters();
          if (h === null) return;
          this._bindUniforms(e.getBindings());
          const d = t.isMesh && t.matrixWorld.determinant() < 0;
          u.setMaterial(n, d, a), u.useProgram(l);
          const f = this.get(e);
          let p = f.staticVao;
          if (p === void 0 || f.geometryId !== e.geometry.id) {
            const T = this._getVaoKey(e.getIndex(), e.getAttributes());
            if (p = this.vaoCache[T], p === void 0) {
              let N;
              ({ vaoGPU: p, staticVao: N } = this._createVao(e.getIndex(), e.getAttributes())), N && (f.staticVao = p, f.geometryId = e.geometry.id);
            }
          }
          o.bindVertexArray(p);
          const g = e.getIndex(), _ = c.lastOcclusionObject;
          if (_ !== t && _ !== void 0) {
            if (_ !== null && _.occlusionTest === true && (o.endQuery(o.ANY_SAMPLES_PASSED), c.occlusionQueryIndex++), t.occlusionTest === true) {
              const T = o.createQuery();
              o.beginQuery(o.ANY_SAMPLES_PASSED, T), c.occlusionQueries[c.occlusionQueryIndex] = T, c.occlusionQueryObjects[c.occlusionQueryIndex] = t;
            }
            c.lastOcclusionObject = t;
          }
          const m = this.bufferRenderer;
          t.isPoints ? m.mode = o.POINTS : t.isLineSegments ? m.mode = o.LINES : t.isLine ? m.mode = o.LINE_STRIP : t.isLineLoop ? m.mode = o.LINE_LOOP : n.wireframe === true ? (u.setLineWidth(n.wireframeLinewidth * this.renderer.getPixelRatio()), m.mode = o.LINES) : m.mode = o.TRIANGLES;
          const { vertexCount: y, instanceCount: x } = h;
          let { firstVertex: b } = h;
          if (m.object = t, g !== null) {
            b *= g.array.BYTES_PER_ELEMENT;
            const T = this.get(g);
            m.index = g.count, m.type = T.type;
          } else m.index = 0;
          t.isBatchedMesh ? t._multiDrawInstances !== null ? m.renderMultiDrawInstances(t._multiDrawStarts, t._multiDrawCounts, t._multiDrawCount, t._multiDrawInstances) : this.hasFeature("WEBGL_multi_draw") ? m.renderMultiDraw(t._multiDrawStarts, t._multiDrawCounts, t._multiDrawCount) : jR("THREE.WebGLRenderer: WEBGL_multi_draw not supported.") : x > 1 ? m.renderInstances(b, y, x) : m.render(b, y), o.bindVertexArray(null);
        }
        needsRenderUpdate() {
          return false;
        }
        getRenderCacheKey() {
          return "";
        }
        createDefaultTexture(e) {
          this.textureUtils.createDefaultTexture(e);
        }
        createTexture(e, t) {
          this.textureUtils.createTexture(e, t);
        }
        updateTexture(e, t) {
          this.textureUtils.updateTexture(e, t);
        }
        generateMipmaps(e) {
          this.textureUtils.generateMipmaps(e);
        }
        destroyTexture(e) {
          this.textureUtils.destroyTexture(e);
        }
        copyTextureToBuffer(e, t, i, n, r, a) {
          return this.textureUtils.copyTextureToBuffer(e, t, i, n, r, a);
        }
        createSampler() {
        }
        destroySampler() {
        }
        createNodeBuilder(e, t) {
          return new GL(e, t);
        }
        createProgram(e) {
          const t = this.gl, { stage: i, code: n } = e, r = i === "fragment" ? t.createShader(t.FRAGMENT_SHADER) : t.createShader(t.VERTEX_SHADER);
          t.shaderSource(r, n), t.compileShader(r), this.set(e, {
            shaderGPU: r
          });
        }
        destroyProgram(e) {
          this.delete(e);
        }
        createRenderPipeline(e, t) {
          const i = this.gl, n = e.pipeline, { fragmentProgram: r, vertexProgram: a } = n, l = i.createProgram(), o = this.get(r).shaderGPU, u = this.get(a).shaderGPU;
          if (i.attachShader(l, o), i.attachShader(l, u), i.linkProgram(l), this.set(n, {
            programGPU: l,
            fragmentShader: o,
            vertexShader: u
          }), t !== null && this.parallel) {
            const c = new Promise((h) => {
              const d = this.parallel, f = () => {
                i.getProgramParameter(l, d.COMPLETION_STATUS_KHR) ? (this._completeCompile(e, n), h()) : requestAnimationFrame(f);
              };
              f();
            });
            t.push(c);
            return;
          }
          this._completeCompile(e, n);
        }
        _handleSource(e, t) {
          const i = e.split(`
`), n = [], r = Math.max(t - 6, 0), a = Math.min(t + 6, i.length);
          for (let l = r; l < a; l++) {
            const o = l + 1;
            n.push(`${o === t ? ">" : " "} ${o}: ${i[l]}`);
          }
          return n.join(`
`);
        }
        _getShaderErrors(e, t, i) {
          const n = e.getShaderParameter(t, e.COMPILE_STATUS), r = e.getShaderInfoLog(t).trim();
          if (n && r === "") return "";
          const a = /ERROR: 0:(\d+)/.exec(r);
          if (a) {
            const l = parseInt(a[1]);
            return i.toUpperCase() + `

` + r + `

` + this._handleSource(e.getShaderSource(t), l);
          } else return r;
        }
        _logProgramError(e, t, i) {
          if (this.renderer.debug.checkShaderErrors) {
            const n = this.gl, r = n.getProgramInfoLog(e).trim();
            if (n.getProgramParameter(e, n.LINK_STATUS) === false) if (typeof this.renderer.debug.onShaderError == "function") this.renderer.debug.onShaderError(n, e, i, t);
            else {
              const a = this._getShaderErrors(n, i, "vertex"), l = this._getShaderErrors(n, t, "fragment");
              console.error("THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(e, n.VALIDATE_STATUS) + `

Program Info Log: ` + r + `
` + a + `
` + l);
            }
            else r !== "" && console.warn("THREE.WebGLProgram: Program Info Log:", r);
          }
        }
        _completeCompile(e, t) {
          const { state: i, gl: n } = this, r = this.get(t), { programGPU: a, fragmentShader: l, vertexShader: o } = r;
          n.getProgramParameter(a, n.LINK_STATUS) === false && this._logProgramError(a, l, o), i.useProgram(a);
          const u = e.getBindings();
          this._setupBindings(u, a), this.set(t, {
            programGPU: a
          });
        }
        createComputePipeline(e, t) {
          const { state: i, gl: n } = this, r = {
            stage: "fragment",
            code: `#version 300 es
precision highp float;
void main() {}`
          };
          this.createProgram(r);
          const { computeProgram: a } = e, l = n.createProgram(), o = this.get(r).shaderGPU, u = this.get(a).shaderGPU, c = a.transforms, h = [], d = [];
          for (let _ = 0; _ < c.length; _++) {
            const m = c[_];
            h.push(m.varyingName), d.push(m.attributeNode);
          }
          n.attachShader(l, o), n.attachShader(l, u), n.transformFeedbackVaryings(l, h, n.SEPARATE_ATTRIBS), n.linkProgram(l), n.getProgramParameter(l, n.LINK_STATUS) === false && this._logProgramError(l, o, u), i.useProgram(l), this._setupBindings(t, l);
          const f = a.attributes, p = [], g = [];
          for (let _ = 0; _ < f.length; _++) {
            const m = f[_].node.attribute;
            p.push(m), this.has(m) || this.attributeUtils.createAttribute(m, n.ARRAY_BUFFER);
          }
          for (let _ = 0; _ < d.length; _++) {
            const m = d[_].attribute;
            this.has(m) || this.attributeUtils.createAttribute(m, n.ARRAY_BUFFER);
            const y = this.get(m);
            g.push(y);
          }
          this.set(e, {
            programGPU: l,
            transformBuffers: g,
            attributes: p
          });
        }
        createBindings(e, t) {
          if (this._knownBindings.has(t) === false) {
            this._knownBindings.add(t);
            let i = 0, n = 0;
            for (const r of t) {
              this.set(r, {
                textures: n,
                uniformBuffers: i
              });
              for (const a of r.bindings) a.isUniformBuffer && i++, a.isSampledTexture && n++;
            }
          }
          this.updateBindings(e, t);
        }
        updateBindings(e) {
          const { gl: t } = this, i = this.get(e);
          let n = i.uniformBuffers, r = i.textures;
          for (const a of e.bindings) if (a.isUniformsGroup || a.isUniformBuffer) {
            const l = a.buffer, o = t.createBuffer();
            t.bindBuffer(t.UNIFORM_BUFFER, o), t.bufferData(t.UNIFORM_BUFFER, l, t.DYNAMIC_DRAW), this.set(a, {
              index: n++,
              bufferGPU: o
            });
          } else if (a.isSampledTexture) {
            const { textureGPU: l, glTextureType: o } = this.get(a.texture);
            this.set(a, {
              index: r++,
              textureGPU: l,
              glTextureType: o
            });
          }
        }
        updateBinding(e) {
          const t = this.gl;
          if (e.isUniformsGroup || e.isUniformBuffer) {
            const n = this.get(e).bufferGPU, r = e.buffer;
            t.bindBuffer(t.UNIFORM_BUFFER, n), t.bufferData(t.UNIFORM_BUFFER, r, t.DYNAMIC_DRAW);
          }
        }
        createIndexAttribute(e) {
          const t = this.gl;
          this.attributeUtils.createAttribute(e, t.ELEMENT_ARRAY_BUFFER);
        }
        createAttribute(e) {
          if (this.has(e)) return;
          const t = this.gl;
          this.attributeUtils.createAttribute(e, t.ARRAY_BUFFER);
        }
        createStorageAttribute(e) {
          if (this.has(e)) return;
          const t = this.gl;
          this.attributeUtils.createAttribute(e, t.ARRAY_BUFFER);
        }
        updateAttribute(e) {
          this.attributeUtils.updateAttribute(e);
        }
        destroyAttribute(e) {
          this.attributeUtils.destroyAttribute(e);
        }
        hasFeature(e) {
          const t = Object.keys(Hb).filter((n) => Hb[n] === e), i = this.extensions;
          for (let n = 0; n < t.length; n++) if (i.has(t[n])) return true;
          return false;
        }
        getMaxAnisotropy() {
          return this.capabilities.getMaxAnisotropy();
        }
        copyTextureToTexture(e, t, i = null, n = null, r = 0) {
          this.textureUtils.copyTextureToTexture(e, t, i, n, r);
        }
        copyFramebufferToTexture(e, t, i) {
          this.textureUtils.copyFramebufferToTexture(e, t, i);
        }
        _setFramebuffer(e) {
          const { gl: t, state: i } = this;
          let n = null;
          if (e.textures !== null) {
            const r = e.renderTarget, a = this.get(r), { samples: l, depthBuffer: o, stencilBuffer: u } = r, c = r.isWebGLCubeRenderTarget === true, h = r.isRenderTarget3D === true, d = r.isRenderTargetArray === true;
            let f = a.msaaFrameBuffer, p = a.depthRenderbuffer;
            const g = nA(e);
            let _;
            if (c ? (a.cubeFramebuffers || (a.cubeFramebuffers = {}), _ = a.cubeFramebuffers[g]) : (a.framebuffers || (a.framebuffers = {}), _ = a.framebuffers[g]), _ === void 0) {
              _ = t.createFramebuffer(), i.bindFramebuffer(t.FRAMEBUFFER, _);
              const m = e.textures;
              if (c) {
                a.cubeFramebuffers[g] = _;
                const { textureGPU: y } = this.get(m[0]), x = this.renderer._activeCubeFace;
                t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + x, y, 0);
              } else {
                a.framebuffers[g] = _;
                for (let y = 0; y < m.length; y++) {
                  const x = m[y], b = this.get(x);
                  b.renderTarget = e.renderTarget, b.cacheKey = g;
                  const T = t.COLOR_ATTACHMENT0 + y;
                  if (h || d) {
                    const N = this.renderer._activeCubeFace;
                    t.framebufferTextureLayer(t.FRAMEBUFFER, T, b.textureGPU, 0, N);
                  } else t.framebufferTexture2D(t.FRAMEBUFFER, T, t.TEXTURE_2D, b.textureGPU, 0);
                }
                i.drawBuffers(e, _);
              }
              if (e.depthTexture !== null) {
                const y = this.get(e.depthTexture), x = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                y.renderTarget = e.renderTarget, y.cacheKey = g, t.framebufferTexture2D(t.FRAMEBUFFER, x, t.TEXTURE_2D, y.textureGPU, 0);
              }
            }
            if (l > 0) {
              if (f === void 0) {
                const m = [];
                f = t.createFramebuffer(), i.bindFramebuffer(t.FRAMEBUFFER, f);
                const y = [], x = e.textures;
                for (let b = 0; b < x.length; b++) {
                  if (y[b] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, y[b]), m.push(t.COLOR_ATTACHMENT0 + b), o) {
                    const A = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                    m.push(A);
                  }
                  const T = e.textures[b], N = this.get(T);
                  t.renderbufferStorageMultisample(t.RENDERBUFFER, l, N.glInternalFormat, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + b, t.RENDERBUFFER, y[b]);
                }
                if (a.msaaFrameBuffer = f, a.msaaRenderbuffers = y, p === void 0) {
                  p = t.createRenderbuffer(), this.textureUtils.setupRenderBufferStorage(p, e), a.depthRenderbuffer = p;
                  const b = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
                  m.push(b);
                }
                a.invalidationArray = m;
              }
              n = a.msaaFrameBuffer;
            } else n = _;
          }
          i.bindFramebuffer(t.FRAMEBUFFER, n);
        }
        _getVaoKey(e, t) {
          let i = "";
          if (e !== null) {
            const n = this.get(e);
            i += ":" + n.id;
          }
          for (let n = 0; n < t.length; n++) {
            const r = this.get(t[n]);
            i += ":" + r.id;
          }
          return i;
        }
        _createVao(e, t) {
          const { gl: i } = this, n = i.createVertexArray();
          let r = "", a = true;
          if (i.bindVertexArray(n), e !== null) {
            const l = this.get(e);
            i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, l.bufferGPU), r += ":" + l.id;
          }
          for (let l = 0; l < t.length; l++) {
            const o = t[l], u = this.get(o);
            r += ":" + u.id, i.bindBuffer(i.ARRAY_BUFFER, u.bufferGPU), i.enableVertexAttribArray(l), (o.isStorageBufferAttribute || o.isStorageInstancedBufferAttribute) && (a = false);
            let c, h;
            o.isInterleavedBufferAttribute === true ? (c = o.data.stride * u.bytesPerElement, h = o.offset * u.bytesPerElement) : (c = 0, h = 0), u.isInteger ? i.vertexAttribIPointer(l, o.itemSize, u.type, c, h) : i.vertexAttribPointer(l, o.itemSize, u.type, o.normalized, c, h), o.isInstancedBufferAttribute && !o.isInterleavedBufferAttribute ? i.vertexAttribDivisor(l, o.meshPerAttribute) : o.isInterleavedBufferAttribute && o.data.isInstancedInterleavedBuffer && i.vertexAttribDivisor(l, o.data.meshPerAttribute);
          }
          return i.bindBuffer(i.ARRAY_BUFFER, null), this.vaoCache[r] = n, {
            vaoGPU: n,
            staticVao: a
          };
        }
        _getTransformFeedback(e) {
          let t = "";
          for (let r = 0; r < e.length; r++) t += ":" + e[r].id;
          let i = this.transformFeedbackCache[t];
          if (i !== void 0) return i;
          const { gl: n } = this;
          i = n.createTransformFeedback(), n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, i);
          for (let r = 0; r < e.length; r++) {
            const a = e[r];
            n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER, r, a.transformBuffer);
          }
          return n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, null), this.transformFeedbackCache[t] = i, i;
        }
        _setupBindings(e, t) {
          const i = this.gl;
          for (const n of e) for (const r of n.bindings) {
            const l = this.get(r).index;
            if (r.isUniformsGroup || r.isUniformBuffer) {
              const o = i.getUniformBlockIndex(t, r.name);
              i.uniformBlockBinding(t, o, l);
            } else if (r.isSampledTexture) {
              const o = i.getUniformLocation(t, r.name);
              i.uniform1i(o, l);
            }
          }
        }
        _bindUniforms(e) {
          const { gl: t, state: i } = this;
          for (const n of e) for (const r of n.bindings) {
            const a = this.get(r), l = a.index;
            r.isUniformsGroup || r.isUniformBuffer ? i.bindBufferBase(t.UNIFORM_BUFFER, l, a.bufferGPU) : r.isSampledTexture && i.bindTexture(a.glTextureType, a.textureGPU, t.TEXTURE0 + l);
          }
        }
        dispose() {
          this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
        }
      }
      const Va = {
        PointList: "point-list",
        LineList: "line-list",
        LineStrip: "line-strip",
        TriangleList: "triangle-list",
        TriangleStrip: "triangle-strip"
      }, bt = {
        Never: "never",
        Less: "less",
        Equal: "equal",
        LessEqual: "less-equal",
        Greater: "greater",
        NotEqual: "not-equal",
        GreaterEqual: "greater-equal",
        Always: "always"
      }, wt = {
        Store: "store",
        Discard: "discard"
      }, Ye = {
        Load: "load",
        Clear: "clear"
      }, zp = {
        CCW: "ccw",
        CW: "cw"
      }, Lp = {
        None: "none",
        Front: "front",
        Back: "back"
      }, Ao = {
        Uint16: "uint16",
        Uint32: "uint32"
      }, S = {
        R8Unorm: "r8unorm",
        R8Snorm: "r8snorm",
        R8Uint: "r8uint",
        R8Sint: "r8sint",
        R16Uint: "r16uint",
        R16Sint: "r16sint",
        R16Float: "r16float",
        RG8Unorm: "rg8unorm",
        RG8Snorm: "rg8snorm",
        RG8Uint: "rg8uint",
        RG8Sint: "rg8sint",
        R32Uint: "r32uint",
        R32Sint: "r32sint",
        R32Float: "r32float",
        RG16Uint: "rg16uint",
        RG16Sint: "rg16sint",
        RG16Float: "rg16float",
        RGBA8Unorm: "rgba8unorm",
        RGBA8UnormSRGB: "rgba8unorm-srgb",
        RGBA8Snorm: "rgba8snorm",
        RGBA8Uint: "rgba8uint",
        RGBA8Sint: "rgba8sint",
        BGRA8Unorm: "bgra8unorm",
        BGRA8UnormSRGB: "bgra8unorm-srgb",
        RGB9E5UFloat: "rgb9e5ufloat",
        RGB10A2Unorm: "rgb10a2unorm",
        RG11B10uFloat: "rgb10a2unorm",
        RG32Uint: "rg32uint",
        RG32Sint: "rg32sint",
        RG32Float: "rg32float",
        RGBA16Uint: "rgba16uint",
        RGBA16Sint: "rgba16sint",
        RGBA16Float: "rgba16float",
        RGBA32Uint: "rgba32uint",
        RGBA32Sint: "rgba32sint",
        RGBA32Float: "rgba32float",
        Stencil8: "stencil8",
        Depth16Unorm: "depth16unorm",
        Depth24Plus: "depth24plus",
        Depth24PlusStencil8: "depth24plus-stencil8",
        Depth32Float: "depth32float",
        Depth32FloatStencil8: "depth32float-stencil8",
        BC1RGBAUnorm: "bc1-rgba-unorm",
        BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
        BC2RGBAUnorm: "bc2-rgba-unorm",
        BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
        BC3RGBAUnorm: "bc3-rgba-unorm",
        BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
        BC4RUnorm: "bc4-r-unorm",
        BC4RSnorm: "bc4-r-snorm",
        BC5RGUnorm: "bc5-rg-unorm",
        BC5RGSnorm: "bc5-rg-snorm",
        BC6HRGBUFloat: "bc6h-rgb-ufloat",
        BC6HRGBFloat: "bc6h-rgb-float",
        BC7RGBAUnorm: "bc7-rgba-unorm",
        BC7RGBAUnormSRGB: "bc7-rgba-srgb",
        ETC2RGB8Unorm: "etc2-rgb8unorm",
        ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
        ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
        ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
        ETC2RGBA8Unorm: "etc2-rgba8unorm",
        ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
        EACR11Unorm: "eac-r11unorm",
        EACR11Snorm: "eac-r11snorm",
        EACRG11Unorm: "eac-rg11unorm",
        EACRG11Snorm: "eac-rg11snorm",
        ASTC4x4Unorm: "astc-4x4-unorm",
        ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
        ASTC5x4Unorm: "astc-5x4-unorm",
        ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
        ASTC5x5Unorm: "astc-5x5-unorm",
        ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
        ASTC6x5Unorm: "astc-6x5-unorm",
        ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
        ASTC6x6Unorm: "astc-6x6-unorm",
        ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
        ASTC8x5Unorm: "astc-8x5-unorm",
        ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
        ASTC8x6Unorm: "astc-8x6-unorm",
        ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
        ASTC8x8Unorm: "astc-8x8-unorm",
        ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
        ASTC10x5Unorm: "astc-10x5-unorm",
        ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
        ASTC10x6Unorm: "astc-10x6-unorm",
        ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
        ASTC10x8Unorm: "astc-10x8-unorm",
        ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
        ASTC10x10Unorm: "astc-10x10-unorm",
        ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
        ASTC12x10Unorm: "astc-12x10-unorm",
        ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
        ASTC12x12Unorm: "astc-12x12-unorm",
        ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
      }, Gp = {
        ClampToEdge: "clamp-to-edge",
        Repeat: "repeat",
        MirrorRepeat: "mirror-repeat"
      }, yr = {
        Linear: "linear",
        Nearest: "nearest"
      }, j = {
        Zero: "zero",
        One: "one",
        Src: "src",
        OneMinusSrc: "one-minus-src",
        SrcAlpha: "src-alpha",
        OneMinusSrcAlpha: "one-minus-src-alpha",
        Dst: "dst",
        OneMinusDstColor: "one-minus-dst",
        DstAlpha: "dst-alpha",
        OneMinusDstAlpha: "one-minus-dst-alpha",
        SrcAlphaSaturated: "src-alpha-saturated",
        Constant: "constant",
        OneMinusConstant: "one-minus-constant"
      }, or = {
        Add: "add",
        Subtract: "subtract",
        ReverseSubtract: "reverse-subtract",
        Min: "min",
        Max: "max"
      }, Yb = {
        None: 0,
        Red: 1,
        Green: 2,
        Blue: 4,
        Alpha: 8,
        All: 15
      }, mn = {
        Keep: "keep",
        Zero: "zero",
        Replace: "replace",
        Invert: "invert",
        IncrementClamp: "increment-clamp",
        DecrementClamp: "decrement-clamp",
        IncrementWrap: "increment-wrap",
        DecrementWrap: "decrement-wrap"
      }, Pp = {
        Uniform: "uniform",
        Storage: "storage",
        ReadOnlyStorage: "read-only-storage"
      }, kp = {
        WriteOnly: "write-only",
        ReadOnly: "read-only",
        ReadWrite: "read-write"
      }, xa = {
        Float: "float",
        UnfilterableFloat: "unfilterable-float",
        Depth: "depth",
        SInt: "sint",
        UInt: "uint"
      }, Wb = {
        OneD: "1d",
        TwoD: "2d",
        ThreeD: "3d"
      }, Ht = {
        OneD: "1d",
        TwoD: "2d",
        TwoDArray: "2d-array",
        Cube: "cube",
        CubeArray: "cube-array",
        ThreeD: "3d"
      }, $L = {
        All: "all",
        StencilOnly: "stencil-only",
        DepthOnly: "depth-only"
      }, Lc = {
        Vertex: "vertex",
        Instance: "instance"
      }, vg = {
        DepthClipControl: "depth-clip-control",
        Depth32FloatStencil8: "depth32float-stencil8",
        TextureCompressionBC: "texture-compression-bc",
        TextureCompressionETC2: "texture-compression-etc2",
        TextureCompressionASTC: "texture-compression-astc",
        TimestampQuery: "timestamp-query",
        IndirectFirstInstance: "indirect-first-instance",
        ShaderF16: "shader-f16",
        RG11B10UFloat: "rg11b10ufloat-renderable",
        BGRA8UNormStorage: "bgra8unorm-storage",
        Float32Filterable: "float32-filterable",
        ClipDistances: "clip-distances",
        DualSourceBlending: "dual-source-blending",
        Subgroups: "subgroups"
      };
      class XL extends y0 {
        constructor(e, t) {
          super(e), this.texture = t, this.version = t ? t.version : 0, this.isSampler = true;
        }
      }
      class ZL extends XL {
        constructor(e, t, i) {
          super(e, t ? t.value : null), this.textureNode = t, this.groupNode = i;
        }
        update() {
          this.texture = this.textureNode.value;
        }
      }
      class QL extends _A {
        constructor(e, t) {
          super(e, t ? t.array : null), this.attribute = t, this.isStorageBuffer = true;
        }
      }
      let KL = 0;
      class JL extends QL {
        constructor(e, t) {
          super("StorageBuffer_" + KL++, e ? e.value : null), this.nodeUniform = e, this.access = e ? e.access : Ls.READ_WRITE, this.groupNode = t;
        }
        get buffer() {
          return this.nodeUniform.value;
        }
      }
      class e4 extends er {
        constructor(e) {
          super(), this.device = e;
          const t = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`, i = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`, n = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
          this.mipmapSampler = e.createSampler({
            minFilter: yr.Linear
          }), this.flipYSampler = e.createSampler({
            minFilter: yr.Nearest
          }), this.transferPipelines = {}, this.flipYPipelines = {}, this.mipmapVertexShaderModule = e.createShaderModule({
            label: "mipmapVertex",
            code: t
          }), this.mipmapFragmentShaderModule = e.createShaderModule({
            label: "mipmapFragment",
            code: i
          }), this.flipYFragmentShaderModule = e.createShaderModule({
            label: "flipYFragment",
            code: n
          });
        }
        getTransferPipeline(e) {
          let t = this.transferPipelines[e];
          return t === void 0 && (t = this.device.createRenderPipeline({
            label: `mipmap-${e}`,
            vertex: {
              module: this.mipmapVertexShaderModule,
              entryPoint: "main"
            },
            fragment: {
              module: this.mipmapFragmentShaderModule,
              entryPoint: "main",
              targets: [
                {
                  format: e
                }
              ]
            },
            primitive: {
              topology: Va.TriangleStrip,
              stripIndexFormat: Ao.Uint32
            },
            layout: "auto"
          }), this.transferPipelines[e] = t), t;
        }
        getFlipYPipeline(e) {
          let t = this.flipYPipelines[e];
          return t === void 0 && (t = this.device.createRenderPipeline({
            label: `flipY-${e}`,
            vertex: {
              module: this.mipmapVertexShaderModule,
              entryPoint: "main"
            },
            fragment: {
              module: this.flipYFragmentShaderModule,
              entryPoint: "main",
              targets: [
                {
                  format: e
                }
              ]
            },
            primitive: {
              topology: Va.TriangleStrip,
              stripIndexFormat: Ao.Uint32
            },
            layout: "auto"
          }), this.flipYPipelines[e] = t), t;
        }
        flipY(e, t, i = 0) {
          const n = t.format, { width: r, height: a } = t.size, l = this.getTransferPipeline(n), o = this.getFlipYPipeline(n), u = this.device.createTexture({
            size: {
              width: r,
              height: a,
              depthOrArrayLayers: 1
            },
            format: n,
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
          }), c = e.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: Ht.TwoD,
            baseArrayLayer: i
          }), h = u.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: Ht.TwoD,
            baseArrayLayer: 0
          }), d = this.device.createCommandEncoder({}), f = (p, g, _) => {
            const m = p.getBindGroupLayout(0), y = this.device.createBindGroup({
              layout: m,
              entries: [
                {
                  binding: 0,
                  resource: this.flipYSampler
                },
                {
                  binding: 1,
                  resource: g
                }
              ]
            }), x = d.beginRenderPass({
              colorAttachments: [
                {
                  view: _,
                  loadOp: Ye.Clear,
                  storeOp: wt.Store,
                  clearValue: [
                    0,
                    0,
                    0,
                    0
                  ]
                }
              ]
            });
            x.setPipeline(p), x.setBindGroup(0, y), x.draw(4, 1, 0, 0), x.end();
          };
          f(l, c, h), f(o, h, c), this.device.queue.submit([
            d.finish()
          ]), u.destroy();
        }
        generateMipmaps(e, t, i = 0) {
          const n = this.get(e);
          n.useCount === void 0 && (n.useCount = 0, n.layers = []);
          const r = n.layers[i] || this._mipmapCreateBundles(e, t, i), a = this.device.createCommandEncoder({});
          this._mipmapRunBundles(a, r), this.device.queue.submit([
            a.finish()
          ]), n.useCount !== 0 && (n.layers[i] = r), n.useCount++;
        }
        _mipmapCreateBundles(e, t, i) {
          const n = this.getTransferPipeline(t.format), r = n.getBindGroupLayout(0);
          let a = e.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: Ht.TwoD,
            baseArrayLayer: i
          });
          const l = [];
          for (let o = 1; o < t.mipLevelCount; o++) {
            const u = this.device.createBindGroup({
              layout: r,
              entries: [
                {
                  binding: 0,
                  resource: this.mipmapSampler
                },
                {
                  binding: 1,
                  resource: a
                }
              ]
            }), c = e.createView({
              baseMipLevel: o,
              mipLevelCount: 1,
              dimension: Ht.TwoD,
              baseArrayLayer: i
            }), h = {
              colorAttachments: [
                {
                  view: c,
                  loadOp: Ye.Clear,
                  storeOp: wt.Store,
                  clearValue: [
                    0,
                    0,
                    0,
                    0
                  ]
                }
              ]
            }, d = this.device.createRenderBundleEncoder({
              colorFormats: [
                t.format
              ]
            });
            d.setPipeline(n), d.setBindGroup(0, u), d.draw(4, 1, 0, 0), l.push({
              renderBundles: [
                d.finish()
              ],
              passDescriptor: h
            }), a = c;
          }
          return l;
        }
        _mipmapRunBundles(e, t) {
          const i = t.length;
          for (let n = 0; n < i; n++) {
            const r = t[n], a = e.beginRenderPass(r.passDescriptor);
            a.executeBundles(r.renderBundles), a.end();
          }
        }
      }
      const t4 = {
        [Sv]: "never",
        [Dy]: "less",
        [Tv]: "equal",
        [vv]: "less-equal",
        [Mv]: "greater",
        [Nv]: "greater-equal",
        [wv]: "always",
        [Av]: "not-equal"
      }, i4 = [
        0,
        1,
        3,
        2,
        4,
        5
      ];
      class s4 {
        constructor(e) {
          this.backend = e, this._passUtils = null, this.defaultTexture = {}, this.defaultCubeTexture = {}, this.defaultVideoFrame = null, this.colorBuffer = null, this.depthTexture = new zo(), this.depthTexture.name = "depthBuffer";
        }
        createSampler(e) {
          const t = this.backend, i = t.device, n = t.get(e), r = {
            addressModeU: this._convertAddressMode(e.wrapS),
            addressModeV: this._convertAddressMode(e.wrapT),
            addressModeW: this._convertAddressMode(e.wrapR),
            magFilter: this._convertFilterMode(e.magFilter),
            minFilter: this._convertFilterMode(e.minFilter),
            mipmapFilter: this._convertFilterMode(e.minFilter),
            maxAnisotropy: 1
          };
          r.magFilter === yr.Linear && r.minFilter === yr.Linear && r.mipmapFilter === yr.Linear && (r.maxAnisotropy = e.anisotropy), e.isDepthTexture && e.compareFunction !== null && (r.compare = t4[e.compareFunction]), n.sampler = i.createSampler(r);
        }
        createDefaultTexture(e) {
          let t;
          const i = Mg(e);
          e.isCubeTexture ? t = this._getDefaultCubeTextureGPU(i) : e.isVideoTexture ? this.backend.get(e).externalTexture = this._getDefaultVideoFrame() : t = this._getDefaultTextureGPU(i), this.backend.get(e).texture = t;
        }
        createTexture(e, t = {}) {
          const i = this.backend, n = i.get(e);
          if (n.initialized) throw new Error("WebGPUTextureUtils: Texture already initialized.");
          t.needsMipmaps === void 0 && (t.needsMipmaps = false), t.levels === void 0 && (t.levels = 1), t.depth === void 0 && (t.depth = 1);
          const { width: r, height: a, depth: l, levels: o } = t;
          e.isFramebufferTexture && (t.renderTarget ? t.format = this.backend.utils.getCurrentColorFormat(t.renderTarget) : t.format = this.backend.utils.getPreferredCanvasFormat());
          const u = this._getDimension(e), c = e.internalFormat || t.format || Mg(e, i.device);
          n.format = c;
          const { samples: h, primarySamples: d, isMSAA: f } = i.utils.getTextureSampleData(e);
          let p = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
          e.isStorageTexture === true && (p |= GPUTextureUsage.STORAGE_BINDING), e.isCompressedTexture !== true && e.isCompressedArrayTexture !== true && (p |= GPUTextureUsage.RENDER_ATTACHMENT);
          const g = {
            label: e.name,
            size: {
              width: r,
              height: a,
              depthOrArrayLayers: l
            },
            mipLevelCount: o,
            sampleCount: d,
            dimension: u,
            format: c,
            usage: p
          };
          if (e.isVideoTexture) {
            const _ = e.source.data, m = new VideoFrame(_);
            g.size.width = m.displayWidth, g.size.height = m.displayHeight, m.close(), n.externalTexture = _;
          } else {
            if (c === void 0) return console.warn("WebGPURenderer: Texture format not supported."), this.createDefaultTexture(e);
            n.texture = i.device.createTexture(g);
          }
          if (f) {
            const _ = Object.assign({}, g);
            _.label = _.label + "-msaa", _.sampleCount = h, n.msaaTexture = i.device.createTexture(_);
          }
          n.initialized = true, n.textureDescriptorGPU = g;
        }
        destroyTexture(e) {
          const t = this.backend, i = t.get(e);
          i.texture !== void 0 && i.texture.destroy(), i.msaaTexture !== void 0 && i.msaaTexture.destroy(), t.delete(e);
        }
        destroySampler(e) {
          const i = this.backend.get(e);
          delete i.sampler;
        }
        generateMipmaps(e) {
          const t = this.backend.get(e);
          if (e.isCubeTexture) for (let i = 0; i < 6; i++) this._generateMipmaps(t.texture, t.textureDescriptorGPU, i);
          else {
            const i = e.image.depth || 1;
            for (let n = 0; n < i; n++) this._generateMipmaps(t.texture, t.textureDescriptorGPU, n);
          }
        }
        getColorBuffer() {
          this.colorBuffer && this.colorBuffer.destroy();
          const e = this.backend, { width: t, height: i } = e.getDrawingBufferSize();
          return this.colorBuffer = e.device.createTexture({
            label: "colorBuffer",
            size: {
              width: t,
              height: i,
              depthOrArrayLayers: 1
            },
            sampleCount: e.utils.getSampleCount(e.renderer.samples),
            format: e.utils.getPreferredCanvasFormat(),
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
          }), this.colorBuffer;
        }
        getDepthBuffer(e = true, t = false) {
          const i = this.backend, { width: n, height: r } = i.getDrawingBufferSize(), a = this.depthTexture, l = i.get(a).texture;
          let o, u;
          if (t ? (o = To, u = Fu) : e && (o = Nr, u = Tt), l !== void 0) {
            if (a.image.width === n && a.image.height === r && a.format === o && a.type === u) return l;
            this.destroyTexture(a);
          }
          return a.name = "depthBuffer", a.format = o, a.type = u, a.image.width = n, a.image.height = r, this.createTexture(a, {
            width: n,
            height: r
          }), i.get(a).texture;
        }
        updateTexture(e, t) {
          const i = this.backend.get(e), { textureDescriptorGPU: n } = i;
          if (!(e.isRenderTargetTexture || n === void 0)) {
            if (e.isDataTexture) this._copyBufferToTexture(t.image, i.texture, n, 0, e.flipY);
            else if (e.isDataArrayTexture || e.isData3DTexture) for (let r = 0; r < t.image.depth; r++) this._copyBufferToTexture(t.image, i.texture, n, r, e.flipY, r);
            else if (e.isCompressedTexture || e.isCompressedArrayTexture) this._copyCompressedBufferToTexture(e.mipmaps, i.texture, n);
            else if (e.isCubeTexture) this._copyCubeMapToTexture(t.images, i.texture, n, e.flipY);
            else if (e.isVideoTexture) {
              const r = e.source.data;
              i.externalTexture = r;
            } else this._copyImageToTexture(t.image, i.texture, n, 0, e.flipY);
            i.version = e.version, e.onUpdate && e.onUpdate(e);
          }
        }
        async copyTextureToBuffer(e, t, i, n, r, a) {
          const l = this.backend.device, o = this.backend.get(e), u = o.texture, c = o.textureDescriptorGPU.format, h = this._getBytesPerTexel(c);
          let d = n * h;
          d = Math.ceil(d / 256) * 256;
          const f = l.createBuffer({
            size: n * r * h,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
          }), p = l.createCommandEncoder();
          p.copyTextureToBuffer({
            texture: u,
            origin: {
              x: t,
              y: i,
              z: a
            }
          }, {
            buffer: f,
            bytesPerRow: d
          }, {
            width: n,
            height: r
          });
          const g = this._getTypedArrayType(c);
          l.queue.submit([
            p.finish()
          ]), await f.mapAsync(GPUMapMode.READ);
          const _ = f.getMappedRange();
          return new g(_);
        }
        _isEnvironmentTexture(e) {
          const t = e.mapping;
          return t === Du || t === Uu || t === Fr || t === _o;
        }
        _getDefaultTextureGPU(e) {
          let t = this.defaultTexture[e];
          if (t === void 0) {
            const i = new Lt();
            i.minFilter = gt, i.magFilter = gt, this.createTexture(i, {
              width: 1,
              height: 1,
              format: e
            }), this.defaultTexture[e] = t = i;
          }
          return this.backend.get(t).texture;
        }
        _getDefaultCubeTextureGPU(e) {
          let t = this.defaultTexture[e];
          if (t === void 0) {
            const i = new Oy();
            i.minFilter = gt, i.magFilter = gt, this.createTexture(i, {
              width: 1,
              height: 1,
              depth: 6
            }), this.defaultCubeTexture[e] = t = i;
          }
          return this.backend.get(t).texture;
        }
        _getDefaultVideoFrame() {
          let e = this.defaultVideoFrame;
          if (e === null) {
            const t = {
              timestamp: 0,
              codedWidth: 1,
              codedHeight: 1,
              format: "RGBA"
            };
            this.defaultVideoFrame = e = new VideoFrame(new Uint8Array([
              0,
              0,
              0,
              255
            ]), t);
          }
          return e;
        }
        _copyCubeMapToTexture(e, t, i, n) {
          for (let r = 0; r < 6; r++) {
            const a = e[r], l = n === true ? i4[r] : r;
            a.isDataTexture ? this._copyBufferToTexture(a.image, t, i, l, n) : this._copyImageToTexture(a, t, i, l, n);
          }
        }
        _copyImageToTexture(e, t, i, n, r) {
          this.backend.device.queue.copyExternalImageToTexture({
            source: e
          }, {
            texture: t,
            mipLevel: 0,
            origin: {
              x: 0,
              y: 0,
              z: n
            }
          }, {
            width: e.width,
            height: e.height,
            depthOrArrayLayers: 1
          }), r === true && this._flipY(t, i, n);
        }
        _getPassUtils() {
          let e = this._passUtils;
          return e === null && (this._passUtils = e = new e4(this.backend.device)), e;
        }
        _generateMipmaps(e, t, i = 0) {
          this._getPassUtils().generateMipmaps(e, t, i);
        }
        _flipY(e, t, i = 0) {
          this._getPassUtils().flipY(e, t, i);
        }
        _copyBufferToTexture(e, t, i, n, r, a = 0) {
          const l = this.backend.device, o = e.data, u = this._getBytesPerTexel(i.format), c = e.width * u;
          l.queue.writeTexture({
            texture: t,
            mipLevel: 0,
            origin: {
              x: 0,
              y: 0,
              z: n
            }
          }, o, {
            offset: e.width * e.height * u * a,
            bytesPerRow: c
          }, {
            width: e.width,
            height: e.height,
            depthOrArrayLayers: 1
          }), r === true && this._flipY(t, i, n);
        }
        _copyCompressedBufferToTexture(e, t, i) {
          const n = this.backend.device, r = this._getBlockData(i.format), a = i.size.depthOrArrayLayers > 1;
          for (let l = 0; l < e.length; l++) {
            const o = e[l], u = o.width, c = o.height, h = a ? i.size.depthOrArrayLayers : 1, d = Math.ceil(u / r.width) * r.byteLength, f = d * Math.ceil(c / r.height);
            for (let p = 0; p < h; p++) n.queue.writeTexture({
              texture: t,
              mipLevel: l,
              origin: {
                x: 0,
                y: 0,
                z: p
              }
            }, o.data, {
              offset: p * f,
              bytesPerRow: d,
              rowsPerImage: Math.ceil(c / r.height)
            }, {
              width: Math.ceil(u / r.width) * r.width,
              height: Math.ceil(c / r.height) * r.height,
              depthOrArrayLayers: 1
            });
          }
        }
        _getBlockData(e) {
          if (e === S.BC1RGBAUnorm || e === S.BC1RGBAUnormSRGB) return {
            byteLength: 8,
            width: 4,
            height: 4
          };
          if (e === S.BC2RGBAUnorm || e === S.BC2RGBAUnormSRGB) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.BC3RGBAUnorm || e === S.BC3RGBAUnormSRGB) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.BC4RUnorm || e === S.BC4RSNorm) return {
            byteLength: 8,
            width: 4,
            height: 4
          };
          if (e === S.BC5RGUnorm || e === S.BC5RGSnorm) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.BC6HRGBUFloat || e === S.BC6HRGBFloat) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.BC7RGBAUnorm || e === S.BC7RGBAUnormSRGB) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.ETC2RGB8Unorm || e === S.ETC2RGB8UnormSRGB) return {
            byteLength: 8,
            width: 4,
            height: 4
          };
          if (e === S.ETC2RGB8A1Unorm || e === S.ETC2RGB8A1UnormSRGB) return {
            byteLength: 8,
            width: 4,
            height: 4
          };
          if (e === S.ETC2RGBA8Unorm || e === S.ETC2RGBA8UnormSRGB) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.EACR11Unorm) return {
            byteLength: 8,
            width: 4,
            height: 4
          };
          if (e === S.EACR11Snorm) return {
            byteLength: 8,
            width: 4,
            height: 4
          };
          if (e === S.EACRG11Unorm) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.EACRG11Snorm) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.ASTC4x4Unorm || e === S.ASTC4x4UnormSRGB) return {
            byteLength: 16,
            width: 4,
            height: 4
          };
          if (e === S.ASTC5x4Unorm || e === S.ASTC5x4UnormSRGB) return {
            byteLength: 16,
            width: 5,
            height: 4
          };
          if (e === S.ASTC5x5Unorm || e === S.ASTC5x5UnormSRGB) return {
            byteLength: 16,
            width: 5,
            height: 5
          };
          if (e === S.ASTC6x5Unorm || e === S.ASTC6x5UnormSRGB) return {
            byteLength: 16,
            width: 6,
            height: 5
          };
          if (e === S.ASTC6x6Unorm || e === S.ASTC6x6UnormSRGB) return {
            byteLength: 16,
            width: 6,
            height: 6
          };
          if (e === S.ASTC8x5Unorm || e === S.ASTC8x5UnormSRGB) return {
            byteLength: 16,
            width: 8,
            height: 5
          };
          if (e === S.ASTC8x6Unorm || e === S.ASTC8x6UnormSRGB) return {
            byteLength: 16,
            width: 8,
            height: 6
          };
          if (e === S.ASTC8x8Unorm || e === S.ASTC8x8UnormSRGB) return {
            byteLength: 16,
            width: 8,
            height: 8
          };
          if (e === S.ASTC10x5Unorm || e === S.ASTC10x5UnormSRGB) return {
            byteLength: 16,
            width: 10,
            height: 5
          };
          if (e === S.ASTC10x6Unorm || e === S.ASTC10x6UnormSRGB) return {
            byteLength: 16,
            width: 10,
            height: 6
          };
          if (e === S.ASTC10x8Unorm || e === S.ASTC10x8UnormSRGB) return {
            byteLength: 16,
            width: 10,
            height: 8
          };
          if (e === S.ASTC10x10Unorm || e === S.ASTC10x10UnormSRGB) return {
            byteLength: 16,
            width: 10,
            height: 10
          };
          if (e === S.ASTC12x10Unorm || e === S.ASTC12x10UnormSRGB) return {
            byteLength: 16,
            width: 12,
            height: 10
          };
          if (e === S.ASTC12x12Unorm || e === S.ASTC12x12UnormSRGB) return {
            byteLength: 16,
            width: 12,
            height: 12
          };
        }
        _convertAddressMode(e) {
          let t = Gp.ClampToEdge;
          return e === bo ? t = Gp.Repeat : e === So && (t = Gp.MirrorRepeat), t;
        }
        _convertFilterMode(e) {
          let t = yr.Linear;
          return (e === gt || e === qm || e === eo) && (t = yr.Nearest), t;
        }
        _getBytesPerTexel(e) {
          if (e === S.R8Unorm || e === S.R8Snorm || e === S.R8Uint || e === S.R8Sint) return 1;
          if (e === S.R16Uint || e === S.R16Sint || e === S.R16Float || e === S.RG8Unorm || e === S.RG8Snorm || e === S.RG8Uint || e === S.RG8Sint) return 2;
          if (e === S.R32Uint || e === S.R32Sint || e === S.R32Float || e === S.RG16Uint || e === S.RG16Sint || e === S.RG16Float || e === S.RGBA8Unorm || e === S.RGBA8UnormSRGB || e === S.RGBA8Snorm || e === S.RGBA8Uint || e === S.RGBA8Sint || e === S.BGRA8Unorm || e === S.BGRA8UnormSRGB || e === S.RGB9E5UFloat || e === S.RGB10A2Unorm || e === S.RG11B10UFloat || e === S.Depth32Float || e === S.Depth24Plus || e === S.Depth24PlusStencil8 || e === S.Depth32FloatStencil8) return 4;
          if (e === S.RG32Uint || e === S.RG32Sint || e === S.RG32Float || e === S.RGBA16Uint || e === S.RGBA16Sint || e === S.RGBA16Float) return 8;
          if (e === S.RGBA32Uint || e === S.RGBA32Sint || e === S.RGBA32Float) return 16;
        }
        _getTypedArrayType(e) {
          if (e === S.R8Uint) return Uint8Array;
          if (e === S.R8Sint) return Int8Array;
          if (e === S.R8Unorm) return Uint8Array;
          if (e === S.R8Snorm) return Int8Array;
          if (e === S.RG8Uint) return Uint8Array;
          if (e === S.RG8Sint) return Int8Array;
          if (e === S.RG8Unorm) return Uint8Array;
          if (e === S.RG8Snorm) return Int8Array;
          if (e === S.RGBA8Uint) return Uint8Array;
          if (e === S.RGBA8Sint) return Int8Array;
          if (e === S.RGBA8Unorm) return Uint8Array;
          if (e === S.RGBA8Snorm) return Int8Array;
          if (e === S.R16Uint) return Uint16Array;
          if (e === S.R16Sint) return Int16Array;
          if (e === S.RG16Uint) return Uint16Array;
          if (e === S.RG16Sint) return Int16Array;
          if (e === S.RGBA16Uint) return Uint16Array;
          if (e === S.RGBA16Sint) return Int16Array;
          if (e === S.R16Float || e === S.RG16Float || e === S.RGBA16Float) return Uint16Array;
          if (e === S.R32Uint) return Uint32Array;
          if (e === S.R32Sint) return Int32Array;
          if (e === S.R32Float) return Float32Array;
          if (e === S.RG32Uint) return Uint32Array;
          if (e === S.RG32Sint) return Int32Array;
          if (e === S.RG32Float) return Float32Array;
          if (e === S.RGBA32Uint) return Uint32Array;
          if (e === S.RGBA32Sint) return Int32Array;
          if (e === S.RGBA32Float) return Float32Array;
          if (e === S.BGRA8Unorm || e === S.BGRA8UnormSRGB) return Uint8Array;
          if (e === S.RGB10A2Unorm || e === S.RGB9E5UFloat || e === S.RG11B10UFloat) return Uint32Array;
          if (e === S.Depth32Float) return Float32Array;
          if (e === S.Depth24Plus || e === S.Depth24PlusStencil8) return Uint32Array;
          if (e === S.Depth32FloatStencil8) return Float32Array;
        }
        _getDimension(e) {
          let t;
          return e.isData3DTexture ? t = Wb.ThreeD : t = Wb.TwoD, t;
        }
      }
      function Mg(s, e = null) {
        const t = s.format, i = s.type, n = s.colorSpace;
        let r;
        if (s.isCompressedTexture === true || s.isCompressedArrayTexture === true) switch (t) {
          case th:
            r = n === H ? S.BC1RGBAUnormSRGB : S.BC1RGBAUnorm;
            break;
          case ih:
            r = n === H ? S.BC2RGBAUnormSRGB : S.BC2RGBAUnorm;
            break;
          case sh:
            r = n === H ? S.BC3RGBAUnormSRGB : S.BC3RGBAUnorm;
            break;
          case Wm:
            r = n === H ? S.ETC2RGB8UnormSRGB : S.ETC2RGB8Unorm;
            break;
          case jm:
            r = n === H ? S.ETC2RGBA8UnormSRGB : S.ETC2RGBA8Unorm;
            break;
          case $m:
            r = n === H ? S.ASTC4x4UnormSRGB : S.ASTC4x4Unorm;
            break;
          case Xm:
            r = n === H ? S.ASTC5x4UnormSRGB : S.ASTC5x4Unorm;
            break;
          case Zm:
            r = n === H ? S.ASTC5x5UnormSRGB : S.ASTC5x5Unorm;
            break;
          case Qm:
            r = n === H ? S.ASTC6x5UnormSRGB : S.ASTC6x5Unorm;
            break;
          case Km:
            r = n === H ? S.ASTC6x6UnormSRGB : S.ASTC6x6Unorm;
            break;
          case Jm:
            r = n === H ? S.ASTC8x5UnormSRGB : S.ASTC8x5Unorm;
            break;
          case eg:
            r = n === H ? S.ASTC8x6UnormSRGB : S.ASTC8x6Unorm;
            break;
          case tg:
            r = n === H ? S.ASTC8x8UnormSRGB : S.ASTC8x8Unorm;
            break;
          case ig:
            r = n === H ? S.ASTC10x5UnormSRGB : S.ASTC10x5Unorm;
            break;
          case sg:
            r = n === H ? S.ASTC10x6UnormSRGB : S.ASTC10x6Unorm;
            break;
          case ng:
            r = n === H ? S.ASTC10x8UnormSRGB : S.ASTC10x8Unorm;
            break;
          case rg:
            r = n === H ? S.ASTC10x10UnormSRGB : S.ASTC10x10Unorm;
            break;
          case ag:
            r = n === H ? S.ASTC12x10UnormSRGB : S.ASTC12x10Unorm;
            break;
          case og:
            r = n === H ? S.ASTC12x12UnormSRGB : S.ASTC12x12Unorm;
            break;
          case Or:
            r = n === H ? S.RGBA8UnormSRGB : S.RGBA8Unorm;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture format.", t);
        }
        else switch (t) {
          case Or:
            switch (i) {
              case Ul:
                r = S.RGBA8Snorm;
                break;
              case Fl:
                r = S.RGBA16Sint;
                break;
              case La:
                r = S.RGBA16Uint;
                break;
              case Tt:
                r = S.RGBA32Uint;
                break;
              case Dt:
                r = S.RGBA32Sint;
                break;
              case In:
                r = n === H ? S.RGBA8UnormSRGB : S.RGBA8Unorm;
                break;
              case ks:
                r = S.RGBA16Float;
                break;
              case Yt:
                r = S.RGBA32Float;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", i);
            }
            break;
          case Ey:
            switch (i) {
              case bv:
                r = S.RGB9E5UFloat;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with RGBFormat.", i);
            }
            break;
          case Dd:
            switch (i) {
              case Ul:
                r = S.R8Snorm;
                break;
              case Fl:
                r = S.R16Sint;
                break;
              case La:
                r = S.R16Uint;
                break;
              case Tt:
                r = S.R32Uint;
                break;
              case Dt:
                r = S.R32Sint;
                break;
              case In:
                r = S.R8Unorm;
                break;
              case ks:
                r = S.R16Float;
                break;
              case Yt:
                r = S.R32Float;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with RedFormat.", i);
            }
            break;
          case lu:
            switch (i) {
              case Ul:
                r = S.RG8Snorm;
                break;
              case Fl:
                r = S.RG16Sint;
                break;
              case La:
                r = S.RG16Uint;
                break;
              case Tt:
                r = S.RG32Uint;
                break;
              case Dt:
                r = S.RG32Sint;
                break;
              case In:
                r = S.RG8Unorm;
                break;
              case ks:
                r = S.RG16Float;
                break;
              case Yt:
                r = S.RG32Float;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with RGFormat.", i);
            }
            break;
          case Nr:
            switch (i) {
              case La:
                r = S.Depth16Unorm;
                break;
              case Tt:
                r = S.Depth24Plus;
                break;
              case Yt:
                r = S.Depth32Float;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", i);
            }
            break;
          case To:
            switch (i) {
              case Fu:
                r = S.Depth24PlusStencil8;
                break;
              case Yt:
                e && e.features.has(vg.Depth32FloatStencil8) === false && console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'), r = S.Depth32FloatStencil8;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", i);
            }
            break;
          case Ry:
            switch (i) {
              case Dt:
                r = S.R32Sint;
                break;
              case Tt:
                r = S.R32Uint;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", i);
            }
            break;
          case Cy:
            switch (i) {
              case Dt:
                r = S.RG32Sint;
                break;
              case Tt:
                r = S.RG32Uint;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", i);
            }
            break;
          case By:
            switch (i) {
              case Dt:
                r = S.RGBA32Sint;
                break;
              case Tt:
                r = S.RGBA32Uint;
                break;
              default:
                console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", i);
            }
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture format.", t);
        }
        return r;
      }
      const n4 = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i, r4 = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig, jb = {
        f32: "float",
        i32: "int",
        u32: "uint",
        bool: "bool",
        "vec2<f32>": "vec2",
        "vec2<i32>": "ivec2",
        "vec2<u32>": "uvec2",
        "vec2<bool>": "bvec2",
        vec2f: "vec2",
        vec2i: "ivec2",
        vec2u: "uvec2",
        vec2b: "bvec2",
        "vec3<f32>": "vec3",
        "vec3<i32>": "ivec3",
        "vec3<u32>": "uvec3",
        "vec3<bool>": "bvec3",
        vec3f: "vec3",
        vec3i: "ivec3",
        vec3u: "uvec3",
        vec3b: "bvec3",
        "vec4<f32>": "vec4",
        "vec4<i32>": "ivec4",
        "vec4<u32>": "uvec4",
        "vec4<bool>": "bvec4",
        vec4f: "vec4",
        vec4i: "ivec4",
        vec4u: "uvec4",
        vec4b: "bvec4",
        "mat2x2<f32>": "mat2",
        mat2x2f: "mat2",
        "mat3x3<f32>": "mat3",
        mat3x3f: "mat3",
        "mat4x4<f32>": "mat4",
        mat4x4f: "mat4",
        sampler: "sampler",
        texture_1d: "texture",
        texture_2d: "texture",
        texture_2d_array: "texture",
        texture_multisampled_2d: "cubeTexture",
        texture_depth_2d: "depthTexture",
        texture_depth_multisampled_2d: "depthTexture",
        texture_3d: "texture3D",
        texture_cube: "cubeTexture",
        texture_cube_array: "cubeTexture",
        texture_storage_1d: "storageTexture",
        texture_storage_2d: "storageTexture",
        texture_storage_2d_array: "storageTexture",
        texture_storage_3d: "storageTexture"
      }, a4 = (s) => {
        s = s.trim();
        const e = s.match(n4);
        if (e !== null && e.length === 4) {
          const t = e[2], i = [];
          let n = null;
          for (; (n = r4.exec(t)) !== null; ) i.push({
            name: n[1],
            type: n[2]
          });
          const r = [];
          for (let c = 0; c < i.length; c++) {
            const { name: h, type: d } = i[c];
            let f = d;
            f.startsWith("ptr") ? f = "pointer" : (f.startsWith("texture") && (f = d.split("<")[0]), f = jb[f]), r.push(new m0(f, h));
          }
          const a = s.substring(e[0].length), l = e[3] || "void", o = e[1] !== void 0 ? e[1] : "";
          return {
            type: jb[l] || l,
            inputs: r,
            name: o,
            inputsCode: t,
            blockCode: a,
            outputType: l
          };
        } else throw new Error("FunctionNode: Function is not a WGSL code.");
      };
      class o4 extends g0 {
        constructor(e) {
          const { type: t, inputs: i, name: n, inputsCode: r, blockCode: a, outputType: l } = a4(e);
          super(t, i, n), this.inputsCode = r, this.blockCode = a, this.outputType = l;
        }
        getCode(e = this.name) {
          const t = this.outputType !== "void" ? "-> " + this.outputType : "";
          return `fn ${e} ( ${this.inputsCode.trim()} ) ${t}` + this.blockCode;
        }
      }
      class l4 extends yA {
        parseFunction(e) {
          return new o4(e);
        }
      }
      const _a = typeof self < "u" ? self.GPUShaderStage : {
        VERTEX: 1,
        FRAGMENT: 2,
        COMPUTE: 4
      }, u4 = {
        [Ls.READ_ONLY]: "read",
        [Ls.WRITE_ONLY]: "write",
        [Ls.READ_WRITE]: "read_write"
      }, $b = {
        [bo]: "repeat",
        [Cn]: "clamp",
        [So]: "mirror"
      }, Gc = {
        vertex: _a ? _a.VERTEX : 1,
        fragment: _a ? _a.FRAGMENT : 2,
        compute: _a ? _a.COMPUTE : 4
      }, Xb = {
        instance: true,
        swizzleAssign: false,
        storageBuffer: true
      }, c4 = {
        "^^": "tsl_xor"
      }, h4 = {
        float: "f32",
        int: "i32",
        uint: "u32",
        bool: "bool",
        color: "vec3<f32>",
        vec2: "vec2<f32>",
        ivec2: "vec2<i32>",
        uvec2: "vec2<u32>",
        bvec2: "vec2<bool>",
        vec3: "vec3<f32>",
        ivec3: "vec3<i32>",
        uvec3: "vec3<u32>",
        bvec3: "vec3<bool>",
        vec4: "vec4<f32>",
        ivec4: "vec4<i32>",
        uvec4: "vec4<u32>",
        bvec4: "vec4<bool>",
        mat2: "mat2x2<f32>",
        mat3: "mat3x3<f32>",
        mat4: "mat4x4<f32>"
      }, Zb = {}, bi = {
        tsl_xor: new nt("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
        mod_float: new nt("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
        mod_vec2: new nt("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
        mod_vec3: new nt("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
        mod_vec4: new nt("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
        equals_bool: new nt("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
        equals_bvec2: new nt("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
        equals_bvec3: new nt("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
        equals_bvec4: new nt("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
        repeatWrapping_float: new nt("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),
        mirrorWrapping_float: new nt("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),
        clampWrapping_float: new nt("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),
        biquadraticTexture: new nt(`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`)
      }, gl = {
        dFdx: "dpdx",
        dFdy: "- dpdy",
        mod_float: "tsl_mod_float",
        mod_vec2: "tsl_mod_vec2",
        mod_vec3: "tsl_mod_vec3",
        mod_vec4: "tsl_mod_vec4",
        equals_bool: "tsl_equals_bool",
        equals_bvec2: "tsl_equals_bvec2",
        equals_bvec3: "tsl_equals_bvec3",
        equals_bvec4: "tsl_equals_bvec4",
        inversesqrt: "inverseSqrt",
        bitcast: "bitcast<f32>"
      };
      typeof navigator < "u" && /Windows/g.test(navigator.userAgent) && (bi.pow_float = new nt("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"), bi.pow_vec2 = new nt("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }", [
        bi.pow_float
      ]), bi.pow_vec3 = new nt("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }", [
        bi.pow_float
      ]), bi.pow_vec4 = new nt("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }", [
        bi.pow_float
      ]), gl.pow_float = "tsl_pow_float", gl.pow_vec2 = "tsl_pow_vec2", gl.pow_vec3 = "tsl_pow_vec3", gl.pow_vec4 = "tsl_pow_vec4");
      let NA = "";
      (typeof navigator < "u" && /Firefox|Deno/g.test(navigator.userAgent)) !== true && (NA += `diagnostic( off, derivative_uniformity );
`);
      class d4 extends mA {
        constructor(e, t) {
          super(e, t, new l4()), this.uniformGroups = {}, this.builtins = {}, this.directives = {}, this.scopedArrays = /* @__PURE__ */ new Map();
        }
        needsToWorkingColorSpace(e) {
          return e.isVideoTexture === true && e.colorSpace !== zr;
        }
        _generateTextureSample(e, t, i, n, r = this.shaderStage) {
          return r === "fragment" ? n ? `textureSample( ${t}, ${t}_sampler, ${i}, ${n} )` : `textureSample( ${t}, ${t}_sampler, ${i} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, t, i) : this.generateTextureLod(e, t, i, n, "0");
        }
        _generateVideoSample(e, t, i = this.shaderStage) {
          if (i === "fragment") return `textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`;
          console.error(`WebGPURenderer: THREE.VideoTexture does not support ${i} shader.`);
        }
        _generateTextureSampleLevel(e, t, i, n, r, a = this.shaderStage) {
          return (a === "fragment" || a === "compute") && this.isUnfilterable(e) === false ? `textureSampleLevel( ${t}, ${t}_sampler, ${i}, ${n} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, t, i, n) : this.generateTextureLod(e, t, i, r, n);
        }
        generateWrapFunction(e) {
          const t = `tsl_coord_${$b[e.wrapS]}S_${$b[e.wrapT]}_${e.isData3DTexture ? "3d" : "2d"}T`;
          let i = Zb[t];
          if (i === void 0) {
            const n = [], r = e.isData3DTexture ? "vec3f" : "vec2f";
            let a = `fn ${t}( coord : ${r} ) -> ${r} {

	return ${r}(
`;
            const l = (o, u) => {
              o === bo ? (n.push(bi.repeatWrapping_float), a += `		tsl_repeatWrapping_float( coord.${u} )`) : o === Cn ? (n.push(bi.clampWrapping_float), a += `		tsl_clampWrapping_float( coord.${u} )`) : o === So ? (n.push(bi.mirrorWrapping_float), a += `		tsl_mirrorWrapping_float( coord.${u} )`) : (a += `		coord.${u}`, console.warn(`WebGPURenderer: Unsupported texture wrap type "${o}" for vertex shader.`));
            };
            l(e.wrapS, "x"), a += `,
`, l(e.wrapT, "y"), e.isData3DTexture && (a += `,
`, l(e.wrapR, "z")), a += `
	);

}
`, Zb[t] = i = new nt(a, n);
          }
          return i.build(this), t;
        }
        generateTextureDimension(e, t, i) {
          const n = this.getDataFromNode(e, this.shaderStage, this.globalCache);
          n.dimensionsSnippet === void 0 && (n.dimensionsSnippet = {});
          let r = n.dimensionsSnippet[i];
          if (n.dimensionsSnippet[i] === void 0) {
            let a, l;
            const { primarySamples: o } = this.renderer.backend.utils.getTextureSampleData(e), u = o > 1;
            e.isData3DTexture ? l = "vec3<u32>" : l = "vec2<u32>", u || e.isVideoTexture || e.isStorageTexture ? a = t : a = `${t}${i ? `, u32( ${i} )` : ""}`, r = new oh(new uh(`textureDimensions( ${a} )`, l)), n.dimensionsSnippet[i] = r, (e.isDataArrayTexture || e.isData3DTexture) && (n.arrayLayerCount = new oh(new uh(`textureNumLayers(${t})`, "u32"))), e.isTextureCube && (n.cubeFaceCount = new oh(new uh("6u", "u32")));
          }
          return r.build(this);
        }
        generateFilteredTexture(e, t, i, n = "0u") {
          this._include("biquadraticTexture");
          const r = this.generateWrapFunction(e), a = this.generateTextureDimension(e, t, n);
          return `tsl_biquadraticTexture( ${t}, ${r}( ${i} ), ${a}, u32( ${n} ) )`;
        }
        generateTextureLod(e, t, i, n, r = "0u") {
          const a = this.generateWrapFunction(e), l = this.generateTextureDimension(e, t, r), o = e.isData3DTexture ? "vec3" : "vec2", u = `${o}<u32>(${a}(${i}) * ${o}<f32>(${l}))`;
          return this.generateTextureLoad(e, t, u, n, r);
        }
        generateTextureLoad(e, t, i, n, r = "0u") {
          return e.isVideoTexture === true || e.isStorageTexture === true ? `textureLoad( ${t}, ${i} )` : n ? `textureLoad( ${t}, ${i}, ${n}, u32( ${r} ) )` : `textureLoad( ${t}, ${i}, u32( ${r} ) )`;
        }
        generateTextureStore(e, t, i, n) {
          return `textureStore( ${t}, ${i}, ${n} )`;
        }
        isSampleCompare(e) {
          return e.isDepthTexture === true && e.compareFunction !== null;
        }
        isUnfilterable(e) {
          return this.getComponentTypeFromTexture(e) !== "float" || !this.isAvailable("float32Filterable") && e.isDataTexture === true && e.type === Yt || this.isSampleCompare(e) === false && e.minFilter === gt && e.magFilter === gt || this.renderer.backend.utils.getTextureSampleData(e).primarySamples > 1;
        }
        generateTexture(e, t, i, n, r = this.shaderStage) {
          let a = null;
          return e.isVideoTexture === true ? a = this._generateVideoSample(t, i, r) : this.isUnfilterable(e) ? a = this.generateTextureLod(e, t, i, n, "0", r) : a = this._generateTextureSample(e, t, i, n, r), a;
        }
        generateTextureGrad(e, t, i, n, r, a = this.shaderStage) {
          if (a === "fragment") return `textureSampleGrad( ${t}, ${t}_sampler, ${i},  ${n[0]}, ${n[1]} )`;
          console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${a} shader.`);
        }
        generateTextureCompare(e, t, i, n, r, a = this.shaderStage) {
          if (a === "fragment") return `textureSampleCompare( ${t}, ${t}_sampler, ${i}, ${n} )`;
          console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${a} shader.`);
        }
        generateTextureLevel(e, t, i, n, r, a = this.shaderStage) {
          let l = null;
          return e.isVideoTexture === true ? l = this._generateVideoSample(t, i, a) : l = this._generateTextureSampleLevel(e, t, i, n, r, a), l;
        }
        generateTextureBias(e, t, i, n, r, a = this.shaderStage) {
          if (a === "fragment") return `textureSampleBias( ${t}, ${t}_sampler, ${i}, ${n} )`;
          console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${a} shader.`);
        }
        getPropertyName(e, t = this.shaderStage) {
          if (e.isNodeVarying === true && e.needsInterpolation === true) {
            if (t === "vertex") return `varyings.${e.name}`;
          } else if (e.isNodeUniform === true) {
            const i = e.name, n = e.type;
            return n === "texture" || n === "cubeTexture" || n === "storageTexture" || n === "texture3D" ? i : n === "buffer" || n === "storageBuffer" || n === "indirectStorageBuffer" ? `NodeBuffer_${e.id}.${i}` : e.groupNode.name + "." + i;
          }
          return super.getPropertyName(e);
        }
        getOutputStructName() {
          return "output";
        }
        _getUniformGroupCount(e) {
          return Object.keys(this.uniforms[e]).length;
        }
        getFunctionOperator(e) {
          const t = c4[e];
          return t !== void 0 ? (this._include(t), t) : null;
        }
        getNodeAccess(e, t) {
          return t !== "compute" ? Ls.READ_ONLY : e.access;
        }
        getStorageAccess(e, t) {
          return u4[this.getNodeAccess(e, t)];
        }
        getUniformFromNode(e, t, i, n = null) {
          const r = super.getUniformFromNode(e, t, i, n), a = this.getDataFromNode(e, i, this.globalCache);
          if (a.uniformGPU === void 0) {
            let l;
            const o = e.groupNode, u = o.name, c = this.getBindGroupArray(u, i);
            if (t === "texture" || t === "cubeTexture" || t === "storageTexture" || t === "texture3D") {
              let h = null;
              const d = this.getNodeAccess(e, i);
              if (t === "texture" || t === "storageTexture" ? h = new $d(r.name, r.node, o, d) : t === "cubeTexture" ? h = new vA(r.name, r.node, o, d) : t === "texture3D" && (h = new MA(r.name, r.node, o, d)), h.store = e.isStorageTextureNode === true, h.setVisibility(Gc[i]), (i === "fragment" || i === "compute") && this.isUnfilterable(e.value) === false && h.store === false) {
                const f = new ZL(`${r.name}_sampler`, r.node, o);
                f.setVisibility(Gc[i]), c.push(f, h), l = [
                  f,
                  h
                ];
              } else c.push(h), l = [
                h
              ];
            } else if (t === "buffer" || t === "storageBuffer" || t === "indirectStorageBuffer") {
              const h = t === "buffer" ? SA : JL, d = new h(e, o);
              d.setVisibility(Gc[i]), c.push(d), l = d;
            } else {
              const h = this.uniformGroups[i] || (this.uniformGroups[i] = {});
              let d = h[u];
              d === void 0 && (d = new TA(u, o), d.setVisibility(Gc[i]), h[u] = d, c.push(d)), l = this.getNodeUniform(r, t), d.addUniform(l);
            }
            a.uniformGPU = l;
          }
          return r;
        }
        getBuiltin(e, t, i, n = this.shaderStage) {
          const r = this.builtins[n] || (this.builtins[n] = /* @__PURE__ */ new Map());
          return r.has(e) === false && r.set(e, {
            name: e,
            property: t,
            type: i
          }), t;
        }
        hasBuiltin(e, t = this.shaderStage) {
          return this.builtins[t] !== void 0 && this.builtins[t].has(e);
        }
        getVertexIndex() {
          return this.shaderStage === "vertex" ? this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute") : "vertexIndex";
        }
        buildFunctionCode(e) {
          const t = e.layout, i = this.flowShaderNode(e), n = [];
          for (const a of t.inputs) n.push(a.name + " : " + this.getType(a.type));
          let r = `fn ${t.name}( ${n.join(", ")} ) -> ${this.getType(t.type)} {
${i.vars}
${i.code}
`;
          return i.result && (r += `	return ${i.result};
`), r += `
}
`, r;
        }
        getInstanceIndex() {
          return this.shaderStage === "vertex" ? this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute") : "instanceIndex";
        }
        getInvocationLocalIndex() {
          return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
        }
        getSubgroupSize() {
          return this.enableSubGroups(), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
        }
        getInvocationSubgroupIndex() {
          return this.enableSubGroups(), this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
        }
        getSubgroupIndex() {
          return this.enableSubGroups(), this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
        }
        getDrawIndex() {
          return null;
        }
        getFrontFacing() {
          return this.getBuiltin("front_facing", "isFront", "bool");
        }
        getFragCoord() {
          return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
        }
        getFragDepth() {
          return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
        }
        getClipDistance() {
          return "varyings.hw_clip_distances";
        }
        isFlipY() {
          return false;
        }
        enableDirective(e, t = this.shaderStage) {
          (this.directives[t] || (this.directives[t] = /* @__PURE__ */ new Set())).add(e);
        }
        getDirectives(e) {
          const t = [], i = this.directives[e];
          if (i !== void 0) for (const n of i) t.push(`enable ${n};`);
          return t.join(`
`);
        }
        enableSubGroups() {
          this.enableDirective("subgroups");
        }
        enableSubgroupsF16() {
          this.enableDirective("subgroups-f16");
        }
        enableClipDistances() {
          this.enableDirective("clip_distances");
        }
        enableShaderF16() {
          this.enableDirective("f16");
        }
        enableDualSourceBlending() {
          this.enableDirective("dual_source_blending");
        }
        enableHardwareClipping(e) {
          this.enableClipDistances(), this.getBuiltin("clip_distances", "hw_clip_distances", `array<f32, ${e} >`, "vertex");
        }
        getBuiltins(e) {
          const t = [], i = this.builtins[e];
          if (i !== void 0) for (const { name: n, property: r, type: a } of i.values()) t.push(`@builtin( ${n} ) ${r} : ${a}`);
          return t.join(`,
	`);
        }
        getScopedArray(e, t, i, n) {
          return this.scopedArrays.has(e) === false && this.scopedArrays.set(e, {
            name: e,
            scope: t,
            bufferType: i,
            bufferCount: n
          }), e;
        }
        getScopedArrays(e) {
          if (e !== "compute") return;
          const t = [];
          for (const { name: i, scope: n, bufferType: r, bufferCount: a } of this.scopedArrays.values()) {
            const l = this.getType(r);
            t.push(`var<${n}> ${i}: array< ${l}, ${a} >;`);
          }
          return t.join(`
`);
        }
        getAttributes(e) {
          const t = [];
          if (e === "compute" && (this.getBuiltin("global_invocation_id", "id", "vec3<u32>", "attribute"), this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute"), this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute"), this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute"), this.renderer.hasFeature("subgroups") && (this.enableDirective("subgroups", e), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute"))), e === "vertex" || e === "compute") {
            const i = this.getBuiltins("attribute");
            i && t.push(i);
            const n = this.getAttributesArray();
            for (let r = 0, a = n.length; r < a; r++) {
              const l = n[r], o = l.name, u = this.getType(l.type);
              t.push(`@location( ${r} ) ${o} : ${u}`);
            }
          }
          return t.join(`,
	`);
        }
        getStructMembers(e) {
          const t = [], i = e.getMemberTypes();
          for (let r = 0; r < i.length; r++) {
            const a = i[r];
            t.push(`	@location( ${r} ) m${r} : ${a}<f32>`);
          }
          const n = this.getBuiltins("output");
          return n && t.push("	" + n), t.join(`,
`);
        }
        getStructs(e) {
          const t = [], i = this.structs[e];
          for (let n = 0, r = i.length; n < r; n++) {
            const a = i[n], l = a.name;
            let o = `struct ${l} {
`;
            o += this.getStructMembers(a), o += `
}`, t.push(o), t.push(`
var<private> output : ${l};

`);
          }
          return t.join(`

`);
        }
        getVar(e, t) {
          return `var ${t} : ${this.getType(e)}`;
        }
        getVars(e) {
          const t = [], i = this.vars[e];
          if (i !== void 0) for (const n of i) t.push(`	${this.getVar(n.type, n.name)};`);
          return `
${t.join(`
`)}
`;
        }
        getVaryings(e) {
          const t = [];
          if (e === "vertex" && this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex"), e === "vertex" || e === "fragment") {
            const r = this.varyings, a = this.vars[e];
            for (let l = 0; l < r.length; l++) {
              const o = r[l];
              if (o.needsInterpolation) {
                let u = `@location( ${l} )`;
                /^(int|uint|ivec|uvec)/.test(o.type) && (u += " @interpolate( flat )"), t.push(`${u} ${o.name} : ${this.getType(o.type)}`);
              } else e === "vertex" && a.includes(o) === false && a.push(o);
            }
          }
          const i = this.getBuiltins(e);
          i && t.push(i);
          const n = t.join(`,
	`);
          return e === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + n) : n;
        }
        getUniforms(e) {
          const t = this.uniforms[e], i = [], n = [], r = [], a = {};
          for (const o of t) {
            const u = o.groupNode.name, c = this.bindingsIndexes[u];
            if (o.type === "texture" || o.type === "cubeTexture" || o.type === "storageTexture" || o.type === "texture3D") {
              const h = o.node.value;
              (e === "fragment" || e === "compute") && this.isUnfilterable(h) === false && o.node.isStorageTextureNode !== true && (this.isSampleCompare(h) ? i.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${o.name}_sampler : sampler_comparison;`) : i.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${o.name}_sampler : sampler;`));
              let d, f = "";
              const { primarySamples: p } = this.renderer.backend.utils.getTextureSampleData(h);
              if (p > 1 && (f = "_multisampled"), h.isCubeTexture === true) d = "texture_cube<f32>";
              else if (h.isDataArrayTexture === true || h.isCompressedArrayTexture === true) d = "texture_2d_array<f32>";
              else if (h.isDepthTexture === true) d = `texture_depth${f}_2d`;
              else if (h.isVideoTexture === true) d = "texture_external";
              else if (h.isData3DTexture === true) d = "texture_3d<f32>";
              else if (o.node.isStorageTextureNode === true) {
                const g = Mg(h), _ = this.getStorageAccess(o.node, e);
                d = `texture_storage_2d<${g}, ${_}>`;
              } else {
                const g = this.getComponentTypeFromTexture(h).charAt(0);
                d = `texture${f}_2d<${g}32>`;
              }
              i.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${o.name} : ${d};`);
            } else if (o.type === "buffer" || o.type === "storageBuffer" || o.type === "indirectStorageBuffer") {
              const h = o.node, d = this.getType(h.bufferType), f = h.bufferCount, p = f > 0 && o.type === "buffer" ? ", " + f : "", g = h.isAtomic ? `atomic<${d}>` : `${d}`, _ = `	${o.name} : array< ${g}${p} >
`, m = h.isStorageBufferNode ? `storage, ${this.getStorageAccess(h, e)}` : "uniform";
              n.push(this._getWGSLStructBinding("NodeBuffer_" + h.id, _, m, c.binding++, c.group));
            } else {
              const h = this.getType(this.getVectorType(o.type)), d = o.groupNode.name;
              (a[d] || (a[d] = {
                index: c.binding++,
                id: c.group,
                snippets: []
              })).snippets.push(`	${o.name} : ${h}`);
            }
          }
          for (const o in a) {
            const u = a[o];
            r.push(this._getWGSLStructBinding(o, u.snippets.join(`,
`), "uniform", u.index, u.id));
          }
          let l = i.join(`
`);
          return l += n.join(`
`), l += r.join(`
`), l;
        }
        buildCode() {
          const e = this.material !== null ? {
            fragment: {},
            vertex: {}
          } : {
            compute: {}
          };
          this.sortBindingGroups();
          for (const t in e) {
            const i = e[t];
            i.uniforms = this.getUniforms(t), i.attributes = this.getAttributes(t), i.varyings = this.getVaryings(t), i.structs = this.getStructs(t), i.vars = this.getVars(t), i.codes = this.getCodes(t), i.directives = this.getDirectives(t), i.scopedArrays = this.getScopedArrays(t);
            let n = `// code

`;
            n += this.flowCode[t];
            const r = this.flowNodes[t], a = r[r.length - 1], l = a.outputNode, o = l !== void 0 && l.isOutputStructNode === true;
            for (const u of r) {
              const c = this.getFlowData(u), h = u.name;
              if (h && (n.length > 0 && (n += `
`), n += `	// flow -> ${h}
	`), n += `${c.code}
	`, u === a && t !== "compute") {
                if (n += `// result

	`, t === "vertex") n += `varyings.Vertex = ${c.result};`;
                else if (t === "fragment") if (o) i.returnType = l.nodeType, n += `return ${c.result};`;
                else {
                  let d = "	@location(0) color: vec4<f32>";
                  const f = this.getBuiltins("output");
                  f && (d += `,
	` + f), i.returnType = "OutputStruct", i.structs += this._getWGSLStruct("OutputStruct", d), i.structs += `
var<private> output : OutputStruct;

`, n += `output.color = ${c.result};

	return output;`;
                }
              }
            }
            i.flow = n;
          }
          this.material !== null ? (this.vertexShader = this._getWGSLVertexCode(e.vertex), this.fragmentShader = this._getWGSLFragmentCode(e.fragment)) : this.computeShader = this._getWGSLComputeCode(e.compute, (this.object.workgroupSize || [
            64
          ]).join(", "));
        }
        getMethod(e, t = null) {
          let i;
          return t !== null && (i = this._getWGSLMethod(e + "_" + t)), i === void 0 && (i = this._getWGSLMethod(e)), i || e;
        }
        getType(e) {
          return h4[e] || e;
        }
        isAvailable(e) {
          let t = Xb[e];
          return t === void 0 && (e === "float32Filterable" ? t = this.renderer.hasFeature("float32-filterable") : e === "clipDistance" && (t = this.renderer.hasFeature("clip-distances")), Xb[e] = t), t;
        }
        _getWGSLMethod(e) {
          return bi[e] !== void 0 && this._include(e), gl[e];
        }
        _include(e) {
          const t = bi[e];
          return t.build(this), this.currentFunctionNode !== null && this.currentFunctionNode.includes.push(t), t;
        }
        _getWGSLVertexCode(e) {
          return `${this.getSignature()}
// directives
${e.directives}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`;
        }
        _getWGSLFragmentCode(e) {
          return `${this.getSignature()}
// global
${NA}

// uniforms
${e.uniforms}

// structs
${e.structs}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
        }
        _getWGSLComputeCode(e, t) {
          return `${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${t} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${t}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${t});

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
        }
        _getWGSLStruct(e, t) {
          return `
struct ${e} {
${t}
};`;
        }
        _getWGSLStructBinding(e, t, i, n = 0, r = 0) {
          const a = e + "Struct";
          return `${this._getWGSLStruct(a, t)}
@binding( ${n} ) @group( ${r} )
var<${i}> ${e} : ${a};`;
        }
      }
      class f4 {
        constructor(e) {
          this.backend = e;
        }
        getCurrentDepthStencilFormat(e) {
          let t;
          return e.depthTexture !== null ? t = this.getTextureFormatGPU(e.depthTexture) : e.depth && e.stencil ? t = S.Depth24PlusStencil8 : e.depth && (t = S.Depth24Plus), t;
        }
        getTextureFormatGPU(e) {
          return this.backend.get(e).format;
        }
        getTextureSampleData(e) {
          let t;
          if (e.isFramebufferTexture) t = 1;
          else if (e.isDepthTexture && !e.renderTarget) {
            const r = this.backend.renderer, a = r.getRenderTarget();
            t = a ? a.samples : r.samples;
          } else e.renderTarget && (t = e.renderTarget.samples);
          t = t || 1;
          const i = t > 1 && e.renderTarget !== null && e.isDepthTexture !== true && e.isFramebufferTexture !== true;
          return {
            samples: t,
            primarySamples: i ? 1 : t,
            isMSAA: i
          };
        }
        getCurrentColorFormat(e) {
          let t;
          return e.textures !== null ? t = this.getTextureFormatGPU(e.textures[0]) : t = this.getPreferredCanvasFormat(), t;
        }
        getCurrentColorSpace(e) {
          return e.textures !== null ? e.textures[0].colorSpace : this.backend.renderer.outputColorSpace;
        }
        getPrimitiveTopology(e, t) {
          if (e.isPoints) return Va.PointList;
          if (e.isLineSegments || e.isMesh && t.wireframe === true) return Va.LineList;
          if (e.isLine) return Va.LineStrip;
          if (e.isMesh) return Va.TriangleList;
        }
        getSampleCount(e) {
          let t = 1;
          return e > 1 && (t = Math.pow(2, Math.floor(Math.log2(e))), t === 2 && (t = 4)), t;
        }
        getSampleCountRenderContext(e) {
          return e.textures !== null ? this.getSampleCount(e.sampleCount) : this.getSampleCount(this.backend.renderer.samples);
        }
        getPreferredCanvasFormat() {
          return navigator.userAgent.includes("Quest") ? S.BGRA8Unorm : navigator.gpu.getPreferredCanvasFormat();
        }
      }
      const p4 = /* @__PURE__ */ new Map([
        [
          Int8Array,
          [
            "sint8",
            "snorm8"
          ]
        ],
        [
          Uint8Array,
          [
            "uint8",
            "unorm8"
          ]
        ],
        [
          Int16Array,
          [
            "sint16",
            "snorm16"
          ]
        ],
        [
          Uint16Array,
          [
            "uint16",
            "unorm16"
          ]
        ],
        [
          Int32Array,
          [
            "sint32",
            "snorm32"
          ]
        ],
        [
          Uint32Array,
          [
            "uint32",
            "unorm32"
          ]
        ],
        [
          Float32Array,
          [
            "float32"
          ]
        ]
      ]), m4 = /* @__PURE__ */ new Map([
        [
          Fv,
          [
            "float16"
          ]
        ]
      ]), g4 = /* @__PURE__ */ new Map([
        [
          Int32Array,
          "sint32"
        ],
        [
          Int16Array,
          "sint32"
        ],
        [
          Uint32Array,
          "uint32"
        ],
        [
          Uint16Array,
          "uint32"
        ],
        [
          Float32Array,
          "float32"
        ]
      ]);
      class y4 {
        constructor(e) {
          this.backend = e;
        }
        createAttribute(e, t) {
          const i = this._getBufferAttribute(e), n = this.backend, r = n.get(i);
          let a = r.buffer;
          if (a === void 0) {
            const l = n.device;
            let o = i.array;
            if (e.normalized === false && (o.constructor === Int16Array || o.constructor === Uint16Array)) {
              const c = new Uint32Array(o.length);
              for (let h = 0; h < o.length; h++) c[h] = o[h];
              o = c;
            }
            if (i.array = o, (i.isStorageBufferAttribute || i.isStorageInstancedBufferAttribute) && i.itemSize === 3) {
              o = new o.constructor(i.count * 4);
              for (let c = 0; c < i.count; c++) o.set(i.array.subarray(c * 3, c * 3 + 3), c * 4);
              i.itemSize = 4, i.array = o;
            }
            const u = o.byteLength + (4 - o.byteLength % 4) % 4;
            a = l.createBuffer({
              label: i.name,
              size: u,
              usage: t,
              mappedAtCreation: true
            }), new o.constructor(a.getMappedRange()).set(o), a.unmap(), r.buffer = a;
          }
        }
        updateAttribute(e) {
          const t = this._getBufferAttribute(e), i = this.backend, n = i.device, r = i.get(t).buffer, a = t.array, l = this._isTypedArray(a), o = t.updateRanges;
          if (o.length === 0) n.queue.writeBuffer(r, 0, a, 0);
          else {
            const u = l ? 1 : a.BYTES_PER_ELEMENT;
            for (let c = 0, h = o.length; c < h; c++) {
              const d = o[c], f = d.start * u, p = d.count * u;
              n.queue.writeBuffer(r, 0, a, f, p);
            }
            t.clearUpdateRanges();
          }
        }
        createShaderVertexBuffers(e) {
          const t = e.getAttributes(), i = /* @__PURE__ */ new Map();
          for (let n = 0; n < t.length; n++) {
            const r = t[n], a = r.array.BYTES_PER_ELEMENT, l = this._getBufferAttribute(r);
            let o = i.get(l);
            if (o === void 0) {
              let h, d;
              r.isInterleavedBufferAttribute === true ? (h = r.data.stride * a, d = r.data.isInstancedInterleavedBuffer ? Lc.Instance : Lc.Vertex) : (h = r.itemSize * a, d = r.isInstancedBufferAttribute ? Lc.Instance : Lc.Vertex), r.normalized === false && (r.array.constructor === Int16Array || r.array.constructor === Uint16Array) && (h = 4), o = {
                arrayStride: h,
                attributes: [],
                stepMode: d
              }, i.set(l, o);
            }
            const u = this._getVertexFormat(r), c = r.isInterleavedBufferAttribute === true ? r.offset * a : 0;
            o.attributes.push({
              shaderLocation: n,
              offset: c,
              format: u
            });
          }
          return Array.from(i.values());
        }
        destroyAttribute(e) {
          const t = this.backend;
          t.get(this._getBufferAttribute(e)).buffer.destroy(), t.delete(e);
        }
        async getArrayBufferAsync(e) {
          const t = this.backend, i = t.device, r = t.get(this._getBufferAttribute(e)).buffer, a = r.size, l = i.createBuffer({
            label: `${e.name}_readback`,
            size: a,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
          }), o = i.createCommandEncoder({
            label: `readback_encoder_${e.name}`
          });
          o.copyBufferToBuffer(r, 0, l, 0, a);
          const u = o.finish();
          i.queue.submit([
            u
          ]), await l.mapAsync(GPUMapMode.READ);
          const c = l.getMappedRange(), h = new e.array.constructor(c.slice(0));
          return l.unmap(), h.buffer;
        }
        _getVertexFormat(e) {
          const { itemSize: t, normalized: i } = e, n = e.array.constructor, r = e.constructor;
          let a;
          if (t === 1) a = g4.get(n);
          else {
            const o = (m4.get(r) || p4.get(n))[i ? 1 : 0];
            if (o) {
              const u = n.BYTES_PER_ELEMENT * t, h = Math.floor((u + 3) / 4) * 4 / n.BYTES_PER_ELEMENT;
              if (h % 1) throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
              a = `${o}x${h}`;
            }
          }
          return a || console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."), a;
        }
        _isTypedArray(e) {
          return ArrayBuffer.isView(e) && !(e instanceof DataView);
        }
        _getBufferAttribute(e) {
          return e.isInterleavedBufferAttribute && (e = e.data), e;
        }
      }
      class x4 {
        constructor(e) {
          this.backend = e, this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
        }
        createBindingsLayout(e) {
          const t = this.backend, i = t.device, n = [];
          let r = 0;
          for (const a of e.bindings) {
            const l = {
              binding: r++,
              visibility: a.visibility
            };
            if (a.isUniformBuffer || a.isStorageBuffer) {
              const o = {};
              a.isStorageBuffer && (a.visibility & 4 && (a.access === Ls.READ_WRITE || a.access === Ls.WRITE_ONLY) ? o.type = Pp.Storage : o.type = Pp.ReadOnlyStorage), l.buffer = o;
            } else if (a.isSampler) {
              const o = {};
              a.texture.isDepthTexture && a.texture.compareFunction !== null && (o.type = "comparison"), l.sampler = o;
            } else if (a.isSampledTexture && a.texture.isVideoTexture) l.externalTexture = {};
            else if (a.isSampledTexture && a.store) {
              const o = {};
              o.format = this.backend.get(a.texture).texture.format;
              const u = a.access;
              u === Ls.READ_WRITE ? o.access = kp.ReadWrite : u === Ls.WRITE_ONLY ? o.access = kp.WriteOnly : o.access = kp.ReadOnly, l.storageTexture = o;
            } else if (a.isSampledTexture) {
              const o = {}, { primarySamples: u } = t.utils.getTextureSampleData(a.texture);
              if (u > 1 && (o.multisampled = true, a.texture.isDepthTexture || (o.sampleType = xa.UnfilterableFloat)), a.texture.isDepthTexture) o.sampleType = xa.Depth;
              else if (a.texture.isDataTexture || a.texture.isDataArrayTexture || a.texture.isData3DTexture) {
                const c = a.texture.type;
                c === Dt ? o.sampleType = xa.SInt : c === Tt ? o.sampleType = xa.UInt : c === Yt && (this.backend.hasFeature("float32-filterable") ? o.sampleType = xa.Float : o.sampleType = xa.UnfilterableFloat);
              }
              a.isSampledCubeTexture ? o.viewDimension = Ht.Cube : a.texture.isDataArrayTexture || a.texture.isCompressedArrayTexture ? o.viewDimension = Ht.TwoDArray : a.isSampledTexture3D && (o.viewDimension = Ht.ThreeD), l.texture = o;
            } else console.error(`WebGPUBindingUtils: Unsupported binding "${a}".`);
            n.push(l);
          }
          return i.createBindGroupLayout({
            entries: n
          });
        }
        createBindings(e, t, i, n = 0) {
          const { backend: r, bindGroupLayoutCache: a } = this, l = r.get(e);
          let o = a.get(e.bindingsReference);
          o === void 0 && (o = this.createBindingsLayout(e), a.set(e.bindingsReference, o));
          let u;
          i > 0 && (l.groups === void 0 && (l.groups = [], l.versions = []), l.versions[i] === n && (u = l.groups[i])), u === void 0 && (u = this.createBindGroup(e, o), i > 0 && (l.groups[i] = u, l.versions[i] = n)), l.group = u, l.layout = o;
        }
        updateBinding(e) {
          const t = this.backend, i = t.device, n = e.buffer, r = t.get(e).buffer;
          i.queue.writeBuffer(r, 0, n, 0);
        }
        createBindGroup(e, t) {
          const i = this.backend, n = i.device;
          let r = 0;
          const a = [];
          for (const l of e.bindings) {
            if (l.isUniformBuffer) {
              const o = i.get(l);
              if (o.buffer === void 0) {
                const u = l.byteLength, c = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, h = n.createBuffer({
                  label: "bindingBuffer_" + l.name,
                  size: u,
                  usage: c
                });
                o.buffer = h;
              }
              a.push({
                binding: r,
                resource: {
                  buffer: o.buffer
                }
              });
            } else if (l.isStorageBuffer) {
              const o = i.get(l);
              if (o.buffer === void 0) {
                const u = l.attribute;
                o.buffer = i.get(u).buffer;
              }
              a.push({
                binding: r,
                resource: {
                  buffer: o.buffer
                }
              });
            } else if (l.isSampler) {
              const o = i.get(l.texture);
              a.push({
                binding: r,
                resource: o.sampler
              });
            } else if (l.isSampledTexture) {
              const o = i.get(l.texture);
              let u;
              if (o.externalTexture !== void 0) u = n.importExternalTexture({
                source: o.externalTexture
              });
              else {
                const c = l.store ? 1 : o.texture.mipLevelCount, h = `view-${o.texture.width}-${o.texture.height}-${c}`;
                if (u = o[h], u === void 0) {
                  const d = $L.All;
                  let f;
                  l.isSampledCubeTexture ? f = Ht.Cube : l.isSampledTexture3D ? f = Ht.ThreeD : l.texture.isDataArrayTexture || l.texture.isCompressedArrayTexture ? f = Ht.TwoDArray : f = Ht.TwoD, u = o[h] = o.texture.createView({
                    aspect: d,
                    dimension: f,
                    mipLevelCount: c
                  });
                }
              }
              a.push({
                binding: r,
                resource: u
              });
            }
            r++;
          }
          return n.createBindGroup({
            label: "bindGroup_" + e.name,
            layout: t,
            entries: a
          });
        }
      }
      class _4 {
        constructor(e) {
          this.backend = e;
        }
        _getSampleCount(e) {
          return this.backend.utils.getSampleCountRenderContext(e);
        }
        createRenderPipeline(e, t) {
          const { object: i, material: n, geometry: r, pipeline: a } = e, { vertexProgram: l, fragmentProgram: o } = a, u = this.backend, c = u.device, h = u.utils, d = u.get(a), f = [];
          for (const ce of e.getBindings()) {
            const Fe = u.get(ce);
            f.push(Fe.layout);
          }
          const p = u.attributeUtils.createShaderVertexBuffers(e);
          let g;
          n.transparent === true && n.blending !== xo && (g = this._getBlending(n));
          let _ = {};
          n.stencilWrite === true && (_ = {
            compare: this._getStencilCompare(n),
            failOp: this._getStencilOperation(n.stencilFail),
            depthFailOp: this._getStencilOperation(n.stencilZFail),
            passOp: this._getStencilOperation(n.stencilZPass)
          });
          const m = this._getColorWriteMask(n), y = [];
          if (e.context.textures !== null) {
            const ce = e.context.textures;
            for (let Fe = 0; Fe < ce.length; Fe++) {
              const qe = h.getTextureFormatGPU(ce[Fe]);
              y.push({
                format: qe,
                blend: g,
                writeMask: m
              });
            }
          } else {
            const ce = h.getCurrentColorFormat(e.context);
            y.push({
              format: ce,
              blend: g,
              writeMask: m
            });
          }
          const x = u.get(l).module, b = u.get(o).module, T = this._getPrimitiveState(i, r, n), N = this._getDepthCompare(n), A = h.getCurrentDepthStencilFormat(e.context), w = this._getSampleCount(e.context), k = {
            label: `renderPipeline_${n.name || n.type}_${n.id}`,
            vertex: Object.assign({}, x, {
              buffers: p
            }),
            fragment: Object.assign({}, b, {
              targets: y
            }),
            primitive: T,
            multisample: {
              count: w,
              alphaToCoverageEnabled: n.alphaToCoverage && w > 1
            },
            layout: c.createPipelineLayout({
              bindGroupLayouts: f
            })
          }, G = {}, I = e.context.depth, be = e.context.stencil;
          if ((I === true || be === true) && (I === true && (G.format = A, G.depthWriteEnabled = n.depthWrite, G.depthCompare = N), be === true && (G.stencilFront = _, G.stencilBack = {}, G.stencilReadMask = n.stencilFuncMask, G.stencilWriteMask = n.stencilWriteMask), k.depthStencil = G), t === null) d.pipeline = c.createRenderPipeline(k);
          else {
            const ce = new Promise((Fe) => {
              c.createRenderPipelineAsync(k).then((qe) => {
                d.pipeline = qe, Fe();
              });
            });
            t.push(ce);
          }
        }
        createBundleEncoder(e) {
          const t = this.backend, { utils: i, device: n } = t, r = i.getCurrentDepthStencilFormat(e), a = i.getCurrentColorFormat(e), l = this._getSampleCount(e), o = {
            label: "renderBundleEncoder",
            colorFormats: [
              a
            ],
            depthStencilFormat: r,
            sampleCount: l
          };
          return n.createRenderBundleEncoder(o);
        }
        createComputePipeline(e, t) {
          const i = this.backend, n = i.device, r = i.get(e.computeProgram).module, a = i.get(e), l = [];
          for (const o of t) {
            const u = i.get(o);
            l.push(u.layout);
          }
          a.pipeline = n.createComputePipeline({
            compute: r,
            layout: n.createPipelineLayout({
              bindGroupLayouts: l
            })
          });
        }
        _getBlending(e) {
          let t, i;
          const n = e.blending, r = e.blendSrc, a = e.blendDst, l = e.blendEquation;
          if (n === tv) {
            const o = e.blendSrcAlpha !== null ? e.blendSrcAlpha : r, u = e.blendDstAlpha !== null ? e.blendDstAlpha : a, c = e.blendEquationAlpha !== null ? e.blendEquationAlpha : l;
            t = {
              srcFactor: this._getBlendFactor(r),
              dstFactor: this._getBlendFactor(a),
              operation: this._getBlendOperation(l)
            }, i = {
              srcFactor: this._getBlendFactor(o),
              dstFactor: this._getBlendFactor(u),
              operation: this._getBlendOperation(c)
            };
          } else {
            const o = e.premultipliedAlpha, u = (c, h, d, f) => {
              t = {
                srcFactor: c,
                dstFactor: h,
                operation: or.Add
              }, i = {
                srcFactor: d,
                dstFactor: f,
                operation: or.Add
              };
            };
            if (o) switch (n) {
              case kn:
                u(j.One, j.OneMinusSrcAlpha, j.One, j.OneMinusSrcAlpha);
                break;
              case Hh:
                u(j.One, j.One, j.One, j.One);
                break;
              case qh:
                u(j.Zero, j.OneMinusSrc, j.Zero, j.One);
                break;
              case Yh:
                u(j.Zero, j.Src, j.Zero, j.SrcAlpha);
                break;
            }
            else switch (n) {
              case kn:
                u(j.SrcAlpha, j.OneMinusSrcAlpha, j.One, j.OneMinusSrcAlpha);
                break;
              case Hh:
                u(j.SrcAlpha, j.One, j.SrcAlpha, j.One);
                break;
              case qh:
                u(j.Zero, j.OneMinusSrc, j.Zero, j.One);
                break;
              case Yh:
                u(j.Zero, j.Src, j.Zero, j.Src);
                break;
            }
          }
          if (t !== void 0 && i !== void 0) return {
            color: t,
            alpha: i
          };
          console.error("THREE.WebGPURenderer: Invalid blending: ", n);
        }
        _getBlendFactor(e) {
          let t;
          switch (e) {
            case nv:
              t = j.Zero;
              break;
            case rv:
              t = j.One;
              break;
            case av:
              t = j.Src;
              break;
            case ov:
              t = j.OneMinusSrc;
              break;
            case Wh:
              t = j.SrcAlpha;
              break;
            case jh:
              t = j.OneMinusSrcAlpha;
              break;
            case cv:
              t = j.Dst;
              break;
            case hv:
              t = j.OneMinusDstColor;
              break;
            case lv:
              t = j.DstAlpha;
              break;
            case uv:
              t = j.OneMinusDstAlpha;
              break;
            case dv:
              t = j.SrcAlphaSaturated;
              break;
            case gO:
              t = j.Constant;
              break;
            case yO:
              t = j.OneMinusConstant;
              break;
            default:
              console.error("THREE.WebGPURenderer: Blend factor not supported.", e);
          }
          return t;
        }
        _getStencilCompare(e) {
          let t;
          const i = e.stencilFunc;
          switch (i) {
            case TR:
              t = bt.Never;
              break;
            case lg:
              t = bt.Always;
              break;
            case vR:
              t = bt.Less;
              break;
            case AR:
              t = bt.LessEqual;
              break;
            case MR:
              t = bt.Equal;
              break;
            case ER:
              t = bt.GreaterEqual;
              break;
            case NR:
              t = bt.Greater;
              break;
            case wR:
              t = bt.NotEqual;
              break;
            default:
              console.error("THREE.WebGPURenderer: Invalid stencil function.", i);
          }
          return t;
        }
        _getStencilOperation(e) {
          let t;
          switch (e) {
            case cr:
              t = mn.Keep;
              break;
            case mR:
              t = mn.Zero;
              break;
            case gR:
              t = mn.Replace;
              break;
            case SR:
              t = mn.Invert;
              break;
            case yR:
              t = mn.IncrementClamp;
              break;
            case xR:
              t = mn.DecrementClamp;
              break;
            case _R:
              t = mn.IncrementWrap;
              break;
            case bR:
              t = mn.DecrementWrap;
              break;
            default:
              console.error("THREE.WebGPURenderer: Invalid stencil operation.", t);
          }
          return t;
        }
        _getBlendOperation(e) {
          let t;
          switch (e) {
            case Mn:
              t = or.Add;
              break;
            case iv:
              t = or.Subtract;
              break;
            case sv:
              t = or.ReverseSubtract;
              break;
            case Q2:
              t = or.Min;
              break;
            case K2:
              t = or.Max;
              break;
            default:
              console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", e);
          }
          return t;
        }
        _getPrimitiveState(e, t, i) {
          const n = {}, r = this.backend.utils;
          switch (n.topology = r.getPrimitiveTopology(e, i), t.index !== null && e.isLine === true && e.isLineSegments !== true && (n.stripIndexFormat = t.index.array instanceof Uint16Array ? Ao.Uint16 : Ao.Uint32), i.side) {
            case yo:
              n.frontFace = zp.CCW, n.cullMode = Lp.Back;
              break;
            case Fi:
              n.frontFace = zp.CCW, n.cullMode = Lp.Front;
              break;
            case Ka:
              n.frontFace = zp.CCW, n.cullMode = Lp.None;
              break;
            default:
              console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.", i.side);
              break;
          }
          return n;
        }
        _getColorWriteMask(e) {
          return e.colorWrite === true ? Yb.All : Yb.None;
        }
        _getDepthCompare(e) {
          let t;
          if (e.depthTest === false) t = bt.Always;
          else {
            const i = e.depthFunc;
            switch (i) {
              case fv:
                t = bt.Never;
                break;
              case pv:
                t = bt.Always;
                break;
              case mv:
                t = bt.Less;
                break;
              case $h:
                t = bt.LessEqual;
                break;
              case gv:
                t = bt.Equal;
                break;
              case yv:
                t = bt.GreaterEqual;
                break;
              case xv:
                t = bt.Greater;
                break;
              case _v:
                t = bt.NotEqual;
                break;
              default:
                console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", i);
            }
          }
          return t;
        }
      }
      class b4 extends AA {
        constructor(e = {}) {
          super(e), this.isWebGPUBackend = true, this.parameters.alpha = e.alpha === void 0 ? true : e.alpha, this.parameters.requiredLimits = e.requiredLimits === void 0 ? {} : e.requiredLimits, this.trackTimestamp = e.trackTimestamp === true, this.device = null, this.context = null, this.colorBuffer = null, this.defaultRenderPassdescriptor = null, this.utils = new f4(this), this.attributeUtils = new y4(this), this.bindingUtils = new x4(this), this.pipelineUtils = new _4(this), this.textureUtils = new s4(this), this.occludedResolveCache = /* @__PURE__ */ new Map();
        }
        async init(e) {
          await super.init(e);
          const t = this.parameters;
          let i;
          if (t.device === void 0) {
            const a = {
              powerPreference: t.powerPreference
            }, l = typeof navigator < "u" ? await navigator.gpu.requestAdapter(a) : null;
            if (l === null) throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
            const o = Object.values(vg), u = [];
            for (const h of o) l.features.has(h) && u.push(h);
            const c = {
              requiredFeatures: u,
              requiredLimits: t.requiredLimits
            };
            i = await l.requestDevice(c);
          } else i = t.device;
          i.lost.then((a) => {
            const l = {
              api: "WebGPU",
              message: a.message || "Unknown reason",
              reason: a.reason || null,
              originalEvent: a
            };
            e.onDeviceLost(l);
          });
          const n = t.context !== void 0 ? t.context : e.domElement.getContext("webgpu");
          this.device = i, this.context = n;
          const r = t.alpha ? "premultiplied" : "opaque";
          this.trackTimestamp = this.trackTimestamp && this.hasFeature(vg.TimestampQuery), this.context.configure({
            device: this.device,
            format: this.utils.getPreferredCanvasFormat(),
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            alphaMode: r
          }), this.updateSize();
        }
        get coordinateSystem() {
          return Zn;
        }
        async getArrayBufferAsync(e) {
          return await this.attributeUtils.getArrayBufferAsync(e);
        }
        getContext() {
          return this.context;
        }
        _getDefaultRenderPassDescriptor() {
          let e = this.defaultRenderPassdescriptor;
          if (e === null) {
            const i = this.renderer;
            e = {
              colorAttachments: [
                {
                  view: null
                }
              ]
            }, (this.renderer.depth === true || this.renderer.stencil === true) && (e.depthStencilAttachment = {
              view: this.textureUtils.getDepthBuffer(i.depth, i.stencil).createView()
            });
            const n = e.colorAttachments[0];
            this.renderer.samples > 0 ? n.view = this.colorBuffer.createView() : n.resolveTarget = void 0, this.defaultRenderPassdescriptor = e;
          }
          const t = e.colorAttachments[0];
          return this.renderer.samples > 0 ? t.resolveTarget = this.context.getCurrentTexture().createView() : t.view = this.context.getCurrentTexture().createView(), e;
        }
        _getRenderPassDescriptor(e, t = {}) {
          const i = e.renderTarget, n = this.get(i);
          let r = n.descriptors;
          if (r === void 0 || n.width !== i.width || n.height !== i.height || n.dimensions !== i.dimensions || n.activeMipmapLevel !== i.activeMipmapLevel || n.activeCubeFace !== e.activeCubeFace || n.samples !== i.samples || n.loadOp !== t.loadOp) {
            r = {}, n.descriptors = r;
            const o = () => {
              i.removeEventListener("dispose", o), this.delete(i);
            };
            i.addEventListener("dispose", o);
          }
          const a = e.getCacheKey();
          let l = r[a];
          if (l === void 0) {
            const o = e.textures, u = [];
            let c;
            for (let h = 0; h < o.length; h++) {
              const d = this.get(o[h]), f = {
                label: `colorAttachment_${h}`,
                baseMipLevel: e.activeMipmapLevel,
                mipLevelCount: 1,
                baseArrayLayer: e.activeCubeFace,
                arrayLayerCount: 1,
                dimension: Ht.TwoD
              };
              i.isRenderTarget3D ? (c = e.activeCubeFace, f.baseArrayLayer = 0, f.dimension = Ht.ThreeD, f.depthOrArrayLayers = o[h].image.depth) : i.isRenderTargetArray && (f.dimension = Ht.TwoDArray, f.depthOrArrayLayers = o[h].image.depth);
              const p = d.texture.createView(f);
              let g, _;
              d.msaaTexture !== void 0 ? (g = d.msaaTexture.createView(), _ = p) : (g = p, _ = void 0), u.push({
                view: g,
                depthSlice: c,
                resolveTarget: _,
                loadOp: Ye.Load,
                storeOp: wt.Store,
                ...t
              });
            }
            if (l = {
              colorAttachments: u
            }, e.depth) {
              const d = {
                view: this.get(e.depthTexture).texture.createView()
              };
              l.depthStencilAttachment = d;
            }
            r[a] = l, n.width = i.width, n.height = i.height, n.samples = i.samples, n.activeMipmapLevel = e.activeMipmapLevel, n.activeCubeFace = e.activeCubeFace, n.dimensions = i.dimensions, n.depthSlice = c, n.loadOp = u[0].loadOp;
          }
          return l;
        }
        beginRender(e) {
          const t = this.get(e), i = this.device, n = e.occlusionQueryCount;
          let r;
          n > 0 && (t.currentOcclusionQuerySet && t.currentOcclusionQuerySet.destroy(), t.currentOcclusionQueryBuffer && t.currentOcclusionQueryBuffer.destroy(), t.currentOcclusionQuerySet = t.occlusionQuerySet, t.currentOcclusionQueryBuffer = t.occlusionQueryBuffer, t.currentOcclusionQueryObjects = t.occlusionQueryObjects, r = i.createQuerySet({
            type: "occlusion",
            count: n,
            label: `occlusionQuerySet_${e.id}`
          }), t.occlusionQuerySet = r, t.occlusionQueryIndex = 0, t.occlusionQueryObjects = new Array(n), t.lastOcclusionObject = null);
          let a;
          e.textures === null ? a = this._getDefaultRenderPassDescriptor() : a = this._getRenderPassDescriptor(e, {
            loadOp: Ye.Load
          }), this.initTimestampQuery(e, a), a.occlusionQuerySet = r;
          const l = a.depthStencilAttachment;
          if (e.textures !== null) {
            const c = a.colorAttachments;
            for (let h = 0; h < c.length; h++) {
              const d = c[h];
              e.clearColor ? (d.clearValue = h === 0 ? e.clearColorValue : {
                r: 0,
                g: 0,
                b: 0,
                a: 1
              }, d.loadOp = Ye.Clear, d.storeOp = wt.Store) : (d.loadOp = Ye.Load, d.storeOp = wt.Store);
            }
          } else {
            const c = a.colorAttachments[0];
            e.clearColor ? (c.clearValue = e.clearColorValue, c.loadOp = Ye.Clear, c.storeOp = wt.Store) : (c.loadOp = Ye.Load, c.storeOp = wt.Store);
          }
          e.depth && (e.clearDepth ? (l.depthClearValue = e.clearDepthValue, l.depthLoadOp = Ye.Clear, l.depthStoreOp = wt.Store) : (l.depthLoadOp = Ye.Load, l.depthStoreOp = wt.Store)), e.stencil && (e.clearStencil ? (l.stencilClearValue = e.clearStencilValue, l.stencilLoadOp = Ye.Clear, l.stencilStoreOp = wt.Store) : (l.stencilLoadOp = Ye.Load, l.stencilStoreOp = wt.Store));
          const o = i.createCommandEncoder({
            label: "renderContext_" + e.id
          }), u = o.beginRenderPass(a);
          if (t.descriptor = a, t.encoder = o, t.currentPass = u, t.currentSets = {
            attributes: {},
            bindingGroups: [],
            pipeline: null,
            index: null
          }, t.renderBundles = [], e.viewport && this.updateViewport(e), e.scissor) {
            const { x: c, y: h, width: d, height: f } = e.scissorValue;
            u.setScissorRect(c, h, d, f);
          }
        }
        finishRender(e) {
          const t = this.get(e), i = e.occlusionQueryCount;
          if (t.renderBundles.length > 0 && t.currentPass.executeBundles(t.renderBundles), i > t.occlusionQueryIndex && t.currentPass.endOcclusionQuery(), t.currentPass.end(), i > 0) {
            const n = i * 8;
            let r = this.occludedResolveCache.get(n);
            r === void 0 && (r = this.device.createBuffer({
              size: n,
              usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
            }), this.occludedResolveCache.set(n, r));
            const a = this.device.createBuffer({
              size: n,
              usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });
            t.encoder.resolveQuerySet(t.occlusionQuerySet, 0, i, r, 0), t.encoder.copyBufferToBuffer(r, 0, a, 0, n), t.occlusionQueryBuffer = a, this.resolveOccludedAsync(e);
          }
          if (this.prepareTimestampBuffer(e, t.encoder), this.device.queue.submit([
            t.encoder.finish()
          ]), e.textures !== null) {
            const n = e.textures;
            for (let r = 0; r < n.length; r++) {
              const a = n[r];
              a.generateMipmaps === true && this.textureUtils.generateMipmaps(a);
            }
          }
        }
        isOccluded(e, t) {
          const i = this.get(e);
          return i.occluded && i.occluded.has(t);
        }
        async resolveOccludedAsync(e) {
          const t = this.get(e), { currentOcclusionQueryBuffer: i, currentOcclusionQueryObjects: n } = t;
          if (i && n) {
            const r = /* @__PURE__ */ new WeakSet();
            t.currentOcclusionQueryObjects = null, t.currentOcclusionQueryBuffer = null, await i.mapAsync(GPUMapMode.READ);
            const a = i.getMappedRange(), l = new BigUint64Array(a);
            for (let o = 0; o < n.length; o++) l[o] !== BigInt(0) && r.add(n[o]);
            i.destroy(), t.occluded = r;
          }
        }
        updateViewport(e) {
          const { currentPass: t } = this.get(e), { x: i, y: n, width: r, height: a, minDepth: l, maxDepth: o } = e.viewportValue;
          t.setViewport(i, n, r, a, l, o);
        }
        clear(e, t, i, n = null) {
          const r = this.device, a = this.renderer;
          let l = [], o, u, c, h;
          if (e) {
            const p = this.getClearColor();
            if (this.renderer.alpha === true) {
              const g = p.a;
              u = {
                r: p.r * g,
                g: p.g * g,
                b: p.b * g,
                a: g
              };
            } else u = {
              r: p.r,
              g: p.g,
              b: p.b,
              a: p.a
            };
          }
          if (n === null) {
            c = a.depth, h = a.stencil;
            const p = this._getDefaultRenderPassDescriptor();
            if (e) {
              l = p.colorAttachments;
              const g = l[0];
              g.clearValue = u, g.loadOp = Ye.Clear, g.storeOp = wt.Store;
            }
            (c || h) && (o = p.depthStencilAttachment);
          } else c = n.depth, h = n.stencil, e && (l = this._getRenderPassDescriptor(n, {
            loadOp: Ye.Clear
          }).colorAttachments), (c || h) && (o = {
            view: this.get(n.depthTexture).texture.createView()
          });
          c && (t ? (o.depthLoadOp = Ye.Clear, o.depthClearValue = a.getClearDepth(), o.depthStoreOp = wt.Store) : (o.depthLoadOp = Ye.Load, o.depthStoreOp = wt.Store)), h && (i ? (o.stencilLoadOp = Ye.Clear, o.stencilClearValue = a.getClearStencil(), o.stencilStoreOp = wt.Store) : (o.stencilLoadOp = Ye.Load, o.stencilStoreOp = wt.Store));
          const d = r.createCommandEncoder({});
          d.beginRenderPass({
            colorAttachments: l,
            depthStencilAttachment: o
          }).end(), r.queue.submit([
            d.finish()
          ]);
        }
        beginCompute(e) {
          const t = this.get(e), i = {};
          this.initTimestampQuery(e, i), t.cmdEncoderGPU = this.device.createCommandEncoder(), t.passEncoderGPU = t.cmdEncoderGPU.beginComputePass(i);
        }
        compute(e, t, i, n) {
          const { passEncoderGPU: r } = this.get(e), a = this.get(n).pipeline;
          r.setPipeline(a);
          for (let c = 0, h = i.length; c < h; c++) {
            const d = i[c], f = this.get(d);
            r.setBindGroup(c, f.group);
          }
          const l = this.device.limits.maxComputeWorkgroupsPerDimension, o = this.get(t);
          o.dispatchSize === void 0 && (o.dispatchSize = {
            x: 0,
            y: 1,
            z: 1
          });
          const { dispatchSize: u } = o;
          t.dispatchCount > l ? (u.x = Math.min(t.dispatchCount, l), u.y = Math.ceil(t.dispatchCount / l)) : u.x = t.dispatchCount, r.dispatchWorkgroups(u.x, u.y, u.z);
        }
        finishCompute(e) {
          const t = this.get(e);
          t.passEncoderGPU.end(), this.prepareTimestampBuffer(e, t.cmdEncoderGPU), this.device.queue.submit([
            t.cmdEncoderGPU.finish()
          ]);
        }
        async waitForGPU() {
          await this.device.queue.onSubmittedWorkDone();
        }
        draw(e, t) {
          const { object: i, context: n, pipeline: r } = e, a = e.getBindings(), l = this.get(n), o = this.get(r).pipeline, u = l.currentSets, c = l.currentPass, h = e.getDrawParameters();
          if (h === null) return;
          u.pipeline !== o && (c.setPipeline(o), u.pipeline = o);
          const d = u.bindingGroups;
          for (let _ = 0, m = a.length; _ < m; _++) {
            const y = a[_], x = this.get(y);
            d[y.index] !== y.id && (c.setBindGroup(y.index, x.group), d[y.index] = y.id);
          }
          const f = e.getIndex(), p = f !== null;
          if (p === true && u.index !== f) {
            const _ = this.get(f).buffer, m = f.array instanceof Uint16Array ? Ao.Uint16 : Ao.Uint32;
            c.setIndexBuffer(_, m), u.index = f;
          }
          const g = e.getVertexBuffers();
          for (let _ = 0, m = g.length; _ < m; _++) {
            const y = g[_];
            if (u.attributes[_] !== y) {
              const x = this.get(y).buffer;
              c.setVertexBuffer(_, x), u.attributes[_] = y;
            }
          }
          if (l.occlusionQuerySet !== void 0) {
            const _ = l.lastOcclusionObject;
            _ !== i && (_ !== null && _.occlusionTest === true && (c.endOcclusionQuery(), l.occlusionQueryIndex++), i.occlusionTest === true && (c.beginOcclusionQuery(l.occlusionQueryIndex), l.occlusionQueryObjects[l.occlusionQueryIndex] = i), l.lastOcclusionObject = i);
          }
          if (i.isBatchedMesh === true) {
            const _ = i._multiDrawStarts, m = i._multiDrawCounts, y = i._multiDrawCount, x = i._multiDrawInstances;
            for (let b = 0; b < y; b++) {
              const T = x ? x[b] : 1, N = T > 1 ? 0 : b;
              p === true ? c.drawIndexed(m[b], T, _[b] / f.array.BYTES_PER_ELEMENT, 0, N) : c.draw(m[b], T, _[b], N);
            }
          } else if (p === true) {
            const { vertexCount: _, instanceCount: m, firstVertex: y } = h, x = e.getIndirect();
            if (x !== null) {
              const b = this.get(x).buffer;
              c.drawIndexedIndirect(b, 0);
            } else c.drawIndexed(_, m, y, 0, 0);
            t.update(i, _, m);
          } else {
            const { vertexCount: _, instanceCount: m, firstVertex: y } = h, x = e.getIndirect();
            if (x !== null) {
              const b = this.get(x).buffer;
              c.drawIndirect(b, 0);
            } else c.draw(_, m, y, 0);
            t.update(i, _, m);
          }
        }
        needsRenderUpdate(e) {
          const t = this.get(e), { object: i, material: n } = e, r = this.utils, a = r.getSampleCountRenderContext(e.context), l = r.getCurrentColorSpace(e.context), o = r.getCurrentColorFormat(e.context), u = r.getCurrentDepthStencilFormat(e.context), c = r.getPrimitiveTopology(i, n);
          let h = false;
          return (t.material !== n || t.materialVersion !== n.version || t.transparent !== n.transparent || t.blending !== n.blending || t.premultipliedAlpha !== n.premultipliedAlpha || t.blendSrc !== n.blendSrc || t.blendDst !== n.blendDst || t.blendEquation !== n.blendEquation || t.blendSrcAlpha !== n.blendSrcAlpha || t.blendDstAlpha !== n.blendDstAlpha || t.blendEquationAlpha !== n.blendEquationAlpha || t.colorWrite !== n.colorWrite || t.depthWrite !== n.depthWrite || t.depthTest !== n.depthTest || t.depthFunc !== n.depthFunc || t.stencilWrite !== n.stencilWrite || t.stencilFunc !== n.stencilFunc || t.stencilFail !== n.stencilFail || t.stencilZFail !== n.stencilZFail || t.stencilZPass !== n.stencilZPass || t.stencilFuncMask !== n.stencilFuncMask || t.stencilWriteMask !== n.stencilWriteMask || t.side !== n.side || t.alphaToCoverage !== n.alphaToCoverage || t.sampleCount !== a || t.colorSpace !== l || t.colorFormat !== o || t.depthStencilFormat !== u || t.primitiveTopology !== c || t.clippingContextCacheKey !== e.clippingContextCacheKey) && (t.material = n, t.materialVersion = n.version, t.transparent = n.transparent, t.blending = n.blending, t.premultipliedAlpha = n.premultipliedAlpha, t.blendSrc = n.blendSrc, t.blendDst = n.blendDst, t.blendEquation = n.blendEquation, t.blendSrcAlpha = n.blendSrcAlpha, t.blendDstAlpha = n.blendDstAlpha, t.blendEquationAlpha = n.blendEquationAlpha, t.colorWrite = n.colorWrite, t.depthWrite = n.depthWrite, t.depthTest = n.depthTest, t.depthFunc = n.depthFunc, t.stencilWrite = n.stencilWrite, t.stencilFunc = n.stencilFunc, t.stencilFail = n.stencilFail, t.stencilZFail = n.stencilZFail, t.stencilZPass = n.stencilZPass, t.stencilFuncMask = n.stencilFuncMask, t.stencilWriteMask = n.stencilWriteMask, t.side = n.side, t.alphaToCoverage = n.alphaToCoverage, t.sampleCount = a, t.colorSpace = l, t.colorFormat = o, t.depthStencilFormat = u, t.primitiveTopology = c, t.clippingContextCacheKey = e.clippingContextCacheKey, h = true), h;
        }
        getRenderCacheKey(e) {
          const { object: t, material: i } = e, n = this.utils, r = e.context;
          return [
            i.transparent,
            i.blending,
            i.premultipliedAlpha,
            i.blendSrc,
            i.blendDst,
            i.blendEquation,
            i.blendSrcAlpha,
            i.blendDstAlpha,
            i.blendEquationAlpha,
            i.colorWrite,
            i.depthWrite,
            i.depthTest,
            i.depthFunc,
            i.stencilWrite,
            i.stencilFunc,
            i.stencilFail,
            i.stencilZFail,
            i.stencilZPass,
            i.stencilFuncMask,
            i.stencilWriteMask,
            i.side,
            n.getSampleCountRenderContext(r),
            n.getCurrentColorSpace(r),
            n.getCurrentColorFormat(r),
            n.getCurrentDepthStencilFormat(r),
            n.getPrimitiveTopology(t, i),
            e.getGeometryCacheKey(),
            e.clippingContextCacheKey
          ].join();
        }
        createSampler(e) {
          this.textureUtils.createSampler(e);
        }
        destroySampler(e) {
          this.textureUtils.destroySampler(e);
        }
        createDefaultTexture(e) {
          this.textureUtils.createDefaultTexture(e);
        }
        createTexture(e, t) {
          this.textureUtils.createTexture(e, t);
        }
        updateTexture(e, t) {
          this.textureUtils.updateTexture(e, t);
        }
        generateMipmaps(e) {
          this.textureUtils.generateMipmaps(e);
        }
        destroyTexture(e) {
          this.textureUtils.destroyTexture(e);
        }
        copyTextureToBuffer(e, t, i, n, r, a) {
          return this.textureUtils.copyTextureToBuffer(e, t, i, n, r, a);
        }
        initTimestampQuery(e, t) {
          if (!this.trackTimestamp) return;
          const i = this.get(e);
          if (!i.timeStampQuerySet) {
            const n = e.isComputeNode ? "compute" : "render", r = this.device.createQuerySet({
              type: "timestamp",
              count: 2,
              label: `timestamp_${n}_${e.id}`
            });
            Object.assign(t, {
              timestampWrites: {
                querySet: r,
                beginningOfPassWriteIndex: 0,
                endOfPassWriteIndex: 1
              }
            }), i.timeStampQuerySet = r;
          }
        }
        prepareTimestampBuffer(e, t) {
          if (!this.trackTimestamp) return;
          const i = this.get(e), n = 2 * BigInt64Array.BYTES_PER_ELEMENT;
          i.currentTimestampQueryBuffers === void 0 && (i.currentTimestampQueryBuffers = {
            resolveBuffer: this.device.createBuffer({
              label: "timestamp resolve buffer",
              size: n,
              usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
            }),
            resultBuffer: this.device.createBuffer({
              label: "timestamp result buffer",
              size: n,
              usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            })
          });
          const { resolveBuffer: r, resultBuffer: a } = i.currentTimestampQueryBuffers;
          t.resolveQuerySet(i.timeStampQuerySet, 0, 2, r, 0), a.mapState === "unmapped" && t.copyBufferToBuffer(r, 0, a, 0, n);
        }
        async resolveTimestampAsync(e, t = "render") {
          if (!this.trackTimestamp) return;
          const i = this.get(e);
          if (i.currentTimestampQueryBuffers === void 0) return;
          const { resultBuffer: n } = i.currentTimestampQueryBuffers;
          n.mapState === "unmapped" && n.mapAsync(GPUMapMode.READ).then(() => {
            const r = new BigUint64Array(n.getMappedRange()), a = Number(r[1] - r[0]) / 1e6;
            this.renderer.info.updateTimestamp(t, a), n.unmap();
          });
        }
        createNodeBuilder(e, t) {
          return new d4(e, t);
        }
        createProgram(e) {
          const t = this.get(e);
          t.module = {
            module: this.device.createShaderModule({
              code: e.code,
              label: e.stage + (e.name !== "" ? `_${e.name}` : "")
            }),
            entryPoint: "main"
          };
        }
        destroyProgram(e) {
          this.delete(e);
        }
        createRenderPipeline(e, t) {
          this.pipelineUtils.createRenderPipeline(e, t);
        }
        createComputePipeline(e, t) {
          this.pipelineUtils.createComputePipeline(e, t);
        }
        beginBundle(e) {
          const t = this.get(e);
          t._currentPass = t.currentPass, t._currentSets = t.currentSets, t.currentSets = {
            attributes: {},
            bindingGroups: [],
            pipeline: null,
            index: null
          }, t.currentPass = this.pipelineUtils.createBundleEncoder(e);
        }
        finishBundle(e, t) {
          const i = this.get(e), r = i.currentPass.finish();
          this.get(t).bundleGPU = r, i.currentSets = i._currentSets, i.currentPass = i._currentPass;
        }
        addBundle(e, t) {
          this.get(e).renderBundles.push(this.get(t).bundleGPU);
        }
        createBindings(e, t, i, n) {
          this.bindingUtils.createBindings(e, t, i, n);
        }
        updateBindings(e, t, i, n) {
          this.bindingUtils.createBindings(e, t, i, n);
        }
        updateBinding(e) {
          this.bindingUtils.updateBinding(e);
        }
        createIndexAttribute(e) {
          this.attributeUtils.createAttribute(e, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
        }
        createAttribute(e) {
          this.attributeUtils.createAttribute(e, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
        }
        createStorageAttribute(e) {
          this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
        }
        createIndirectStorageAttribute(e) {
          this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
        }
        updateAttribute(e) {
          this.attributeUtils.updateAttribute(e);
        }
        destroyAttribute(e) {
          this.attributeUtils.destroyAttribute(e);
        }
        updateSize() {
          this.colorBuffer = this.textureUtils.getColorBuffer(), this.defaultRenderPassdescriptor = null;
        }
        getMaxAnisotropy() {
          return 16;
        }
        hasFeature(e) {
          return this.device.features.has(e);
        }
        copyTextureToTexture(e, t, i = null, n = null, r = 0) {
          let a = 0, l = 0, o = 0, u = 0, c = 0, h = 0, d = e.image.width, f = e.image.height;
          i !== null && (u = i.x, c = i.y, h = i.z || 0, d = i.width, f = i.height), n !== null && (a = n.x, l = n.y, o = n.z || 0);
          const p = this.device.createCommandEncoder({
            label: "copyTextureToTexture_" + e.id + "_" + t.id
          }), g = this.get(e).texture, _ = this.get(t).texture;
          p.copyTextureToTexture({
            texture: g,
            mipLevel: r,
            origin: {
              x: u,
              y: c,
              z: h
            }
          }, {
            texture: _,
            mipLevel: r,
            origin: {
              x: a,
              y: l,
              z: o
            }
          }, [
            d,
            f,
            1
          ]), this.device.queue.submit([
            p.finish()
          ]);
        }
        copyFramebufferToTexture(e, t, i) {
          const n = this.get(t);
          let r = null;
          t.renderTarget ? e.isDepthTexture ? r = this.get(t.depthTexture).texture : r = this.get(t.textures[0]).texture : e.isDepthTexture ? r = this.textureUtils.getDepthBuffer(t.depth, t.stencil) : r = this.context.getCurrentTexture();
          const a = this.get(e).texture;
          if (r.format !== a.format) {
            console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", r.format, a.format);
            return;
          }
          let l;
          if (n.currentPass ? (n.currentPass.end(), l = n.encoder) : l = this.device.createCommandEncoder({
            label: "copyFramebufferToTexture_" + e.id
          }), l.copyTextureToTexture({
            texture: r,
            origin: [
              i.x,
              i.y,
              0
            ]
          }, {
            texture: a
          }, [
            i.z,
            i.w
          ]), e.generateMipmaps && this.textureUtils.generateMipmaps(e), n.currentPass) {
            const { descriptor: o } = n;
            for (let u = 0; u < o.colorAttachments.length; u++) o.colorAttachments[u].loadOp = Ye.Load;
            if (t.depth && (o.depthStencilAttachment.depthLoadOp = Ye.Load), t.stencil && (o.depthStencilAttachment.stencilLoadOp = Ye.Load), n.currentPass = l.beginRenderPass(o), n.currentSets = {
              attributes: {},
              bindingGroups: [],
              pipeline: null,
              index: null
            }, t.viewport && this.updateViewport(t), t.scissor) {
              const { x: u, y: c, width: h, height: d } = t.scissorValue;
              n.currentPass.setScissorRect(u, c, h, d);
            }
          } else this.device.queue.submit([
            l.finish()
          ]);
        }
      }
      class S4 extends Iv {
        constructor(e, t, i, n, r, a) {
          super(e, t, i, n, r, a), this.iesMap = null;
        }
        copy(e, t) {
          return super.copy(e, t), this.iesMap = e.iesMap, this;
        }
      }
      class T4 extends xA {
        constructor() {
          super(), this.addMaterial(oF, "MeshPhongMaterial"), this.addMaterial(tA, "MeshStandardMaterial"), this.addMaterial(jF, "MeshPhysicalMaterial"), this.addMaterial(QF, "MeshToonMaterial"), this.addMaterial(eF, "MeshBasicMaterial"), this.addMaterial(rF, "MeshLambertMaterial"), this.addMaterial($U, "MeshNormalMaterial"), this.addMaterial(tO, "MeshMatcapMaterial"), this.addMaterial(HU, "LineBasicMaterial"), this.addMaterial(YU, "LineDashedMaterial"), this.addMaterial(sO, "PointsMaterial"), this.addMaterial(oO, "SpriteMaterial"), this.addMaterial(cO, "ShadowMaterial"), this.addLight(Oz, LC), this.addLight(hL, Vv), this.addLight(dL, PC), this.addLight(gA, Iv), this.addLight(pL, Hv), this.addLight(mL, FC), this.addLight(gL, IC), this.addLight(fL, S4), this.addToneMapping(qO, tR), this.addToneMapping(YO, iR), this.addToneMapping(WO, sR), this.addToneMapping($O, nR), this.addToneMapping(KO, rR), this.addToneMapping(JO, aR);
        }
      }
      class v4 extends wL {
        constructor(e = {}) {
          let t;
          e.forceWebGL ? t = qb : (t = b4, e.getFallback = () => (console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."), new qb(e)));
          const i = new t(e);
          super(i, e), this.library = new T4(), this.isWebGPURenderer = true;
        }
      }
      const Qb = {
        type: "change"
      }, x0 = {
        type: "start"
      }, wA = {
        type: "end"
      }, Pc = new Ud(), Kb = new As(), M4 = Math.cos(70 * Ev.DEG2RAD), st = new v(), It = 2 * Math.PI, Ae = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      }, Ip = 1e-6;
      class A4 extends qC {
        constructor(e, t = null) {
          super(e, t), this.state = Ae.NONE, this.enabled = true, this.target = new v(), this.cursor = new v(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.zoomToCursor = false, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
          }, this.mouseButtons = {
            LEFT: Qa.ROTATE,
            MIDDLE: Qa.DOLLY,
            RIGHT: Qa.PAN
          }, this.touches = {
            ONE: za.ROTATE,
            TWO: za.DOLLY_PAN
          }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new v(), this._lastQuaternion = new Lr(), this._lastTargetPosition = new v(), this._quat = new Lr().setFromUnitVectors(e.up, new v(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new B_(), this._sphericalDelta = new B_(), this._scale = 1, this._panOffset = new v(), this._rotateStart = new q(), this._rotateEnd = new q(), this._rotateDelta = new q(), this._panStart = new q(), this._panEnd = new q(), this._panDelta = new q(), this._dollyStart = new q(), this._dollyEnd = new q(), this._dollyDelta = new q(), this._dollyDirection = new v(), this._mouse = new q(), this._performCursorZoom = false, this._pointers = [], this._pointerPositions = {}, this._controlActive = false, this._onPointerMove = w4.bind(this), this._onPointerDown = N4.bind(this), this._onPointerUp = E4.bind(this), this._onContextMenu = O4.bind(this), this._onMouseWheel = B4.bind(this), this._onKeyDown = D4.bind(this), this._onTouchStart = U4.bind(this), this._onTouchMove = F4.bind(this), this._onMouseDown = R4.bind(this), this._onMouseMove = C4.bind(this), this._interceptControlDown = z4.bind(this), this._interceptControlUp = L4.bind(this), this.domElement !== null && this.connect(), this.update();
        }
        connect() {
          this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, {
            passive: false
          }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
            passive: true,
            capture: true
          }), this.domElement.style.touchAction = "none";
        }
        disconnect() {
          this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
            capture: true
          }), this.domElement.style.touchAction = "auto";
        }
        dispose() {
          this.disconnect();
        }
        getPolarAngle() {
          return this._spherical.phi;
        }
        getAzimuthalAngle() {
          return this._spherical.theta;
        }
        getDistance() {
          return this.object.position.distanceTo(this.target);
        }
        listenToKeyEvents(e) {
          e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
        }
        stopListenToKeyEvents() {
          this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
        }
        saveState() {
          this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
        }
        reset() {
          this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(Qb), this.update(), this.state = Ae.NONE;
        }
        update(e = null) {
          const t = this.object.position;
          st.copy(t).sub(this.target), st.applyQuaternion(this._quat), this._spherical.setFromVector3(st), this.autoRotate && this.state === Ae.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
          let i = this.minAzimuthAngle, n = this.maxAzimuthAngle;
          isFinite(i) && isFinite(n) && (i < -Math.PI ? i += It : i > Math.PI && (i -= It), n < -Math.PI ? n += It : n > Math.PI && (n -= It), i <= n ? this._spherical.theta = Math.max(i, Math.min(n, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (i + n) / 2 ? Math.max(i, this._spherical.theta) : Math.min(n, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === true ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
          let r = false;
          if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) this._spherical.radius = this._clampDistance(this._spherical.radius);
          else {
            const a = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), r = a != this._spherical.radius;
          }
          if (st.setFromSpherical(this._spherical), st.applyQuaternion(this._quatInverse), t.copy(this.target).add(st), this.object.lookAt(this.target), this.enableDamping === true ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
            let a = null;
            if (this.object.isPerspectiveCamera) {
              const l = st.length();
              a = this._clampDistance(l * this._scale);
              const o = l - a;
              this.object.position.addScaledVector(this._dollyDirection, o), this.object.updateMatrixWorld(), r = !!o;
            } else if (this.object.isOrthographicCamera) {
              const l = new v(this._mouse.x, this._mouse.y, 0);
              l.unproject(this.object);
              const o = this.object.zoom;
              this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), r = o !== this.object.zoom;
              const u = new v(this._mouse.x, this._mouse.y, 0);
              u.unproject(this.object), this.object.position.sub(u).add(l), this.object.updateMatrixWorld(), a = st.length();
            } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = false;
            a !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(a).add(this.object.position) : (Pc.origin.copy(this.object.position), Pc.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(Pc.direction)) < M4 ? this.object.lookAt(this.target) : (Kb.setFromNormalAndCoplanarPoint(this.object.up, this.target), Pc.intersectPlane(Kb, this.target))));
          } else if (this.object.isOrthographicCamera) {
            const a = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), a !== this.object.zoom && (this.object.updateProjectionMatrix(), r = true);
          }
          return this._scale = 1, this._performCursorZoom = false, r || this._lastPosition.distanceToSquared(this.object.position) > Ip || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Ip || this._lastTargetPosition.distanceToSquared(this.target) > Ip ? (this.dispatchEvent(Qb), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), true) : false;
        }
        _getAutoRotationAngle(e) {
          return e !== null ? It / 60 * this.autoRotateSpeed * e : It / 60 / 60 * this.autoRotateSpeed;
        }
        _getZoomScale(e) {
          const t = Math.abs(e * 0.01);
          return Math.pow(0.95, this.zoomSpeed * t);
        }
        _rotateLeft(e) {
          this._sphericalDelta.theta -= e;
        }
        _rotateUp(e) {
          this._sphericalDelta.phi -= e;
        }
        _panLeft(e, t) {
          st.setFromMatrixColumn(t, 0), st.multiplyScalar(-e), this._panOffset.add(st);
        }
        _panUp(e, t) {
          this.screenSpacePanning === true ? st.setFromMatrixColumn(t, 1) : (st.setFromMatrixColumn(t, 0), st.crossVectors(this.object.up, st)), st.multiplyScalar(e), this._panOffset.add(st);
        }
        _pan(e, t) {
          const i = this.domElement;
          if (this.object.isPerspectiveCamera) {
            const n = this.object.position;
            st.copy(n).sub(this.target);
            let r = st.length();
            r *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * r / i.clientHeight, this.object.matrix), this._panUp(2 * t * r / i.clientHeight, this.object.matrix);
          } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / i.clientWidth, this.object.matrix), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / i.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = false);
        }
        _dollyOut(e) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _dollyIn(e) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _updateZoomParameters(e, t) {
          if (!this.zoomToCursor) return;
          this._performCursorZoom = true;
          const i = this.domElement.getBoundingClientRect(), n = e - i.left, r = t - i.top, a = i.width, l = i.height;
          this._mouse.x = n / a * 2 - 1, this._mouse.y = -(r / l) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
        }
        _clampDistance(e) {
          return Math.max(this.minDistance, Math.min(this.maxDistance, e));
        }
        _handleMouseDownRotate(e) {
          this._rotateStart.set(e.clientX, e.clientY);
        }
        _handleMouseDownDolly(e) {
          this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
        }
        _handleMouseDownPan(e) {
          this._panStart.set(e.clientX, e.clientY);
        }
        _handleMouseMoveRotate(e) {
          this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const t = this.domElement;
          this._rotateLeft(It * this._rotateDelta.x / t.clientHeight), this._rotateUp(It * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
        }
        _handleMouseMoveDolly(e) {
          this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
        }
        _handleMouseMovePan(e) {
          this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
        }
        _handleMouseWheel(e) {
          this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
        }
        _handleKeyDown(e) {
          let t = false;
          switch (e.code) {
            case this.keys.UP:
              e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(It * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), t = true;
              break;
            case this.keys.BOTTOM:
              e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(-It * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), t = true;
              break;
            case this.keys.LEFT:
              e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(It * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), t = true;
              break;
            case this.keys.RIGHT:
              e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(-It * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), t = true;
              break;
          }
          t && (e.preventDefault(), this.update());
        }
        _handleTouchStartRotate(e) {
          if (this._pointers.length === 1) this._rotateStart.set(e.pageX, e.pageY);
          else {
            const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
            this._rotateStart.set(i, n);
          }
        }
        _handleTouchStartPan(e) {
          if (this._pointers.length === 1) this._panStart.set(e.pageX, e.pageY);
          else {
            const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
            this._panStart.set(i, n);
          }
        }
        _handleTouchStartDolly(e) {
          const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n);
          this._dollyStart.set(0, r);
        }
        _handleTouchStartDollyPan(e) {
          this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
        }
        _handleTouchStartDollyRotate(e) {
          this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
        }
        _handleTouchMoveRotate(e) {
          if (this._pointers.length == 1) this._rotateEnd.set(e.pageX, e.pageY);
          else {
            const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), r = 0.5 * (e.pageY + i.y);
            this._rotateEnd.set(n, r);
          }
          this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const t = this.domElement;
          this._rotateLeft(It * this._rotateDelta.x / t.clientHeight), this._rotateUp(It * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd);
        }
        _handleTouchMovePan(e) {
          if (this._pointers.length === 1) this._panEnd.set(e.pageX, e.pageY);
          else {
            const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
            this._panEnd.set(i, n);
          }
          this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
        }
        _handleTouchMoveDolly(e) {
          const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n);
          this._dollyEnd.set(0, r), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
          const a = (e.pageX + t.x) * 0.5, l = (e.pageY + t.y) * 0.5;
          this._updateZoomParameters(a, l);
        }
        _handleTouchMoveDollyPan(e) {
          this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
        }
        _handleTouchMoveDollyRotate(e) {
          this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
        }
        _addPointer(e) {
          this._pointers.push(e.pointerId);
        }
        _removePointer(e) {
          delete this._pointerPositions[e.pointerId];
          for (let t = 0; t < this._pointers.length; t++) if (this._pointers[t] == e.pointerId) {
            this._pointers.splice(t, 1);
            return;
          }
        }
        _isTrackingPointer(e) {
          for (let t = 0; t < this._pointers.length; t++) if (this._pointers[t] == e.pointerId) return true;
          return false;
        }
        _trackPointer(e) {
          let t = this._pointerPositions[e.pointerId];
          t === void 0 && (t = new q(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
        }
        _getSecondPointerPosition(e) {
          const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
          return this._pointerPositions[t];
        }
        _customWheelEvent(e) {
          const t = e.deltaMode, i = {
            clientX: e.clientX,
            clientY: e.clientY,
            deltaY: e.deltaY
          };
          switch (t) {
            case 1:
              i.deltaY *= 16;
              break;
            case 2:
              i.deltaY *= 100;
              break;
          }
          return e.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
        }
      }
      function N4(s) {
        this.enabled !== false && (this._pointers.length === 0 && (this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(s) && (this._addPointer(s), s.pointerType === "touch" ? this._onTouchStart(s) : this._onMouseDown(s)));
      }
      function w4(s) {
        this.enabled !== false && (s.pointerType === "touch" ? this._onTouchMove(s) : this._onMouseMove(s));
      }
      function E4(s) {
        switch (this._removePointer(s), this._pointers.length) {
          case 0:
            this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(wA), this.state = Ae.NONE;
            break;
          case 1:
            const e = this._pointers[0], t = this._pointerPositions[e];
            this._onTouchStart({
              pointerId: e,
              pageX: t.x,
              pageY: t.y
            });
            break;
        }
      }
      function R4(s) {
        let e;
        switch (s.button) {
          case 0:
            e = this.mouseButtons.LEFT;
            break;
          case 1:
            e = this.mouseButtons.MIDDLE;
            break;
          case 2:
            e = this.mouseButtons.RIGHT;
            break;
          default:
            e = -1;
        }
        switch (e) {
          case Qa.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseDownDolly(s), this.state = Ae.DOLLY;
            break;
          case Qa.ROTATE:
            if (s.ctrlKey || s.metaKey || s.shiftKey) {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(s), this.state = Ae.PAN;
            } else {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(s), this.state = Ae.ROTATE;
            }
            break;
          case Qa.PAN:
            if (s.ctrlKey || s.metaKey || s.shiftKey) {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(s), this.state = Ae.ROTATE;
            } else {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(s), this.state = Ae.PAN;
            }
            break;
          default:
            this.state = Ae.NONE;
        }
        this.state !== Ae.NONE && this.dispatchEvent(x0);
      }
      function C4(s) {
        switch (this.state) {
          case Ae.ROTATE:
            if (this.enableRotate === false) return;
            this._handleMouseMoveRotate(s);
            break;
          case Ae.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseMoveDolly(s);
            break;
          case Ae.PAN:
            if (this.enablePan === false) return;
            this._handleMouseMovePan(s);
            break;
        }
      }
      function B4(s) {
        this.enabled === false || this.enableZoom === false || this.state !== Ae.NONE || (s.preventDefault(), this.dispatchEvent(x0), this._handleMouseWheel(this._customWheelEvent(s)), this.dispatchEvent(wA));
      }
      function D4(s) {
        this.enabled !== false && this._handleKeyDown(s);
      }
      function U4(s) {
        switch (this._trackPointer(s), this._pointers.length) {
          case 1:
            switch (this.touches.ONE) {
              case za.ROTATE:
                if (this.enableRotate === false) return;
                this._handleTouchStartRotate(s), this.state = Ae.TOUCH_ROTATE;
                break;
              case za.PAN:
                if (this.enablePan === false) return;
                this._handleTouchStartPan(s), this.state = Ae.TOUCH_PAN;
                break;
              default:
                this.state = Ae.NONE;
            }
            break;
          case 2:
            switch (this.touches.TWO) {
              case za.DOLLY_PAN:
                if (this.enableZoom === false && this.enablePan === false) return;
                this._handleTouchStartDollyPan(s), this.state = Ae.TOUCH_DOLLY_PAN;
                break;
              case za.DOLLY_ROTATE:
                if (this.enableZoom === false && this.enableRotate === false) return;
                this._handleTouchStartDollyRotate(s), this.state = Ae.TOUCH_DOLLY_ROTATE;
                break;
              default:
                this.state = Ae.NONE;
            }
            break;
          default:
            this.state = Ae.NONE;
        }
        this.state !== Ae.NONE && this.dispatchEvent(x0);
      }
      function F4(s) {
        switch (this._trackPointer(s), this.state) {
          case Ae.TOUCH_ROTATE:
            if (this.enableRotate === false) return;
            this._handleTouchMoveRotate(s), this.update();
            break;
          case Ae.TOUCH_PAN:
            if (this.enablePan === false) return;
            this._handleTouchMovePan(s), this.update();
            break;
          case Ae.TOUCH_DOLLY_PAN:
            if (this.enableZoom === false && this.enablePan === false) return;
            this._handleTouchMoveDollyPan(s), this.update();
            break;
          case Ae.TOUCH_DOLLY_ROTATE:
            if (this.enableZoom === false && this.enableRotate === false) return;
            this._handleTouchMoveDollyRotate(s), this.update();
            break;
          default:
            this.state = Ae.NONE;
        }
      }
      function O4(s) {
        this.enabled !== false && s.preventDefault();
      }
      function z4(s) {
        s.key === "Control" && (this._controlActive = true, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      function L4(s) {
        s.key === "Control" && (this._controlActive = false, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      class Xd extends as {
        constructor() {
          const e = Xd.SkyShader, t = new Ov({
            name: e.name,
            uniforms: fC.clone(e.uniforms),
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader,
            side: Fi,
            depthWrite: false
          });
          super(new Oo(1, 1, 1), t), this.isSky = true;
        }
      }
      Xd.SkyShader = {
        name: "SkyShader",
        uniforms: {
          turbidity: {
            value: 2
          },
          rayleigh: {
            value: 1
          },
          mieCoefficient: {
            value: 5e-3
          },
          mieDirectionalG: {
            value: 0.8
          },
          sunPosition: {
            value: new v()
          },
          up: {
            value: new v(0, 1, 0)
          }
        },
        vertexShader: `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorption + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,
        fragmentShader: `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
      };
      function G4(s) {
        return new Worker("/StephensSausageRollSolver/assets/physicsWorker-Z5ue0Jm-.js", {
          name: s == null ? void 0 : s.name
        });
      }
      const Ma = {
        defaultColor: new ie().setHex(12103586),
        selectedColor: new ie().setHex(16773494),
        burntColor: new ie().setHex(11012609),
        lostColor: new ie().setHex(81576),
        originColor: new ie().setHex(6467412),
        solvedColor: new ie().setHex(1746945)
      }, Jb = (s) => s.is_initial ? Ma.originColor : s.status === "Lost" ? Ma.lostColor : s.status === "Solution" ? Ma.solvedColor : s.status === "Burnt" ? Ma.burntColor : Ma.defaultColor, Ag = new q(), ji = new v4();
      ji.setSize(600, 450);
      ji.setClearColor(new ie(16777215));
      ji.domElement.onmousemove = (s) => {
        Ag.x = s.offsetX / ji.domElement.width * 2 - 1, Ag.y = -(s.offsetY / ji.domElement.height) * 2 + 1;
      };
      const Zd = new Ki(75, 4 / 3, 0.1, 1e3);
      Zd.position.set(10, 10, 20).multiplyScalar(10);
      let kr = new A4(Zd, ji.domElement);
      kr.maxPolarAngle = Math.PI * 0.8;
      kr.enableDamping = true;
      kr.screenSpacePanning = false;
      kr.update();
      const Bn = new zy(), EA = new Vv(16777215, 1);
      EA.position.set(1, 1, 1);
      Bn.add(EA);
      const P4 = new Hv(16777215, 1);
      Bn.add(P4);
      const _0 = new Xd();
      _0.scale.setScalar(45e3);
      const k4 = new v(1, 1, 1);
      _0.material.uniforms.sunPosition.value = k4;
      Bn.add(_0);
      const eS = new HC(), I4 = () => {
        kr.update(), ji.render(Bn, Zd);
      };
      ji.setAnimationLoop(I4);
      const kc = new G4(), V4 = ({ solution: s }) => {
        const e = Ne.useRef(null), [t, i] = Ne.useState(s.initial_state), [n, r] = Ne.useState(false), [a, l] = Ne.useState(0);
        Ne.useEffect(() => {
          kc.postMessage({
            graph: s,
            pause: false
          });
        }, [
          s
        ]);
        const [o, u] = Ne.useState(null), [c, h] = Ne.useMemo(() => {
          let f = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map();
          return s.states.forEach((g, _) => {
            f.set(g.id, _), p.set(_, g.id);
          }), [
            f,
            p
          ];
        }, [
          s
        ]), d = Ne.useMemo(() => {
          const f = new zd(), p = new Gy({
            color: new ie().setHex(16777215)
          }), g = new _C(f, p, s.states.length);
          return g.userData.levelStates = [], s.states.forEach((_, m) => {
            g.userData.levelStates.push(_), g.setColorAt(m, Jb(_));
          }), g.instanceColor !== null && (g.instanceColor.needsUpdate = true), g;
        }, [
          s
        ]);
        return Ne.useEffect(() => {
          let f = [], p = new pe(), g = new pe();
          for (const m of s.edges) {
            const y = c.get(m.source), x = c.get(m.target);
            x === void 0 || y === void 0 || (d.getMatrixAt(y, p), d.getMatrixAt(x, g), f.push(new v().setFromMatrixPosition(p)), f.push(new v().setFromMatrixPosition(g)));
          }
          let _ = new vC(new en().setFromPoints(f), new Od({
            color: 0
          }));
          return Bn.add(_), () => {
            Bn.remove(_);
          };
        }, [
          s,
          d,
          a
        ]), Ne.useEffect(() => (Bn.add(d), () => {
          Bn.remove(d);
        }), [
          d
        ]), Ne.useEffect(() => {
          var _a2;
          return (_a2 = e.current) == null ? void 0 : _a2.appendChild(ji.domElement), () => {
            var _a3;
            (_a3 = e.current) == null ? void 0 : _a3.removeChild(ji.domElement);
          };
        }, [
          e
        ]), Ne.useEffect(() => {
          kc.onmessage = (f) => {
            f.data.forEach(({ id: g, position: _ }) => {
              let m = c.get(g);
              m !== void 0 && d.setMatrixAt(m, new pe().makeTranslation(_.x, _.y, _.z));
            }), d.instanceMatrix.needsUpdate = true, l((g) => g + 1);
          };
        }, [
          s,
          d
        ]), Ne.useEffect(() => {
          if (o !== null) {
            let f = new pe();
            d.getMatrixAt(o, f), kr.target = new v().setFromMatrixPosition(f), kr.cursor = new v(), d.setColorAt(o, Ma.selectedColor), d.instanceColor !== null && (d.instanceColor.needsUpdate = true), i(d.userData.levelStates[o] ?? null);
          }
          return () => {
            o !== null && (d.setColorAt(o, Jb(d.userData.levelStates[o])), d.instanceColor !== null && (d.instanceColor.needsUpdate = true));
          };
        }, [
          o,
          d
        ]), Ne.useEffect(() => {
          ji.domElement.onmousedown = (f) => {
            var _a2;
            if (f.button !== 0) return;
            eS.setFromCamera(Ag, Zd), d.computeBoundingSphere();
            const p = (_a2 = eS.intersectObject(d)[0]) == null ? void 0 : _a2.instanceId;
            p !== void 0 && u(p);
          };
        }, [
          d
        ]), V.jsxs(V.Fragment, {
          children: [
            V.jsx("div", {
              ref: e
            }),
            V.jsx("button", {
              type: "button",
              defaultValue: "",
              className: `${n ? "active" : null}`,
              onClick: () => {
                kc.postMessage({
                  pause: !n
                }), r(!n);
              },
              children: "Pause Physics"
            }),
            o !== null ? V.jsx("button", {
              onClick: () => {
                let f = h.get(o);
                f !== void 0 && kc.postMessage({
                  togglePin: f
                });
              },
              children: "Pin"
            }) : V.jsx("button", {
              disabled: true,
              children: "Pin"
            }),
            t !== null && V.jsx(ev, {
              description: s.level_description,
              state: t,
              lenX: 10,
              lenY: 10,
              lenZ: 3
            })
          ]
        });
      };
      function H4() {
        const [s, e] = Ne.useState(null);
        return V.jsxs(V.Fragment, {
          children: [
            V.jsx("div", {
              className: "column",
              children: V.jsx(Y2, {
                setSolution: e
              })
            }),
            s !== null ? V.jsx("div", {
              className: "column",
              children: V.jsx(V4, {
                solution: s
              })
            }) : ""
          ]
        });
      }
      G2();
      AE.createRoot(document.getElementById("root")).render(V.jsx(Ne.StrictMode, {
        children: V.jsx(H4, {})
      }));
    })();
  }
});
export default require_stdin();
