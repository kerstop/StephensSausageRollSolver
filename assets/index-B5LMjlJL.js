var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_stdin = __commonJS({
  "<stdin>"(exports, module) {
    (async () => {
      (function() {
        const t = document.createElement("link").relList;
        if (t && t.supports && t.supports("modulepreload")) return;
        for (const a of document.querySelectorAll('link[rel="modulepreload"]')) i(a);
        new MutationObserver((a) => {
          for (const s of a) if (s.type === "childList") for (const r of s.addedNodes) r.tagName === "LINK" && r.rel === "modulepreload" && i(r);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function n(a) {
          const s = {};
          return a.integrity && (s.integrity = a.integrity), a.referrerPolicy && (s.referrerPolicy = a.referrerPolicy), a.crossOrigin === "use-credentials" ? s.credentials = "include" : a.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
        }
        function i(a) {
          if (a.ep) return;
          a.ep = true;
          const s = n(a);
          fetch(a.href, s);
        }
      })();
      var a0 = {
        exports: {}
      }, Su = {};
      var WS = Symbol.for("react.transitional.element"), YS = Symbol.for("react.fragment");
      function s0(e, t, n) {
        var i = null;
        if (n !== void 0 && (i = "" + n), t.key !== void 0 && (i = "" + t.key), "key" in t) {
          n = {};
          for (var a in t) a !== "key" && (n[a] = t[a]);
        } else n = t;
        return t = n.ref, {
          $$typeof: WS,
          type: e,
          key: i,
          ref: t !== void 0 ? t : null,
          props: n
        };
      }
      Su.Fragment = YS;
      Su.jsx = s0;
      Su.jsxs = s0;
      a0.exports = Su;
      var vt = a0.exports, r0 = {
        exports: {}
      }, Ft = {};
      var Qd = Symbol.for("react.transitional.element"), qS = Symbol.for("react.portal"), jS = Symbol.for("react.fragment"), ZS = Symbol.for("react.strict_mode"), KS = Symbol.for("react.profiler"), QS = Symbol.for("react.consumer"), JS = Symbol.for("react.context"), $S = Symbol.for("react.forward_ref"), tx = Symbol.for("react.suspense"), ex = Symbol.for("react.memo"), o0 = Symbol.for("react.lazy"), ym = Symbol.iterator;
      function nx(e) {
        return e === null || typeof e != "object" ? null : (e = ym && e[ym] || e["@@iterator"], typeof e == "function" ? e : null);
      }
      var l0 = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      }, c0 = Object.assign, u0 = {};
      function Wr(e, t, n) {
        this.props = e, this.context = t, this.refs = u0, this.updater = n || l0;
      }
      Wr.prototype.isReactComponent = {};
      Wr.prototype.setState = function(e, t) {
        if (typeof e != "object" && typeof e != "function" && e != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, e, t, "setState");
      };
      Wr.prototype.forceUpdate = function(e) {
        this.updater.enqueueForceUpdate(this, e, "forceUpdate");
      };
      function f0() {
      }
      f0.prototype = Wr.prototype;
      function Jd(e, t, n) {
        this.props = e, this.context = t, this.refs = u0, this.updater = n || l0;
      }
      var $d = Jd.prototype = new f0();
      $d.constructor = Jd;
      c0($d, Wr.prototype);
      $d.isPureReactComponent = true;
      var Sm = Array.isArray, Ee = {
        H: null,
        A: null,
        T: null,
        S: null
      }, h0 = Object.prototype.hasOwnProperty;
      function tp(e, t, n, i, a, s) {
        return n = s.ref, {
          $$typeof: Qd,
          type: e,
          key: t,
          ref: n !== void 0 ? n : null,
          props: s
        };
      }
      function ix(e, t) {
        return tp(e.type, t, void 0, void 0, void 0, e.props);
      }
      function ep(e) {
        return typeof e == "object" && e !== null && e.$$typeof === Qd;
      }
      function ax(e) {
        var t = {
          "=": "=0",
          ":": "=2"
        };
        return "$" + e.replace(/[=:]/g, function(n) {
          return t[n];
        });
      }
      var xm = /\/+/g;
      function ju(e, t) {
        return typeof e == "object" && e !== null && e.key != null ? ax("" + e.key) : t.toString(36);
      }
      function Mm() {
      }
      function sx(e) {
        switch (e.status) {
          case "fulfilled":
            return e.value;
          case "rejected":
            throw e.reason;
          default:
            switch (typeof e.status == "string" ? e.then(Mm, Mm) : (e.status = "pending", e.then(function(t) {
              e.status === "pending" && (e.status = "fulfilled", e.value = t);
            }, function(t) {
              e.status === "pending" && (e.status = "rejected", e.reason = t);
            })), e.status) {
              case "fulfilled":
                return e.value;
              case "rejected":
                throw e.reason;
            }
        }
        throw e;
      }
      function Zs(e, t, n, i, a) {
        var s = typeof e;
        (s === "undefined" || s === "boolean") && (e = null);
        var r = false;
        if (e === null) r = true;
        else switch (s) {
          case "bigint":
          case "string":
          case "number":
            r = true;
            break;
          case "object":
            switch (e.$$typeof) {
              case Qd:
              case qS:
                r = true;
                break;
              case o0:
                return r = e._init, Zs(r(e._payload), t, n, i, a);
            }
        }
        if (r) return a = a(e), r = i === "" ? "." + ju(e, 0) : i, Sm(a) ? (n = "", r != null && (n = r.replace(xm, "$&/") + "/"), Zs(a, t, n, "", function(c) {
          return c;
        })) : a != null && (ep(a) && (a = ix(a, n + (a.key == null || e && e.key === a.key ? "" : ("" + a.key).replace(xm, "$&/") + "/") + r)), t.push(a)), 1;
        r = 0;
        var o = i === "" ? "." : i + ":";
        if (Sm(e)) for (var l = 0; l < e.length; l++) i = e[l], s = o + ju(i, l), r += Zs(i, t, n, s, a);
        else if (l = nx(e), typeof l == "function") for (e = l.call(e), l = 0; !(i = e.next()).done; ) i = i.value, s = o + ju(i, l++), r += Zs(i, t, n, s, a);
        else if (s === "object") {
          if (typeof e.then == "function") return Zs(sx(e), t, n, i, a);
          throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
        }
        return r;
      }
      function Cl(e, t, n) {
        if (e == null) return e;
        var i = [], a = 0;
        return Zs(e, i, "", "", function(s) {
          return t.call(n, s, a++);
        }), i;
      }
      function rx(e) {
        if (e._status === -1) {
          var t = e._result;
          t = t(), t.then(function(n) {
            (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n);
          }, function(n) {
            (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n);
          }), e._status === -1 && (e._status = 0, e._result = t);
        }
        if (e._status === 1) return e._result.default;
        throw e._result;
      }
      var Em = typeof reportError == "function" ? reportError : function(e) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var t = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: typeof e == "object" && e !== null && typeof e.message == "string" ? String(e.message) : String(e),
            error: e
          });
          if (!window.dispatchEvent(t)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", e);
          return;
        }
        console.error(e);
      };
      function ox() {
      }
      Ft.Children = {
        map: Cl,
        forEach: function(e, t, n) {
          Cl(e, function() {
            t.apply(this, arguments);
          }, n);
        },
        count: function(e) {
          var t = 0;
          return Cl(e, function() {
            t++;
          }), t;
        },
        toArray: function(e) {
          return Cl(e, function(t) {
            return t;
          }) || [];
        },
        only: function(e) {
          if (!ep(e)) throw Error("React.Children.only expected to receive a single React element child.");
          return e;
        }
      };
      Ft.Component = Wr;
      Ft.Fragment = jS;
      Ft.Profiler = KS;
      Ft.PureComponent = Jd;
      Ft.StrictMode = ZS;
      Ft.Suspense = tx;
      Ft.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Ee;
      Ft.act = function() {
        throw Error("act(...) is not supported in production builds of React.");
      };
      Ft.cache = function(e) {
        return function() {
          return e.apply(null, arguments);
        };
      };
      Ft.cloneElement = function(e, t, n) {
        if (e == null) throw Error("The argument must be a React element, but you passed " + e + ".");
        var i = c0({}, e.props), a = e.key, s = void 0;
        if (t != null) for (r in t.ref !== void 0 && (s = void 0), t.key !== void 0 && (a = "" + t.key), t) !h0.call(t, r) || r === "key" || r === "__self" || r === "__source" || r === "ref" && t.ref === void 0 || (i[r] = t[r]);
        var r = arguments.length - 2;
        if (r === 1) i.children = n;
        else if (1 < r) {
          for (var o = Array(r), l = 0; l < r; l++) o[l] = arguments[l + 2];
          i.children = o;
        }
        return tp(e.type, a, void 0, void 0, s, i);
      };
      Ft.createContext = function(e) {
        return e = {
          $$typeof: JS,
          _currentValue: e,
          _currentValue2: e,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }, e.Provider = e, e.Consumer = {
          $$typeof: QS,
          _context: e
        }, e;
      };
      Ft.createElement = function(e, t, n) {
        var i, a = {}, s = null;
        if (t != null) for (i in t.key !== void 0 && (s = "" + t.key), t) h0.call(t, i) && i !== "key" && i !== "__self" && i !== "__source" && (a[i] = t[i]);
        var r = arguments.length - 2;
        if (r === 1) a.children = n;
        else if (1 < r) {
          for (var o = Array(r), l = 0; l < r; l++) o[l] = arguments[l + 2];
          a.children = o;
        }
        if (e && e.defaultProps) for (i in r = e.defaultProps, r) a[i] === void 0 && (a[i] = r[i]);
        return tp(e, s, void 0, void 0, null, a);
      };
      Ft.createRef = function() {
        return {
          current: null
        };
      };
      Ft.forwardRef = function(e) {
        return {
          $$typeof: $S,
          render: e
        };
      };
      Ft.isValidElement = ep;
      Ft.lazy = function(e) {
        return {
          $$typeof: o0,
          _payload: {
            _status: -1,
            _result: e
          },
          _init: rx
        };
      };
      Ft.memo = function(e, t) {
        return {
          $$typeof: ex,
          type: e,
          compare: t === void 0 ? null : t
        };
      };
      Ft.startTransition = function(e) {
        var t = Ee.T, n = {};
        Ee.T = n;
        try {
          var i = e(), a = Ee.S;
          a !== null && a(n, i), typeof i == "object" && i !== null && typeof i.then == "function" && i.then(ox, Em);
        } catch (s) {
          Em(s);
        } finally {
          Ee.T = t;
        }
      };
      Ft.unstable_useCacheRefresh = function() {
        return Ee.H.useCacheRefresh();
      };
      Ft.use = function(e) {
        return Ee.H.use(e);
      };
      Ft.useActionState = function(e, t, n) {
        return Ee.H.useActionState(e, t, n);
      };
      Ft.useCallback = function(e, t) {
        return Ee.H.useCallback(e, t);
      };
      Ft.useContext = function(e) {
        return Ee.H.useContext(e);
      };
      Ft.useDebugValue = function() {
      };
      Ft.useDeferredValue = function(e, t) {
        return Ee.H.useDeferredValue(e, t);
      };
      Ft.useEffect = function(e, t) {
        return Ee.H.useEffect(e, t);
      };
      Ft.useId = function() {
        return Ee.H.useId();
      };
      Ft.useImperativeHandle = function(e, t, n) {
        return Ee.H.useImperativeHandle(e, t, n);
      };
      Ft.useInsertionEffect = function(e, t) {
        return Ee.H.useInsertionEffect(e, t);
      };
      Ft.useLayoutEffect = function(e, t) {
        return Ee.H.useLayoutEffect(e, t);
      };
      Ft.useMemo = function(e, t) {
        return Ee.H.useMemo(e, t);
      };
      Ft.useOptimistic = function(e, t) {
        return Ee.H.useOptimistic(e, t);
      };
      Ft.useReducer = function(e, t, n) {
        return Ee.H.useReducer(e, t, n);
      };
      Ft.useRef = function(e) {
        return Ee.H.useRef(e);
      };
      Ft.useState = function(e) {
        return Ee.H.useState(e);
      };
      Ft.useSyncExternalStore = function(e, t, n) {
        return Ee.H.useSyncExternalStore(e, t, n);
      };
      Ft.useTransition = function() {
        return Ee.H.useTransition();
      };
      Ft.version = "19.0.0";
      r0.exports = Ft;
      var Ot = r0.exports, d0 = {
        exports: {}
      }, xu = {}, p0 = {
        exports: {}
      }, m0 = {};
      (function(e) {
        function t(L, W) {
          var B = L.length;
          L.push(W);
          t: for (; 0 < B; ) {
            var $ = B - 1 >>> 1, it = L[$];
            if (0 < a(it, W)) L[$] = W, L[B] = it, B = $;
            else break t;
          }
        }
        function n(L) {
          return L.length === 0 ? null : L[0];
        }
        function i(L) {
          if (L.length === 0) return null;
          var W = L[0], B = L.pop();
          if (B !== W) {
            L[0] = B;
            t: for (var $ = 0, it = L.length, gt = it >>> 1; $ < gt; ) {
              var Dt = 2 * ($ + 1) - 1, ne = L[Dt], Y = Dt + 1, nt = L[Y];
              if (0 > a(ne, B)) Y < it && 0 > a(nt, ne) ? (L[$] = nt, L[Y] = B, $ = Y) : (L[$] = ne, L[Dt] = B, $ = Dt);
              else if (Y < it && 0 > a(nt, B)) L[$] = nt, L[Y] = B, $ = Y;
              else break t;
            }
          }
          return W;
        }
        function a(L, W) {
          var B = L.sortIndex - W.sortIndex;
          return B !== 0 ? B : L.id - W.id;
        }
        if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
          var s = performance;
          e.unstable_now = function() {
            return s.now();
          };
        } else {
          var r = Date, o = r.now();
          e.unstable_now = function() {
            return r.now() - o;
          };
        }
        var l = [], c = [], f = 1, d = null, h = 3, p = false, y = false, S = false, m = typeof setTimeout == "function" ? setTimeout : null, u = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
        function g(L) {
          for (var W = n(c); W !== null; ) {
            if (W.callback === null) i(c);
            else if (W.startTime <= L) i(c), W.sortIndex = W.expirationTime, t(l, W);
            else break;
            W = n(c);
          }
        }
        function v(L) {
          if (S = false, g(L), !y) if (n(l) !== null) y = true, X();
          else {
            var W = n(c);
            W !== null && Q(v, W.startTime - L);
          }
        }
        var T = false, R = -1, w = 5, D = -1;
        function b() {
          return !(e.unstable_now() - D < w);
        }
        function x() {
          if (T) {
            var L = e.unstable_now();
            D = L;
            var W = true;
            try {
              t: {
                y = false, S && (S = false, u(R), R = -1), p = true;
                var B = h;
                try {
                  e: {
                    for (g(L), d = n(l); d !== null && !(d.expirationTime > L && b()); ) {
                      var $ = d.callback;
                      if (typeof $ == "function") {
                        d.callback = null, h = d.priorityLevel;
                        var it = $(d.expirationTime <= L);
                        if (L = e.unstable_now(), typeof it == "function") {
                          d.callback = it, g(L), W = true;
                          break e;
                        }
                        d === n(l) && i(l), g(L);
                      } else i(l);
                      d = n(l);
                    }
                    if (d !== null) W = true;
                    else {
                      var gt = n(c);
                      gt !== null && Q(v, gt.startTime - L), W = false;
                    }
                  }
                  break t;
                } finally {
                  d = null, h = B, p = false;
                }
                W = void 0;
              }
            } finally {
              W ? C() : T = false;
            }
          }
        }
        var C;
        if (typeof _ == "function") C = function() {
          _(x);
        };
        else if (typeof MessageChannel < "u") {
          var V = new MessageChannel(), I = V.port2;
          V.port1.onmessage = x, C = function() {
            I.postMessage(null);
          };
        } else C = function() {
          m(x, 0);
        };
        function X() {
          T || (T = true, C());
        }
        function Q(L, W) {
          R = m(function() {
            L(e.unstable_now());
          }, W);
        }
        e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(L) {
          L.callback = null;
        }, e.unstable_continueExecution = function() {
          y || p || (y = true, X());
        }, e.unstable_forceFrameRate = function(L) {
          0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : w = 0 < L ? Math.floor(1e3 / L) : 5;
        }, e.unstable_getCurrentPriorityLevel = function() {
          return h;
        }, e.unstable_getFirstCallbackNode = function() {
          return n(l);
        }, e.unstable_next = function(L) {
          switch (h) {
            case 1:
            case 2:
            case 3:
              var W = 3;
              break;
            default:
              W = h;
          }
          var B = h;
          h = W;
          try {
            return L();
          } finally {
            h = B;
          }
        }, e.unstable_pauseExecution = function() {
        }, e.unstable_requestPaint = function() {
        }, e.unstable_runWithPriority = function(L, W) {
          switch (L) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              L = 3;
          }
          var B = h;
          h = L;
          try {
            return W();
          } finally {
            h = B;
          }
        }, e.unstable_scheduleCallback = function(L, W, B) {
          var $ = e.unstable_now();
          switch (typeof B == "object" && B !== null ? (B = B.delay, B = typeof B == "number" && 0 < B ? $ + B : $) : B = $, L) {
            case 1:
              var it = -1;
              break;
            case 2:
              it = 250;
              break;
            case 5:
              it = 1073741823;
              break;
            case 4:
              it = 1e4;
              break;
            default:
              it = 5e3;
          }
          return it = B + it, L = {
            id: f++,
            callback: W,
            priorityLevel: L,
            startTime: B,
            expirationTime: it,
            sortIndex: -1
          }, B > $ ? (L.sortIndex = B, t(c, L), n(l) === null && L === n(c) && (S ? (u(R), R = -1) : S = true, Q(v, B - $))) : (L.sortIndex = it, t(l, L), y || p || (y = true, X())), L;
        }, e.unstable_shouldYield = b, e.unstable_wrapCallback = function(L) {
          var W = h;
          return function() {
            var B = h;
            h = W;
            try {
              return L.apply(this, arguments);
            } finally {
              h = B;
            }
          };
        };
      })(m0);
      p0.exports = m0;
      var lx = p0.exports, _0 = {
        exports: {}
      }, mn = {};
      var cx = Ot;
      function g0(e) {
        var t = "https://react.dev/errors/" + e;
        if (1 < arguments.length) {
          t += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var n = 2; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
        }
        return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function sa() {
      }
      var fn = {
        d: {
          f: sa,
          r: function() {
            throw Error(g0(522));
          },
          D: sa,
          C: sa,
          L: sa,
          m: sa,
          X: sa,
          S: sa,
          M: sa
        },
        p: 0,
        findDOMNode: null
      }, ux = Symbol.for("react.portal");
      function fx(e, t, n) {
        var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
          $$typeof: ux,
          key: i == null ? null : "" + i,
          children: e,
          containerInfo: t,
          implementation: n
        };
      }
      var Ao = cx.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function Mu(e, t) {
        if (e === "font") return "";
        if (typeof t == "string") return t === "use-credentials" ? t : "";
      }
      mn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = fn;
      mn.createPortal = function(e, t) {
        var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) throw Error(g0(299));
        return fx(e, t, null, n);
      };
      mn.flushSync = function(e) {
        var t = Ao.T, n = fn.p;
        try {
          if (Ao.T = null, fn.p = 2, e) return e();
        } finally {
          Ao.T = t, fn.p = n, fn.d.f();
        }
      };
      mn.preconnect = function(e, t) {
        typeof e == "string" && (t ? (t = t.crossOrigin, t = typeof t == "string" ? t === "use-credentials" ? t : "" : void 0) : t = null, fn.d.C(e, t));
      };
      mn.prefetchDNS = function(e) {
        typeof e == "string" && fn.d.D(e);
      };
      mn.preinit = function(e, t) {
        if (typeof e == "string" && t && typeof t.as == "string") {
          var n = t.as, i = Mu(n, t.crossOrigin), a = typeof t.integrity == "string" ? t.integrity : void 0, s = typeof t.fetchPriority == "string" ? t.fetchPriority : void 0;
          n === "style" ? fn.d.S(e, typeof t.precedence == "string" ? t.precedence : void 0, {
            crossOrigin: i,
            integrity: a,
            fetchPriority: s
          }) : n === "script" && fn.d.X(e, {
            crossOrigin: i,
            integrity: a,
            fetchPriority: s,
            nonce: typeof t.nonce == "string" ? t.nonce : void 0
          });
        }
      };
      mn.preinitModule = function(e, t) {
        if (typeof e == "string") if (typeof t == "object" && t !== null) {
          if (t.as == null || t.as === "script") {
            var n = Mu(t.as, t.crossOrigin);
            fn.d.M(e, {
              crossOrigin: n,
              integrity: typeof t.integrity == "string" ? t.integrity : void 0,
              nonce: typeof t.nonce == "string" ? t.nonce : void 0
            });
          }
        } else t == null && fn.d.M(e);
      };
      mn.preload = function(e, t) {
        if (typeof e == "string" && typeof t == "object" && t !== null && typeof t.as == "string") {
          var n = t.as, i = Mu(n, t.crossOrigin);
          fn.d.L(e, n, {
            crossOrigin: i,
            integrity: typeof t.integrity == "string" ? t.integrity : void 0,
            nonce: typeof t.nonce == "string" ? t.nonce : void 0,
            type: typeof t.type == "string" ? t.type : void 0,
            fetchPriority: typeof t.fetchPriority == "string" ? t.fetchPriority : void 0,
            referrerPolicy: typeof t.referrerPolicy == "string" ? t.referrerPolicy : void 0,
            imageSrcSet: typeof t.imageSrcSet == "string" ? t.imageSrcSet : void 0,
            imageSizes: typeof t.imageSizes == "string" ? t.imageSizes : void 0,
            media: typeof t.media == "string" ? t.media : void 0
          });
        }
      };
      mn.preloadModule = function(e, t) {
        if (typeof e == "string") if (t) {
          var n = Mu(t.as, t.crossOrigin);
          fn.d.m(e, {
            as: typeof t.as == "string" && t.as !== "script" ? t.as : void 0,
            crossOrigin: n,
            integrity: typeof t.integrity == "string" ? t.integrity : void 0
          });
        } else fn.d.m(e);
      };
      mn.requestFormReset = function(e) {
        fn.d.r(e);
      };
      mn.unstable_batchedUpdates = function(e, t) {
        return e(t);
      };
      mn.useFormState = function(e, t, n) {
        return Ao.H.useFormState(e, t, n);
      };
      mn.useFormStatus = function() {
        return Ao.H.useHostTransitionStatus();
      };
      mn.version = "19.0.0";
      function v0() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(v0);
        } catch (e) {
          console.error(e);
        }
      }
      v0(), _0.exports = mn;
      var hx = _0.exports;
      var He = lx, y0 = Ot, dx = hx;
      function j(e) {
        var t = "https://react.dev/errors/" + e;
        if (1 < arguments.length) {
          t += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var n = 2; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
        }
        return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function S0(e) {
        return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
      }
      var px = Symbol.for("react.element"), Dl = Symbol.for("react.transitional.element"), So = Symbol.for("react.portal"), nr = Symbol.for("react.fragment"), x0 = Symbol.for("react.strict_mode"), ch = Symbol.for("react.profiler"), mx = Symbol.for("react.provider"), M0 = Symbol.for("react.consumer"), Vi = Symbol.for("react.context"), np = Symbol.for("react.forward_ref"), uh = Symbol.for("react.suspense"), fh = Symbol.for("react.suspense_list"), ip = Symbol.for("react.memo"), pa = Symbol.for("react.lazy"), E0 = Symbol.for("react.offscreen"), _x = Symbol.for("react.memo_cache_sentinel"), bm = Symbol.iterator;
      function ao(e) {
        return e === null || typeof e != "object" ? null : (e = bm && e[bm] || e["@@iterator"], typeof e == "function" ? e : null);
      }
      var gx = Symbol.for("react.client.reference");
      function hh(e) {
        if (e == null) return null;
        if (typeof e == "function") return e.$$typeof === gx ? null : e.displayName || e.name || null;
        if (typeof e == "string") return e;
        switch (e) {
          case nr:
            return "Fragment";
          case So:
            return "Portal";
          case ch:
            return "Profiler";
          case x0:
            return "StrictMode";
          case uh:
            return "Suspense";
          case fh:
            return "SuspenseList";
        }
        if (typeof e == "object") switch (e.$$typeof) {
          case Vi:
            return (e.displayName || "Context") + ".Provider";
          case M0:
            return (e._context.displayName || "Context") + ".Consumer";
          case np:
            var t = e.render;
            return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
          case ip:
            return t = e.displayName || null, t !== null ? t : hh(e.type) || "Memo";
          case pa:
            t = e._payload, e = e._init;
            try {
              return hh(e(t));
            } catch {
            }
        }
        return null;
      }
      var Lt = y0.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ve = Object.assign, Zu, Tm;
      function xo(e) {
        if (Zu === void 0) try {
          throw Error();
        } catch (n) {
          var t = n.stack.trim().match(/\n( *(at )?)/);
          Zu = t && t[1] || "", Tm = -1 < n.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < n.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
        return `
` + Zu + e + Tm;
      }
      var Ku = false;
      function Qu(e, t) {
        if (!e || Ku) return "";
        Ku = true;
        var n = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var i = {
            DetermineComponentFrameRoot: function() {
              try {
                if (t) {
                  var d = function() {
                    throw Error();
                  };
                  if (Object.defineProperty(d.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                      Reflect.construct(d, []);
                    } catch (p) {
                      var h = p;
                    }
                    Reflect.construct(e, [], d);
                  } else {
                    try {
                      d.call();
                    } catch (p) {
                      h = p;
                    }
                    e.call(d.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (p) {
                    h = p;
                  }
                  (d = e()) && typeof d.catch == "function" && d.catch(function() {
                  });
                }
              } catch (p) {
                if (p && h && typeof p.stack == "string") return [
                  p.stack,
                  h.stack
                ];
              }
              return [
                null,
                null
              ];
            }
          };
          i.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var a = Object.getOwnPropertyDescriptor(i.DetermineComponentFrameRoot, "name");
          a && a.configurable && Object.defineProperty(i.DetermineComponentFrameRoot, "name", {
            value: "DetermineComponentFrameRoot"
          });
          var s = i.DetermineComponentFrameRoot(), r = s[0], o = s[1];
          if (r && o) {
            var l = r.split(`
`), c = o.split(`
`);
            for (a = i = 0; i < l.length && !l[i].includes("DetermineComponentFrameRoot"); ) i++;
            for (; a < c.length && !c[a].includes("DetermineComponentFrameRoot"); ) a++;
            if (i === l.length || a === c.length) for (i = l.length - 1, a = c.length - 1; 1 <= i && 0 <= a && l[i] !== c[a]; ) a--;
            for (; 1 <= i && 0 <= a; i--, a--) if (l[i] !== c[a]) {
              if (i !== 1 || a !== 1) do
                if (i--, a--, 0 > a || l[i] !== c[a]) {
                  var f = `
` + l[i].replace(" at new ", " at ");
                  return e.displayName && f.includes("<anonymous>") && (f = f.replace("<anonymous>", e.displayName)), f;
                }
              while (1 <= i && 0 <= a);
              break;
            }
          }
        } finally {
          Ku = false, Error.prepareStackTrace = n;
        }
        return (n = e ? e.displayName || e.name : "") ? xo(n) : "";
      }
      function vx(e) {
        switch (e.tag) {
          case 26:
          case 27:
          case 5:
            return xo(e.type);
          case 16:
            return xo("Lazy");
          case 13:
            return xo("Suspense");
          case 19:
            return xo("SuspenseList");
          case 0:
          case 15:
            return e = Qu(e.type, false), e;
          case 11:
            return e = Qu(e.type.render, false), e;
          case 1:
            return e = Qu(e.type, true), e;
          default:
            return "";
        }
      }
      function Am(e) {
        try {
          var t = "";
          do
            t += vx(e), e = e.return;
          while (e);
          return t;
        } catch (n) {
          return `
Error generating stack: ` + n.message + `
` + n.stack;
        }
      }
      function Yr(e) {
        var t = e, n = e;
        if (e.alternate) for (; t.return; ) t = t.return;
        else {
          e = t;
          do
            t = e, t.flags & 4098 && (n = t.return), e = t.return;
          while (e);
        }
        return t.tag === 3 ? n : null;
      }
      function b0(e) {
        if (e.tag === 13) {
          var t = e.memoizedState;
          if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
        }
        return null;
      }
      function Rm(e) {
        if (Yr(e) !== e) throw Error(j(188));
      }
      function yx(e) {
        var t = e.alternate;
        if (!t) {
          if (t = Yr(e), t === null) throw Error(j(188));
          return t !== e ? null : e;
        }
        for (var n = e, i = t; ; ) {
          var a = n.return;
          if (a === null) break;
          var s = a.alternate;
          if (s === null) {
            if (i = a.return, i !== null) {
              n = i;
              continue;
            }
            break;
          }
          if (a.child === s.child) {
            for (s = a.child; s; ) {
              if (s === n) return Rm(a), e;
              if (s === i) return Rm(a), t;
              s = s.sibling;
            }
            throw Error(j(188));
          }
          if (n.return !== i.return) n = a, i = s;
          else {
            for (var r = false, o = a.child; o; ) {
              if (o === n) {
                r = true, n = a, i = s;
                break;
              }
              if (o === i) {
                r = true, i = a, n = s;
                break;
              }
              o = o.sibling;
            }
            if (!r) {
              for (o = s.child; o; ) {
                if (o === n) {
                  r = true, n = s, i = a;
                  break;
                }
                if (o === i) {
                  r = true, i = s, n = a;
                  break;
                }
                o = o.sibling;
              }
              if (!r) throw Error(j(189));
            }
          }
          if (n.alternate !== i) throw Error(j(190));
        }
        if (n.tag !== 3) throw Error(j(188));
        return n.stateNode.current === n ? e : t;
      }
      function T0(e) {
        var t = e.tag;
        if (t === 5 || t === 26 || t === 27 || t === 6) return e;
        for (e = e.child; e !== null; ) {
          if (t = T0(e), t !== null) return t;
          e = e.sibling;
        }
        return null;
      }
      var Mo = Array.isArray, ge = dx.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, os = {
        pending: false,
        data: null,
        method: null,
        action: null
      }, dh = [], ir = -1;
      function Ei(e) {
        return {
          current: e
        };
      }
      function je(e) {
        0 > ir || (e.current = dh[ir], dh[ir] = null, ir--);
      }
      function Se(e, t) {
        ir++, dh[ir] = e.current, e.current = t;
      }
      var vi = Ei(null), Xo = Ei(null), ba = Ei(null), Fc = Ei(null);
      function Ic(e, t) {
        switch (Se(ba, t), Se(Xo, e), Se(vi, null), e = t.nodeType, e) {
          case 9:
          case 11:
            t = (t = t.documentElement) && (t = t.namespaceURI) ? w_(t) : 0;
            break;
          default:
            if (e = e === 8 ? t.parentNode : t, t = e.tagName, e = e.namespaceURI) e = w_(e), t = By(e, t);
            else switch (t) {
              case "svg":
                t = 1;
                break;
              case "math":
                t = 2;
                break;
              default:
                t = 0;
            }
        }
        je(vi), Se(vi, t);
      }
      function Rr() {
        je(vi), je(Xo), je(ba);
      }
      function ph(e) {
        e.memoizedState !== null && Se(Fc, e);
        var t = vi.current, n = By(t, e.type);
        t !== n && (Se(Xo, e), Se(vi, n));
      }
      function Hc(e) {
        Xo.current === e && (je(vi), je(Xo)), Fc.current === e && (je(Fc), el._currentValue = os);
      }
      var mh = Object.prototype.hasOwnProperty, ap = He.unstable_scheduleCallback, Ju = He.unstable_cancelCallback, Sx = He.unstable_shouldYield, xx = He.unstable_requestPaint, yi = He.unstable_now, Mx = He.unstable_getCurrentPriorityLevel, A0 = He.unstable_ImmediatePriority, R0 = He.unstable_UserBlockingPriority, Gc = He.unstable_NormalPriority, Ex = He.unstable_LowPriority, w0 = He.unstable_IdlePriority, bx = He.log, Tx = He.unstable_setDisableYieldValue, dl = null, Rn = null;
      function Ax(e) {
        if (Rn && typeof Rn.onCommitFiberRoot == "function") try {
          Rn.onCommitFiberRoot(dl, e, void 0, (e.current.flags & 128) === 128);
        } catch {
        }
      }
      function Ma(e) {
        if (typeof bx == "function" && Tx(e), Rn && typeof Rn.setStrictMode == "function") try {
          Rn.setStrictMode(dl, e);
        } catch {
        }
      }
      var wn = Math.clz32 ? Math.clz32 : Cx, Rx = Math.log, wx = Math.LN2;
      function Cx(e) {
        return e >>>= 0, e === 0 ? 32 : 31 - (Rx(e) / wx | 0) | 0;
      }
      var Ul = 128, Ll = 4194304;
      function Qa(e) {
        var t = e & 42;
        if (t !== 0) return t;
        switch (e & -e) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return e & 4194176;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return e & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return e;
        }
      }
      function Eu(e, t) {
        var n = e.pendingLanes;
        if (n === 0) return 0;
        var i = 0, a = e.suspendedLanes, s = e.pingedLanes, r = e.warmLanes;
        e = e.finishedLanes !== 0;
        var o = n & 134217727;
        return o !== 0 ? (n = o & ~a, n !== 0 ? i = Qa(n) : (s &= o, s !== 0 ? i = Qa(s) : e || (r = o & ~r, r !== 0 && (i = Qa(r))))) : (o = n & ~a, o !== 0 ? i = Qa(o) : s !== 0 ? i = Qa(s) : e || (r = n & ~r, r !== 0 && (i = Qa(r)))), i === 0 ? 0 : t !== 0 && t !== i && !(t & a) && (a = i & -i, r = t & -t, a >= r || a === 32 && (r & 4194176) !== 0) ? t : i;
      }
      function pl(e, t) {
        return (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & t) === 0;
      }
      function Dx(e, t) {
        switch (e) {
          case 1:
          case 2:
          case 4:
          case 8:
            return t + 250;
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return t + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function C0() {
        var e = Ul;
        return Ul <<= 1, !(Ul & 4194176) && (Ul = 128), e;
      }
      function D0() {
        var e = Ll;
        return Ll <<= 1, !(Ll & 62914560) && (Ll = 4194304), e;
      }
      function $u(e) {
        for (var t = [], n = 0; 31 > n; n++) t.push(e);
        return t;
      }
      function ml(e, t) {
        e.pendingLanes |= t, t !== 268435456 && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0);
      }
      function Ux(e, t, n, i, a, s) {
        var r = e.pendingLanes;
        e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= n, e.entangledLanes &= n, e.errorRecoveryDisabledLanes &= n, e.shellSuspendCounter = 0;
        var o = e.entanglements, l = e.expirationTimes, c = e.hiddenUpdates;
        for (n = r & ~n; 0 < n; ) {
          var f = 31 - wn(n), d = 1 << f;
          o[f] = 0, l[f] = -1;
          var h = c[f];
          if (h !== null) for (c[f] = null, f = 0; f < h.length; f++) {
            var p = h[f];
            p !== null && (p.lane &= -536870913);
          }
          n &= ~d;
        }
        i !== 0 && U0(e, i, 0), s !== 0 && a === 0 && e.tag !== 0 && (e.suspendedLanes |= s & ~(r & ~t));
      }
      function U0(e, t, n) {
        e.pendingLanes |= t, e.suspendedLanes &= ~t;
        var i = 31 - wn(t);
        e.entangledLanes |= t, e.entanglements[i] = e.entanglements[i] | 1073741824 | n & 4194218;
      }
      function L0(e, t) {
        var n = e.entangledLanes |= t;
        for (e = e.entanglements; n; ) {
          var i = 31 - wn(n), a = 1 << i;
          a & t | e[i] & t && (e[i] |= t), n &= ~a;
        }
      }
      function N0(e) {
        return e &= -e, 2 < e ? 8 < e ? e & 134217727 ? 32 : 268435456 : 8 : 2;
      }
      function O0() {
        var e = ge.p;
        return e !== 0 ? e : (e = window.event, e === void 0 ? 32 : qy(e.type));
      }
      function Lx(e, t) {
        var n = ge.p;
        try {
          return ge.p = e, t();
        } finally {
          ge.p = n;
        }
      }
      var Ha = Math.random().toString(36).slice(2), sn = "__reactFiber$" + Ha, yn = "__reactProps$" + Ha, qr = "__reactContainer$" + Ha, _h = "__reactEvents$" + Ha, Nx = "__reactListeners$" + Ha, Ox = "__reactHandles$" + Ha, wm = "__reactResources$" + Ha, Wo = "__reactMarker$" + Ha;
      function sp(e) {
        delete e[sn], delete e[yn], delete e[_h], delete e[Nx], delete e[Ox];
      }
      function is(e) {
        var t = e[sn];
        if (t) return t;
        for (var n = e.parentNode; n; ) {
          if (t = n[qr] || n[sn]) {
            if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = D_(e); e !== null; ) {
              if (n = e[sn]) return n;
              e = D_(e);
            }
            return t;
          }
          e = n, n = e.parentNode;
        }
        return null;
      }
      function jr(e) {
        if (e = e[sn] || e[qr]) {
          var t = e.tag;
          if (t === 5 || t === 6 || t === 13 || t === 26 || t === 27 || t === 3) return e;
        }
        return null;
      }
      function Eo(e) {
        var t = e.tag;
        if (t === 5 || t === 26 || t === 27 || t === 6) return e.stateNode;
        throw Error(j(33));
      }
      function mr(e) {
        var t = e[wm];
        return t || (t = e[wm] = {
          hoistableStyles: /* @__PURE__ */ new Map(),
          hoistableScripts: /* @__PURE__ */ new Map()
        }), t;
      }
      function Ye(e) {
        e[Wo] = true;
      }
      var P0 = /* @__PURE__ */ new Set(), z0 = {};
      function Ms(e, t) {
        wr(e, t), wr(e + "Capture", t);
      }
      function wr(e, t) {
        for (z0[e] = t, e = 0; e < t.length; e++) P0.add(t[e]);
      }
      var Ki = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Px = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Cm = {}, Dm = {};
      function zx(e) {
        return mh.call(Dm, e) ? true : mh.call(Cm, e) ? false : Px.test(e) ? Dm[e] = true : (Cm[e] = true, false);
      }
      function vc(e, t, n) {
        if (zx(t)) if (n === null) e.removeAttribute(t);
        else {
          switch (typeof n) {
            case "undefined":
            case "function":
            case "symbol":
              e.removeAttribute(t);
              return;
            case "boolean":
              var i = t.toLowerCase().slice(0, 5);
              if (i !== "data-" && i !== "aria-") {
                e.removeAttribute(t);
                return;
              }
          }
          e.setAttribute(t, "" + n);
        }
      }
      function Nl(e, t, n) {
        if (n === null) e.removeAttribute(t);
        else {
          switch (typeof n) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              e.removeAttribute(t);
              return;
          }
          e.setAttribute(t, "" + n);
        }
      }
      function Ri(e, t, n, i) {
        if (i === null) e.removeAttribute(n);
        else {
          switch (typeof i) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              e.removeAttribute(n);
              return;
          }
          e.setAttributeNS(t, n, "" + i);
        }
      }
      function Vn(e) {
        switch (typeof e) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return e;
          case "object":
            return e;
          default:
            return "";
        }
      }
      function B0(e) {
        var t = e.type;
        return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
      }
      function Bx(e) {
        var t = B0(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), i = "" + e[t];
        if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
          var a = n.get, s = n.set;
          return Object.defineProperty(e, t, {
            configurable: true,
            get: function() {
              return a.call(this);
            },
            set: function(r) {
              i = "" + r, s.call(this, r);
            }
          }), Object.defineProperty(e, t, {
            enumerable: n.enumerable
          }), {
            getValue: function() {
              return i;
            },
            setValue: function(r) {
              i = "" + r;
            },
            stopTracking: function() {
              e._valueTracker = null, delete e[t];
            }
          };
        }
      }
      function Vc(e) {
        e._valueTracker || (e._valueTracker = Bx(e));
      }
      function F0(e) {
        if (!e) return false;
        var t = e._valueTracker;
        if (!t) return true;
        var n = t.getValue(), i = "";
        return e && (i = B0(e) ? e.checked ? "true" : "false" : e.value), e = i, e !== n ? (t.setValue(e), true) : false;
      }
      function kc(e) {
        if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
        try {
          return e.activeElement || e.body;
        } catch {
          return e.body;
        }
      }
      var Fx = /[\n"\\]/g;
      function Yn(e) {
        return e.replace(Fx, function(t) {
          return "\\" + t.charCodeAt(0).toString(16) + " ";
        });
      }
      function gh(e, t, n, i, a, s, r, o) {
        e.name = "", r != null && typeof r != "function" && typeof r != "symbol" && typeof r != "boolean" ? e.type = r : e.removeAttribute("type"), t != null ? r === "number" ? (t === 0 && e.value === "" || e.value != t) && (e.value = "" + Vn(t)) : e.value !== "" + Vn(t) && (e.value = "" + Vn(t)) : r !== "submit" && r !== "reset" || e.removeAttribute("value"), t != null ? vh(e, r, Vn(t)) : n != null ? vh(e, r, Vn(n)) : i != null && e.removeAttribute("value"), a == null && s != null && (e.defaultChecked = !!s), a != null && (e.checked = a && typeof a != "function" && typeof a != "symbol"), o != null && typeof o != "function" && typeof o != "symbol" && typeof o != "boolean" ? e.name = "" + Vn(o) : e.removeAttribute("name");
      }
      function I0(e, t, n, i, a, s, r, o) {
        if (s != null && typeof s != "function" && typeof s != "symbol" && typeof s != "boolean" && (e.type = s), t != null || n != null) {
          if (!(s !== "submit" && s !== "reset" || t != null)) return;
          n = n != null ? "" + Vn(n) : "", t = t != null ? "" + Vn(t) : n, o || t === e.value || (e.value = t), e.defaultValue = t;
        }
        i = i ?? a, i = typeof i != "function" && typeof i != "symbol" && !!i, e.checked = o ? e.checked : !!i, e.defaultChecked = !!i, r != null && typeof r != "function" && typeof r != "symbol" && typeof r != "boolean" && (e.name = r);
      }
      function vh(e, t, n) {
        t === "number" && kc(e.ownerDocument) === e || e.defaultValue === "" + n || (e.defaultValue = "" + n);
      }
      function _r(e, t, n, i) {
        if (e = e.options, t) {
          t = {};
          for (var a = 0; a < n.length; a++) t["$" + n[a]] = true;
          for (n = 0; n < e.length; n++) a = t.hasOwnProperty("$" + e[n].value), e[n].selected !== a && (e[n].selected = a), a && i && (e[n].defaultSelected = true);
        } else {
          for (n = "" + Vn(n), t = null, a = 0; a < e.length; a++) {
            if (e[a].value === n) {
              e[a].selected = true, i && (e[a].defaultSelected = true);
              return;
            }
            t !== null || e[a].disabled || (t = e[a]);
          }
          t !== null && (t.selected = true);
        }
      }
      function H0(e, t, n) {
        if (t != null && (t = "" + Vn(t), t !== e.value && (e.value = t), n == null)) {
          e.defaultValue !== t && (e.defaultValue = t);
          return;
        }
        e.defaultValue = n != null ? "" + Vn(n) : "";
      }
      function G0(e, t, n, i) {
        if (t == null) {
          if (i != null) {
            if (n != null) throw Error(j(92));
            if (Mo(i)) {
              if (1 < i.length) throw Error(j(93));
              i = i[0];
            }
            n = i;
          }
          n == null && (n = ""), t = n;
        }
        n = Vn(t), e.defaultValue = n, i = e.textContent, i === n && i !== "" && i !== null && (e.value = i);
      }
      function Cr(e, t) {
        if (t) {
          var n = e.firstChild;
          if (n && n === e.lastChild && n.nodeType === 3) {
            n.nodeValue = t;
            return;
          }
        }
        e.textContent = t;
      }
      var Ix = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
      function Um(e, t, n) {
        var i = t.indexOf("--") === 0;
        n == null || typeof n == "boolean" || n === "" ? i ? e.setProperty(t, "") : t === "float" ? e.cssFloat = "" : e[t] = "" : i ? e.setProperty(t, n) : typeof n != "number" || n === 0 || Ix.has(t) ? t === "float" ? e.cssFloat = n : e[t] = ("" + n).trim() : e[t] = n + "px";
      }
      function V0(e, t, n) {
        if (t != null && typeof t != "object") throw Error(j(62));
        if (e = e.style, n != null) {
          for (var i in n) !n.hasOwnProperty(i) || t != null && t.hasOwnProperty(i) || (i.indexOf("--") === 0 ? e.setProperty(i, "") : i === "float" ? e.cssFloat = "" : e[i] = "");
          for (var a in t) i = t[a], t.hasOwnProperty(a) && n[a] !== i && Um(e, a, i);
        } else for (var s in t) t.hasOwnProperty(s) && Um(e, s, t[s]);
      }
      function rp(e) {
        if (e.indexOf("-") === -1) return false;
        switch (e) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var Hx = /* @__PURE__ */ new Map([
        [
          "acceptCharset",
          "accept-charset"
        ],
        [
          "htmlFor",
          "for"
        ],
        [
          "httpEquiv",
          "http-equiv"
        ],
        [
          "crossOrigin",
          "crossorigin"
        ],
        [
          "accentHeight",
          "accent-height"
        ],
        [
          "alignmentBaseline",
          "alignment-baseline"
        ],
        [
          "arabicForm",
          "arabic-form"
        ],
        [
          "baselineShift",
          "baseline-shift"
        ],
        [
          "capHeight",
          "cap-height"
        ],
        [
          "clipPath",
          "clip-path"
        ],
        [
          "clipRule",
          "clip-rule"
        ],
        [
          "colorInterpolation",
          "color-interpolation"
        ],
        [
          "colorInterpolationFilters",
          "color-interpolation-filters"
        ],
        [
          "colorProfile",
          "color-profile"
        ],
        [
          "colorRendering",
          "color-rendering"
        ],
        [
          "dominantBaseline",
          "dominant-baseline"
        ],
        [
          "enableBackground",
          "enable-background"
        ],
        [
          "fillOpacity",
          "fill-opacity"
        ],
        [
          "fillRule",
          "fill-rule"
        ],
        [
          "floodColor",
          "flood-color"
        ],
        [
          "floodOpacity",
          "flood-opacity"
        ],
        [
          "fontFamily",
          "font-family"
        ],
        [
          "fontSize",
          "font-size"
        ],
        [
          "fontSizeAdjust",
          "font-size-adjust"
        ],
        [
          "fontStretch",
          "font-stretch"
        ],
        [
          "fontStyle",
          "font-style"
        ],
        [
          "fontVariant",
          "font-variant"
        ],
        [
          "fontWeight",
          "font-weight"
        ],
        [
          "glyphName",
          "glyph-name"
        ],
        [
          "glyphOrientationHorizontal",
          "glyph-orientation-horizontal"
        ],
        [
          "glyphOrientationVertical",
          "glyph-orientation-vertical"
        ],
        [
          "horizAdvX",
          "horiz-adv-x"
        ],
        [
          "horizOriginX",
          "horiz-origin-x"
        ],
        [
          "imageRendering",
          "image-rendering"
        ],
        [
          "letterSpacing",
          "letter-spacing"
        ],
        [
          "lightingColor",
          "lighting-color"
        ],
        [
          "markerEnd",
          "marker-end"
        ],
        [
          "markerMid",
          "marker-mid"
        ],
        [
          "markerStart",
          "marker-start"
        ],
        [
          "overlinePosition",
          "overline-position"
        ],
        [
          "overlineThickness",
          "overline-thickness"
        ],
        [
          "paintOrder",
          "paint-order"
        ],
        [
          "panose-1",
          "panose-1"
        ],
        [
          "pointerEvents",
          "pointer-events"
        ],
        [
          "renderingIntent",
          "rendering-intent"
        ],
        [
          "shapeRendering",
          "shape-rendering"
        ],
        [
          "stopColor",
          "stop-color"
        ],
        [
          "stopOpacity",
          "stop-opacity"
        ],
        [
          "strikethroughPosition",
          "strikethrough-position"
        ],
        [
          "strikethroughThickness",
          "strikethrough-thickness"
        ],
        [
          "strokeDasharray",
          "stroke-dasharray"
        ],
        [
          "strokeDashoffset",
          "stroke-dashoffset"
        ],
        [
          "strokeLinecap",
          "stroke-linecap"
        ],
        [
          "strokeLinejoin",
          "stroke-linejoin"
        ],
        [
          "strokeMiterlimit",
          "stroke-miterlimit"
        ],
        [
          "strokeOpacity",
          "stroke-opacity"
        ],
        [
          "strokeWidth",
          "stroke-width"
        ],
        [
          "textAnchor",
          "text-anchor"
        ],
        [
          "textDecoration",
          "text-decoration"
        ],
        [
          "textRendering",
          "text-rendering"
        ],
        [
          "transformOrigin",
          "transform-origin"
        ],
        [
          "underlinePosition",
          "underline-position"
        ],
        [
          "underlineThickness",
          "underline-thickness"
        ],
        [
          "unicodeBidi",
          "unicode-bidi"
        ],
        [
          "unicodeRange",
          "unicode-range"
        ],
        [
          "unitsPerEm",
          "units-per-em"
        ],
        [
          "vAlphabetic",
          "v-alphabetic"
        ],
        [
          "vHanging",
          "v-hanging"
        ],
        [
          "vIdeographic",
          "v-ideographic"
        ],
        [
          "vMathematical",
          "v-mathematical"
        ],
        [
          "vectorEffect",
          "vector-effect"
        ],
        [
          "vertAdvY",
          "vert-adv-y"
        ],
        [
          "vertOriginX",
          "vert-origin-x"
        ],
        [
          "vertOriginY",
          "vert-origin-y"
        ],
        [
          "wordSpacing",
          "word-spacing"
        ],
        [
          "writingMode",
          "writing-mode"
        ],
        [
          "xmlnsXlink",
          "xmlns:xlink"
        ],
        [
          "xHeight",
          "x-height"
        ]
      ]), Gx = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function yc(e) {
        return Gx.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e;
      }
      var yh = null;
      function op(e) {
        return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
      }
      var ar = null, gr = null;
      function Lm(e) {
        var t = jr(e);
        if (t && (e = t.stateNode)) {
          var n = e[yn] || null;
          t: switch (e = t.stateNode, t.type) {
            case "input":
              if (gh(e, n.value, n.defaultValue, n.defaultValue, n.checked, n.defaultChecked, n.type, n.name), t = n.name, n.type === "radio" && t != null) {
                for (n = e; n.parentNode; ) n = n.parentNode;
                for (n = n.querySelectorAll('input[name="' + Yn("" + t) + '"][type="radio"]'), t = 0; t < n.length; t++) {
                  var i = n[t];
                  if (i !== e && i.form === e.form) {
                    var a = i[yn] || null;
                    if (!a) throw Error(j(90));
                    gh(i, a.value, a.defaultValue, a.defaultValue, a.checked, a.defaultChecked, a.type, a.name);
                  }
                }
                for (t = 0; t < n.length; t++) i = n[t], i.form === e.form && F0(i);
              }
              break t;
            case "textarea":
              H0(e, n.value, n.defaultValue);
              break t;
            case "select":
              t = n.value, t != null && _r(e, !!n.multiple, t, false);
          }
        }
      }
      var tf = false;
      function k0(e, t, n) {
        if (tf) return e(t, n);
        tf = true;
        try {
          var i = e(t);
          return i;
        } finally {
          if (tf = false, (ar !== null || gr !== null) && (Nu(), ar && (t = ar, e = gr, gr = ar = null, Lm(t), e))) for (t = 0; t < e.length; t++) Lm(e[t]);
        }
      }
      function Yo(e, t) {
        var n = e.stateNode;
        if (n === null) return null;
        var i = n[yn] || null;
        if (i === null) return null;
        n = i[t];
        t: switch (t) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (i = !i.disabled) || (e = e.type, i = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !i;
            break t;
          default:
            e = false;
        }
        if (e) return null;
        if (n && typeof n != "function") throw Error(j(231, t, typeof n));
        return n;
      }
      var Sh = false;
      if (Ki) try {
        var so = {};
        Object.defineProperty(so, "passive", {
          get: function() {
            Sh = true;
          }
        }), window.addEventListener("test", so, so), window.removeEventListener("test", so, so);
      } catch {
        Sh = false;
      }
      var Ea = null, lp = null, Sc = null;
      function X0() {
        if (Sc) return Sc;
        var e, t = lp, n = t.length, i, a = "value" in Ea ? Ea.value : Ea.textContent, s = a.length;
        for (e = 0; e < n && t[e] === a[e]; e++) ;
        var r = n - e;
        for (i = 1; i <= r && t[n - i] === a[s - i]; i++) ;
        return Sc = a.slice(e, 1 < i ? 1 - i : void 0);
      }
      function xc(e) {
        var t = e.keyCode;
        return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
      }
      function Ol() {
        return true;
      }
      function Nm() {
        return false;
      }
      function Sn(e) {
        function t(n, i, a, s, r) {
          this._reactName = n, this._targetInst = a, this.type = i, this.nativeEvent = s, this.target = r, this.currentTarget = null;
          for (var o in e) e.hasOwnProperty(o) && (n = e[o], this[o] = n ? n(s) : s[o]);
          return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === false) ? Ol : Nm, this.isPropagationStopped = Nm, this;
        }
        return ve(t.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var n = this.nativeEvent;
            n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = false), this.isDefaultPrevented = Ol);
          },
          stopPropagation: function() {
            var n = this.nativeEvent;
            n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = true), this.isPropagationStopped = Ol);
          },
          persist: function() {
          },
          isPersistent: Ol
        }), t;
      }
      var Es = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(e) {
          return e.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      }, bu = Sn(Es), _l = ve({}, Es, {
        view: 0,
        detail: 0
      }), Vx = Sn(_l), ef, nf, ro, Tu = ve({}, _l, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: cp,
        button: 0,
        buttons: 0,
        relatedTarget: function(e) {
          return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
        },
        movementX: function(e) {
          return "movementX" in e ? e.movementX : (e !== ro && (ro && e.type === "mousemove" ? (ef = e.screenX - ro.screenX, nf = e.screenY - ro.screenY) : nf = ef = 0, ro = e), ef);
        },
        movementY: function(e) {
          return "movementY" in e ? e.movementY : nf;
        }
      }), Om = Sn(Tu), kx = ve({}, Tu, {
        dataTransfer: 0
      }), Xx = Sn(kx), Wx = ve({}, _l, {
        relatedTarget: 0
      }), af = Sn(Wx), Yx = ve({}, Es, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), qx = Sn(Yx), jx = ve({}, Es, {
        clipboardData: function(e) {
          return "clipboardData" in e ? e.clipboardData : window.clipboardData;
        }
      }), Zx = Sn(jx), Kx = ve({}, Es, {
        data: 0
      }), Pm = Sn(Kx), Qx = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, Jx = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, $x = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function tM(e) {
        var t = this.nativeEvent;
        return t.getModifierState ? t.getModifierState(e) : (e = $x[e]) ? !!t[e] : false;
      }
      function cp() {
        return tM;
      }
      var eM = ve({}, _l, {
        key: function(e) {
          if (e.key) {
            var t = Qx[e.key] || e.key;
            if (t !== "Unidentified") return t;
          }
          return e.type === "keypress" ? (e = xc(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Jx[e.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: cp,
        charCode: function(e) {
          return e.type === "keypress" ? xc(e) : 0;
        },
        keyCode: function(e) {
          return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
        },
        which: function(e) {
          return e.type === "keypress" ? xc(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
        }
      }), nM = Sn(eM), iM = ve({}, Tu, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      }), zm = Sn(iM), aM = ve({}, _l, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: cp
      }), sM = Sn(aM), rM = ve({}, Es, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      }), oM = Sn(rM), lM = ve({}, Tu, {
        deltaX: function(e) {
          return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
        },
        deltaY: function(e) {
          return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), cM = Sn(lM), uM = ve({}, Es, {
        newState: 0,
        oldState: 0
      }), fM = Sn(uM), hM = [
        9,
        13,
        27,
        32
      ], up = Ki && "CompositionEvent" in window, Ro = null;
      Ki && "documentMode" in document && (Ro = document.documentMode);
      var dM = Ki && "TextEvent" in window && !Ro, W0 = Ki && (!up || Ro && 8 < Ro && 11 >= Ro), Bm = " ", Fm = false;
      function Y0(e, t) {
        switch (e) {
          case "keyup":
            return hM.indexOf(t.keyCode) !== -1;
          case "keydown":
            return t.keyCode !== 229;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function q0(e) {
        return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
      }
      var sr = false;
      function pM(e, t) {
        switch (e) {
          case "compositionend":
            return q0(t);
          case "keypress":
            return t.which !== 32 ? null : (Fm = true, Bm);
          case "textInput":
            return e = t.data, e === Bm && Fm ? null : e;
          default:
            return null;
        }
      }
      function mM(e, t) {
        if (sr) return e === "compositionend" || !up && Y0(e, t) ? (e = X0(), Sc = lp = Ea = null, sr = false, e) : null;
        switch (e) {
          case "paste":
            return null;
          case "keypress":
            if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
              if (t.char && 1 < t.char.length) return t.char;
              if (t.which) return String.fromCharCode(t.which);
            }
            return null;
          case "compositionend":
            return W0 && t.locale !== "ko" ? null : t.data;
          default:
            return null;
        }
      }
      var _M = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function Im(e) {
        var t = e && e.nodeName && e.nodeName.toLowerCase();
        return t === "input" ? !!_M[e.type] : t === "textarea";
      }
      function j0(e, t, n, i) {
        ar ? gr ? gr.push(i) : gr = [
          i
        ] : ar = i, t = su(t, "onChange"), 0 < t.length && (n = new bu("onChange", "change", null, n, i), e.push({
          event: n,
          listeners: t
        }));
      }
      var wo = null, qo = null;
      function gM(e) {
        Oy(e, 0);
      }
      function Au(e) {
        var t = Eo(e);
        if (F0(t)) return e;
      }
      function Hm(e, t) {
        if (e === "change") return t;
      }
      var Z0 = false;
      if (Ki) {
        var sf;
        if (Ki) {
          var rf = "oninput" in document;
          if (!rf) {
            var Gm = document.createElement("div");
            Gm.setAttribute("oninput", "return;"), rf = typeof Gm.oninput == "function";
          }
          sf = rf;
        } else sf = false;
        Z0 = sf && (!document.documentMode || 9 < document.documentMode);
      }
      function Vm() {
        wo && (wo.detachEvent("onpropertychange", K0), qo = wo = null);
      }
      function K0(e) {
        if (e.propertyName === "value" && Au(qo)) {
          var t = [];
          j0(t, qo, e, op(e)), k0(gM, t);
        }
      }
      function vM(e, t, n) {
        e === "focusin" ? (Vm(), wo = t, qo = n, wo.attachEvent("onpropertychange", K0)) : e === "focusout" && Vm();
      }
      function yM(e) {
        if (e === "selectionchange" || e === "keyup" || e === "keydown") return Au(qo);
      }
      function SM(e, t) {
        if (e === "click") return Au(t);
      }
      function xM(e, t) {
        if (e === "input" || e === "change") return Au(t);
      }
      function MM(e, t) {
        return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
      }
      var Un = typeof Object.is == "function" ? Object.is : MM;
      function jo(e, t) {
        if (Un(e, t)) return true;
        if (typeof e != "object" || e === null || typeof t != "object" || t === null) return false;
        var n = Object.keys(e), i = Object.keys(t);
        if (n.length !== i.length) return false;
        for (i = 0; i < n.length; i++) {
          var a = n[i];
          if (!mh.call(t, a) || !Un(e[a], t[a])) return false;
        }
        return true;
      }
      function km(e) {
        for (; e && e.firstChild; ) e = e.firstChild;
        return e;
      }
      function Xm(e, t) {
        var n = km(e);
        e = 0;
        for (var i; n; ) {
          if (n.nodeType === 3) {
            if (i = e + n.textContent.length, e <= t && i >= t) return {
              node: n,
              offset: t - e
            };
            e = i;
          }
          t: {
            for (; n; ) {
              if (n.nextSibling) {
                n = n.nextSibling;
                break t;
              }
              n = n.parentNode;
            }
            n = void 0;
          }
          n = km(n);
        }
      }
      function Q0(e, t) {
        return e && t ? e === t ? true : e && e.nodeType === 3 ? false : t && t.nodeType === 3 ? Q0(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : false : false;
      }
      function J0(e) {
        e = e != null && e.ownerDocument != null && e.ownerDocument.defaultView != null ? e.ownerDocument.defaultView : window;
        for (var t = kc(e.document); t instanceof e.HTMLIFrameElement; ) {
          try {
            var n = typeof t.contentWindow.location.href == "string";
          } catch {
            n = false;
          }
          if (n) e = t.contentWindow;
          else break;
          t = kc(e.document);
        }
        return t;
      }
      function fp(e) {
        var t = e && e.nodeName && e.nodeName.toLowerCase();
        return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
      }
      function EM(e, t) {
        var n = J0(t);
        t = e.focusedElem;
        var i = e.selectionRange;
        if (n !== t && t && t.ownerDocument && Q0(t.ownerDocument.documentElement, t)) {
          if (i !== null && fp(t)) {
            if (e = i.start, n = i.end, n === void 0 && (n = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length);
            else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) {
              n = n.getSelection();
              var a = t.textContent.length, s = Math.min(i.start, a);
              i = i.end === void 0 ? s : Math.min(i.end, a), !n.extend && s > i && (a = i, i = s, s = a), a = Xm(t, s);
              var r = Xm(t, i);
              a && r && (n.rangeCount !== 1 || n.anchorNode !== a.node || n.anchorOffset !== a.offset || n.focusNode !== r.node || n.focusOffset !== r.offset) && (e = e.createRange(), e.setStart(a.node, a.offset), n.removeAllRanges(), s > i ? (n.addRange(e), n.extend(r.node, r.offset)) : (e.setEnd(r.node, r.offset), n.addRange(e)));
            }
          }
          for (e = [], n = t; n = n.parentNode; ) n.nodeType === 1 && e.push({
            element: n,
            left: n.scrollLeft,
            top: n.scrollTop
          });
          for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++) n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top;
        }
      }
      var bM = Ki && "documentMode" in document && 11 >= document.documentMode, rr = null, xh = null, Co = null, Mh = false;
      function Wm(e, t, n) {
        var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
        Mh || rr == null || rr !== kc(i) || (i = rr, "selectionStart" in i && fp(i) ? i = {
          start: i.selectionStart,
          end: i.selectionEnd
        } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset
        }), Co && jo(Co, i) || (Co = i, i = su(xh, "onSelect"), 0 < i.length && (t = new bu("onSelect", "select", null, t, n), e.push({
          event: t,
          listeners: i
        }), t.target = rr)));
      }
      function Xa(e, t) {
        var n = {};
        return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n;
      }
      var or = {
        animationend: Xa("Animation", "AnimationEnd"),
        animationiteration: Xa("Animation", "AnimationIteration"),
        animationstart: Xa("Animation", "AnimationStart"),
        transitionrun: Xa("Transition", "TransitionRun"),
        transitionstart: Xa("Transition", "TransitionStart"),
        transitioncancel: Xa("Transition", "TransitionCancel"),
        transitionend: Xa("Transition", "TransitionEnd")
      }, of = {}, $0 = {};
      Ki && ($0 = document.createElement("div").style, "AnimationEvent" in window || (delete or.animationend.animation, delete or.animationiteration.animation, delete or.animationstart.animation), "TransitionEvent" in window || delete or.transitionend.transition);
      function bs(e) {
        if (of[e]) return of[e];
        if (!or[e]) return e;
        var t = or[e], n;
        for (n in t) if (t.hasOwnProperty(n) && n in $0) return of[e] = t[n];
        return e;
      }
      var tv = bs("animationend"), ev = bs("animationiteration"), nv = bs("animationstart"), TM = bs("transitionrun"), AM = bs("transitionstart"), RM = bs("transitioncancel"), iv = bs("transitionend"), av = /* @__PURE__ */ new Map(), Ym = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" ");
      function hi(e, t) {
        av.set(e, t), Ms(t, [
          e
        ]);
      }
      var Hn = [], lr = 0, hp = 0;
      function Ru() {
        for (var e = lr, t = hp = lr = 0; t < e; ) {
          var n = Hn[t];
          Hn[t++] = null;
          var i = Hn[t];
          Hn[t++] = null;
          var a = Hn[t];
          Hn[t++] = null;
          var s = Hn[t];
          if (Hn[t++] = null, i !== null && a !== null) {
            var r = i.pending;
            r === null ? a.next = a : (a.next = r.next, r.next = a), i.pending = a;
          }
          s !== 0 && sv(n, a, s);
        }
      }
      function wu(e, t, n, i) {
        Hn[lr++] = e, Hn[lr++] = t, Hn[lr++] = n, Hn[lr++] = i, hp |= i, e.lanes |= i, e = e.alternate, e !== null && (e.lanes |= i);
      }
      function dp(e, t, n, i) {
        return wu(e, t, n, i), Xc(e);
      }
      function Oa(e, t) {
        return wu(e, null, null, t), Xc(e);
      }
      function sv(e, t, n) {
        e.lanes |= n;
        var i = e.alternate;
        i !== null && (i.lanes |= n);
        for (var a = false, s = e.return; s !== null; ) s.childLanes |= n, i = s.alternate, i !== null && (i.childLanes |= n), s.tag === 22 && (e = s.stateNode, e === null || e._visibility & 1 || (a = true)), e = s, s = s.return;
        a && t !== null && e.tag === 3 && (s = e.stateNode, a = 31 - wn(n), s = s.hiddenUpdates, e = s[a], e === null ? s[a] = [
          t
        ] : e.push(t), t.lane = n | 536870912);
      }
      function Xc(e) {
        if (50 < Go) throw Go = 0, Xh = null, Error(j(185));
        for (var t = e.return; t !== null; ) e = t, t = e.return;
        return e.tag === 3 ? e.stateNode : null;
      }
      var cr = {}, qm = /* @__PURE__ */ new WeakMap();
      function qn(e, t) {
        if (typeof e == "object" && e !== null) {
          var n = qm.get(e);
          return n !== void 0 ? n : (t = {
            value: e,
            source: t,
            stack: Am(t)
          }, qm.set(e, t), t);
        }
        return {
          value: e,
          source: t,
          stack: Am(t)
        };
      }
      var ur = [], fr = 0, Wc = null, Yc = 0, kn = [], Xn = 0, ls = null, ki = 1, Xi = "";
      function Ja(e, t) {
        ur[fr++] = Yc, ur[fr++] = Wc, Wc = e, Yc = t;
      }
      function rv(e, t, n) {
        kn[Xn++] = ki, kn[Xn++] = Xi, kn[Xn++] = ls, ls = e;
        var i = ki;
        e = Xi;
        var a = 32 - wn(i) - 1;
        i &= ~(1 << a), n += 1;
        var s = 32 - wn(t) + a;
        if (30 < s) {
          var r = a - a % 5;
          s = (i & (1 << r) - 1).toString(32), i >>= r, a -= r, ki = 1 << 32 - wn(t) + a | n << a | i, Xi = s + e;
        } else ki = 1 << s | n << a | i, Xi = e;
      }
      function pp(e) {
        e.return !== null && (Ja(e, 1), rv(e, 1, 0));
      }
      function mp(e) {
        for (; e === Wc; ) Wc = ur[--fr], ur[fr] = null, Yc = ur[--fr], ur[fr] = null;
        for (; e === ls; ) ls = kn[--Xn], kn[Xn] = null, Xi = kn[--Xn], kn[Xn] = null, ki = kn[--Xn], kn[Xn] = null;
      }
      var un = null, Je = null, ee = false, oi = null, pi = false, Eh = Error(j(519));
      function ds(e) {
        var t = Error(j(418, ""));
        throw Zo(qn(t, e)), Eh;
      }
      function jm(e) {
        var t = e.stateNode, n = e.type, i = e.memoizedProps;
        switch (t[sn] = e, t[yn] = i, n) {
          case "dialog":
            Xt("cancel", t), Xt("close", t);
            break;
          case "iframe":
          case "object":
          case "embed":
            Xt("load", t);
            break;
          case "video":
          case "audio":
            for (n = 0; n < Jo.length; n++) Xt(Jo[n], t);
            break;
          case "source":
            Xt("error", t);
            break;
          case "img":
          case "image":
          case "link":
            Xt("error", t), Xt("load", t);
            break;
          case "details":
            Xt("toggle", t);
            break;
          case "input":
            Xt("invalid", t), I0(t, i.value, i.defaultValue, i.checked, i.defaultChecked, i.type, i.name, true), Vc(t);
            break;
          case "select":
            Xt("invalid", t);
            break;
          case "textarea":
            Xt("invalid", t), G0(t, i.value, i.defaultValue, i.children), Vc(t);
        }
        n = i.children, typeof n != "string" && typeof n != "number" && typeof n != "bigint" || t.textContent === "" + n || i.suppressHydrationWarning === true || zy(t.textContent, n) ? (i.popover != null && (Xt("beforetoggle", t), Xt("toggle", t)), i.onScroll != null && Xt("scroll", t), i.onScrollEnd != null && Xt("scrollend", t), i.onClick != null && (t.onclick = Pu), t = true) : t = false, t || ds(e);
      }
      function Zm(e) {
        for (un = e.return; un; ) switch (un.tag) {
          case 3:
          case 27:
            pi = true;
            return;
          case 5:
          case 13:
            pi = false;
            return;
          default:
            un = un.return;
        }
      }
      function oo(e) {
        if (e !== un) return false;
        if (!ee) return Zm(e), ee = true, false;
        var t = false, n;
        if ((n = e.tag !== 3 && e.tag !== 27) && ((n = e.tag === 5) && (n = e.type, n = !(n !== "form" && n !== "button") || Qh(e.type, e.memoizedProps)), n = !n), n && (t = true), t && Je && ds(e), Zm(e), e.tag === 13) {
          if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(j(317));
          t: {
            for (e = e.nextSibling, t = 0; e; ) {
              if (e.nodeType === 8) if (n = e.data, n === "/$") {
                if (t === 0) {
                  Je = ui(e.nextSibling);
                  break t;
                }
                t--;
              } else n !== "$" && n !== "$!" && n !== "$?" || t++;
              e = e.nextSibling;
            }
            Je = null;
          }
        } else Je = un ? ui(e.stateNode.nextSibling) : null;
        return true;
      }
      function gl() {
        Je = un = null, ee = false;
      }
      function Zo(e) {
        oi === null ? oi = [
          e
        ] : oi.push(e);
      }
      var Do = Error(j(460)), ov = Error(j(474)), bh = {
        then: function() {
        }
      };
      function Km(e) {
        return e = e.status, e === "fulfilled" || e === "rejected";
      }
      function Pl() {
      }
      function lv(e, t, n) {
        switch (n = e[n], n === void 0 ? e.push(t) : n !== t && (t.then(Pl, Pl), t = n), t.status) {
          case "fulfilled":
            return t.value;
          case "rejected":
            throw e = t.reason, e === Do ? Error(j(483)) : e;
          default:
            if (typeof t.status == "string") t.then(Pl, Pl);
            else {
              if (e = me, e !== null && 100 < e.shellSuspendCounter) throw Error(j(482));
              e = t, e.status = "pending", e.then(function(i) {
                if (t.status === "pending") {
                  var a = t;
                  a.status = "fulfilled", a.value = i;
                }
              }, function(i) {
                if (t.status === "pending") {
                  var a = t;
                  a.status = "rejected", a.reason = i;
                }
              });
            }
            switch (t.status) {
              case "fulfilled":
                return t.value;
              case "rejected":
                throw e = t.reason, e === Do ? Error(j(483)) : e;
            }
            throw Uo = t, Do;
        }
      }
      var Uo = null;
      function Qm() {
        if (Uo === null) throw Error(j(459));
        var e = Uo;
        return Uo = null, e;
      }
      var vr = null, Ko = 0;
      function zl(e) {
        var t = Ko;
        return Ko += 1, vr === null && (vr = []), lv(vr, e, t);
      }
      function lo(e, t) {
        t = t.props.ref, e.ref = t !== void 0 ? t : null;
      }
      function Bl(e, t) {
        throw t.$$typeof === px ? Error(j(525)) : (e = Object.prototype.toString.call(t), Error(j(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)));
      }
      function Jm(e) {
        var t = e._init;
        return t(e._payload);
      }
      function cv(e) {
        function t(u, _) {
          if (e) {
            var g = u.deletions;
            g === null ? (u.deletions = [
              _
            ], u.flags |= 16) : g.push(_);
          }
        }
        function n(u, _) {
          if (!e) return null;
          for (; _ !== null; ) t(u, _), _ = _.sibling;
          return null;
        }
        function i(u) {
          for (var _ = /* @__PURE__ */ new Map(); u !== null; ) u.key !== null ? _.set(u.key, u) : _.set(u.index, u), u = u.sibling;
          return _;
        }
        function a(u, _) {
          return u = Ra(u, _), u.index = 0, u.sibling = null, u;
        }
        function s(u, _, g) {
          return u.index = g, e ? (g = u.alternate, g !== null ? (g = g.index, g < _ ? (u.flags |= 33554434, _) : g) : (u.flags |= 33554434, _)) : (u.flags |= 1048576, _);
        }
        function r(u) {
          return e && u.alternate === null && (u.flags |= 33554434), u;
        }
        function o(u, _, g, v) {
          return _ === null || _.tag !== 6 ? (_ = yf(g, u.mode, v), _.return = u, _) : (_ = a(_, g), _.return = u, _);
        }
        function l(u, _, g, v) {
          var T = g.type;
          return T === nr ? f(u, _, g.props.children, v, g.key) : _ !== null && (_.elementType === T || typeof T == "object" && T !== null && T.$$typeof === pa && Jm(T) === _.type) ? (_ = a(_, g.props), lo(_, g), _.return = u, _) : (_ = Ac(g.type, g.key, g.props, null, u.mode, v), lo(_, g), _.return = u, _);
        }
        function c(u, _, g, v) {
          return _ === null || _.tag !== 4 || _.stateNode.containerInfo !== g.containerInfo || _.stateNode.implementation !== g.implementation ? (_ = Sf(g, u.mode, v), _.return = u, _) : (_ = a(_, g.children || []), _.return = u, _);
        }
        function f(u, _, g, v, T) {
          return _ === null || _.tag !== 7 ? (_ = us(g, u.mode, v, T), _.return = u, _) : (_ = a(_, g), _.return = u, _);
        }
        function d(u, _, g) {
          if (typeof _ == "string" && _ !== "" || typeof _ == "number" || typeof _ == "bigint") return _ = yf("" + _, u.mode, g), _.return = u, _;
          if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
              case Dl:
                return g = Ac(_.type, _.key, _.props, null, u.mode, g), lo(g, _), g.return = u, g;
              case So:
                return _ = Sf(_, u.mode, g), _.return = u, _;
              case pa:
                var v = _._init;
                return _ = v(_._payload), d(u, _, g);
            }
            if (Mo(_) || ao(_)) return _ = us(_, u.mode, g, null), _.return = u, _;
            if (typeof _.then == "function") return d(u, zl(_), g);
            if (_.$$typeof === Vi) return d(u, Fl(u, _), g);
            Bl(u, _);
          }
          return null;
        }
        function h(u, _, g, v) {
          var T = _ !== null ? _.key : null;
          if (typeof g == "string" && g !== "" || typeof g == "number" || typeof g == "bigint") return T !== null ? null : o(u, _, "" + g, v);
          if (typeof g == "object" && g !== null) {
            switch (g.$$typeof) {
              case Dl:
                return g.key === T ? l(u, _, g, v) : null;
              case So:
                return g.key === T ? c(u, _, g, v) : null;
              case pa:
                return T = g._init, g = T(g._payload), h(u, _, g, v);
            }
            if (Mo(g) || ao(g)) return T !== null ? null : f(u, _, g, v, null);
            if (typeof g.then == "function") return h(u, _, zl(g), v);
            if (g.$$typeof === Vi) return h(u, _, Fl(u, g), v);
            Bl(u, g);
          }
          return null;
        }
        function p(u, _, g, v, T) {
          if (typeof v == "string" && v !== "" || typeof v == "number" || typeof v == "bigint") return u = u.get(g) || null, o(_, u, "" + v, T);
          if (typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
              case Dl:
                return u = u.get(v.key === null ? g : v.key) || null, l(_, u, v, T);
              case So:
                return u = u.get(v.key === null ? g : v.key) || null, c(_, u, v, T);
              case pa:
                var R = v._init;
                return v = R(v._payload), p(u, _, g, v, T);
            }
            if (Mo(v) || ao(v)) return u = u.get(g) || null, f(_, u, v, T, null);
            if (typeof v.then == "function") return p(u, _, g, zl(v), T);
            if (v.$$typeof === Vi) return p(u, _, g, Fl(_, v), T);
            Bl(_, v);
          }
          return null;
        }
        function y(u, _, g, v) {
          for (var T = null, R = null, w = _, D = _ = 0, b = null; w !== null && D < g.length; D++) {
            w.index > D ? (b = w, w = null) : b = w.sibling;
            var x = h(u, w, g[D], v);
            if (x === null) {
              w === null && (w = b);
              break;
            }
            e && w && x.alternate === null && t(u, w), _ = s(x, _, D), R === null ? T = x : R.sibling = x, R = x, w = b;
          }
          if (D === g.length) return n(u, w), ee && Ja(u, D), T;
          if (w === null) {
            for (; D < g.length; D++) w = d(u, g[D], v), w !== null && (_ = s(w, _, D), R === null ? T = w : R.sibling = w, R = w);
            return ee && Ja(u, D), T;
          }
          for (w = i(w); D < g.length; D++) b = p(w, u, D, g[D], v), b !== null && (e && b.alternate !== null && w.delete(b.key === null ? D : b.key), _ = s(b, _, D), R === null ? T = b : R.sibling = b, R = b);
          return e && w.forEach(function(C) {
            return t(u, C);
          }), ee && Ja(u, D), T;
        }
        function S(u, _, g, v) {
          if (g == null) throw Error(j(151));
          for (var T = null, R = null, w = _, D = _ = 0, b = null, x = g.next(); w !== null && !x.done; D++, x = g.next()) {
            w.index > D ? (b = w, w = null) : b = w.sibling;
            var C = h(u, w, x.value, v);
            if (C === null) {
              w === null && (w = b);
              break;
            }
            e && w && C.alternate === null && t(u, w), _ = s(C, _, D), R === null ? T = C : R.sibling = C, R = C, w = b;
          }
          if (x.done) return n(u, w), ee && Ja(u, D), T;
          if (w === null) {
            for (; !x.done; D++, x = g.next()) x = d(u, x.value, v), x !== null && (_ = s(x, _, D), R === null ? T = x : R.sibling = x, R = x);
            return ee && Ja(u, D), T;
          }
          for (w = i(w); !x.done; D++, x = g.next()) x = p(w, u, D, x.value, v), x !== null && (e && x.alternate !== null && w.delete(x.key === null ? D : x.key), _ = s(x, _, D), R === null ? T = x : R.sibling = x, R = x);
          return e && w.forEach(function(V) {
            return t(u, V);
          }), ee && Ja(u, D), T;
        }
        function m(u, _, g, v) {
          if (typeof g == "object" && g !== null && g.type === nr && g.key === null && (g = g.props.children), typeof g == "object" && g !== null) {
            switch (g.$$typeof) {
              case Dl:
                t: {
                  for (var T = g.key; _ !== null; ) {
                    if (_.key === T) {
                      if (T = g.type, T === nr) {
                        if (_.tag === 7) {
                          n(u, _.sibling), v = a(_, g.props.children), v.return = u, u = v;
                          break t;
                        }
                      } else if (_.elementType === T || typeof T == "object" && T !== null && T.$$typeof === pa && Jm(T) === _.type) {
                        n(u, _.sibling), v = a(_, g.props), lo(v, g), v.return = u, u = v;
                        break t;
                      }
                      n(u, _);
                      break;
                    } else t(u, _);
                    _ = _.sibling;
                  }
                  g.type === nr ? (v = us(g.props.children, u.mode, v, g.key), v.return = u, u = v) : (v = Ac(g.type, g.key, g.props, null, u.mode, v), lo(v, g), v.return = u, u = v);
                }
                return r(u);
              case So:
                t: {
                  for (T = g.key; _ !== null; ) {
                    if (_.key === T) if (_.tag === 4 && _.stateNode.containerInfo === g.containerInfo && _.stateNode.implementation === g.implementation) {
                      n(u, _.sibling), v = a(_, g.children || []), v.return = u, u = v;
                      break t;
                    } else {
                      n(u, _);
                      break;
                    }
                    else t(u, _);
                    _ = _.sibling;
                  }
                  v = Sf(g, u.mode, v), v.return = u, u = v;
                }
                return r(u);
              case pa:
                return T = g._init, g = T(g._payload), m(u, _, g, v);
            }
            if (Mo(g)) return y(u, _, g, v);
            if (ao(g)) {
              if (T = ao(g), typeof T != "function") throw Error(j(150));
              return g = T.call(g), S(u, _, g, v);
            }
            if (typeof g.then == "function") return m(u, _, zl(g), v);
            if (g.$$typeof === Vi) return m(u, _, Fl(u, g), v);
            Bl(u, g);
          }
          return typeof g == "string" && g !== "" || typeof g == "number" || typeof g == "bigint" ? (g = "" + g, _ !== null && _.tag === 6 ? (n(u, _.sibling), v = a(_, g), v.return = u, u = v) : (n(u, _), v = yf(g, u.mode, v), v.return = u, u = v), r(u)) : n(u, _);
        }
        return function(u, _, g, v) {
          try {
            Ko = 0;
            var T = m(u, _, g, v);
            return vr = null, T;
          } catch (w) {
            if (w === Do) throw w;
            var R = Zn(29, w, null, u.mode);
            return R.lanes = v, R.return = u, R;
          } finally {
          }
        };
      }
      var ps = cv(true), uv = cv(false), Dr = Ei(null), qc = Ei(0);
      function $m(e, t) {
        e = $i, Se(qc, e), Se(Dr, t), $i = e | t.baseLanes;
      }
      function Th() {
        Se(qc, $i), Se(Dr, Dr.current);
      }
      function _p() {
        $i = qc.current, je(Dr), je(qc);
      }
      var $n = Ei(null), Si = null;
      function ga(e) {
        var t = e.alternate;
        Se(Ie, Ie.current & 1), Se($n, e), Si === null && (t === null || Dr.current !== null || t.memoizedState !== null) && (Si = e);
      }
      function fv(e) {
        if (e.tag === 22) {
          if (Se(Ie, Ie.current), Se($n, e), Si === null) {
            var t = e.alternate;
            t !== null && t.memoizedState !== null && (Si = e);
          }
        } else va();
      }
      function va() {
        Se(Ie, Ie.current), Se($n, $n.current);
      }
      function Wi(e) {
        je($n), Si === e && (Si = null), je(Ie);
      }
      var Ie = Ei(0);
      function jc(e) {
        for (var t = e; t !== null; ) {
          if (t.tag === 13) {
            var n = t.memoizedState;
            if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t;
          } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
            if (t.flags & 128) return t;
          } else if (t.child !== null) {
            t.child.return = t, t = t.child;
            continue;
          }
          if (t === e) break;
          for (; t.sibling === null; ) {
            if (t.return === null || t.return === e) return null;
            t = t.return;
          }
          t.sibling.return = t.return, t = t.sibling;
        }
        return null;
      }
      var wM = typeof AbortController < "u" ? AbortController : function() {
        var e = [], t = this.signal = {
          aborted: false,
          addEventListener: function(n, i) {
            e.push(i);
          }
        };
        this.abort = function() {
          t.aborted = true, e.forEach(function(n) {
            return n();
          });
        };
      }, CM = He.unstable_scheduleCallback, DM = He.unstable_NormalPriority, Fe = {
        $$typeof: Vi,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function gp() {
        return {
          controller: new wM(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function vl(e) {
        e.refCount--, e.refCount === 0 && CM(DM, function() {
          e.controller.abort();
        });
      }
      var Lo = null, Ah = 0, Ur = 0, yr = null;
      function UM(e, t) {
        if (Lo === null) {
          var n = Lo = [];
          Ah = 0, Ur = Hp(), yr = {
            status: "pending",
            value: void 0,
            then: function(i) {
              n.push(i);
            }
          };
        }
        return Ah++, t.then(t_, t_), t;
      }
      function t_() {
        if (--Ah === 0 && Lo !== null) {
          yr !== null && (yr.status = "fulfilled");
          var e = Lo;
          Lo = null, Ur = 0, yr = null;
          for (var t = 0; t < e.length; t++) (0, e[t])();
        }
      }
      function LM(e, t) {
        var n = [], i = {
          status: "pending",
          value: null,
          reason: null,
          then: function(a) {
            n.push(a);
          }
        };
        return e.then(function() {
          i.status = "fulfilled", i.value = t;
          for (var a = 0; a < n.length; a++) (0, n[a])(t);
        }, function(a) {
          for (i.status = "rejected", i.reason = a, a = 0; a < n.length; a++) (0, n[a])(void 0);
        }), i;
      }
      var e_ = Lt.S;
      Lt.S = function(e, t) {
        typeof t == "object" && t !== null && typeof t.then == "function" && UM(e, t), e_ !== null && e_(e, t);
      };
      var cs = Ei(null);
      function vp() {
        var e = cs.current;
        return e !== null ? e : me.pooledCache;
      }
      function Mc(e, t) {
        t === null ? Se(cs, cs.current) : Se(cs, t.pool);
      }
      function hv() {
        var e = vp();
        return e === null ? null : {
          parent: Fe._currentValue,
          pool: e
        };
      }
      var Pa = 0, Ht = null, ue = null, Pe = null, Zc = false, Sr = false, ms = false, Kc = 0, Qo = 0, xr = null, NM = 0;
      function Ue() {
        throw Error(j(321));
      }
      function yp(e, t) {
        if (t === null) return false;
        for (var n = 0; n < t.length && n < e.length; n++) if (!Un(e[n], t[n])) return false;
        return true;
      }
      function Sp(e, t, n, i, a, s) {
        return Pa = s, Ht = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Lt.H = e === null || e.memoizedState === null ? Ts : Ga, ms = false, s = n(i, a), ms = false, Sr && (s = pv(t, n, i, a)), dv(e), s;
      }
      function dv(e) {
        Lt.H = xi;
        var t = ue !== null && ue.next !== null;
        if (Pa = 0, Pe = ue = Ht = null, Zc = false, Qo = 0, xr = null, t) throw Error(j(300));
        e === null || qe || (e = e.dependencies, e !== null && $c(e) && (qe = true));
      }
      function pv(e, t, n, i) {
        Ht = e;
        var a = 0;
        do {
          if (Sr && (xr = null), Qo = 0, Sr = false, 25 <= a) throw Error(j(301));
          if (a += 1, Pe = ue = null, e.updateQueue != null) {
            var s = e.updateQueue;
            s.lastEffect = null, s.events = null, s.stores = null, s.memoCache != null && (s.memoCache.index = 0);
          }
          Lt.H = As, s = t(n, i);
        } while (Sr);
        return s;
      }
      function OM() {
        var e = Lt.H, t = e.useState()[0];
        return t = typeof t.then == "function" ? yl(t) : t, e = e.useState()[0], (ue !== null ? ue.memoizedState : null) !== e && (Ht.flags |= 1024), t;
      }
      function xp() {
        var e = Kc !== 0;
        return Kc = 0, e;
      }
      function Mp(e, t, n) {
        t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~n;
      }
      function Ep(e) {
        if (Zc) {
          for (e = e.memoizedState; e !== null; ) {
            var t = e.queue;
            t !== null && (t.pending = null), e = e.next;
          }
          Zc = false;
        }
        Pa = 0, Pe = ue = Ht = null, Sr = false, Qo = Kc = 0, xr = null;
      }
      function vn() {
        var e = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return Pe === null ? Ht.memoizedState = Pe = e : Pe = Pe.next = e, Pe;
      }
      function ze() {
        if (ue === null) {
          var e = Ht.alternate;
          e = e !== null ? e.memoizedState : null;
        } else e = ue.next;
        var t = Pe === null ? Ht.memoizedState : Pe.next;
        if (t !== null) Pe = t, ue = e;
        else {
          if (e === null) throw Ht.alternate === null ? Error(j(467)) : Error(j(310));
          ue = e, e = {
            memoizedState: ue.memoizedState,
            baseState: ue.baseState,
            baseQueue: ue.baseQueue,
            queue: ue.queue,
            next: null
          }, Pe === null ? Ht.memoizedState = Pe = e : Pe = Pe.next = e;
        }
        return Pe;
      }
      var Cu;
      Cu = function() {
        return {
          lastEffect: null,
          events: null,
          stores: null,
          memoCache: null
        };
      };
      function yl(e) {
        var t = Qo;
        return Qo += 1, xr === null && (xr = []), e = lv(xr, e, t), t = Ht, (Pe === null ? t.memoizedState : Pe.next) === null && (t = t.alternate, Lt.H = t === null || t.memoizedState === null ? Ts : Ga), e;
      }
      function Du(e) {
        if (e !== null && typeof e == "object") {
          if (typeof e.then == "function") return yl(e);
          if (e.$$typeof === Vi) return rn(e);
        }
        throw Error(j(438, String(e)));
      }
      function bp(e) {
        var t = null, n = Ht.updateQueue;
        if (n !== null && (t = n.memoCache), t == null) {
          var i = Ht.alternate;
          i !== null && (i = i.updateQueue, i !== null && (i = i.memoCache, i != null && (t = {
            data: i.data.map(function(a) {
              return a.slice();
            }),
            index: 0
          })));
        }
        if (t == null && (t = {
          data: [],
          index: 0
        }), n === null && (n = Cu(), Ht.updateQueue = n), n.memoCache = t, n = t.data[t.index], n === void 0) for (n = t.data[t.index] = Array(e), i = 0; i < e; i++) n[i] = _x;
        return t.index++, n;
      }
      function Qi(e, t) {
        return typeof t == "function" ? t(e) : t;
      }
      function Ec(e) {
        var t = ze();
        return Tp(t, ue, e);
      }
      function Tp(e, t, n) {
        var i = e.queue;
        if (i === null) throw Error(j(311));
        i.lastRenderedReducer = n;
        var a = e.baseQueue, s = i.pending;
        if (s !== null) {
          if (a !== null) {
            var r = a.next;
            a.next = s.next, s.next = r;
          }
          t.baseQueue = a = s, i.pending = null;
        }
        if (s = e.baseState, a === null) e.memoizedState = s;
        else {
          t = a.next;
          var o = r = null, l = null, c = t, f = false;
          do {
            var d = c.lane & -536870913;
            if (d !== c.lane ? (jt & d) === d : (Pa & d) === d) {
              var h = c.revertLane;
              if (h === 0) l !== null && (l = l.next = {
                lane: 0,
                revertLane: 0,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null
              }), d === Ur && (f = true);
              else if ((Pa & h) === h) {
                c = c.next, h === Ur && (f = true);
                continue;
              } else d = {
                lane: 0,
                revertLane: c.revertLane,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null
              }, l === null ? (o = l = d, r = s) : l = l.next = d, Ht.lanes |= h, Ba |= h;
              d = c.action, ms && n(s, d), s = c.hasEagerState ? c.eagerState : n(s, d);
            } else h = {
              lane: d,
              revertLane: c.revertLane,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null
            }, l === null ? (o = l = h, r = s) : l = l.next = h, Ht.lanes |= d, Ba |= d;
            c = c.next;
          } while (c !== null && c !== t);
          if (l === null ? r = s : l.next = o, !Un(s, e.memoizedState) && (qe = true, f && (n = yr, n !== null))) throw n;
          e.memoizedState = s, e.baseState = r, e.baseQueue = l, i.lastRenderedState = s;
        }
        return a === null && (i.lanes = 0), [
          e.memoizedState,
          i.dispatch
        ];
      }
      function lf(e) {
        var t = ze(), n = t.queue;
        if (n === null) throw Error(j(311));
        n.lastRenderedReducer = e;
        var i = n.dispatch, a = n.pending, s = t.memoizedState;
        if (a !== null) {
          n.pending = null;
          var r = a = a.next;
          do
            s = e(s, r.action), r = r.next;
          while (r !== a);
          Un(s, t.memoizedState) || (qe = true), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), n.lastRenderedState = s;
        }
        return [
          s,
          i
        ];
      }
      function mv(e, t, n) {
        var i = Ht, a = ze(), s = ee;
        if (s) {
          if (n === void 0) throw Error(j(407));
          n = n();
        } else n = t();
        var r = !Un((ue || a).memoizedState, n);
        if (r && (a.memoizedState = n, qe = true), a = a.queue, Ap(vv.bind(null, i, a, e), [
          e
        ]), a.getSnapshot !== t || r || Pe !== null && Pe.memoizedState.tag & 1) {
          if (i.flags |= 2048, Lr(9, gv.bind(null, i, a, n, t), {
            destroy: void 0
          }, null), me === null) throw Error(j(349));
          s || Pa & 60 || _v(i, t, n);
        }
        return n;
      }
      function _v(e, t, n) {
        e.flags |= 16384, e = {
          getSnapshot: t,
          value: n
        }, t = Ht.updateQueue, t === null ? (t = Cu(), Ht.updateQueue = t, t.stores = [
          e
        ]) : (n = t.stores, n === null ? t.stores = [
          e
        ] : n.push(e));
      }
      function gv(e, t, n, i) {
        t.value = n, t.getSnapshot = i, yv(t) && Sv(e);
      }
      function vv(e, t, n) {
        return n(function() {
          yv(t) && Sv(e);
        });
      }
      function yv(e) {
        var t = e.getSnapshot;
        e = e.value;
        try {
          var n = t();
          return !Un(e, n);
        } catch {
          return true;
        }
      }
      function Sv(e) {
        var t = Oa(e, 2);
        t !== null && hn(t, e, 2);
      }
      function Rh(e) {
        var t = vn();
        if (typeof e == "function") {
          var n = e;
          if (e = n(), ms) {
            Ma(true);
            try {
              n();
            } finally {
              Ma(false);
            }
          }
        }
        return t.memoizedState = t.baseState = e, t.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Qi,
          lastRenderedState: e
        }, t;
      }
      function xv(e, t, n, i) {
        return e.baseState = n, Tp(e, ue, typeof i == "function" ? i : Qi);
      }
      function PM(e, t, n, i, a) {
        if (Lu(e)) throw Error(j(485));
        if (e = t.action, e !== null) {
          var s = {
            payload: a,
            action: e,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(r) {
              s.listeners.push(r);
            }
          };
          Lt.T !== null ? n(true) : s.isTransition = false, i(s), n = t.pending, n === null ? (s.next = t.pending = s, Mv(t, s)) : (s.next = n.next, t.pending = n.next = s);
        }
      }
      function Mv(e, t) {
        var n = t.action, i = t.payload, a = e.state;
        if (t.isTransition) {
          var s = Lt.T, r = {};
          Lt.T = r;
          try {
            var o = n(a, i), l = Lt.S;
            l !== null && l(r, o), n_(e, t, o);
          } catch (c) {
            wh(e, t, c);
          } finally {
            Lt.T = s;
          }
        } else try {
          s = n(a, i), n_(e, t, s);
        } catch (c) {
          wh(e, t, c);
        }
      }
      function n_(e, t, n) {
        n !== null && typeof n == "object" && typeof n.then == "function" ? n.then(function(i) {
          i_(e, t, i);
        }, function(i) {
          return wh(e, t, i);
        }) : i_(e, t, n);
      }
      function i_(e, t, n) {
        t.status = "fulfilled", t.value = n, Ev(t), e.state = n, t = e.pending, t !== null && (n = t.next, n === t ? e.pending = null : (n = n.next, t.next = n, Mv(e, n)));
      }
      function wh(e, t, n) {
        var i = e.pending;
        if (e.pending = null, i !== null) {
          i = i.next;
          do
            t.status = "rejected", t.reason = n, Ev(t), t = t.next;
          while (t !== i);
        }
        e.action = null;
      }
      function Ev(e) {
        e = e.listeners;
        for (var t = 0; t < e.length; t++) (0, e[t])();
      }
      function bv(e, t) {
        return t;
      }
      function Tv(e, t) {
        if (ee) {
          var n = me.formState;
          if (n !== null) {
            t: {
              var i = Ht;
              if (ee) {
                if (Je) {
                  e: {
                    for (var a = Je, s = pi; a.nodeType !== 8; ) {
                      if (!s) {
                        a = null;
                        break e;
                      }
                      if (a = ui(a.nextSibling), a === null) {
                        a = null;
                        break e;
                      }
                    }
                    s = a.data, a = s === "F!" || s === "F" ? a : null;
                  }
                  if (a) {
                    Je = ui(a.nextSibling), i = a.data === "F!";
                    break t;
                  }
                }
                ds(i);
              }
              i = false;
            }
            i && (t = n[0]);
          }
        }
        return n = vn(), n.memoizedState = n.baseState = t, i = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: bv,
          lastRenderedState: t
        }, n.queue = i, n = Vv.bind(null, Ht, i), i.dispatch = n, i = Rh(false), s = Dp.bind(null, Ht, false, i.queue), i = vn(), a = {
          state: t,
          dispatch: null,
          action: e,
          pending: null
        }, i.queue = a, n = PM.bind(null, Ht, a, s, n), a.dispatch = n, i.memoizedState = e, [
          t,
          n,
          false
        ];
      }
      function Av(e) {
        var t = ze();
        return Rv(t, ue, e);
      }
      function Rv(e, t, n) {
        t = Tp(e, t, bv)[0], e = Ec(Qi)[0], t = typeof t == "object" && t !== null && typeof t.then == "function" ? yl(t) : t;
        var i = ze(), a = i.queue, s = a.dispatch;
        return n !== i.memoizedState && (Ht.flags |= 2048, Lr(9, zM.bind(null, a, n), {
          destroy: void 0
        }, null)), [
          t,
          s,
          e
        ];
      }
      function zM(e, t) {
        e.action = t;
      }
      function wv(e) {
        var t = ze(), n = ue;
        if (n !== null) return Rv(t, n, e);
        ze(), t = t.memoizedState, n = ze();
        var i = n.queue.dispatch;
        return n.memoizedState = e, [
          t,
          i,
          false
        ];
      }
      function Lr(e, t, n, i) {
        return e = {
          tag: e,
          create: t,
          inst: n,
          deps: i,
          next: null
        }, t = Ht.updateQueue, t === null && (t = Cu(), Ht.updateQueue = t), n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (i = n.next, n.next = e, e.next = i, t.lastEffect = e), e;
      }
      function Cv() {
        return ze().memoizedState;
      }
      function bc(e, t, n, i) {
        var a = vn();
        Ht.flags |= e, a.memoizedState = Lr(1 | t, n, {
          destroy: void 0
        }, i === void 0 ? null : i);
      }
      function Uu(e, t, n, i) {
        var a = ze();
        i = i === void 0 ? null : i;
        var s = a.memoizedState.inst;
        ue !== null && i !== null && yp(i, ue.memoizedState.deps) ? a.memoizedState = Lr(t, n, s, i) : (Ht.flags |= e, a.memoizedState = Lr(1 | t, n, s, i));
      }
      function a_(e, t) {
        bc(8390656, 8, e, t);
      }
      function Ap(e, t) {
        Uu(2048, 8, e, t);
      }
      function Dv(e, t) {
        return Uu(4, 2, e, t);
      }
      function Uv(e, t) {
        return Uu(4, 4, e, t);
      }
      function Lv(e, t) {
        if (typeof t == "function") {
          e = e();
          var n = t(e);
          return function() {
            typeof n == "function" ? n() : t(null);
          };
        }
        if (t != null) return e = e(), t.current = e, function() {
          t.current = null;
        };
      }
      function Nv(e, t, n) {
        n = n != null ? n.concat([
          e
        ]) : null, Uu(4, 4, Lv.bind(null, t, e), n);
      }
      function Rp() {
      }
      function Ov(e, t) {
        var n = ze();
        t = t === void 0 ? null : t;
        var i = n.memoizedState;
        return t !== null && yp(t, i[1]) ? i[0] : (n.memoizedState = [
          e,
          t
        ], e);
      }
      function Pv(e, t) {
        var n = ze();
        t = t === void 0 ? null : t;
        var i = n.memoizedState;
        if (t !== null && yp(t, i[1])) return i[0];
        if (i = e(), ms) {
          Ma(true);
          try {
            e();
          } finally {
            Ma(false);
          }
        }
        return n.memoizedState = [
          i,
          t
        ], i;
      }
      function wp(e, t, n) {
        return n === void 0 || Pa & 1073741824 ? e.memoizedState = t : (e.memoizedState = n, e = Ey(), Ht.lanes |= e, Ba |= e, n);
      }
      function zv(e, t, n, i) {
        return Un(n, t) ? n : Dr.current !== null ? (e = wp(e, n, i), Un(e, t) || (qe = true), e) : Pa & 42 ? (e = Ey(), Ht.lanes |= e, Ba |= e, t) : (qe = true, e.memoizedState = n);
      }
      function Bv(e, t, n, i, a) {
        var s = ge.p;
        ge.p = s !== 0 && 8 > s ? s : 8;
        var r = Lt.T, o = {};
        Lt.T = o, Dp(e, false, t, n);
        try {
          var l = a(), c = Lt.S;
          if (c !== null && c(o, l), l !== null && typeof l == "object" && typeof l.then == "function") {
            var f = LM(l, i);
            No(e, t, f, Cn(e));
          } else No(e, t, i, Cn(e));
        } catch (d) {
          No(e, t, {
            then: function() {
            },
            status: "rejected",
            reason: d
          }, Cn());
        } finally {
          ge.p = s, Lt.T = r;
        }
      }
      function BM() {
      }
      function Ch(e, t, n, i) {
        if (e.tag !== 5) throw Error(j(476));
        var a = Fv(e).queue;
        Bv(e, a, t, os, n === null ? BM : function() {
          return Iv(e), n(i);
        });
      }
      function Fv(e) {
        var t = e.memoizedState;
        if (t !== null) return t;
        t = {
          memoizedState: os,
          baseState: os,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Qi,
            lastRenderedState: os
          },
          next: null
        };
        var n = {};
        return t.next = {
          memoizedState: n,
          baseState: n,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Qi,
            lastRenderedState: n
          },
          next: null
        }, e.memoizedState = t, e = e.alternate, e !== null && (e.memoizedState = t), t;
      }
      function Iv(e) {
        var t = Fv(e).next.queue;
        No(e, t, {}, Cn());
      }
      function Cp() {
        return rn(el);
      }
      function Hv() {
        return ze().memoizedState;
      }
      function Gv() {
        return ze().memoizedState;
      }
      function FM(e) {
        for (var t = e.return; t !== null; ) {
          switch (t.tag) {
            case 24:
            case 3:
              var n = Cn();
              e = Ta(n);
              var i = Aa(t, e, n);
              i !== null && (hn(i, t, n), Po(i, t, n)), t = {
                cache: gp()
              }, e.payload = t;
              return;
          }
          t = t.return;
        }
      }
      function IM(e, t, n) {
        var i = Cn();
        n = {
          lane: i,
          revertLane: 0,
          action: n,
          hasEagerState: false,
          eagerState: null,
          next: null
        }, Lu(e) ? kv(t, n) : (n = dp(e, t, n, i), n !== null && (hn(n, e, i), Xv(n, t, i)));
      }
      function Vv(e, t, n) {
        var i = Cn();
        No(e, t, n, i);
      }
      function No(e, t, n, i) {
        var a = {
          lane: i,
          revertLane: 0,
          action: n,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (Lu(e)) kv(t, a);
        else {
          var s = e.alternate;
          if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer, s !== null)) try {
            var r = t.lastRenderedState, o = s(r, n);
            if (a.hasEagerState = true, a.eagerState = o, Un(o, r)) return wu(e, t, a, 0), me === null && Ru(), false;
          } catch {
          } finally {
          }
          if (n = dp(e, t, a, i), n !== null) return hn(n, e, i), Xv(n, t, i), true;
        }
        return false;
      }
      function Dp(e, t, n, i) {
        if (i = {
          lane: 2,
          revertLane: Hp(),
          action: i,
          hasEagerState: false,
          eagerState: null,
          next: null
        }, Lu(e)) {
          if (t) throw Error(j(479));
        } else t = dp(e, n, i, 2), t !== null && hn(t, e, 2);
      }
      function Lu(e) {
        var t = e.alternate;
        return e === Ht || t !== null && t === Ht;
      }
      function kv(e, t) {
        Sr = Zc = true;
        var n = e.pending;
        n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t;
      }
      function Xv(e, t, n) {
        if (n & 4194176) {
          var i = t.lanes;
          i &= e.pendingLanes, n |= i, t.lanes = n, L0(e, n);
        }
      }
      var xi = {
        readContext: rn,
        use: Du,
        useCallback: Ue,
        useContext: Ue,
        useEffect: Ue,
        useImperativeHandle: Ue,
        useLayoutEffect: Ue,
        useInsertionEffect: Ue,
        useMemo: Ue,
        useReducer: Ue,
        useRef: Ue,
        useState: Ue,
        useDebugValue: Ue,
        useDeferredValue: Ue,
        useTransition: Ue,
        useSyncExternalStore: Ue,
        useId: Ue
      };
      xi.useCacheRefresh = Ue;
      xi.useMemoCache = Ue;
      xi.useHostTransitionStatus = Ue;
      xi.useFormState = Ue;
      xi.useActionState = Ue;
      xi.useOptimistic = Ue;
      var Ts = {
        readContext: rn,
        use: Du,
        useCallback: function(e, t) {
          return vn().memoizedState = [
            e,
            t === void 0 ? null : t
          ], e;
        },
        useContext: rn,
        useEffect: a_,
        useImperativeHandle: function(e, t, n) {
          n = n != null ? n.concat([
            e
          ]) : null, bc(4194308, 4, Lv.bind(null, t, e), n);
        },
        useLayoutEffect: function(e, t) {
          return bc(4194308, 4, e, t);
        },
        useInsertionEffect: function(e, t) {
          bc(4, 2, e, t);
        },
        useMemo: function(e, t) {
          var n = vn();
          t = t === void 0 ? null : t;
          var i = e();
          if (ms) {
            Ma(true);
            try {
              e();
            } finally {
              Ma(false);
            }
          }
          return n.memoizedState = [
            i,
            t
          ], i;
        },
        useReducer: function(e, t, n) {
          var i = vn();
          if (n !== void 0) {
            var a = n(t);
            if (ms) {
              Ma(true);
              try {
                n(t);
              } finally {
                Ma(false);
              }
            }
          } else a = t;
          return i.memoizedState = i.baseState = a, e = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: e,
            lastRenderedState: a
          }, i.queue = e, e = e.dispatch = IM.bind(null, Ht, e), [
            i.memoizedState,
            e
          ];
        },
        useRef: function(e) {
          var t = vn();
          return e = {
            current: e
          }, t.memoizedState = e;
        },
        useState: function(e) {
          e = Rh(e);
          var t = e.queue, n = Vv.bind(null, Ht, t);
          return t.dispatch = n, [
            e.memoizedState,
            n
          ];
        },
        useDebugValue: Rp,
        useDeferredValue: function(e, t) {
          var n = vn();
          return wp(n, e, t);
        },
        useTransition: function() {
          var e = Rh(false);
          return e = Bv.bind(null, Ht, e.queue, true, false), vn().memoizedState = e, [
            false,
            e
          ];
        },
        useSyncExternalStore: function(e, t, n) {
          var i = Ht, a = vn();
          if (ee) {
            if (n === void 0) throw Error(j(407));
            n = n();
          } else {
            if (n = t(), me === null) throw Error(j(349));
            jt & 60 || _v(i, t, n);
          }
          a.memoizedState = n;
          var s = {
            value: n,
            getSnapshot: t
          };
          return a.queue = s, a_(vv.bind(null, i, s, e), [
            e
          ]), i.flags |= 2048, Lr(9, gv.bind(null, i, s, n, t), {
            destroy: void 0
          }, null), n;
        },
        useId: function() {
          var e = vn(), t = me.identifierPrefix;
          if (ee) {
            var n = Xi, i = ki;
            n = (i & ~(1 << 32 - wn(i) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Kc++, 0 < n && (t += "H" + n.toString(32)), t += ":";
          } else n = NM++, t = ":" + t + "r" + n.toString(32) + ":";
          return e.memoizedState = t;
        },
        useCacheRefresh: function() {
          return vn().memoizedState = FM.bind(null, Ht);
        }
      };
      Ts.useMemoCache = bp;
      Ts.useHostTransitionStatus = Cp;
      Ts.useFormState = Tv;
      Ts.useActionState = Tv;
      Ts.useOptimistic = function(e) {
        var t = vn();
        t.memoizedState = t.baseState = e;
        var n = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return t.queue = n, t = Dp.bind(null, Ht, true, n), n.dispatch = t, [
          e,
          t
        ];
      };
      var Ga = {
        readContext: rn,
        use: Du,
        useCallback: Ov,
        useContext: rn,
        useEffect: Ap,
        useImperativeHandle: Nv,
        useInsertionEffect: Dv,
        useLayoutEffect: Uv,
        useMemo: Pv,
        useReducer: Ec,
        useRef: Cv,
        useState: function() {
          return Ec(Qi);
        },
        useDebugValue: Rp,
        useDeferredValue: function(e, t) {
          var n = ze();
          return zv(n, ue.memoizedState, e, t);
        },
        useTransition: function() {
          var e = Ec(Qi)[0], t = ze().memoizedState;
          return [
            typeof e == "boolean" ? e : yl(e),
            t
          ];
        },
        useSyncExternalStore: mv,
        useId: Hv
      };
      Ga.useCacheRefresh = Gv;
      Ga.useMemoCache = bp;
      Ga.useHostTransitionStatus = Cp;
      Ga.useFormState = Av;
      Ga.useActionState = Av;
      Ga.useOptimistic = function(e, t) {
        var n = ze();
        return xv(n, ue, e, t);
      };
      var As = {
        readContext: rn,
        use: Du,
        useCallback: Ov,
        useContext: rn,
        useEffect: Ap,
        useImperativeHandle: Nv,
        useInsertionEffect: Dv,
        useLayoutEffect: Uv,
        useMemo: Pv,
        useReducer: lf,
        useRef: Cv,
        useState: function() {
          return lf(Qi);
        },
        useDebugValue: Rp,
        useDeferredValue: function(e, t) {
          var n = ze();
          return ue === null ? wp(n, e, t) : zv(n, ue.memoizedState, e, t);
        },
        useTransition: function() {
          var e = lf(Qi)[0], t = ze().memoizedState;
          return [
            typeof e == "boolean" ? e : yl(e),
            t
          ];
        },
        useSyncExternalStore: mv,
        useId: Hv
      };
      As.useCacheRefresh = Gv;
      As.useMemoCache = bp;
      As.useHostTransitionStatus = Cp;
      As.useFormState = wv;
      As.useActionState = wv;
      As.useOptimistic = function(e, t) {
        var n = ze();
        return ue !== null ? xv(n, ue, e, t) : (n.baseState = e, [
          e,
          n.queue.dispatch
        ]);
      };
      function cf(e, t, n, i) {
        t = e.memoizedState, n = n(i, t), n = n == null ? t : ve({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n);
      }
      var Dh = {
        isMounted: function(e) {
          return (e = e._reactInternals) ? Yr(e) === e : false;
        },
        enqueueSetState: function(e, t, n) {
          e = e._reactInternals;
          var i = Cn(), a = Ta(i);
          a.payload = t, n != null && (a.callback = n), t = Aa(e, a, i), t !== null && (hn(t, e, i), Po(t, e, i));
        },
        enqueueReplaceState: function(e, t, n) {
          e = e._reactInternals;
          var i = Cn(), a = Ta(i);
          a.tag = 1, a.payload = t, n != null && (a.callback = n), t = Aa(e, a, i), t !== null && (hn(t, e, i), Po(t, e, i));
        },
        enqueueForceUpdate: function(e, t) {
          e = e._reactInternals;
          var n = Cn(), i = Ta(n);
          i.tag = 2, t != null && (i.callback = t), t = Aa(e, i, n), t !== null && (hn(t, e, n), Po(t, e, n));
        }
      };
      function s_(e, t, n, i, a, s, r) {
        return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(i, s, r) : t.prototype && t.prototype.isPureReactComponent ? !jo(n, i) || !jo(a, s) : true;
      }
      function r_(e, t, n, i) {
        e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, i), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, i), t.state !== e && Dh.enqueueReplaceState(t, t.state, null);
      }
      function _s(e, t) {
        var n = t;
        if ("ref" in t) {
          n = {};
          for (var i in t) i !== "ref" && (n[i] = t[i]);
        }
        if (e = e.defaultProps) {
          n === t && (n = ve({}, n));
          for (var a in e) n[a] === void 0 && (n[a] = e[a]);
        }
        return n;
      }
      var Qc = typeof reportError == "function" ? reportError : function(e) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
          var t = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: typeof e == "object" && e !== null && typeof e.message == "string" ? String(e.message) : String(e),
            error: e
          });
          if (!window.dispatchEvent(t)) return;
        } else if (typeof process == "object" && typeof process.emit == "function") {
          process.emit("uncaughtException", e);
          return;
        }
        console.error(e);
      };
      function Wv(e) {
        Qc(e);
      }
      function Yv(e) {
        console.error(e);
      }
      function qv(e) {
        Qc(e);
      }
      function Jc(e, t) {
        try {
          var n = e.onUncaughtError;
          n(t.value, {
            componentStack: t.stack
          });
        } catch (i) {
          setTimeout(function() {
            throw i;
          });
        }
      }
      function o_(e, t, n) {
        try {
          var i = e.onCaughtError;
          i(n.value, {
            componentStack: n.stack,
            errorBoundary: t.tag === 1 ? t.stateNode : null
          });
        } catch (a) {
          setTimeout(function() {
            throw a;
          });
        }
      }
      function Uh(e, t, n) {
        return n = Ta(n), n.tag = 3, n.payload = {
          element: null
        }, n.callback = function() {
          Jc(e, t);
        }, n;
      }
      function jv(e) {
        return e = Ta(e), e.tag = 3, e;
      }
      function Zv(e, t, n, i) {
        var a = n.type.getDerivedStateFromError;
        if (typeof a == "function") {
          var s = i.value;
          e.payload = function() {
            return a(s);
          }, e.callback = function() {
            o_(t, n, i);
          };
        }
        var r = n.stateNode;
        r !== null && typeof r.componentDidCatch == "function" && (e.callback = function() {
          o_(t, n, i), typeof a != "function" && (wa === null ? wa = /* @__PURE__ */ new Set([
            this
          ]) : wa.add(this));
          var o = i.stack;
          this.componentDidCatch(i.value, {
            componentStack: o !== null ? o : ""
          });
        });
      }
      function HM(e, t, n, i, a) {
        if (n.flags |= 32768, i !== null && typeof i == "object" && typeof i.then == "function") {
          if (t = n.alternate, t !== null && Sl(t, n, a, true), n = $n.current, n !== null) {
            switch (n.tag) {
              case 13:
                return Si === null ? Yh() : n.alternate === null && we === 0 && (we = 3), n.flags &= -257, n.flags |= 65536, n.lanes = a, i === bh ? n.flags |= 16384 : (t = n.updateQueue, t === null ? n.updateQueue = /* @__PURE__ */ new Set([
                  i
                ]) : t.add(i), Mf(e, i, a)), false;
              case 22:
                return n.flags |= 65536, i === bh ? n.flags |= 16384 : (t = n.updateQueue, t === null ? (t = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([
                    i
                  ])
                }, n.updateQueue = t) : (n = t.retryQueue, n === null ? t.retryQueue = /* @__PURE__ */ new Set([
                  i
                ]) : n.add(i)), Mf(e, i, a)), false;
            }
            throw Error(j(435, n.tag));
          }
          return Mf(e, i, a), Yh(), false;
        }
        if (ee) return t = $n.current, t !== null ? (!(t.flags & 65536) && (t.flags |= 256), t.flags |= 65536, t.lanes = a, i !== Eh && (e = Error(j(422), {
          cause: i
        }), Zo(qn(e, n)))) : (i !== Eh && (t = Error(j(423), {
          cause: i
        }), Zo(qn(t, n))), e = e.current.alternate, e.flags |= 65536, a &= -a, e.lanes |= a, i = qn(i, n), a = Uh(e.stateNode, i, a), mf(e, a), we !== 4 && (we = 2)), false;
        var s = Error(j(520), {
          cause: i
        });
        if (s = qn(s, n), Io === null ? Io = [
          s
        ] : Io.push(s), we !== 4 && (we = 2), t === null) return true;
        i = qn(i, n), n = t;
        do {
          switch (n.tag) {
            case 3:
              return n.flags |= 65536, e = a & -a, n.lanes |= e, e = Uh(n.stateNode, i, e), mf(n, e), false;
            case 1:
              if (t = n.type, s = n.stateNode, (n.flags & 128) === 0 && (typeof t.getDerivedStateFromError == "function" || s !== null && typeof s.componentDidCatch == "function" && (wa === null || !wa.has(s)))) return n.flags |= 65536, a &= -a, n.lanes |= a, a = jv(a), Zv(a, e, n, i), mf(n, a), false;
          }
          n = n.return;
        } while (n !== null);
        return false;
      }
      var Kv = Error(j(461)), qe = false;
      function Qe(e, t, n, i) {
        t.child = e === null ? uv(t, null, n, i) : ps(t, e.child, n, i);
      }
      function l_(e, t, n, i, a) {
        n = n.render;
        var s = t.ref;
        if ("ref" in i) {
          var r = {};
          for (var o in i) o !== "ref" && (r[o] = i[o]);
        } else r = i;
        return gs(t), i = Sp(e, t, n, r, s, a), o = xp(), e !== null && !qe ? (Mp(e, t, a), Ji(e, t, a)) : (ee && o && pp(t), t.flags |= 1, Qe(e, t, i, a), t.child);
      }
      function c_(e, t, n, i, a) {
        if (e === null) {
          var s = n.type;
          return typeof s == "function" && !Pp(s) && s.defaultProps === void 0 && n.compare === null ? (t.tag = 15, t.type = s, Qv(e, t, s, i, a)) : (e = Ac(n.type, null, i, t, t.mode, a), e.ref = t.ref, e.return = t, t.child = e);
        }
        if (s = e.child, !Up(e, a)) {
          var r = s.memoizedProps;
          if (n = n.compare, n = n !== null ? n : jo, n(r, i) && e.ref === t.ref) return Ji(e, t, a);
        }
        return t.flags |= 1, e = Ra(s, i), e.ref = t.ref, e.return = t, t.child = e;
      }
      function Qv(e, t, n, i, a) {
        if (e !== null) {
          var s = e.memoizedProps;
          if (jo(s, i) && e.ref === t.ref) if (qe = false, t.pendingProps = i = s, Up(e, a)) e.flags & 131072 && (qe = true);
          else return t.lanes = e.lanes, Ji(e, t, a);
        }
        return Lh(e, t, n, i, a);
      }
      function Jv(e, t, n) {
        var i = t.pendingProps, a = i.children, s = (t.stateNode._pendingVisibility & 2) !== 0, r = e !== null ? e.memoizedState : null;
        if (Oo(e, t), i.mode === "hidden" || s) {
          if (t.flags & 128) {
            if (i = r !== null ? r.baseLanes | n : n, e !== null) {
              for (a = t.child = e.child, s = 0; a !== null; ) s = s | a.lanes | a.childLanes, a = a.sibling;
              t.childLanes = s & ~i;
            } else t.childLanes = 0, t.child = null;
            return u_(e, t, i, n);
          }
          if (n & 536870912) t.memoizedState = {
            baseLanes: 0,
            cachePool: null
          }, e !== null && Mc(t, r !== null ? r.cachePool : null), r !== null ? $m(t, r) : Th(), fv(t);
          else return t.lanes = t.childLanes = 536870912, u_(e, t, r !== null ? r.baseLanes | n : n, n);
        } else r !== null ? (Mc(t, r.cachePool), $m(t, r), va(), t.memoizedState = null) : (e !== null && Mc(t, null), Th(), va());
        return Qe(e, t, a, n), t.child;
      }
      function u_(e, t, n, i) {
        var a = vp();
        return a = a === null ? null : {
          parent: Fe._currentValue,
          pool: a
        }, t.memoizedState = {
          baseLanes: n,
          cachePool: a
        }, e !== null && Mc(t, null), Th(), fv(t), e !== null && Sl(e, t, i, true), null;
      }
      function Oo(e, t) {
        var n = t.ref;
        if (n === null) e !== null && e.ref !== null && (t.flags |= 2097664);
        else {
          if (typeof n != "function" && typeof n != "object") throw Error(j(284));
          (e === null || e.ref !== n) && (t.flags |= 2097664);
        }
      }
      function Lh(e, t, n, i, a) {
        return gs(t), n = Sp(e, t, n, i, void 0, a), i = xp(), e !== null && !qe ? (Mp(e, t, a), Ji(e, t, a)) : (ee && i && pp(t), t.flags |= 1, Qe(e, t, n, a), t.child);
      }
      function f_(e, t, n, i, a, s) {
        return gs(t), t.updateQueue = null, n = pv(t, i, n, a), dv(e), i = xp(), e !== null && !qe ? (Mp(e, t, s), Ji(e, t, s)) : (ee && i && pp(t), t.flags |= 1, Qe(e, t, n, s), t.child);
      }
      function h_(e, t, n, i, a) {
        if (gs(t), t.stateNode === null) {
          var s = cr, r = n.contextType;
          typeof r == "object" && r !== null && (s = rn(r)), s = new n(i, s), t.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null, s.updater = Dh, t.stateNode = s, s._reactInternals = t, s = t.stateNode, s.props = i, s.state = t.memoizedState, s.refs = {}, Lp(t), r = n.contextType, s.context = typeof r == "object" && r !== null ? rn(r) : cr, s.state = t.memoizedState, r = n.getDerivedStateFromProps, typeof r == "function" && (cf(t, n, r, i), s.state = t.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (r = s.state, typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), r !== s.state && Dh.enqueueReplaceState(s, s.state, null), Bo(t, i, s, a), zo(), s.state = t.memoizedState), typeof s.componentDidMount == "function" && (t.flags |= 4194308), i = true;
        } else if (e === null) {
          s = t.stateNode;
          var o = t.memoizedProps, l = _s(n, o);
          s.props = l;
          var c = s.context, f = n.contextType;
          r = cr, typeof f == "object" && f !== null && (r = rn(f));
          var d = n.getDerivedStateFromProps;
          f = typeof d == "function" || typeof s.getSnapshotBeforeUpdate == "function", o = t.pendingProps !== o, f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (o || c !== r) && r_(t, s, i, r), ma = false;
          var h = t.memoizedState;
          s.state = h, Bo(t, i, s, a), zo(), c = t.memoizedState, o || h !== c || ma ? (typeof d == "function" && (cf(t, n, d, i), c = t.memoizedState), (l = ma || s_(t, n, l, i, h, c, r)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = i, t.memoizedState = c), s.props = i, s.state = c, s.context = r, i = l) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), i = false);
        } else {
          s = t.stateNode, Fh(e, t), r = t.memoizedProps, f = _s(n, r), s.props = f, d = t.pendingProps, h = s.context, c = n.contextType, l = cr, typeof c == "object" && c !== null && (l = rn(c)), o = n.getDerivedStateFromProps, (c = typeof o == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (r !== d || h !== l) && r_(t, s, i, l), ma = false, h = t.memoizedState, s.state = h, Bo(t, i, s, a), zo();
          var p = t.memoizedState;
          r !== d || h !== p || ma || e !== null && e.dependencies !== null && $c(e.dependencies) ? (typeof o == "function" && (cf(t, n, o, i), p = t.memoizedState), (f = ma || s_(t, n, f, i, h, p, l) || e !== null && e.dependencies !== null && $c(e.dependencies)) ? (c || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(i, p, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(i, p, l)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || r === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || r === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = i, t.memoizedState = p), s.props = i, s.state = p, s.context = l, i = f) : (typeof s.componentDidUpdate != "function" || r === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || r === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), i = false);
        }
        return s = i, Oo(e, t), i = (t.flags & 128) !== 0, s || i ? (s = t.stateNode, n = i && typeof n.getDerivedStateFromError != "function" ? null : s.render(), t.flags |= 1, e !== null && i ? (t.child = ps(t, e.child, null, a), t.child = ps(t, null, n, a)) : Qe(e, t, n, a), t.memoizedState = s.state, e = t.child) : e = Ji(e, t, a), e;
      }
      function d_(e, t, n, i) {
        return gl(), t.flags |= 256, Qe(e, t, n, i), t.child;
      }
      var uf = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
      };
      function ff(e) {
        return {
          baseLanes: e,
          cachePool: hv()
        };
      }
      function hf(e, t, n) {
        return e = e !== null ? e.childLanes & ~n : 0, t && (e |= Kn), e;
      }
      function $v(e, t, n) {
        var i = t.pendingProps, a = false, s = (t.flags & 128) !== 0, r;
        if ((r = s) || (r = e !== null && e.memoizedState === null ? false : (Ie.current & 2) !== 0), r && (a = true, t.flags &= -129), r = (t.flags & 32) !== 0, t.flags &= -33, e === null) {
          if (ee) {
            if (a ? ga(t) : va(), ee) {
              var o = Je, l;
              if (l = o) {
                t: {
                  for (l = o, o = pi; l.nodeType !== 8; ) {
                    if (!o) {
                      o = null;
                      break t;
                    }
                    if (l = ui(l.nextSibling), l === null) {
                      o = null;
                      break t;
                    }
                  }
                  o = l;
                }
                o !== null ? (t.memoizedState = {
                  dehydrated: o,
                  treeContext: ls !== null ? {
                    id: ki,
                    overflow: Xi
                  } : null,
                  retryLane: 536870912
                }, l = Zn(18, null, null, 0), l.stateNode = o, l.return = t, t.child = l, un = t, Je = null, l = true) : l = false;
              }
              l || ds(t);
            }
            if (o = t.memoizedState, o !== null && (o = o.dehydrated, o !== null)) return o.data === "$!" ? t.lanes = 16 : t.lanes = 536870912, null;
            Wi(t);
          }
          return o = i.children, i = i.fallback, a ? (va(), a = t.mode, o = Oh({
            mode: "hidden",
            children: o
          }, a), i = us(i, a, n, null), o.return = t, i.return = t, o.sibling = i, t.child = o, a = t.child, a.memoizedState = ff(n), a.childLanes = hf(e, r, n), t.memoizedState = uf, i) : (ga(t), Nh(t, o));
        }
        if (l = e.memoizedState, l !== null && (o = l.dehydrated, o !== null)) {
          if (s) t.flags & 256 ? (ga(t), t.flags &= -257, t = df(e, t, n)) : t.memoizedState !== null ? (va(), t.child = e.child, t.flags |= 128, t = null) : (va(), a = i.fallback, o = t.mode, i = Oh({
            mode: "visible",
            children: i.children
          }, o), a = us(a, o, n, null), a.flags |= 2, i.return = t, a.return = t, i.sibling = a, t.child = i, ps(t, e.child, null, n), i = t.child, i.memoizedState = ff(n), i.childLanes = hf(e, r, n), t.memoizedState = uf, t = a);
          else if (ga(t), o.data === "$!") {
            if (r = o.nextSibling && o.nextSibling.dataset, r) var c = r.dgst;
            r = c, i = Error(j(419)), i.stack = "", i.digest = r, Zo({
              value: i,
              source: null,
              stack: null
            }), t = df(e, t, n);
          } else if (qe || Sl(e, t, n, false), r = (n & e.childLanes) !== 0, qe || r) {
            if (r = me, r !== null) {
              if (i = n & -n, i & 42) i = 1;
              else switch (i) {
                case 2:
                  i = 1;
                  break;
                case 8:
                  i = 4;
                  break;
                case 32:
                  i = 16;
                  break;
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                  i = 64;
                  break;
                case 268435456:
                  i = 134217728;
                  break;
                default:
                  i = 0;
              }
              if (i = i & (r.suspendedLanes | n) ? 0 : i, i !== 0 && i !== l.retryLane) throw l.retryLane = i, Oa(e, i), hn(r, e, i), Kv;
            }
            o.data === "$?" || Yh(), t = df(e, t, n);
          } else o.data === "$?" ? (t.flags |= 128, t.child = e.child, t = eE.bind(null, e), o._reactRetry = t, t = null) : (e = l.treeContext, Je = ui(o.nextSibling), un = t, ee = true, oi = null, pi = false, e !== null && (kn[Xn++] = ki, kn[Xn++] = Xi, kn[Xn++] = ls, ki = e.id, Xi = e.overflow, ls = t), t = Nh(t, i.children), t.flags |= 4096);
          return t;
        }
        return a ? (va(), a = i.fallback, o = t.mode, l = e.child, c = l.sibling, i = Ra(l, {
          mode: "hidden",
          children: i.children
        }), i.subtreeFlags = l.subtreeFlags & 31457280, c !== null ? a = Ra(c, a) : (a = us(a, o, n, null), a.flags |= 2), a.return = t, i.return = t, i.sibling = a, t.child = i, i = a, a = t.child, o = e.child.memoizedState, o === null ? o = ff(n) : (l = o.cachePool, l !== null ? (c = Fe._currentValue, l = l.parent !== c ? {
          parent: c,
          pool: c
        } : l) : l = hv(), o = {
          baseLanes: o.baseLanes | n,
          cachePool: l
        }), a.memoizedState = o, a.childLanes = hf(e, r, n), t.memoizedState = uf, i) : (ga(t), n = e.child, e = n.sibling, n = Ra(n, {
          mode: "visible",
          children: i.children
        }), n.return = t, n.sibling = null, e !== null && (r = t.deletions, r === null ? (t.deletions = [
          e
        ], t.flags |= 16) : r.push(e)), t.child = n, t.memoizedState = null, n);
      }
      function Nh(e, t) {
        return t = Oh({
          mode: "visible",
          children: t
        }, e.mode), t.return = e, e.child = t;
      }
      function Oh(e, t) {
        return xy(e, t, 0, null);
      }
      function df(e, t, n) {
        return ps(t, e.child, null, n), e = Nh(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e;
      }
      function p_(e, t, n) {
        e.lanes |= t;
        var i = e.alternate;
        i !== null && (i.lanes |= t), zh(e.return, t, n);
      }
      function pf(e, t, n, i, a) {
        var s = e.memoizedState;
        s === null ? e.memoizedState = {
          isBackwards: t,
          rendering: null,
          renderingStartTime: 0,
          last: i,
          tail: n,
          tailMode: a
        } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = n, s.tailMode = a);
      }
      function ty(e, t, n) {
        var i = t.pendingProps, a = i.revealOrder, s = i.tail;
        if (Qe(e, t, i.children, n), i = Ie.current, i & 2) i = i & 1 | 2, t.flags |= 128;
        else {
          if (e !== null && e.flags & 128) t: for (e = t.child; e !== null; ) {
            if (e.tag === 13) e.memoizedState !== null && p_(e, n, t);
            else if (e.tag === 19) p_(e, n, t);
            else if (e.child !== null) {
              e.child.return = e, e = e.child;
              continue;
            }
            if (e === t) break t;
            for (; e.sibling === null; ) {
              if (e.return === null || e.return === t) break t;
              e = e.return;
            }
            e.sibling.return = e.return, e = e.sibling;
          }
          i &= 1;
        }
        switch (Se(Ie, i), a) {
          case "forwards":
            for (n = t.child, a = null; n !== null; ) e = n.alternate, e !== null && jc(e) === null && (a = n), n = n.sibling;
            n = a, n === null ? (a = t.child, t.child = null) : (a = n.sibling, n.sibling = null), pf(t, false, a, n, s);
            break;
          case "backwards":
            for (n = null, a = t.child, t.child = null; a !== null; ) {
              if (e = a.alternate, e !== null && jc(e) === null) {
                t.child = a;
                break;
              }
              e = a.sibling, a.sibling = n, n = a, a = e;
            }
            pf(t, true, n, null, s);
            break;
          case "together":
            pf(t, false, null, null, void 0);
            break;
          default:
            t.memoizedState = null;
        }
        return t.child;
      }
      function Ji(e, t, n) {
        if (e !== null && (t.dependencies = e.dependencies), Ba |= t.lanes, !(n & t.childLanes)) if (e !== null) {
          if (Sl(e, t, n, false), (n & t.childLanes) === 0) return null;
        } else return null;
        if (e !== null && t.child !== e.child) throw Error(j(153));
        if (t.child !== null) {
          for (e = t.child, n = Ra(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null; ) e = e.sibling, n = n.sibling = Ra(e, e.pendingProps), n.return = t;
          n.sibling = null;
        }
        return t.child;
      }
      function Up(e, t) {
        return e.lanes & t ? true : (e = e.dependencies, !!(e !== null && $c(e)));
      }
      function GM(e, t, n) {
        switch (t.tag) {
          case 3:
            Ic(t, t.stateNode.containerInfo), ya(t, Fe, e.memoizedState.cache), gl();
            break;
          case 27:
          case 5:
            ph(t);
            break;
          case 4:
            Ic(t, t.stateNode.containerInfo);
            break;
          case 10:
            ya(t, t.type, t.memoizedProps.value);
            break;
          case 13:
            var i = t.memoizedState;
            if (i !== null) return i.dehydrated !== null ? (ga(t), t.flags |= 128, null) : n & t.child.childLanes ? $v(e, t, n) : (ga(t), e = Ji(e, t, n), e !== null ? e.sibling : null);
            ga(t);
            break;
          case 19:
            var a = (e.flags & 128) !== 0;
            if (i = (n & t.childLanes) !== 0, i || (Sl(e, t, n, false), i = (n & t.childLanes) !== 0), a) {
              if (i) return ty(e, t, n);
              t.flags |= 128;
            }
            if (a = t.memoizedState, a !== null && (a.rendering = null, a.tail = null, a.lastEffect = null), Se(Ie, Ie.current), i) break;
            return null;
          case 22:
          case 23:
            return t.lanes = 0, Jv(e, t, n);
          case 24:
            ya(t, Fe, e.memoizedState.cache);
        }
        return Ji(e, t, n);
      }
      function ey(e, t, n) {
        if (e !== null) if (e.memoizedProps !== t.pendingProps) qe = true;
        else {
          if (!Up(e, n) && !(t.flags & 128)) return qe = false, GM(e, t, n);
          qe = !!(e.flags & 131072);
        }
        else qe = false, ee && t.flags & 1048576 && rv(t, Yc, t.index);
        switch (t.lanes = 0, t.tag) {
          case 16:
            t: {
              e = t.pendingProps;
              var i = t.elementType, a = i._init;
              if (i = a(i._payload), t.type = i, typeof i == "function") Pp(i) ? (e = _s(i, e), t.tag = 1, t = h_(null, t, i, e, n)) : (t.tag = 0, t = Lh(null, t, i, e, n));
              else {
                if (i != null) {
                  if (a = i.$$typeof, a === np) {
                    t.tag = 11, t = l_(null, t, i, e, n);
                    break t;
                  } else if (a === ip) {
                    t.tag = 14, t = c_(null, t, i, e, n);
                    break t;
                  }
                }
                throw t = hh(i) || i, Error(j(306, t, ""));
              }
            }
            return t;
          case 0:
            return Lh(e, t, t.type, t.pendingProps, n);
          case 1:
            return i = t.type, a = _s(i, t.pendingProps), h_(e, t, i, a, n);
          case 3:
            t: {
              if (Ic(t, t.stateNode.containerInfo), e === null) throw Error(j(387));
              var s = t.pendingProps;
              a = t.memoizedState, i = a.element, Fh(e, t), Bo(t, s, null, n);
              var r = t.memoizedState;
              if (s = r.cache, ya(t, Fe, s), s !== a.cache && Bh(t, [
                Fe
              ], n, true), zo(), s = r.element, a.isDehydrated) if (a = {
                element: s,
                isDehydrated: false,
                cache: r.cache
              }, t.updateQueue.baseState = a, t.memoizedState = a, t.flags & 256) {
                t = d_(e, t, s, n);
                break t;
              } else if (s !== i) {
                i = qn(Error(j(424)), t), Zo(i), t = d_(e, t, s, n);
                break t;
              } else for (Je = ui(t.stateNode.containerInfo.firstChild), un = t, ee = true, oi = null, pi = true, n = uv(t, null, s, n), t.child = n; n; ) n.flags = n.flags & -3 | 4096, n = n.sibling;
              else {
                if (gl(), s === i) {
                  t = Ji(e, t, n);
                  break t;
                }
                Qe(e, t, s, n);
              }
              t = t.child;
            }
            return t;
          case 26:
            return Oo(e, t), e === null ? (n = L_(t.type, null, t.pendingProps, null)) ? t.memoizedState = n : ee || (n = t.type, e = t.pendingProps, i = ru(ba.current).createElement(n), i[sn] = t, i[yn] = e, $e(i, n, e), Ye(i), t.stateNode = i) : t.memoizedState = L_(t.type, e.memoizedProps, t.pendingProps, e.memoizedState), null;
          case 27:
            return ph(t), e === null && ee && (i = t.stateNode = Iy(t.type, t.pendingProps, ba.current), un = t, pi = true, Je = ui(i.firstChild)), i = t.pendingProps.children, e !== null || ee ? Qe(e, t, i, n) : t.child = ps(t, null, i, n), Oo(e, t), t.child;
          case 5:
            return e === null && ee && ((a = i = Je) && (i = gE(i, t.type, t.pendingProps, pi), i !== null ? (t.stateNode = i, un = t, Je = ui(i.firstChild), pi = false, a = true) : a = false), a || ds(t)), ph(t), a = t.type, s = t.pendingProps, r = e !== null ? e.memoizedProps : null, i = s.children, Qh(a, s) ? i = null : r !== null && Qh(a, r) && (t.flags |= 32), t.memoizedState !== null && (a = Sp(e, t, OM, null, null, n), el._currentValue = a), Oo(e, t), Qe(e, t, i, n), t.child;
          case 6:
            return e === null && ee && ((e = n = Je) && (n = vE(n, t.pendingProps, pi), n !== null ? (t.stateNode = n, un = t, Je = null, e = true) : e = false), e || ds(t)), null;
          case 13:
            return $v(e, t, n);
          case 4:
            return Ic(t, t.stateNode.containerInfo), i = t.pendingProps, e === null ? t.child = ps(t, null, i, n) : Qe(e, t, i, n), t.child;
          case 11:
            return l_(e, t, t.type, t.pendingProps, n);
          case 7:
            return Qe(e, t, t.pendingProps, n), t.child;
          case 8:
            return Qe(e, t, t.pendingProps.children, n), t.child;
          case 12:
            return Qe(e, t, t.pendingProps.children, n), t.child;
          case 10:
            return i = t.pendingProps, ya(t, t.type, i.value), Qe(e, t, i.children, n), t.child;
          case 9:
            return a = t.type._context, i = t.pendingProps.children, gs(t), a = rn(a), i = i(a), t.flags |= 1, Qe(e, t, i, n), t.child;
          case 14:
            return c_(e, t, t.type, t.pendingProps, n);
          case 15:
            return Qv(e, t, t.type, t.pendingProps, n);
          case 19:
            return ty(e, t, n);
          case 22:
            return Jv(e, t, n);
          case 24:
            return gs(t), i = rn(Fe), e === null ? (a = vp(), a === null && (a = me, s = gp(), a.pooledCache = s, s.refCount++, s !== null && (a.pooledCacheLanes |= n), a = s), t.memoizedState = {
              parent: i,
              cache: a
            }, Lp(t), ya(t, Fe, a)) : (e.lanes & n && (Fh(e, t), Bo(t, null, null, n), zo()), a = e.memoizedState, s = t.memoizedState, a.parent !== i ? (a = {
              parent: i,
              cache: i
            }, t.memoizedState = a, t.lanes === 0 && (t.memoizedState = t.updateQueue.baseState = a), ya(t, Fe, i)) : (i = s.cache, ya(t, Fe, i), i !== a.cache && Bh(t, [
              Fe
            ], n, true))), Qe(e, t, t.pendingProps.children, n), t.child;
          case 29:
            throw t.pendingProps;
        }
        throw Error(j(156, t.tag));
      }
      var Ph = Ei(null), Rs = null, Yi = null;
      function ya(e, t, n) {
        Se(Ph, t._currentValue), t._currentValue = n;
      }
      function ji(e) {
        e._currentValue = Ph.current, je(Ph);
      }
      function zh(e, t, n) {
        for (; e !== null; ) {
          var i = e.alternate;
          if ((e.childLanes & t) !== t ? (e.childLanes |= t, i !== null && (i.childLanes |= t)) : i !== null && (i.childLanes & t) !== t && (i.childLanes |= t), e === n) break;
          e = e.return;
        }
      }
      function Bh(e, t, n, i) {
        var a = e.child;
        for (a !== null && (a.return = e); a !== null; ) {
          var s = a.dependencies;
          if (s !== null) {
            var r = a.child;
            s = s.firstContext;
            t: for (; s !== null; ) {
              var o = s;
              s = a;
              for (var l = 0; l < t.length; l++) if (o.context === t[l]) {
                s.lanes |= n, o = s.alternate, o !== null && (o.lanes |= n), zh(s.return, n, e), i || (r = null);
                break t;
              }
              s = o.next;
            }
          } else if (a.tag === 18) {
            if (r = a.return, r === null) throw Error(j(341));
            r.lanes |= n, s = r.alternate, s !== null && (s.lanes |= n), zh(r, n, e), r = null;
          } else r = a.child;
          if (r !== null) r.return = a;
          else for (r = a; r !== null; ) {
            if (r === e) {
              r = null;
              break;
            }
            if (a = r.sibling, a !== null) {
              a.return = r.return, r = a;
              break;
            }
            r = r.return;
          }
          a = r;
        }
      }
      function Sl(e, t, n, i) {
        e = null;
        for (var a = t, s = false; a !== null; ) {
          if (!s) {
            if (a.flags & 524288) s = true;
            else if (a.flags & 262144) break;
          }
          if (a.tag === 10) {
            var r = a.alternate;
            if (r === null) throw Error(j(387));
            if (r = r.memoizedProps, r !== null) {
              var o = a.type;
              Un(a.pendingProps.value, r.value) || (e !== null ? e.push(o) : e = [
                o
              ]);
            }
          } else if (a === Fc.current) {
            if (r = a.alternate, r === null) throw Error(j(387));
            r.memoizedState.memoizedState !== a.memoizedState.memoizedState && (e !== null ? e.push(el) : e = [
              el
            ]);
          }
          a = a.return;
        }
        e !== null && Bh(t, e, n, i), t.flags |= 262144;
      }
      function $c(e) {
        for (e = e.firstContext; e !== null; ) {
          if (!Un(e.context._currentValue, e.memoizedValue)) return true;
          e = e.next;
        }
        return false;
      }
      function gs(e) {
        Rs = e, Yi = null, e = e.dependencies, e !== null && (e.firstContext = null);
      }
      function rn(e) {
        return ny(Rs, e);
      }
      function Fl(e, t) {
        return Rs === null && gs(e), ny(e, t);
      }
      function ny(e, t) {
        var n = t._currentValue;
        if (t = {
          context: t,
          memoizedValue: n,
          next: null
        }, Yi === null) {
          if (e === null) throw Error(j(308));
          Yi = t, e.dependencies = {
            lanes: 0,
            firstContext: t
          }, e.flags |= 524288;
        } else Yi = Yi.next = t;
        return n;
      }
      var ma = false;
      function Lp(e) {
        e.updateQueue = {
          baseState: e.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null,
            lanes: 0,
            hiddenCallbacks: null
          },
          callbacks: null
        };
      }
      function Fh(e, t) {
        e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
          baseState: e.baseState,
          firstBaseUpdate: e.firstBaseUpdate,
          lastBaseUpdate: e.lastBaseUpdate,
          shared: e.shared,
          callbacks: null
        });
      }
      function Ta(e) {
        return {
          lane: e,
          tag: 0,
          payload: null,
          callback: null,
          next: null
        };
      }
      function Aa(e, t, n) {
        var i = e.updateQueue;
        if (i === null) return null;
        if (i = i.shared, be & 2) {
          var a = i.pending;
          return a === null ? t.next = t : (t.next = a.next, a.next = t), i.pending = t, t = Xc(e), sv(e, null, n), t;
        }
        return wu(e, i, t, n), Xc(e);
      }
      function Po(e, t, n) {
        if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194176) !== 0)) {
          var i = t.lanes;
          i &= e.pendingLanes, n |= i, t.lanes = n, L0(e, n);
        }
      }
      function mf(e, t) {
        var n = e.updateQueue, i = e.alternate;
        if (i !== null && (i = i.updateQueue, n === i)) {
          var a = null, s = null;
          if (n = n.firstBaseUpdate, n !== null) {
            do {
              var r = {
                lane: n.lane,
                tag: n.tag,
                payload: n.payload,
                callback: null,
                next: null
              };
              s === null ? a = s = r : s = s.next = r, n = n.next;
            } while (n !== null);
            s === null ? a = s = t : s = s.next = t;
          } else a = s = t;
          n = {
            baseState: i.baseState,
            firstBaseUpdate: a,
            lastBaseUpdate: s,
            shared: i.shared,
            callbacks: i.callbacks
          }, e.updateQueue = n;
          return;
        }
        e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t;
      }
      var Ih = false;
      function zo() {
        if (Ih) {
          var e = yr;
          if (e !== null) throw e;
        }
      }
      function Bo(e, t, n, i) {
        Ih = false;
        var a = e.updateQueue;
        ma = false;
        var s = a.firstBaseUpdate, r = a.lastBaseUpdate, o = a.shared.pending;
        if (o !== null) {
          a.shared.pending = null;
          var l = o, c = l.next;
          l.next = null, r === null ? s = c : r.next = c, r = l;
          var f = e.alternate;
          f !== null && (f = f.updateQueue, o = f.lastBaseUpdate, o !== r && (o === null ? f.firstBaseUpdate = c : o.next = c, f.lastBaseUpdate = l));
        }
        if (s !== null) {
          var d = a.baseState;
          r = 0, f = c = l = null, o = s;
          do {
            var h = o.lane & -536870913, p = h !== o.lane;
            if (p ? (jt & h) === h : (i & h) === h) {
              h !== 0 && h === Ur && (Ih = true), f !== null && (f = f.next = {
                lane: 0,
                tag: o.tag,
                payload: o.payload,
                callback: null,
                next: null
              });
              t: {
                var y = e, S = o;
                h = t;
                var m = n;
                switch (S.tag) {
                  case 1:
                    if (y = S.payload, typeof y == "function") {
                      d = y.call(m, d, h);
                      break t;
                    }
                    d = y;
                    break t;
                  case 3:
                    y.flags = y.flags & -65537 | 128;
                  case 0:
                    if (y = S.payload, h = typeof y == "function" ? y.call(m, d, h) : y, h == null) break t;
                    d = ve({}, d, h);
                    break t;
                  case 2:
                    ma = true;
                }
              }
              h = o.callback, h !== null && (e.flags |= 64, p && (e.flags |= 8192), p = a.callbacks, p === null ? a.callbacks = [
                h
              ] : p.push(h));
            } else p = {
              lane: h,
              tag: o.tag,
              payload: o.payload,
              callback: o.callback,
              next: null
            }, f === null ? (c = f = p, l = d) : f = f.next = p, r |= h;
            if (o = o.next, o === null) {
              if (o = a.shared.pending, o === null) break;
              p = o, o = p.next, p.next = null, a.lastBaseUpdate = p, a.shared.pending = null;
            }
          } while (true);
          f === null && (l = d), a.baseState = l, a.firstBaseUpdate = c, a.lastBaseUpdate = f, s === null && (a.shared.lanes = 0), Ba |= r, e.lanes = r, e.memoizedState = d;
        }
      }
      function iy(e, t) {
        if (typeof e != "function") throw Error(j(191, e));
        e.call(t);
      }
      function ay(e, t) {
        var n = e.callbacks;
        if (n !== null) for (e.callbacks = null, e = 0; e < n.length; e++) iy(n[e], t);
      }
      function xl(e, t) {
        try {
          var n = t.updateQueue, i = n !== null ? n.lastEffect : null;
          if (i !== null) {
            var a = i.next;
            n = a;
            do {
              if ((n.tag & e) === e) {
                i = void 0;
                var s = n.create, r = n.inst;
                i = s(), r.destroy = i;
              }
              n = n.next;
            } while (n !== a);
          }
        } catch (o) {
          he(t, t.return, o);
        }
      }
      function za(e, t, n) {
        try {
          var i = t.updateQueue, a = i !== null ? i.lastEffect : null;
          if (a !== null) {
            var s = a.next;
            i = s;
            do {
              if ((i.tag & e) === e) {
                var r = i.inst, o = r.destroy;
                if (o !== void 0) {
                  r.destroy = void 0, a = t;
                  var l = n;
                  try {
                    o();
                  } catch (c) {
                    he(a, l, c);
                  }
                }
              }
              i = i.next;
            } while (i !== s);
          }
        } catch (c) {
          he(t, t.return, c);
        }
      }
      function sy(e) {
        var t = e.updateQueue;
        if (t !== null) {
          var n = e.stateNode;
          try {
            ay(t, n);
          } catch (i) {
            he(e, e.return, i);
          }
        }
      }
      function ry(e, t, n) {
        n.props = _s(e.type, e.memoizedProps), n.state = e.memoizedState;
        try {
          n.componentWillUnmount();
        } catch (i) {
          he(e, t, i);
        }
      }
      function as(e, t) {
        try {
          var n = e.ref;
          if (n !== null) {
            var i = e.stateNode;
            switch (e.tag) {
              case 26:
              case 27:
              case 5:
                var a = i;
                break;
              default:
                a = i;
            }
            typeof n == "function" ? e.refCleanup = n(a) : n.current = a;
          }
        } catch (s) {
          he(e, t, s);
        }
      }
      function An(e, t) {
        var n = e.ref, i = e.refCleanup;
        if (n !== null) if (typeof i == "function") try {
          i();
        } catch (a) {
          he(e, t, a);
        } finally {
          e.refCleanup = null, e = e.alternate, e != null && (e.refCleanup = null);
        }
        else if (typeof n == "function") try {
          n(null);
        } catch (a) {
          he(e, t, a);
        }
        else n.current = null;
      }
      function oy(e) {
        var t = e.type, n = e.memoizedProps, i = e.stateNode;
        try {
          t: switch (t) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              n.autoFocus && i.focus();
              break t;
            case "img":
              n.src ? i.src = n.src : n.srcSet && (i.srcset = n.srcSet);
          }
        } catch (a) {
          he(e, e.return, a);
        }
      }
      function m_(e, t, n) {
        try {
          var i = e.stateNode;
          hE(i, e.type, n, t), i[yn] = t;
        } catch (a) {
          he(e, e.return, a);
        }
      }
      function ly(e) {
        return e.tag === 5 || e.tag === 3 || e.tag === 26 || e.tag === 27 || e.tag === 4;
      }
      function _f(e) {
        t: for (; ; ) {
          for (; e.sibling === null; ) {
            if (e.return === null || ly(e.return)) return null;
            e = e.return;
          }
          for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 27 && e.tag !== 18; ) {
            if (e.flags & 2 || e.child === null || e.tag === 4) continue t;
            e.child.return = e, e = e.child;
          }
          if (!(e.flags & 2)) return e.stateNode;
        }
      }
      function Hh(e, t, n) {
        var i = e.tag;
        if (i === 5 || i === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Pu));
        else if (i !== 4 && i !== 27 && (e = e.child, e !== null)) for (Hh(e, t, n), e = e.sibling; e !== null; ) Hh(e, t, n), e = e.sibling;
      }
      function tu(e, t, n) {
        var i = e.tag;
        if (i === 5 || i === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
        else if (i !== 4 && i !== 27 && (e = e.child, e !== null)) for (tu(e, t, n), e = e.sibling; e !== null; ) tu(e, t, n), e = e.sibling;
      }
      var Fi = false, Re = false, gf = false, __ = typeof WeakSet == "function" ? WeakSet : Set, We = null, g_ = false;
      function VM(e, t) {
        if (e = e.containerInfo, Zh = uu, e = J0(e), fp(e)) {
          if ("selectionStart" in e) var n = {
            start: e.selectionStart,
            end: e.selectionEnd
          };
          else t: {
            n = (n = e.ownerDocument) && n.defaultView || window;
            var i = n.getSelection && n.getSelection();
            if (i && i.rangeCount !== 0) {
              n = i.anchorNode;
              var a = i.anchorOffset, s = i.focusNode;
              i = i.focusOffset;
              try {
                n.nodeType, s.nodeType;
              } catch {
                n = null;
                break t;
              }
              var r = 0, o = -1, l = -1, c = 0, f = 0, d = e, h = null;
              e: for (; ; ) {
                for (var p; d !== n || a !== 0 && d.nodeType !== 3 || (o = r + a), d !== s || i !== 0 && d.nodeType !== 3 || (l = r + i), d.nodeType === 3 && (r += d.nodeValue.length), (p = d.firstChild) !== null; ) h = d, d = p;
                for (; ; ) {
                  if (d === e) break e;
                  if (h === n && ++c === a && (o = r), h === s && ++f === i && (l = r), (p = d.nextSibling) !== null) break;
                  d = h, h = d.parentNode;
                }
                d = p;
              }
              n = o === -1 || l === -1 ? null : {
                start: o,
                end: l
              };
            } else n = null;
          }
          n = n || {
            start: 0,
            end: 0
          };
        } else n = null;
        for (Kh = {
          focusedElem: e,
          selectionRange: n
        }, uu = false, We = t; We !== null; ) if (t = We, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, We = e;
        else for (; We !== null; ) {
          switch (t = We, s = t.alternate, e = t.flags, t.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if (e & 1024 && s !== null) {
                e = void 0, n = t, a = s.memoizedProps, s = s.memoizedState, i = n.stateNode;
                try {
                  var y = _s(n.type, a, n.elementType === n.type);
                  e = i.getSnapshotBeforeUpdate(y, s), i.__reactInternalSnapshotBeforeUpdate = e;
                } catch (S) {
                  he(n, n.return, S);
                }
              }
              break;
            case 3:
              if (e & 1024) {
                if (e = t.stateNode.containerInfo, n = e.nodeType, n === 9) Jh(e);
                else if (n === 1) switch (e.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    Jh(e);
                    break;
                  default:
                    e.textContent = "";
                }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if (e & 1024) throw Error(j(163));
          }
          if (e = t.sibling, e !== null) {
            e.return = t.return, We = e;
            break;
          }
          We = t.return;
        }
        return y = g_, g_ = false, y;
      }
      function cy(e, t, n) {
        var i = n.flags;
        switch (n.tag) {
          case 0:
          case 11:
          case 15:
            Ci(e, n), i & 4 && xl(5, n);
            break;
          case 1:
            if (Ci(e, n), i & 4) if (e = n.stateNode, t === null) try {
              e.componentDidMount();
            } catch (o) {
              he(n, n.return, o);
            }
            else {
              var a = _s(n.type, t.memoizedProps);
              t = t.memoizedState;
              try {
                e.componentDidUpdate(a, t, e.__reactInternalSnapshotBeforeUpdate);
              } catch (o) {
                he(n, n.return, o);
              }
            }
            i & 64 && sy(n), i & 512 && as(n, n.return);
            break;
          case 3:
            if (Ci(e, n), i & 64 && (i = n.updateQueue, i !== null)) {
              if (e = null, n.child !== null) switch (n.child.tag) {
                case 27:
                case 5:
                  e = n.child.stateNode;
                  break;
                case 1:
                  e = n.child.stateNode;
              }
              try {
                ay(i, e);
              } catch (o) {
                he(n, n.return, o);
              }
            }
            break;
          case 26:
            Ci(e, n), i & 512 && as(n, n.return);
            break;
          case 27:
          case 5:
            Ci(e, n), t === null && i & 4 && oy(n), i & 512 && as(n, n.return);
            break;
          case 12:
            Ci(e, n);
            break;
          case 13:
            Ci(e, n), i & 4 && hy(e, n);
            break;
          case 22:
            if (a = n.memoizedState !== null || Fi, !a) {
              t = t !== null && t.memoizedState !== null || Re;
              var s = Fi, r = Re;
              Fi = a, (Re = t) && !r ? da(e, n, (n.subtreeFlags & 8772) !== 0) : Ci(e, n), Fi = s, Re = r;
            }
            i & 512 && (n.memoizedProps.mode === "manual" ? as(n, n.return) : An(n, n.return));
            break;
          default:
            Ci(e, n);
        }
      }
      function uy(e) {
        var t = e.alternate;
        t !== null && (e.alternate = null, uy(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && sp(t)), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
      var Oe = null, bn = false;
      function wi(e, t, n) {
        for (n = n.child; n !== null; ) fy(e, t, n), n = n.sibling;
      }
      function fy(e, t, n) {
        if (Rn && typeof Rn.onCommitFiberUnmount == "function") try {
          Rn.onCommitFiberUnmount(dl, n);
        } catch {
        }
        switch (n.tag) {
          case 26:
            Re || An(n, t), wi(e, t, n), n.memoizedState ? n.memoizedState.count-- : n.stateNode && (n = n.stateNode, n.parentNode.removeChild(n));
            break;
          case 27:
            Re || An(n, t);
            var i = Oe, a = bn;
            for (Oe = n.stateNode, wi(e, t, n), n = n.stateNode, t = n.attributes; t.length; ) n.removeAttributeNode(t[0]);
            sp(n), Oe = i, bn = a;
            break;
          case 5:
            Re || An(n, t);
          case 6:
            a = Oe;
            var s = bn;
            if (Oe = null, wi(e, t, n), Oe = a, bn = s, Oe !== null) if (bn) try {
              e = Oe, i = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(i) : e.removeChild(i);
            } catch (r) {
              he(n, t, r);
            }
            else try {
              Oe.removeChild(n.stateNode);
            } catch (r) {
              he(n, t, r);
            }
            break;
          case 18:
            Oe !== null && (bn ? (t = Oe, n = n.stateNode, t.nodeType === 8 ? Cf(t.parentNode, n) : t.nodeType === 1 && Cf(t, n), al(t)) : Cf(Oe, n.stateNode));
            break;
          case 4:
            i = Oe, a = bn, Oe = n.stateNode.containerInfo, bn = true, wi(e, t, n), Oe = i, bn = a;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            Re || za(2, n, t), Re || za(4, n, t), wi(e, t, n);
            break;
          case 1:
            Re || (An(n, t), i = n.stateNode, typeof i.componentWillUnmount == "function" && ry(n, t, i)), wi(e, t, n);
            break;
          case 21:
            wi(e, t, n);
            break;
          case 22:
            Re || An(n, t), Re = (i = Re) || n.memoizedState !== null, wi(e, t, n), Re = i;
            break;
          default:
            wi(e, t, n);
        }
      }
      function hy(e, t) {
        if (t.memoizedState === null && (e = t.alternate, e !== null && (e = e.memoizedState, e !== null && (e = e.dehydrated, e !== null)))) try {
          al(e);
        } catch (n) {
          he(t, t.return, n);
        }
      }
      function kM(e) {
        switch (e.tag) {
          case 13:
          case 19:
            var t = e.stateNode;
            return t === null && (t = e.stateNode = new __()), t;
          case 22:
            return e = e.stateNode, t = e._retryCache, t === null && (t = e._retryCache = new __()), t;
          default:
            throw Error(j(435, e.tag));
        }
      }
      function vf(e, t) {
        var n = kM(e);
        t.forEach(function(i) {
          var a = nE.bind(null, e, i);
          n.has(i) || (n.add(i), i.then(a, a));
        });
      }
      function zn(e, t) {
        var n = t.deletions;
        if (n !== null) for (var i = 0; i < n.length; i++) {
          var a = n[i], s = e, r = t, o = r;
          t: for (; o !== null; ) {
            switch (o.tag) {
              case 27:
              case 5:
                Oe = o.stateNode, bn = false;
                break t;
              case 3:
                Oe = o.stateNode.containerInfo, bn = true;
                break t;
              case 4:
                Oe = o.stateNode.containerInfo, bn = true;
                break t;
            }
            o = o.return;
          }
          if (Oe === null) throw Error(j(160));
          fy(s, r, a), Oe = null, bn = false, s = a.alternate, s !== null && (s.return = null), a.return = null;
        }
        if (t.subtreeFlags & 13878) for (t = t.child; t !== null; ) dy(t, e), t = t.sibling;
      }
      var ri = null;
      function dy(e, t) {
        var n = e.alternate, i = e.flags;
        switch (e.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            zn(t, e), Bn(e), i & 4 && (za(3, e, e.return), xl(3, e), za(5, e, e.return));
            break;
          case 1:
            zn(t, e), Bn(e), i & 512 && (Re || n === null || An(n, n.return)), i & 64 && Fi && (e = e.updateQueue, e !== null && (i = e.callbacks, i !== null && (n = e.shared.hiddenCallbacks, e.shared.hiddenCallbacks = n === null ? i : n.concat(i))));
            break;
          case 26:
            var a = ri;
            if (zn(t, e), Bn(e), i & 512 && (Re || n === null || An(n, n.return)), i & 4) {
              var s = n !== null ? n.memoizedState : null;
              if (i = e.memoizedState, n === null) if (i === null) if (e.stateNode === null) {
                t: {
                  i = e.type, n = e.memoizedProps, a = a.ownerDocument || a;
                  e: switch (i) {
                    case "title":
                      s = a.getElementsByTagName("title")[0], (!s || s[Wo] || s[sn] || s.namespaceURI === "http://www.w3.org/2000/svg" || s.hasAttribute("itemprop")) && (s = a.createElement(i), a.head.insertBefore(s, a.querySelector("head > title"))), $e(s, i, n), s[sn] = e, Ye(s), i = s;
                      break t;
                    case "link":
                      var r = O_("link", "href", a).get(i + (n.href || ""));
                      if (r) {
                        for (var o = 0; o < r.length; o++) if (s = r[o], s.getAttribute("href") === (n.href == null ? null : n.href) && s.getAttribute("rel") === (n.rel == null ? null : n.rel) && s.getAttribute("title") === (n.title == null ? null : n.title) && s.getAttribute("crossorigin") === (n.crossOrigin == null ? null : n.crossOrigin)) {
                          r.splice(o, 1);
                          break e;
                        }
                      }
                      s = a.createElement(i), $e(s, i, n), a.head.appendChild(s);
                      break;
                    case "meta":
                      if (r = O_("meta", "content", a).get(i + (n.content || ""))) {
                        for (o = 0; o < r.length; o++) if (s = r[o], s.getAttribute("content") === (n.content == null ? null : "" + n.content) && s.getAttribute("name") === (n.name == null ? null : n.name) && s.getAttribute("property") === (n.property == null ? null : n.property) && s.getAttribute("http-equiv") === (n.httpEquiv == null ? null : n.httpEquiv) && s.getAttribute("charset") === (n.charSet == null ? null : n.charSet)) {
                          r.splice(o, 1);
                          break e;
                        }
                      }
                      s = a.createElement(i), $e(s, i, n), a.head.appendChild(s);
                      break;
                    default:
                      throw Error(j(468, i));
                  }
                  s[sn] = e, Ye(s), i = s;
                }
                e.stateNode = i;
              } else P_(a, e.type, e.stateNode);
              else e.stateNode = N_(a, i, e.memoizedProps);
              else s !== i ? (s === null ? n.stateNode !== null && (n = n.stateNode, n.parentNode.removeChild(n)) : s.count--, i === null ? P_(a, e.type, e.stateNode) : N_(a, i, e.memoizedProps)) : i === null && e.stateNode !== null && m_(e, e.memoizedProps, n.memoizedProps);
            }
            break;
          case 27:
            if (i & 4 && e.alternate === null) {
              a = e.stateNode, s = e.memoizedProps;
              try {
                for (var l = a.firstChild; l; ) {
                  var c = l.nextSibling, f = l.nodeName;
                  l[Wo] || f === "HEAD" || f === "BODY" || f === "SCRIPT" || f === "STYLE" || f === "LINK" && l.rel.toLowerCase() === "stylesheet" || a.removeChild(l), l = c;
                }
                for (var d = e.type, h = a.attributes; h.length; ) a.removeAttributeNode(h[0]);
                $e(a, d, s), a[sn] = e, a[yn] = s;
              } catch (y) {
                he(e, e.return, y);
              }
            }
          case 5:
            if (zn(t, e), Bn(e), i & 512 && (Re || n === null || An(n, n.return)), e.flags & 32) {
              a = e.stateNode;
              try {
                Cr(a, "");
              } catch (y) {
                he(e, e.return, y);
              }
            }
            i & 4 && e.stateNode != null && (a = e.memoizedProps, m_(e, a, n !== null ? n.memoizedProps : a)), i & 1024 && (gf = true);
            break;
          case 6:
            if (zn(t, e), Bn(e), i & 4) {
              if (e.stateNode === null) throw Error(j(162));
              i = e.memoizedProps, n = e.stateNode;
              try {
                n.nodeValue = i;
              } catch (y) {
                he(e, e.return, y);
              }
            }
            break;
          case 3:
            if (wc = null, a = ri, ri = ou(t.containerInfo), zn(t, e), ri = a, Bn(e), i & 4 && n !== null && n.memoizedState.isDehydrated) try {
              al(t.containerInfo);
            } catch (y) {
              he(e, e.return, y);
            }
            gf && (gf = false, py(e));
            break;
          case 4:
            i = ri, ri = ou(e.stateNode.containerInfo), zn(t, e), Bn(e), ri = i;
            break;
          case 12:
            zn(t, e), Bn(e);
            break;
          case 13:
            zn(t, e), Bn(e), e.child.flags & 8192 && e.memoizedState !== null != (n !== null && n.memoizedState !== null) && (Fp = yi()), i & 4 && (i = e.updateQueue, i !== null && (e.updateQueue = null, vf(e, i)));
            break;
          case 22:
            if (i & 512 && (Re || n === null || An(n, n.return)), l = e.memoizedState !== null, c = n !== null && n.memoizedState !== null, f = Fi, d = Re, Fi = f || l, Re = d || c, zn(t, e), Re = d, Fi = f, Bn(e), t = e.stateNode, t._current = e, t._visibility &= -3, t._visibility |= t._pendingVisibility & 2, i & 8192 && (t._visibility = l ? t._visibility & -2 : t._visibility | 1, l && (t = Fi || Re, n === null || c || t || Ks(e)), e.memoizedProps === null || e.memoizedProps.mode !== "manual")) t: for (n = null, t = e; ; ) {
              if (t.tag === 5 || t.tag === 26 || t.tag === 27) {
                if (n === null) {
                  c = n = t;
                  try {
                    if (a = c.stateNode, l) s = a.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none";
                    else {
                      r = c.stateNode, o = c.memoizedProps.style;
                      var p = o != null && o.hasOwnProperty("display") ? o.display : null;
                      r.style.display = p == null || typeof p == "boolean" ? "" : ("" + p).trim();
                    }
                  } catch (y) {
                    he(c, c.return, y);
                  }
                }
              } else if (t.tag === 6) {
                if (n === null) {
                  c = t;
                  try {
                    c.stateNode.nodeValue = l ? "" : c.memoizedProps;
                  } catch (y) {
                    he(c, c.return, y);
                  }
                }
              } else if ((t.tag !== 22 && t.tag !== 23 || t.memoizedState === null || t === e) && t.child !== null) {
                t.child.return = t, t = t.child;
                continue;
              }
              if (t === e) break t;
              for (; t.sibling === null; ) {
                if (t.return === null || t.return === e) break t;
                n === t && (n = null), t = t.return;
              }
              n === t && (n = null), t.sibling.return = t.return, t = t.sibling;
            }
            i & 4 && (i = e.updateQueue, i !== null && (n = i.retryQueue, n !== null && (i.retryQueue = null, vf(e, n))));
            break;
          case 19:
            zn(t, e), Bn(e), i & 4 && (i = e.updateQueue, i !== null && (e.updateQueue = null, vf(e, i)));
            break;
          case 21:
            break;
          default:
            zn(t, e), Bn(e);
        }
      }
      function Bn(e) {
        var t = e.flags;
        if (t & 2) {
          try {
            if (e.tag !== 27) {
              t: {
                for (var n = e.return; n !== null; ) {
                  if (ly(n)) {
                    var i = n;
                    break t;
                  }
                  n = n.return;
                }
                throw Error(j(160));
              }
              switch (i.tag) {
                case 27:
                  var a = i.stateNode, s = _f(e);
                  tu(e, s, a);
                  break;
                case 5:
                  var r = i.stateNode;
                  i.flags & 32 && (Cr(r, ""), i.flags &= -33);
                  var o = _f(e);
                  tu(e, o, r);
                  break;
                case 3:
                case 4:
                  var l = i.stateNode.containerInfo, c = _f(e);
                  Hh(e, c, l);
                  break;
                default:
                  throw Error(j(161));
              }
            }
          } catch (f) {
            he(e, e.return, f);
          }
          e.flags &= -3;
        }
        t & 4096 && (e.flags &= -4097);
      }
      function py(e) {
        if (e.subtreeFlags & 1024) for (e = e.child; e !== null; ) {
          var t = e;
          py(t), t.tag === 5 && t.flags & 1024 && t.stateNode.reset(), e = e.sibling;
        }
      }
      function Ci(e, t) {
        if (t.subtreeFlags & 8772) for (t = t.child; t !== null; ) cy(e, t.alternate, t), t = t.sibling;
      }
      function Ks(e) {
        for (e = e.child; e !== null; ) {
          var t = e;
          switch (t.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              za(4, t, t.return), Ks(t);
              break;
            case 1:
              An(t, t.return);
              var n = t.stateNode;
              typeof n.componentWillUnmount == "function" && ry(t, t.return, n), Ks(t);
              break;
            case 26:
            case 27:
            case 5:
              An(t, t.return), Ks(t);
              break;
            case 22:
              An(t, t.return), t.memoizedState === null && Ks(t);
              break;
            default:
              Ks(t);
          }
          e = e.sibling;
        }
      }
      function da(e, t, n) {
        for (n = n && (t.subtreeFlags & 8772) !== 0, t = t.child; t !== null; ) {
          var i = t.alternate, a = e, s = t, r = s.flags;
          switch (s.tag) {
            case 0:
            case 11:
            case 15:
              da(a, s, n), xl(4, s);
              break;
            case 1:
              if (da(a, s, n), i = s, a = i.stateNode, typeof a.componentDidMount == "function") try {
                a.componentDidMount();
              } catch (c) {
                he(i, i.return, c);
              }
              if (i = s, a = i.updateQueue, a !== null) {
                var o = i.stateNode;
                try {
                  var l = a.shared.hiddenCallbacks;
                  if (l !== null) for (a.shared.hiddenCallbacks = null, a = 0; a < l.length; a++) iy(l[a], o);
                } catch (c) {
                  he(i, i.return, c);
                }
              }
              n && r & 64 && sy(s), as(s, s.return);
              break;
            case 26:
            case 27:
            case 5:
              da(a, s, n), n && i === null && r & 4 && oy(s), as(s, s.return);
              break;
            case 12:
              da(a, s, n);
              break;
            case 13:
              da(a, s, n), n && r & 4 && hy(a, s);
              break;
            case 22:
              s.memoizedState === null && da(a, s, n), as(s, s.return);
              break;
            default:
              da(a, s, n);
          }
          t = t.sibling;
        }
      }
      function Np(e, t) {
        var n = null;
        e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), e = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (e = t.memoizedState.cachePool.pool), e !== n && (e != null && e.refCount++, n != null && vl(n));
      }
      function Op(e, t) {
        e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (t.refCount++, e != null && vl(e));
      }
      function ra(e, t, n, i) {
        if (t.subtreeFlags & 10256) for (t = t.child; t !== null; ) my(e, t, n, i), t = t.sibling;
      }
      function my(e, t, n, i) {
        var a = t.flags;
        switch (t.tag) {
          case 0:
          case 11:
          case 15:
            ra(e, t, n, i), a & 2048 && xl(9, t);
            break;
          case 3:
            ra(e, t, n, i), a & 2048 && (e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (t.refCount++, e != null && vl(e)));
            break;
          case 12:
            if (a & 2048) {
              ra(e, t, n, i), e = t.stateNode;
              try {
                var s = t.memoizedProps, r = s.id, o = s.onPostCommit;
                typeof o == "function" && o(r, t.alternate === null ? "mount" : "update", e.passiveEffectDuration, -0);
              } catch (l) {
                he(t, t.return, l);
              }
            } else ra(e, t, n, i);
            break;
          case 23:
            break;
          case 22:
            s = t.stateNode, t.memoizedState !== null ? s._visibility & 4 ? ra(e, t, n, i) : Fo(e, t) : s._visibility & 4 ? ra(e, t, n, i) : (s._visibility |= 4, Qs(e, t, n, i, (t.subtreeFlags & 10256) !== 0)), a & 2048 && Np(t.alternate, t);
            break;
          case 24:
            ra(e, t, n, i), a & 2048 && Op(t.alternate, t);
            break;
          default:
            ra(e, t, n, i);
        }
      }
      function Qs(e, t, n, i, a) {
        for (a = a && (t.subtreeFlags & 10256) !== 0, t = t.child; t !== null; ) {
          var s = e, r = t, o = n, l = i, c = r.flags;
          switch (r.tag) {
            case 0:
            case 11:
            case 15:
              Qs(s, r, o, l, a), xl(8, r);
              break;
            case 23:
              break;
            case 22:
              var f = r.stateNode;
              r.memoizedState !== null ? f._visibility & 4 ? Qs(s, r, o, l, a) : Fo(s, r) : (f._visibility |= 4, Qs(s, r, o, l, a)), a && c & 2048 && Np(r.alternate, r);
              break;
            case 24:
              Qs(s, r, o, l, a), a && c & 2048 && Op(r.alternate, r);
              break;
            default:
              Qs(s, r, o, l, a);
          }
          t = t.sibling;
        }
      }
      function Fo(e, t) {
        if (t.subtreeFlags & 10256) for (t = t.child; t !== null; ) {
          var n = e, i = t, a = i.flags;
          switch (i.tag) {
            case 22:
              Fo(n, i), a & 2048 && Np(i.alternate, i);
              break;
            case 24:
              Fo(n, i), a & 2048 && Op(i.alternate, i);
              break;
            default:
              Fo(n, i);
          }
          t = t.sibling;
        }
      }
      var bo = 8192;
      function Us(e) {
        if (e.subtreeFlags & bo) for (e = e.child; e !== null; ) _y(e), e = e.sibling;
      }
      function _y(e) {
        switch (e.tag) {
          case 26:
            Us(e), e.flags & bo && e.memoizedState !== null && UE(ri, e.memoizedState, e.memoizedProps);
            break;
          case 5:
            Us(e);
            break;
          case 3:
          case 4:
            var t = ri;
            ri = ou(e.stateNode.containerInfo), Us(e), ri = t;
            break;
          case 22:
            e.memoizedState === null && (t = e.alternate, t !== null && t.memoizedState !== null ? (t = bo, bo = 16777216, Us(e), bo = t) : Us(e));
            break;
          default:
            Us(e);
        }
      }
      function gy(e) {
        var t = e.alternate;
        if (t !== null && (e = t.child, e !== null)) {
          t.child = null;
          do
            t = e.sibling, e.sibling = null, e = t;
          while (e !== null);
        }
      }
      function co(e) {
        var t = e.deletions;
        if (e.flags & 16) {
          if (t !== null) for (var n = 0; n < t.length; n++) {
            var i = t[n];
            We = i, yy(i, e);
          }
          gy(e);
        }
        if (e.subtreeFlags & 10256) for (e = e.child; e !== null; ) vy(e), e = e.sibling;
      }
      function vy(e) {
        switch (e.tag) {
          case 0:
          case 11:
          case 15:
            co(e), e.flags & 2048 && za(9, e, e.return);
            break;
          case 3:
            co(e);
            break;
          case 12:
            co(e);
            break;
          case 22:
            var t = e.stateNode;
            e.memoizedState !== null && t._visibility & 4 && (e.return === null || e.return.tag !== 13) ? (t._visibility &= -5, Tc(e)) : co(e);
            break;
          default:
            co(e);
        }
      }
      function Tc(e) {
        var t = e.deletions;
        if (e.flags & 16) {
          if (t !== null) for (var n = 0; n < t.length; n++) {
            var i = t[n];
            We = i, yy(i, e);
          }
          gy(e);
        }
        for (e = e.child; e !== null; ) {
          switch (t = e, t.tag) {
            case 0:
            case 11:
            case 15:
              za(8, t, t.return), Tc(t);
              break;
            case 22:
              n = t.stateNode, n._visibility & 4 && (n._visibility &= -5, Tc(t));
              break;
            default:
              Tc(t);
          }
          e = e.sibling;
        }
      }
      function yy(e, t) {
        for (; We !== null; ) {
          var n = We;
          switch (n.tag) {
            case 0:
            case 11:
            case 15:
              za(8, n, t);
              break;
            case 23:
            case 22:
              if (n.memoizedState !== null && n.memoizedState.cachePool !== null) {
                var i = n.memoizedState.cachePool.pool;
                i != null && i.refCount++;
              }
              break;
            case 24:
              vl(n.memoizedState.cache);
          }
          if (i = n.child, i !== null) i.return = n, We = i;
          else t: for (n = e; We !== null; ) {
            i = We;
            var a = i.sibling, s = i.return;
            if (uy(i), i === n) {
              We = null;
              break t;
            }
            if (a !== null) {
              a.return = s, We = a;
              break t;
            }
            We = s;
          }
        }
      }
      function XM(e, t, n, i) {
        this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
      }
      function Zn(e, t, n, i) {
        return new XM(e, t, n, i);
      }
      function Pp(e) {
        return e = e.prototype, !(!e || !e.isReactComponent);
      }
      function Ra(e, t) {
        var n = e.alternate;
        return n === null ? (n = Zn(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 31457280, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : {
          lanes: t.lanes,
          firstContext: t.firstContext
        }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n.refCleanup = e.refCleanup, n;
      }
      function Sy(e, t) {
        e.flags &= 31457282;
        var n = e.alternate;
        return n === null ? (e.childLanes = 0, e.lanes = t, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null) : (e.childLanes = n.childLanes, e.lanes = n.lanes, e.child = n.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = n.memoizedProps, e.memoizedState = n.memoizedState, e.updateQueue = n.updateQueue, e.type = n.type, t = n.dependencies, e.dependencies = t === null ? null : {
          lanes: t.lanes,
          firstContext: t.firstContext
        }), e;
      }
      function Ac(e, t, n, i, a, s) {
        var r = 0;
        if (i = e, typeof e == "function") Pp(e) && (r = 1);
        else if (typeof e == "string") r = CE(e, n, vi.current) ? 26 : e === "html" || e === "head" || e === "body" ? 27 : 5;
        else t: switch (e) {
          case nr:
            return us(n.children, a, s, t);
          case x0:
            r = 8, a |= 24;
            break;
          case ch:
            return e = Zn(12, n, t, a | 2), e.elementType = ch, e.lanes = s, e;
          case uh:
            return e = Zn(13, n, t, a), e.elementType = uh, e.lanes = s, e;
          case fh:
            return e = Zn(19, n, t, a), e.elementType = fh, e.lanes = s, e;
          case E0:
            return xy(n, a, s, t);
          default:
            if (typeof e == "object" && e !== null) switch (e.$$typeof) {
              case mx:
              case Vi:
                r = 10;
                break t;
              case M0:
                r = 9;
                break t;
              case np:
                r = 11;
                break t;
              case ip:
                r = 14;
                break t;
              case pa:
                r = 16, i = null;
                break t;
            }
            r = 29, n = Error(j(130, e === null ? "null" : typeof e, "")), i = null;
        }
        return t = Zn(r, n, t, a), t.elementType = e, t.type = i, t.lanes = s, t;
      }
      function us(e, t, n, i) {
        return e = Zn(7, e, i, t), e.lanes = n, e;
      }
      function xy(e, t, n, i) {
        e = Zn(22, e, i, t), e.elementType = E0, e.lanes = n;
        var a = {
          _visibility: 1,
          _pendingVisibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
          _current: null,
          detach: function() {
            var s = a._current;
            if (s === null) throw Error(j(456));
            if (!(a._pendingVisibility & 2)) {
              var r = Oa(s, 2);
              r !== null && (a._pendingVisibility |= 2, hn(r, s, 2));
            }
          },
          attach: function() {
            var s = a._current;
            if (s === null) throw Error(j(456));
            if (a._pendingVisibility & 2) {
              var r = Oa(s, 2);
              r !== null && (a._pendingVisibility &= -3, hn(r, s, 2));
            }
          }
        };
        return e.stateNode = a, e;
      }
      function yf(e, t, n) {
        return e = Zn(6, e, null, t), e.lanes = n, e;
      }
      function Sf(e, t, n) {
        return t = Zn(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = {
          containerInfo: e.containerInfo,
          pendingChildren: null,
          implementation: e.implementation
        }, t;
      }
      function Di(e) {
        e.flags |= 4;
      }
      function v_(e, t) {
        if (t.type !== "stylesheet" || t.state.loading & 4) e.flags &= -16777217;
        else if (e.flags |= 16777216, !Vy(t)) {
          if (t = $n.current, t !== null && ((jt & 4194176) === jt ? Si !== null : (jt & 62914560) !== jt && !(jt & 536870912) || t !== Si)) throw Uo = bh, ov;
          e.flags |= 8192;
        }
      }
      function Il(e, t) {
        t !== null && (e.flags |= 4), e.flags & 16384 && (t = e.tag !== 22 ? D0() : 536870912, e.lanes |= t, Nr |= t);
      }
      function uo(e, t) {
        if (!ee) switch (e.tailMode) {
          case "hidden":
            t = e.tail;
            for (var n = null; t !== null; ) t.alternate !== null && (n = t), t = t.sibling;
            n === null ? e.tail = null : n.sibling = null;
            break;
          case "collapsed":
            n = e.tail;
            for (var i = null; n !== null; ) n.alternate !== null && (i = n), n = n.sibling;
            i === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : i.sibling = null;
        }
      }
      function Me(e) {
        var t = e.alternate !== null && e.alternate.child === e.child, n = 0, i = 0;
        if (t) for (var a = e.child; a !== null; ) n |= a.lanes | a.childLanes, i |= a.subtreeFlags & 31457280, i |= a.flags & 31457280, a.return = e, a = a.sibling;
        else for (a = e.child; a !== null; ) n |= a.lanes | a.childLanes, i |= a.subtreeFlags, i |= a.flags, a.return = e, a = a.sibling;
        return e.subtreeFlags |= i, e.childLanes = n, t;
      }
      function WM(e, t, n) {
        var i = t.pendingProps;
        switch (mp(t), t.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return Me(t), null;
          case 1:
            return Me(t), null;
          case 3:
            return n = t.stateNode, i = null, e !== null && (i = e.memoizedState.cache), t.memoizedState.cache !== i && (t.flags |= 2048), ji(Fe), Rr(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (e === null || e.child === null) && (oo(t) ? Di(t) : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, oi !== null && (Wh(oi), oi = null))), Me(t), null;
          case 26:
            return n = t.memoizedState, e === null ? (Di(t), n !== null ? (Me(t), v_(t, n)) : (Me(t), t.flags &= -16777217)) : n ? n !== e.memoizedState ? (Di(t), Me(t), v_(t, n)) : (Me(t), t.flags &= -16777217) : (e.memoizedProps !== i && Di(t), Me(t), t.flags &= -16777217), null;
          case 27:
            Hc(t), n = ba.current;
            var a = t.type;
            if (e !== null && t.stateNode != null) e.memoizedProps !== i && Di(t);
            else {
              if (!i) {
                if (t.stateNode === null) throw Error(j(166));
                return Me(t), null;
              }
              e = vi.current, oo(t) ? jm(t) : (e = Iy(a, i, n), t.stateNode = e, Di(t));
            }
            return Me(t), null;
          case 5:
            if (Hc(t), n = t.type, e !== null && t.stateNode != null) e.memoizedProps !== i && Di(t);
            else {
              if (!i) {
                if (t.stateNode === null) throw Error(j(166));
                return Me(t), null;
              }
              if (e = vi.current, oo(t)) jm(t);
              else {
                switch (a = ru(ba.current), e) {
                  case 1:
                    e = a.createElementNS("http://www.w3.org/2000/svg", n);
                    break;
                  case 2:
                    e = a.createElementNS("http://www.w3.org/1998/Math/MathML", n);
                    break;
                  default:
                    switch (n) {
                      case "svg":
                        e = a.createElementNS("http://www.w3.org/2000/svg", n);
                        break;
                      case "math":
                        e = a.createElementNS("http://www.w3.org/1998/Math/MathML", n);
                        break;
                      case "script":
                        e = a.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild);
                        break;
                      case "select":
                        e = typeof i.is == "string" ? a.createElement("select", {
                          is: i.is
                        }) : a.createElement("select"), i.multiple ? e.multiple = true : i.size && (e.size = i.size);
                        break;
                      default:
                        e = typeof i.is == "string" ? a.createElement(n, {
                          is: i.is
                        }) : a.createElement(n);
                    }
                }
                e[sn] = t, e[yn] = i;
                t: for (a = t.child; a !== null; ) {
                  if (a.tag === 5 || a.tag === 6) e.appendChild(a.stateNode);
                  else if (a.tag !== 4 && a.tag !== 27 && a.child !== null) {
                    a.child.return = a, a = a.child;
                    continue;
                  }
                  if (a === t) break t;
                  for (; a.sibling === null; ) {
                    if (a.return === null || a.return === t) break t;
                    a = a.return;
                  }
                  a.sibling.return = a.return, a = a.sibling;
                }
                t.stateNode = e;
                t: switch ($e(e, n, i), n) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    e = !!i.autoFocus;
                    break t;
                  case "img":
                    e = true;
                    break t;
                  default:
                    e = false;
                }
                e && Di(t);
              }
            }
            return Me(t), t.flags &= -16777217, null;
          case 6:
            if (e && t.stateNode != null) e.memoizedProps !== i && Di(t);
            else {
              if (typeof i != "string" && t.stateNode === null) throw Error(j(166));
              if (e = ba.current, oo(t)) {
                if (e = t.stateNode, n = t.memoizedProps, i = null, a = un, a !== null) switch (a.tag) {
                  case 27:
                  case 5:
                    i = a.memoizedProps;
                }
                e[sn] = t, e = !!(e.nodeValue === n || i !== null && i.suppressHydrationWarning === true || zy(e.nodeValue, n)), e || ds(t);
              } else e = ru(e).createTextNode(i), e[sn] = t, t.stateNode = e;
            }
            return Me(t), null;
          case 13:
            if (i = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
              if (a = oo(t), i !== null && i.dehydrated !== null) {
                if (e === null) {
                  if (!a) throw Error(j(318));
                  if (a = t.memoizedState, a = a !== null ? a.dehydrated : null, !a) throw Error(j(317));
                  a[sn] = t;
                } else gl(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
                Me(t), a = false;
              } else oi !== null && (Wh(oi), oi = null), a = true;
              if (!a) return t.flags & 256 ? (Wi(t), t) : (Wi(t), null);
            }
            if (Wi(t), t.flags & 128) return t.lanes = n, t;
            if (n = i !== null, e = e !== null && e.memoizedState !== null, n) {
              i = t.child, a = null, i.alternate !== null && i.alternate.memoizedState !== null && i.alternate.memoizedState.cachePool !== null && (a = i.alternate.memoizedState.cachePool.pool);
              var s = null;
              i.memoizedState !== null && i.memoizedState.cachePool !== null && (s = i.memoizedState.cachePool.pool), s !== a && (i.flags |= 2048);
            }
            return n !== e && n && (t.child.flags |= 8192), Il(t, t.updateQueue), Me(t), null;
          case 4:
            return Rr(), e === null && Gp(t.stateNode.containerInfo), Me(t), null;
          case 10:
            return ji(t.type), Me(t), null;
          case 19:
            if (je(Ie), a = t.memoizedState, a === null) return Me(t), null;
            if (i = (t.flags & 128) !== 0, s = a.rendering, s === null) if (i) uo(a, false);
            else {
              if (we !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null; ) {
                if (s = jc(e), s !== null) {
                  for (t.flags |= 128, uo(a, false), e = s.updateQueue, t.updateQueue = e, Il(t, e), t.subtreeFlags = 0, e = n, n = t.child; n !== null; ) Sy(n, e), n = n.sibling;
                  return Se(Ie, Ie.current & 1 | 2), t.child;
                }
                e = e.sibling;
              }
              a.tail !== null && yi() > eu && (t.flags |= 128, i = true, uo(a, false), t.lanes = 4194304);
            }
            else {
              if (!i) if (e = jc(s), e !== null) {
                if (t.flags |= 128, i = true, e = e.updateQueue, t.updateQueue = e, Il(t, e), uo(a, true), a.tail === null && a.tailMode === "hidden" && !s.alternate && !ee) return Me(t), null;
              } else 2 * yi() - a.renderingStartTime > eu && n !== 536870912 && (t.flags |= 128, i = true, uo(a, false), t.lanes = 4194304);
              a.isBackwards ? (s.sibling = t.child, t.child = s) : (e = a.last, e !== null ? e.sibling = s : t.child = s, a.last = s);
            }
            return a.tail !== null ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = yi(), t.sibling = null, e = Ie.current, Se(Ie, i ? e & 1 | 2 : e & 1), t) : (Me(t), null);
          case 22:
          case 23:
            return Wi(t), _p(), i = t.memoizedState !== null, e !== null ? e.memoizedState !== null !== i && (t.flags |= 8192) : i && (t.flags |= 8192), i ? n & 536870912 && !(t.flags & 128) && (Me(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Me(t), n = t.updateQueue, n !== null && Il(t, n.retryQueue), n = null, e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), i = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (i = t.memoizedState.cachePool.pool), i !== n && (t.flags |= 2048), e !== null && je(cs), null;
          case 24:
            return n = null, e !== null && (n = e.memoizedState.cache), t.memoizedState.cache !== n && (t.flags |= 2048), ji(Fe), Me(t), null;
          case 25:
            return null;
        }
        throw Error(j(156, t.tag));
      }
      function YM(e, t) {
        switch (mp(t), t.tag) {
          case 1:
            return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
          case 3:
            return ji(Fe), Rr(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
          case 26:
          case 27:
          case 5:
            return Hc(t), null;
          case 13:
            if (Wi(t), e = t.memoizedState, e !== null && e.dehydrated !== null) {
              if (t.alternate === null) throw Error(j(340));
              gl();
            }
            return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
          case 19:
            return je(Ie), null;
          case 4:
            return Rr(), null;
          case 10:
            return ji(t.type), null;
          case 22:
          case 23:
            return Wi(t), _p(), e !== null && je(cs), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
          case 24:
            return ji(Fe), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function My(e, t) {
        switch (mp(t), t.tag) {
          case 3:
            ji(Fe), Rr();
            break;
          case 26:
          case 27:
          case 5:
            Hc(t);
            break;
          case 4:
            Rr();
            break;
          case 13:
            Wi(t);
            break;
          case 19:
            je(Ie);
            break;
          case 10:
            ji(t.type);
            break;
          case 22:
          case 23:
            Wi(t), _p(), e !== null && je(cs);
            break;
          case 24:
            ji(Fe);
        }
      }
      var qM = {
        getCacheForType: function(e) {
          var t = rn(Fe), n = t.data.get(e);
          return n === void 0 && (n = e(), t.data.set(e, n)), n;
        }
      }, jM = typeof WeakMap == "function" ? WeakMap : Map, be = 0, me = null, kt = null, jt = 0, pe = 0, Tn = null, Ii = false, Zr = false, zp = false, $i = 0, we = 0, Ba = 0, fs = 0, Bp = 0, Kn = 0, Nr = 0, Io = null, mi = null, Gh = false, Fp = 0, eu = 1 / 0, nu = null, wa = null, Hl = false, ts = null, Ho = 0, Vh = 0, kh = null, Go = 0, Xh = null;
      function Cn() {
        if (be & 2 && jt !== 0) return jt & -jt;
        if (Lt.T !== null) {
          var e = Ur;
          return e !== 0 ? e : Hp();
        }
        return O0();
      }
      function Ey() {
        Kn === 0 && (Kn = !(jt & 536870912) || ee ? C0() : 536870912);
        var e = $n.current;
        return e !== null && (e.flags |= 32), Kn;
      }
      function hn(e, t, n) {
        (e === me && pe === 2 || e.cancelPendingCommit !== null) && (Or(e, 0), Hi(e, jt, Kn, false)), ml(e, n), (!(be & 2) || e !== me) && (e === me && (!(be & 2) && (fs |= n), we === 4 && Hi(e, jt, Kn, false)), bi(e));
      }
      function by(e, t, n) {
        if (be & 6) throw Error(j(327));
        var i = !n && (t & 60) === 0 && (t & e.expiredLanes) === 0 || pl(e, t), a = i ? QM(e, t) : xf(e, t, true), s = i;
        do {
          if (a === 0) {
            Zr && !i && Hi(e, t, 0, false);
            break;
          } else if (a === 6) Hi(e, t, 0, !Ii);
          else {
            if (n = e.current.alternate, s && !ZM(n)) {
              a = xf(e, t, false), s = false;
              continue;
            }
            if (a === 2) {
              if (s = t, e.errorRecoveryDisabledLanes & s) var r = 0;
              else r = e.pendingLanes & -536870913, r = r !== 0 ? r : r & 536870912 ? 536870912 : 0;
              if (r !== 0) {
                t = r;
                t: {
                  var o = e;
                  a = Io;
                  var l = o.current.memoizedState.isDehydrated;
                  if (l && (Or(o, r).flags |= 256), r = xf(o, r, false), r !== 2) {
                    if (zp && !l) {
                      o.errorRecoveryDisabledLanes |= s, fs |= s, a = 4;
                      break t;
                    }
                    s = mi, mi = a, s !== null && Wh(s);
                  }
                  a = r;
                }
                if (s = false, a !== 2) continue;
              }
            }
            if (a === 1) {
              Or(e, 0), Hi(e, t, 0, true);
              break;
            }
            t: {
              switch (i = e, a) {
                case 0:
                case 1:
                  throw Error(j(345));
                case 4:
                  if ((t & 4194176) === t) {
                    Hi(i, t, Kn, !Ii);
                    break t;
                  }
                  break;
                case 2:
                  mi = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(j(329));
              }
              if (i.finishedWork = n, i.finishedLanes = t, (t & 62914560) === t && (s = Fp + 300 - yi(), 10 < s)) {
                if (Hi(i, t, Kn, !Ii), Eu(i, 0) !== 0) break t;
                i.timeoutHandle = Fy(y_.bind(null, i, n, mi, nu, Gh, t, Kn, fs, Nr, Ii, 2, -0, 0), s);
                break t;
              }
              y_(i, n, mi, nu, Gh, t, Kn, fs, Nr, Ii, 0, -0, 0);
            }
          }
          break;
        } while (true);
        bi(e);
      }
      function Wh(e) {
        mi === null ? mi = e : mi.push.apply(mi, e);
      }
      function y_(e, t, n, i, a, s, r, o, l, c, f, d, h) {
        var p = t.subtreeFlags;
        if ((p & 8192 || (p & 16785408) === 16785408) && (tl = {
          stylesheets: null,
          count: 0,
          unsuspend: DE
        }, _y(t), t = LE(), t !== null)) {
          e.cancelPendingCommit = t(x_.bind(null, e, n, i, a, r, o, l, 1, d, h)), Hi(e, s, r, !c);
          return;
        }
        x_(e, n, i, a, r, o, l, f, d, h);
      }
      function ZM(e) {
        for (var t = e; ; ) {
          var n = t.tag;
          if ((n === 0 || n === 11 || n === 15) && t.flags & 16384 && (n = t.updateQueue, n !== null && (n = n.stores, n !== null))) for (var i = 0; i < n.length; i++) {
            var a = n[i], s = a.getSnapshot;
            a = a.value;
            try {
              if (!Un(s(), a)) return false;
            } catch {
              return false;
            }
          }
          if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n;
          else {
            if (t === e) break;
            for (; t.sibling === null; ) {
              if (t.return === null || t.return === e) return true;
              t = t.return;
            }
            t.sibling.return = t.return, t = t.sibling;
          }
        }
        return true;
      }
      function Hi(e, t, n, i) {
        t &= ~Bp, t &= ~fs, e.suspendedLanes |= t, e.pingedLanes &= ~t, i && (e.warmLanes |= t), i = e.expirationTimes;
        for (var a = t; 0 < a; ) {
          var s = 31 - wn(a), r = 1 << s;
          i[s] = -1, a &= ~r;
        }
        n !== 0 && U0(e, n, t);
      }
      function Nu() {
        return be & 6 ? true : (Ml(0), false);
      }
      function Ip() {
        if (kt !== null) {
          if (pe === 0) var e = kt.return;
          else e = kt, Yi = Rs = null, Ep(e), vr = null, Ko = 0, e = kt;
          for (; e !== null; ) My(e.alternate, e), e = e.return;
          kt = null;
        }
      }
      function Or(e, t) {
        e.finishedWork = null, e.finishedLanes = 0;
        var n = e.timeoutHandle;
        n !== -1 && (e.timeoutHandle = -1, pE(n)), n = e.cancelPendingCommit, n !== null && (e.cancelPendingCommit = null, n()), Ip(), me = e, kt = n = Ra(e.current, null), jt = t, pe = 0, Tn = null, Ii = false, Zr = pl(e, t), zp = false, Nr = Kn = Bp = fs = Ba = we = 0, mi = Io = null, Gh = false, t & 8 && (t |= t & 32);
        var i = e.entangledLanes;
        if (i !== 0) for (e = e.entanglements, i &= t; 0 < i; ) {
          var a = 31 - wn(i), s = 1 << a;
          t |= e[a], i &= ~s;
        }
        return $i = t, Ru(), n;
      }
      function Ty(e, t) {
        Ht = null, Lt.H = xi, t === Do ? (t = Qm(), pe = 3) : t === ov ? (t = Qm(), pe = 4) : pe = t === Kv ? 8 : t !== null && typeof t == "object" && typeof t.then == "function" ? 6 : 1, Tn = t, kt === null && (we = 1, Jc(e, qn(t, e.current)));
      }
      function Ay() {
        var e = Lt.H;
        return Lt.H = xi, e === null ? xi : e;
      }
      function Ry() {
        var e = Lt.A;
        return Lt.A = qM, e;
      }
      function Yh() {
        we = 4, Ii || (jt & 4194176) !== jt && $n.current !== null || (Zr = true), !(Ba & 134217727) && !(fs & 134217727) || me === null || Hi(me, jt, Kn, false);
      }
      function xf(e, t, n) {
        var i = be;
        be |= 2;
        var a = Ay(), s = Ry();
        (me !== e || jt !== t) && (nu = null, Or(e, t)), t = false;
        var r = we;
        t: do
          try {
            if (pe !== 0 && kt !== null) {
              var o = kt, l = Tn;
              switch (pe) {
                case 8:
                  Ip(), r = 6;
                  break t;
                case 3:
                case 2:
                case 6:
                  $n.current === null && (t = true);
                  var c = pe;
                  if (pe = 0, Tn = null, hr(e, o, l, c), n && Zr) {
                    r = 0;
                    break t;
                  }
                  break;
                default:
                  c = pe, pe = 0, Tn = null, hr(e, o, l, c);
              }
            }
            KM(), r = we;
            break;
          } catch (f) {
            Ty(e, f);
          }
        while (true);
        return t && e.shellSuspendCounter++, Yi = Rs = null, be = i, Lt.H = a, Lt.A = s, kt === null && (me = null, jt = 0, Ru()), r;
      }
      function KM() {
        for (; kt !== null; ) wy(kt);
      }
      function QM(e, t) {
        var n = be;
        be |= 2;
        var i = Ay(), a = Ry();
        me !== e || jt !== t ? (nu = null, eu = yi() + 500, Or(e, t)) : Zr = pl(e, t);
        t: do
          try {
            if (pe !== 0 && kt !== null) {
              t = kt;
              var s = Tn;
              e: switch (pe) {
                case 1:
                  pe = 0, Tn = null, hr(e, t, s, 1);
                  break;
                case 2:
                  if (Km(s)) {
                    pe = 0, Tn = null, S_(t);
                    break;
                  }
                  t = function() {
                    pe === 2 && me === e && (pe = 7), bi(e);
                  }, s.then(t, t);
                  break t;
                case 3:
                  pe = 7;
                  break t;
                case 4:
                  pe = 5;
                  break t;
                case 7:
                  Km(s) ? (pe = 0, Tn = null, S_(t)) : (pe = 0, Tn = null, hr(e, t, s, 7));
                  break;
                case 5:
                  var r = null;
                  switch (kt.tag) {
                    case 26:
                      r = kt.memoizedState;
                    case 5:
                    case 27:
                      var o = kt;
                      if (!r || Vy(r)) {
                        pe = 0, Tn = null;
                        var l = o.sibling;
                        if (l !== null) kt = l;
                        else {
                          var c = o.return;
                          c !== null ? (kt = c, Ou(c)) : kt = null;
                        }
                        break e;
                      }
                  }
                  pe = 0, Tn = null, hr(e, t, s, 5);
                  break;
                case 6:
                  pe = 0, Tn = null, hr(e, t, s, 6);
                  break;
                case 8:
                  Ip(), we = 6;
                  break t;
                default:
                  throw Error(j(462));
              }
            }
            JM();
            break;
          } catch (f) {
            Ty(e, f);
          }
        while (true);
        return Yi = Rs = null, Lt.H = i, Lt.A = a, be = n, kt !== null ? 0 : (me = null, jt = 0, Ru(), we);
      }
      function JM() {
        for (; kt !== null && !Sx(); ) wy(kt);
      }
      function wy(e) {
        var t = ey(e.alternate, e, $i);
        e.memoizedProps = e.pendingProps, t === null ? Ou(e) : kt = t;
      }
      function S_(e) {
        var t = e, n = t.alternate;
        switch (t.tag) {
          case 15:
          case 0:
            t = f_(n, t, t.pendingProps, t.type, void 0, jt);
            break;
          case 11:
            t = f_(n, t, t.pendingProps, t.type.render, t.ref, jt);
            break;
          case 5:
            Ep(t);
          default:
            My(n, t), t = kt = Sy(t, $i), t = ey(n, t, $i);
        }
        e.memoizedProps = e.pendingProps, t === null ? Ou(e) : kt = t;
      }
      function hr(e, t, n, i) {
        Yi = Rs = null, Ep(t), vr = null, Ko = 0;
        var a = t.return;
        try {
          if (HM(e, a, t, n, jt)) {
            we = 1, Jc(e, qn(n, e.current)), kt = null;
            return;
          }
        } catch (s) {
          if (a !== null) throw kt = a, s;
          we = 1, Jc(e, qn(n, e.current)), kt = null;
          return;
        }
        t.flags & 32768 ? (ee || i === 1 ? e = true : Zr || jt & 536870912 ? e = false : (Ii = e = true, (i === 2 || i === 3 || i === 6) && (i = $n.current, i !== null && i.tag === 13 && (i.flags |= 16384))), Cy(t, e)) : Ou(t);
      }
      function Ou(e) {
        var t = e;
        do {
          if (t.flags & 32768) {
            Cy(t, Ii);
            return;
          }
          e = t.return;
          var n = WM(t.alternate, t, $i);
          if (n !== null) {
            kt = n;
            return;
          }
          if (t = t.sibling, t !== null) {
            kt = t;
            return;
          }
          kt = t = e;
        } while (t !== null);
        we === 0 && (we = 5);
      }
      function Cy(e, t) {
        do {
          var n = YM(e.alternate, e);
          if (n !== null) {
            n.flags &= 32767, kt = n;
            return;
          }
          if (n = e.return, n !== null && (n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null), !t && (e = e.sibling, e !== null)) {
            kt = e;
            return;
          }
          kt = e = n;
        } while (e !== null);
        we = 6, kt = null;
      }
      function x_(e, t, n, i, a, s, r, o, l, c) {
        var f = Lt.T, d = ge.p;
        try {
          ge.p = 2, Lt.T = null, $M(e, t, n, i, d, a, s, r, o, l, c);
        } finally {
          Lt.T = f, ge.p = d;
        }
      }
      function $M(e, t, n, i, a, s, r, o) {
        do
          Mr();
        while (ts !== null);
        if (be & 6) throw Error(j(327));
        var l = e.finishedWork;
        if (i = e.finishedLanes, l === null) return null;
        if (e.finishedWork = null, e.finishedLanes = 0, l === e.current) throw Error(j(177));
        e.callbackNode = null, e.callbackPriority = 0, e.cancelPendingCommit = null;
        var c = l.lanes | l.childLanes;
        if (c |= hp, Ux(e, i, c, s, r, o), e === me && (kt = me = null, jt = 0), !(l.subtreeFlags & 10256) && !(l.flags & 10256) || Hl || (Hl = true, Vh = c, kh = n, iE(Gc, function() {
          return Mr(), null;
        })), n = (l.flags & 15990) !== 0, l.subtreeFlags & 15990 || n ? (n = Lt.T, Lt.T = null, s = ge.p, ge.p = 2, r = be, be |= 4, VM(e, l), dy(l, e), EM(Kh, e.containerInfo), uu = !!Zh, Kh = Zh = null, e.current = l, cy(e, l.alternate, l), xx(), be = r, ge.p = s, Lt.T = n) : e.current = l, Hl ? (Hl = false, ts = e, Ho = i) : Dy(e, c), c = e.pendingLanes, c === 0 && (wa = null), Ax(l.stateNode), bi(e), t !== null) for (a = e.onRecoverableError, l = 0; l < t.length; l++) c = t[l], a(c.value, {
          componentStack: c.stack
        });
        return Ho & 3 && Mr(), c = e.pendingLanes, i & 4194218 && c & 42 ? e === Xh ? Go++ : (Go = 0, Xh = e) : Go = 0, Ml(0), null;
      }
      function Dy(e, t) {
        (e.pooledCacheLanes &= t) === 0 && (t = e.pooledCache, t != null && (e.pooledCache = null, vl(t)));
      }
      function Mr() {
        if (ts !== null) {
          var e = ts, t = Vh;
          Vh = 0;
          var n = N0(Ho), i = Lt.T, a = ge.p;
          try {
            if (ge.p = 32 > n ? 32 : n, Lt.T = null, ts === null) var s = false;
            else {
              n = kh, kh = null;
              var r = ts, o = Ho;
              if (ts = null, Ho = 0, be & 6) throw Error(j(331));
              var l = be;
              if (be |= 4, vy(r.current), my(r, r.current, o, n), be = l, Ml(0, false), Rn && typeof Rn.onPostCommitFiberRoot == "function") try {
                Rn.onPostCommitFiberRoot(dl, r);
              } catch {
              }
              s = true;
            }
            return s;
          } finally {
            ge.p = a, Lt.T = i, Dy(e, t);
          }
        }
        return false;
      }
      function M_(e, t, n) {
        t = qn(n, t), t = Uh(e.stateNode, t, 2), e = Aa(e, t, 2), e !== null && (ml(e, 2), bi(e));
      }
      function he(e, t, n) {
        if (e.tag === 3) M_(e, e, n);
        else for (; t !== null; ) {
          if (t.tag === 3) {
            M_(t, e, n);
            break;
          } else if (t.tag === 1) {
            var i = t.stateNode;
            if (typeof t.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (wa === null || !wa.has(i))) {
              e = qn(n, e), n = jv(2), i = Aa(t, n, 2), i !== null && (Zv(n, i, t, e), ml(i, 2), bi(i));
              break;
            }
          }
          t = t.return;
        }
      }
      function Mf(e, t, n) {
        var i = e.pingCache;
        if (i === null) {
          i = e.pingCache = new jM();
          var a = /* @__PURE__ */ new Set();
          i.set(t, a);
        } else a = i.get(t), a === void 0 && (a = /* @__PURE__ */ new Set(), i.set(t, a));
        a.has(n) || (zp = true, a.add(n), e = tE.bind(null, e, t, n), t.then(e, e));
      }
      function tE(e, t, n) {
        var i = e.pingCache;
        i !== null && i.delete(t), e.pingedLanes |= e.suspendedLanes & n, e.warmLanes &= ~n, me === e && (jt & n) === n && (we === 4 || we === 3 && (jt & 62914560) === jt && 300 > yi() - Fp ? !(be & 2) && Or(e, 0) : Bp |= n, Nr === jt && (Nr = 0)), bi(e);
      }
      function Uy(e, t) {
        t === 0 && (t = D0()), e = Oa(e, t), e !== null && (ml(e, t), bi(e));
      }
      function eE(e) {
        var t = e.memoizedState, n = 0;
        t !== null && (n = t.retryLane), Uy(e, n);
      }
      function nE(e, t) {
        var n = 0;
        switch (e.tag) {
          case 13:
            var i = e.stateNode, a = e.memoizedState;
            a !== null && (n = a.retryLane);
            break;
          case 19:
            i = e.stateNode;
            break;
          case 22:
            i = e.stateNode._retryCache;
            break;
          default:
            throw Error(j(314));
        }
        i !== null && i.delete(t), Uy(e, n);
      }
      function iE(e, t) {
        return ap(e, t);
      }
      var iu = null, Js = null, qh = false, au = false, Ef = false, hs = 0;
      function bi(e) {
        e !== Js && e.next === null && (Js === null ? iu = Js = e : Js = Js.next = e), au = true, qh || (qh = true, sE(aE));
      }
      function Ml(e, t) {
        if (!Ef && au) {
          Ef = true;
          do
            for (var n = false, i = iu; i !== null; ) {
              if (e !== 0) {
                var a = i.pendingLanes;
                if (a === 0) var s = 0;
                else {
                  var r = i.suspendedLanes, o = i.pingedLanes;
                  s = (1 << 31 - wn(42 | e) + 1) - 1, s &= a & ~(r & ~o), s = s & 201326677 ? s & 201326677 | 1 : s ? s | 2 : 0;
                }
                s !== 0 && (n = true, E_(i, s));
              } else s = jt, s = Eu(i, i === me ? s : 0), !(s & 3) || pl(i, s) || (n = true, E_(i, s));
              i = i.next;
            }
          while (n);
          Ef = false;
        }
      }
      function aE() {
        au = qh = false;
        var e = 0;
        hs !== 0 && (dE() && (e = hs), hs = 0);
        for (var t = yi(), n = null, i = iu; i !== null; ) {
          var a = i.next, s = Ly(i, t);
          s === 0 ? (i.next = null, n === null ? iu = a : n.next = a, a === null && (Js = n)) : (n = i, (e !== 0 || s & 3) && (au = true)), i = a;
        }
        Ml(e);
      }
      function Ly(e, t) {
        for (var n = e.suspendedLanes, i = e.pingedLanes, a = e.expirationTimes, s = e.pendingLanes & -62914561; 0 < s; ) {
          var r = 31 - wn(s), o = 1 << r, l = a[r];
          l === -1 ? (!(o & n) || o & i) && (a[r] = Dx(o, t)) : l <= t && (e.expiredLanes |= o), s &= ~o;
        }
        if (t = me, n = jt, n = Eu(e, e === t ? n : 0), i = e.callbackNode, n === 0 || e === t && pe === 2 || e.cancelPendingCommit !== null) return i !== null && i !== null && Ju(i), e.callbackNode = null, e.callbackPriority = 0;
        if (!(n & 3) || pl(e, n)) {
          if (t = n & -n, t === e.callbackPriority) return t;
          switch (i !== null && Ju(i), N0(n)) {
            case 2:
            case 8:
              n = R0;
              break;
            case 32:
              n = Gc;
              break;
            case 268435456:
              n = w0;
              break;
            default:
              n = Gc;
          }
          return i = Ny.bind(null, e), n = ap(n, i), e.callbackPriority = t, e.callbackNode = n, t;
        }
        return i !== null && i !== null && Ju(i), e.callbackPriority = 2, e.callbackNode = null, 2;
      }
      function Ny(e, t) {
        var n = e.callbackNode;
        if (Mr() && e.callbackNode !== n) return null;
        var i = jt;
        return i = Eu(e, e === me ? i : 0), i === 0 ? null : (by(e, i, t), Ly(e, yi()), e.callbackNode != null && e.callbackNode === n ? Ny.bind(null, e) : null);
      }
      function E_(e, t) {
        if (Mr()) return null;
        by(e, t, true);
      }
      function sE(e) {
        mE(function() {
          be & 6 ? ap(A0, e) : e();
        });
      }
      function Hp() {
        return hs === 0 && (hs = C0()), hs;
      }
      function b_(e) {
        return e == null || typeof e == "symbol" || typeof e == "boolean" ? null : typeof e == "function" ? e : yc("" + e);
      }
      function T_(e, t) {
        var n = t.ownerDocument.createElement("input");
        return n.name = t.name, n.value = t.value, e.id && n.setAttribute("form", e.id), t.parentNode.insertBefore(n, t), e = new FormData(e), n.parentNode.removeChild(n), e;
      }
      function rE(e, t, n, i, a) {
        if (t === "submit" && n && n.stateNode === a) {
          var s = b_((a[yn] || null).action), r = i.submitter;
          r && (t = (t = r[yn] || null) ? b_(t.formAction) : r.getAttribute("formAction"), t !== null && (s = t, r = null));
          var o = new bu("action", "action", null, i, a);
          e.push({
            event: o,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (i.defaultPrevented) {
                    if (hs !== 0) {
                      var l = r ? T_(a, r) : new FormData(a);
                      Ch(n, {
                        pending: true,
                        data: l,
                        method: a.method,
                        action: s
                      }, null, l);
                    }
                  } else typeof s == "function" && (o.preventDefault(), l = r ? T_(a, r) : new FormData(a), Ch(n, {
                    pending: true,
                    data: l,
                    method: a.method,
                    action: s
                  }, s, l));
                },
                currentTarget: a
              }
            ]
          });
        }
      }
      for (var bf = 0; bf < Ym.length; bf++) {
        var Tf = Ym[bf], oE = Tf.toLowerCase(), lE = Tf[0].toUpperCase() + Tf.slice(1);
        hi(oE, "on" + lE);
      }
      hi(tv, "onAnimationEnd");
      hi(ev, "onAnimationIteration");
      hi(nv, "onAnimationStart");
      hi("dblclick", "onDoubleClick");
      hi("focusin", "onFocus");
      hi("focusout", "onBlur");
      hi(TM, "onTransitionRun");
      hi(AM, "onTransitionStart");
      hi(RM, "onTransitionCancel");
      hi(iv, "onTransitionEnd");
      wr("onMouseEnter", [
        "mouseout",
        "mouseover"
      ]);
      wr("onMouseLeave", [
        "mouseout",
        "mouseover"
      ]);
      wr("onPointerEnter", [
        "pointerout",
        "pointerover"
      ]);
      wr("onPointerLeave", [
        "pointerout",
        "pointerover"
      ]);
      Ms("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      Ms("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      Ms("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      Ms("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      Ms("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      Ms("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var Jo = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), cE = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Jo));
      function Oy(e, t) {
        t = (t & 4) !== 0;
        for (var n = 0; n < e.length; n++) {
          var i = e[n], a = i.event;
          i = i.listeners;
          t: {
            var s = void 0;
            if (t) for (var r = i.length - 1; 0 <= r; r--) {
              var o = i[r], l = o.instance, c = o.currentTarget;
              if (o = o.listener, l !== s && a.isPropagationStopped()) break t;
              s = o, a.currentTarget = c;
              try {
                s(a);
              } catch (f) {
                Qc(f);
              }
              a.currentTarget = null, s = l;
            }
            else for (r = 0; r < i.length; r++) {
              if (o = i[r], l = o.instance, c = o.currentTarget, o = o.listener, l !== s && a.isPropagationStopped()) break t;
              s = o, a.currentTarget = c;
              try {
                s(a);
              } catch (f) {
                Qc(f);
              }
              a.currentTarget = null, s = l;
            }
          }
        }
      }
      function Xt(e, t) {
        var n = t[_h];
        n === void 0 && (n = t[_h] = /* @__PURE__ */ new Set());
        var i = e + "__bubble";
        n.has(i) || (Py(t, e, 2, false), n.add(i));
      }
      function Af(e, t, n) {
        var i = 0;
        t && (i |= 4), Py(n, e, i, t);
      }
      var Gl = "_reactListening" + Math.random().toString(36).slice(2);
      function Gp(e) {
        if (!e[Gl]) {
          e[Gl] = true, P0.forEach(function(n) {
            n !== "selectionchange" && (cE.has(n) || Af(n, false, e), Af(n, true, e));
          });
          var t = e.nodeType === 9 ? e : e.ownerDocument;
          t === null || t[Gl] || (t[Gl] = true, Af("selectionchange", false, t));
        }
      }
      function Py(e, t, n, i) {
        switch (qy(t)) {
          case 2:
            var a = PE;
            break;
          case 8:
            a = zE;
            break;
          default:
            a = Wp;
        }
        n = a.bind(null, t, n, e), a = void 0, !Sh || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (a = true), i ? a !== void 0 ? e.addEventListener(t, n, {
          capture: true,
          passive: a
        }) : e.addEventListener(t, n, true) : a !== void 0 ? e.addEventListener(t, n, {
          passive: a
        }) : e.addEventListener(t, n, false);
      }
      function Rf(e, t, n, i, a) {
        var s = i;
        if (!(t & 1) && !(t & 2) && i !== null) t: for (; ; ) {
          if (i === null) return;
          var r = i.tag;
          if (r === 3 || r === 4) {
            var o = i.stateNode.containerInfo;
            if (o === a || o.nodeType === 8 && o.parentNode === a) break;
            if (r === 4) for (r = i.return; r !== null; ) {
              var l = r.tag;
              if ((l === 3 || l === 4) && (l = r.stateNode.containerInfo, l === a || l.nodeType === 8 && l.parentNode === a)) return;
              r = r.return;
            }
            for (; o !== null; ) {
              if (r = is(o), r === null) return;
              if (l = r.tag, l === 5 || l === 6 || l === 26 || l === 27) {
                i = s = r;
                continue t;
              }
              o = o.parentNode;
            }
          }
          i = i.return;
        }
        k0(function() {
          var c = s, f = op(n), d = [];
          t: {
            var h = av.get(e);
            if (h !== void 0) {
              var p = bu, y = e;
              switch (e) {
                case "keypress":
                  if (xc(n) === 0) break t;
                case "keydown":
                case "keyup":
                  p = nM;
                  break;
                case "focusin":
                  y = "focus", p = af;
                  break;
                case "focusout":
                  y = "blur", p = af;
                  break;
                case "beforeblur":
                case "afterblur":
                  p = af;
                  break;
                case "click":
                  if (n.button === 2) break t;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  p = Om;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  p = Xx;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  p = sM;
                  break;
                case tv:
                case ev:
                case nv:
                  p = qx;
                  break;
                case iv:
                  p = oM;
                  break;
                case "scroll":
                case "scrollend":
                  p = Vx;
                  break;
                case "wheel":
                  p = cM;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  p = Zx;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  p = zm;
                  break;
                case "toggle":
                case "beforetoggle":
                  p = fM;
              }
              var S = (t & 4) !== 0, m = !S && (e === "scroll" || e === "scrollend"), u = S ? h !== null ? h + "Capture" : null : h;
              S = [];
              for (var _ = c, g; _ !== null; ) {
                var v = _;
                if (g = v.stateNode, v = v.tag, v !== 5 && v !== 26 && v !== 27 || g === null || u === null || (v = Yo(_, u), v != null && S.push($o(_, v, g))), m) break;
                _ = _.return;
              }
              0 < S.length && (h = new p(h, y, null, n, f), d.push({
                event: h,
                listeners: S
              }));
            }
          }
          if (!(t & 7)) {
            t: {
              if (h = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", h && n !== yh && (y = n.relatedTarget || n.fromElement) && (is(y) || y[qr])) break t;
              if ((p || h) && (h = f.window === f ? f : (h = f.ownerDocument) ? h.defaultView || h.parentWindow : window, p ? (y = n.relatedTarget || n.toElement, p = c, y = y ? is(y) : null, y !== null && (m = Yr(y), S = y.tag, y !== m || S !== 5 && S !== 27 && S !== 6) && (y = null)) : (p = null, y = c), p !== y)) {
                if (S = Om, v = "onMouseLeave", u = "onMouseEnter", _ = "mouse", (e === "pointerout" || e === "pointerover") && (S = zm, v = "onPointerLeave", u = "onPointerEnter", _ = "pointer"), m = p == null ? h : Eo(p), g = y == null ? h : Eo(y), h = new S(v, _ + "leave", p, n, f), h.target = m, h.relatedTarget = g, v = null, is(f) === c && (S = new S(u, _ + "enter", y, n, f), S.target = g, S.relatedTarget = m, v = S), m = v, p && y) e: {
                  for (S = p, u = y, _ = 0, g = S; g; g = Ls(g)) _++;
                  for (g = 0, v = u; v; v = Ls(v)) g++;
                  for (; 0 < _ - g; ) S = Ls(S), _--;
                  for (; 0 < g - _; ) u = Ls(u), g--;
                  for (; _--; ) {
                    if (S === u || u !== null && S === u.alternate) break e;
                    S = Ls(S), u = Ls(u);
                  }
                  S = null;
                }
                else S = null;
                p !== null && A_(d, h, p, S, false), y !== null && m !== null && A_(d, m, y, S, true);
              }
            }
            t: {
              if (h = c ? Eo(c) : window, p = h.nodeName && h.nodeName.toLowerCase(), p === "select" || p === "input" && h.type === "file") var T = Hm;
              else if (Im(h)) if (Z0) T = xM;
              else {
                T = yM;
                var R = vM;
              }
              else p = h.nodeName, !p || p.toLowerCase() !== "input" || h.type !== "checkbox" && h.type !== "radio" ? c && rp(c.elementType) && (T = Hm) : T = SM;
              if (T && (T = T(e, c))) {
                j0(d, T, n, f);
                break t;
              }
              R && R(e, h, c), e === "focusout" && c && h.type === "number" && c.memoizedProps.value != null && vh(h, "number", h.value);
            }
            switch (R = c ? Eo(c) : window, e) {
              case "focusin":
                (Im(R) || R.contentEditable === "true") && (rr = R, xh = c, Co = null);
                break;
              case "focusout":
                Co = xh = rr = null;
                break;
              case "mousedown":
                Mh = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Mh = false, Wm(d, n, f);
                break;
              case "selectionchange":
                if (bM) break;
              case "keydown":
              case "keyup":
                Wm(d, n, f);
            }
            var w;
            if (up) t: {
              switch (e) {
                case "compositionstart":
                  var D = "onCompositionStart";
                  break t;
                case "compositionend":
                  D = "onCompositionEnd";
                  break t;
                case "compositionupdate":
                  D = "onCompositionUpdate";
                  break t;
              }
              D = void 0;
            }
            else sr ? Y0(e, n) && (D = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (D = "onCompositionStart");
            D && (W0 && n.locale !== "ko" && (sr || D !== "onCompositionStart" ? D === "onCompositionEnd" && sr && (w = X0()) : (Ea = f, lp = "value" in Ea ? Ea.value : Ea.textContent, sr = true)), R = su(c, D), 0 < R.length && (D = new Pm(D, e, null, n, f), d.push({
              event: D,
              listeners: R
            }), w ? D.data = w : (w = q0(n), w !== null && (D.data = w)))), (w = dM ? pM(e, n) : mM(e, n)) && (D = su(c, "onBeforeInput"), 0 < D.length && (R = new Pm("onBeforeInput", "beforeinput", null, n, f), d.push({
              event: R,
              listeners: D
            }), R.data = w)), rE(d, e, c, n, f);
          }
          Oy(d, t);
        });
      }
      function $o(e, t, n) {
        return {
          instance: e,
          listener: t,
          currentTarget: n
        };
      }
      function su(e, t) {
        for (var n = t + "Capture", i = []; e !== null; ) {
          var a = e, s = a.stateNode;
          a = a.tag, a !== 5 && a !== 26 && a !== 27 || s === null || (a = Yo(e, n), a != null && i.unshift($o(e, a, s)), a = Yo(e, t), a != null && i.push($o(e, a, s))), e = e.return;
        }
        return i;
      }
      function Ls(e) {
        if (e === null) return null;
        do
          e = e.return;
        while (e && e.tag !== 5 && e.tag !== 27);
        return e || null;
      }
      function A_(e, t, n, i, a) {
        for (var s = t._reactName, r = []; n !== null && n !== i; ) {
          var o = n, l = o.alternate, c = o.stateNode;
          if (o = o.tag, l !== null && l === i) break;
          o !== 5 && o !== 26 && o !== 27 || c === null || (l = c, a ? (c = Yo(n, s), c != null && r.unshift($o(n, c, l))) : a || (c = Yo(n, s), c != null && r.push($o(n, c, l)))), n = n.return;
        }
        r.length !== 0 && e.push({
          event: t,
          listeners: r
        });
      }
      var uE = /\r\n?/g, fE = /\u0000|\uFFFD/g;
      function R_(e) {
        return (typeof e == "string" ? e : "" + e).replace(uE, `
`).replace(fE, "");
      }
      function zy(e, t) {
        return t = R_(t), R_(e) === t;
      }
      function Pu() {
      }
      function ce(e, t, n, i, a, s) {
        switch (n) {
          case "children":
            typeof i == "string" ? t === "body" || t === "textarea" && i === "" || Cr(e, i) : (typeof i == "number" || typeof i == "bigint") && t !== "body" && Cr(e, "" + i);
            break;
          case "className":
            Nl(e, "class", i);
            break;
          case "tabIndex":
            Nl(e, "tabindex", i);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            Nl(e, n, i);
            break;
          case "style":
            V0(e, i, s);
            break;
          case "data":
            if (t !== "object") {
              Nl(e, "data", i);
              break;
            }
          case "src":
          case "href":
            if (i === "" && (t !== "a" || n !== "href")) {
              e.removeAttribute(n);
              break;
            }
            if (i == null || typeof i == "function" || typeof i == "symbol" || typeof i == "boolean") {
              e.removeAttribute(n);
              break;
            }
            i = yc("" + i), e.setAttribute(n, i);
            break;
          case "action":
          case "formAction":
            if (typeof i == "function") {
              e.setAttribute(n, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
              break;
            } else typeof s == "function" && (n === "formAction" ? (t !== "input" && ce(e, t, "name", a.name, a, null), ce(e, t, "formEncType", a.formEncType, a, null), ce(e, t, "formMethod", a.formMethod, a, null), ce(e, t, "formTarget", a.formTarget, a, null)) : (ce(e, t, "encType", a.encType, a, null), ce(e, t, "method", a.method, a, null), ce(e, t, "target", a.target, a, null)));
            if (i == null || typeof i == "symbol" || typeof i == "boolean") {
              e.removeAttribute(n);
              break;
            }
            i = yc("" + i), e.setAttribute(n, i);
            break;
          case "onClick":
            i != null && (e.onclick = Pu);
            break;
          case "onScroll":
            i != null && Xt("scroll", e);
            break;
          case "onScrollEnd":
            i != null && Xt("scrollend", e);
            break;
          case "dangerouslySetInnerHTML":
            if (i != null) {
              if (typeof i != "object" || !("__html" in i)) throw Error(j(61));
              if (n = i.__html, n != null) {
                if (a.children != null) throw Error(j(60));
                e.innerHTML = n;
              }
            }
            break;
          case "multiple":
            e.multiple = i && typeof i != "function" && typeof i != "symbol";
            break;
          case "muted":
            e.muted = i && typeof i != "function" && typeof i != "symbol";
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (i == null || typeof i == "function" || typeof i == "boolean" || typeof i == "symbol") {
              e.removeAttribute("xlink:href");
              break;
            }
            n = yc("" + i), e.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", n);
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            i != null && typeof i != "function" && typeof i != "symbol" ? e.setAttribute(n, "" + i) : e.removeAttribute(n);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            i && typeof i != "function" && typeof i != "symbol" ? e.setAttribute(n, "") : e.removeAttribute(n);
            break;
          case "capture":
          case "download":
            i === true ? e.setAttribute(n, "") : i !== false && i != null && typeof i != "function" && typeof i != "symbol" ? e.setAttribute(n, i) : e.removeAttribute(n);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            i != null && typeof i != "function" && typeof i != "symbol" && !isNaN(i) && 1 <= i ? e.setAttribute(n, i) : e.removeAttribute(n);
            break;
          case "rowSpan":
          case "start":
            i == null || typeof i == "function" || typeof i == "symbol" || isNaN(i) ? e.removeAttribute(n) : e.setAttribute(n, i);
            break;
          case "popover":
            Xt("beforetoggle", e), Xt("toggle", e), vc(e, "popover", i);
            break;
          case "xlinkActuate":
            Ri(e, "http://www.w3.org/1999/xlink", "xlink:actuate", i);
            break;
          case "xlinkArcrole":
            Ri(e, "http://www.w3.org/1999/xlink", "xlink:arcrole", i);
            break;
          case "xlinkRole":
            Ri(e, "http://www.w3.org/1999/xlink", "xlink:role", i);
            break;
          case "xlinkShow":
            Ri(e, "http://www.w3.org/1999/xlink", "xlink:show", i);
            break;
          case "xlinkTitle":
            Ri(e, "http://www.w3.org/1999/xlink", "xlink:title", i);
            break;
          case "xlinkType":
            Ri(e, "http://www.w3.org/1999/xlink", "xlink:type", i);
            break;
          case "xmlBase":
            Ri(e, "http://www.w3.org/XML/1998/namespace", "xml:base", i);
            break;
          case "xmlLang":
            Ri(e, "http://www.w3.org/XML/1998/namespace", "xml:lang", i);
            break;
          case "xmlSpace":
            Ri(e, "http://www.w3.org/XML/1998/namespace", "xml:space", i);
            break;
          case "is":
            vc(e, "is", i);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            (!(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (n = Hx.get(n) || n, vc(e, n, i));
        }
      }
      function jh(e, t, n, i, a, s) {
        switch (n) {
          case "style":
            V0(e, i, s);
            break;
          case "dangerouslySetInnerHTML":
            if (i != null) {
              if (typeof i != "object" || !("__html" in i)) throw Error(j(61));
              if (n = i.__html, n != null) {
                if (a.children != null) throw Error(j(60));
                e.innerHTML = n;
              }
            }
            break;
          case "children":
            typeof i == "string" ? Cr(e, i) : (typeof i == "number" || typeof i == "bigint") && Cr(e, "" + i);
            break;
          case "onScroll":
            i != null && Xt("scroll", e);
            break;
          case "onScrollEnd":
            i != null && Xt("scrollend", e);
            break;
          case "onClick":
            i != null && (e.onclick = Pu);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!z0.hasOwnProperty(n)) t: {
              if (n[0] === "o" && n[1] === "n" && (a = n.endsWith("Capture"), t = n.slice(2, a ? n.length - 7 : void 0), s = e[yn] || null, s = s != null ? s[n] : null, typeof s == "function" && e.removeEventListener(t, s, a), typeof i == "function")) {
                typeof s != "function" && s !== null && (n in e ? e[n] = null : e.hasAttribute(n) && e.removeAttribute(n)), e.addEventListener(t, i, a);
                break t;
              }
              n in e ? e[n] = i : i === true ? e.setAttribute(n, "") : vc(e, n, i);
            }
        }
      }
      function $e(e, t, n) {
        switch (t) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            Xt("error", e), Xt("load", e);
            var i = false, a = false, s;
            for (s in n) if (n.hasOwnProperty(s)) {
              var r = n[s];
              if (r != null) switch (s) {
                case "src":
                  i = true;
                  break;
                case "srcSet":
                  a = true;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(j(137, t));
                default:
                  ce(e, t, s, r, n, null);
              }
            }
            a && ce(e, t, "srcSet", n.srcSet, n, null), i && ce(e, t, "src", n.src, n, null);
            return;
          case "input":
            Xt("invalid", e);
            var o = s = r = a = null, l = null, c = null;
            for (i in n) if (n.hasOwnProperty(i)) {
              var f = n[i];
              if (f != null) switch (i) {
                case "name":
                  a = f;
                  break;
                case "type":
                  r = f;
                  break;
                case "checked":
                  l = f;
                  break;
                case "defaultChecked":
                  c = f;
                  break;
                case "value":
                  s = f;
                  break;
                case "defaultValue":
                  o = f;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (f != null) throw Error(j(137, t));
                  break;
                default:
                  ce(e, t, i, f, n, null);
              }
            }
            I0(e, s, o, l, c, r, a, false), Vc(e);
            return;
          case "select":
            Xt("invalid", e), i = r = s = null;
            for (a in n) if (n.hasOwnProperty(a) && (o = n[a], o != null)) switch (a) {
              case "value":
                s = o;
                break;
              case "defaultValue":
                r = o;
                break;
              case "multiple":
                i = o;
              default:
                ce(e, t, a, o, n, null);
            }
            t = s, n = r, e.multiple = !!i, t != null ? _r(e, !!i, t, false) : n != null && _r(e, !!i, n, true);
            return;
          case "textarea":
            Xt("invalid", e), s = a = i = null;
            for (r in n) if (n.hasOwnProperty(r) && (o = n[r], o != null)) switch (r) {
              case "value":
                i = o;
                break;
              case "defaultValue":
                a = o;
                break;
              case "children":
                s = o;
                break;
              case "dangerouslySetInnerHTML":
                if (o != null) throw Error(j(91));
                break;
              default:
                ce(e, t, r, o, n, null);
            }
            G0(e, i, a, s), Vc(e);
            return;
          case "option":
            for (l in n) if (n.hasOwnProperty(l) && (i = n[l], i != null)) switch (l) {
              case "selected":
                e.selected = i && typeof i != "function" && typeof i != "symbol";
                break;
              default:
                ce(e, t, l, i, n, null);
            }
            return;
          case "dialog":
            Xt("cancel", e), Xt("close", e);
            break;
          case "iframe":
          case "object":
            Xt("load", e);
            break;
          case "video":
          case "audio":
            for (i = 0; i < Jo.length; i++) Xt(Jo[i], e);
            break;
          case "image":
            Xt("error", e), Xt("load", e);
            break;
          case "details":
            Xt("toggle", e);
            break;
          case "embed":
          case "source":
          case "link":
            Xt("error", e), Xt("load", e);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (c in n) if (n.hasOwnProperty(c) && (i = n[c], i != null)) switch (c) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(j(137, t));
              default:
                ce(e, t, c, i, n, null);
            }
            return;
          default:
            if (rp(t)) {
              for (f in n) n.hasOwnProperty(f) && (i = n[f], i !== void 0 && jh(e, t, f, i, n, void 0));
              return;
            }
        }
        for (o in n) n.hasOwnProperty(o) && (i = n[o], i != null && ce(e, t, o, i, n, null));
      }
      function hE(e, t, n, i) {
        switch (t) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var a = null, s = null, r = null, o = null, l = null, c = null, f = null;
            for (p in n) {
              var d = n[p];
              if (n.hasOwnProperty(p) && d != null) switch (p) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  l = d;
                default:
                  i.hasOwnProperty(p) || ce(e, t, p, null, i, d);
              }
            }
            for (var h in i) {
              var p = i[h];
              if (d = n[h], i.hasOwnProperty(h) && (p != null || d != null)) switch (h) {
                case "type":
                  s = p;
                  break;
                case "name":
                  a = p;
                  break;
                case "checked":
                  c = p;
                  break;
                case "defaultChecked":
                  f = p;
                  break;
                case "value":
                  r = p;
                  break;
                case "defaultValue":
                  o = p;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (p != null) throw Error(j(137, t));
                  break;
                default:
                  p !== d && ce(e, t, h, p, i, d);
              }
            }
            gh(e, r, o, l, c, f, s, a);
            return;
          case "select":
            p = r = o = h = null;
            for (s in n) if (l = n[s], n.hasOwnProperty(s) && l != null) switch (s) {
              case "value":
                break;
              case "multiple":
                p = l;
              default:
                i.hasOwnProperty(s) || ce(e, t, s, null, i, l);
            }
            for (a in i) if (s = i[a], l = n[a], i.hasOwnProperty(a) && (s != null || l != null)) switch (a) {
              case "value":
                h = s;
                break;
              case "defaultValue":
                o = s;
                break;
              case "multiple":
                r = s;
              default:
                s !== l && ce(e, t, a, s, i, l);
            }
            t = o, n = r, i = p, h != null ? _r(e, !!n, h, false) : !!i != !!n && (t != null ? _r(e, !!n, t, true) : _r(e, !!n, n ? [] : "", false));
            return;
          case "textarea":
            p = h = null;
            for (o in n) if (a = n[o], n.hasOwnProperty(o) && a != null && !i.hasOwnProperty(o)) switch (o) {
              case "value":
                break;
              case "children":
                break;
              default:
                ce(e, t, o, null, i, a);
            }
            for (r in i) if (a = i[r], s = n[r], i.hasOwnProperty(r) && (a != null || s != null)) switch (r) {
              case "value":
                h = a;
                break;
              case "defaultValue":
                p = a;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (a != null) throw Error(j(91));
                break;
              default:
                a !== s && ce(e, t, r, a, i, s);
            }
            H0(e, h, p);
            return;
          case "option":
            for (var y in n) if (h = n[y], n.hasOwnProperty(y) && h != null && !i.hasOwnProperty(y)) switch (y) {
              case "selected":
                e.selected = false;
                break;
              default:
                ce(e, t, y, null, i, h);
            }
            for (l in i) if (h = i[l], p = n[l], i.hasOwnProperty(l) && h !== p && (h != null || p != null)) switch (l) {
              case "selected":
                e.selected = h && typeof h != "function" && typeof h != "symbol";
                break;
              default:
                ce(e, t, l, h, i, p);
            }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var S in n) h = n[S], n.hasOwnProperty(S) && h != null && !i.hasOwnProperty(S) && ce(e, t, S, null, i, h);
            for (c in i) if (h = i[c], p = n[c], i.hasOwnProperty(c) && h !== p && (h != null || p != null)) switch (c) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (h != null) throw Error(j(137, t));
                break;
              default:
                ce(e, t, c, h, i, p);
            }
            return;
          default:
            if (rp(t)) {
              for (var m in n) h = n[m], n.hasOwnProperty(m) && h !== void 0 && !i.hasOwnProperty(m) && jh(e, t, m, void 0, i, h);
              for (f in i) h = i[f], p = n[f], !i.hasOwnProperty(f) || h === p || h === void 0 && p === void 0 || jh(e, t, f, h, i, p);
              return;
            }
        }
        for (var u in n) h = n[u], n.hasOwnProperty(u) && h != null && !i.hasOwnProperty(u) && ce(e, t, u, null, i, h);
        for (d in i) h = i[d], p = n[d], !i.hasOwnProperty(d) || h === p || h == null && p == null || ce(e, t, d, h, i, p);
      }
      var Zh = null, Kh = null;
      function ru(e) {
        return e.nodeType === 9 ? e : e.ownerDocument;
      }
      function w_(e) {
        switch (e) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function By(e, t) {
        if (e === 0) switch (t) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
        return e === 1 && t === "foreignObject" ? 0 : e;
      }
      function Qh(e, t) {
        return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.children == "bigint" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
      }
      var wf = null;
      function dE() {
        var e = window.event;
        return e && e.type === "popstate" ? e === wf ? false : (wf = e, true) : (wf = null, false);
      }
      var Fy = typeof setTimeout == "function" ? setTimeout : void 0, pE = typeof clearTimeout == "function" ? clearTimeout : void 0, C_ = typeof Promise == "function" ? Promise : void 0, mE = typeof queueMicrotask == "function" ? queueMicrotask : typeof C_ < "u" ? function(e) {
        return C_.resolve(null).then(e).catch(_E);
      } : Fy;
      function _E(e) {
        setTimeout(function() {
          throw e;
        });
      }
      function Cf(e, t) {
        var n = t, i = 0;
        do {
          var a = n.nextSibling;
          if (e.removeChild(n), a && a.nodeType === 8) if (n = a.data, n === "/$") {
            if (i === 0) {
              e.removeChild(a), al(t);
              return;
            }
            i--;
          } else n !== "$" && n !== "$?" && n !== "$!" || i++;
          n = a;
        } while (n);
        al(t);
      }
      function Jh(e) {
        var t = e.firstChild;
        for (t && t.nodeType === 10 && (t = t.nextSibling); t; ) {
          var n = t;
          switch (t = t.nextSibling, n.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              Jh(n), sp(n);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if (n.rel.toLowerCase() === "stylesheet") continue;
          }
          e.removeChild(n);
        }
      }
      function gE(e, t, n, i) {
        for (; e.nodeType === 1; ) {
          var a = n;
          if (e.nodeName.toLowerCase() !== t.toLowerCase()) {
            if (!i && (e.nodeName !== "INPUT" || e.type !== "hidden")) break;
          } else if (i) {
            if (!e[Wo]) switch (t) {
              case "meta":
                if (!e.hasAttribute("itemprop")) break;
                return e;
              case "link":
                if (s = e.getAttribute("rel"), s === "stylesheet" && e.hasAttribute("data-precedence")) break;
                if (s !== a.rel || e.getAttribute("href") !== (a.href == null ? null : a.href) || e.getAttribute("crossorigin") !== (a.crossOrigin == null ? null : a.crossOrigin) || e.getAttribute("title") !== (a.title == null ? null : a.title)) break;
                return e;
              case "style":
                if (e.hasAttribute("data-precedence")) break;
                return e;
              case "script":
                if (s = e.getAttribute("src"), (s !== (a.src == null ? null : a.src) || e.getAttribute("type") !== (a.type == null ? null : a.type) || e.getAttribute("crossorigin") !== (a.crossOrigin == null ? null : a.crossOrigin)) && s && e.hasAttribute("async") && !e.hasAttribute("itemprop")) break;
                return e;
              default:
                return e;
            }
          } else if (t === "input" && e.type === "hidden") {
            var s = a.name == null ? null : "" + a.name;
            if (a.type === "hidden" && e.getAttribute("name") === s) return e;
          } else return e;
          if (e = ui(e.nextSibling), e === null) break;
        }
        return null;
      }
      function vE(e, t, n) {
        if (t === "") return null;
        for (; e.nodeType !== 3; ) if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !n || (e = ui(e.nextSibling), e === null)) return null;
        return e;
      }
      function ui(e) {
        for (; e != null; e = e.nextSibling) {
          var t = e.nodeType;
          if (t === 1 || t === 3) break;
          if (t === 8) {
            if (t = e.data, t === "$" || t === "$!" || t === "$?" || t === "F!" || t === "F") break;
            if (t === "/$") return null;
          }
        }
        return e;
      }
      function D_(e) {
        e = e.previousSibling;
        for (var t = 0; e; ) {
          if (e.nodeType === 8) {
            var n = e.data;
            if (n === "$" || n === "$!" || n === "$?") {
              if (t === 0) return e;
              t--;
            } else n === "/$" && t++;
          }
          e = e.previousSibling;
        }
        return null;
      }
      function Iy(e, t, n) {
        switch (t = ru(n), e) {
          case "html":
            if (e = t.documentElement, !e) throw Error(j(452));
            return e;
          case "head":
            if (e = t.head, !e) throw Error(j(453));
            return e;
          case "body":
            if (e = t.body, !e) throw Error(j(454));
            return e;
          default:
            throw Error(j(451));
        }
      }
      var ti = /* @__PURE__ */ new Map(), U_ = /* @__PURE__ */ new Set();
      function ou(e) {
        return typeof e.getRootNode == "function" ? e.getRootNode() : e.ownerDocument;
      }
      var ia = ge.d;
      ge.d = {
        f: yE,
        r: SE,
        D: xE,
        C: ME,
        L: EE,
        m: bE,
        X: AE,
        S: TE,
        M: RE
      };
      function yE() {
        var e = ia.f(), t = Nu();
        return e || t;
      }
      function SE(e) {
        var t = jr(e);
        t !== null && t.tag === 5 && t.type === "form" ? Iv(t) : ia.r(e);
      }
      var Kr = typeof document > "u" ? null : document;
      function Hy(e, t, n) {
        var i = Kr;
        if (i && typeof t == "string" && t) {
          var a = Yn(t);
          a = 'link[rel="' + e + '"][href="' + a + '"]', typeof n == "string" && (a += '[crossorigin="' + n + '"]'), U_.has(a) || (U_.add(a), e = {
            rel: e,
            crossOrigin: n,
            href: t
          }, i.querySelector(a) === null && (t = i.createElement("link"), $e(t, "link", e), Ye(t), i.head.appendChild(t)));
        }
      }
      function xE(e) {
        ia.D(e), Hy("dns-prefetch", e, null);
      }
      function ME(e, t) {
        ia.C(e, t), Hy("preconnect", e, t);
      }
      function EE(e, t, n) {
        ia.L(e, t, n);
        var i = Kr;
        if (i && e && t) {
          var a = 'link[rel="preload"][as="' + Yn(t) + '"]';
          t === "image" && n && n.imageSrcSet ? (a += '[imagesrcset="' + Yn(n.imageSrcSet) + '"]', typeof n.imageSizes == "string" && (a += '[imagesizes="' + Yn(n.imageSizes) + '"]')) : a += '[href="' + Yn(e) + '"]';
          var s = a;
          switch (t) {
            case "style":
              s = Pr(e);
              break;
            case "script":
              s = Qr(e);
          }
          ti.has(s) || (e = ve({
            rel: "preload",
            href: t === "image" && n && n.imageSrcSet ? void 0 : e,
            as: t
          }, n), ti.set(s, e), i.querySelector(a) !== null || t === "style" && i.querySelector(El(s)) || t === "script" && i.querySelector(bl(s)) || (t = i.createElement("link"), $e(t, "link", e), Ye(t), i.head.appendChild(t)));
        }
      }
      function bE(e, t) {
        ia.m(e, t);
        var n = Kr;
        if (n && e) {
          var i = t && typeof t.as == "string" ? t.as : "script", a = 'link[rel="modulepreload"][as="' + Yn(i) + '"][href="' + Yn(e) + '"]', s = a;
          switch (i) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              s = Qr(e);
          }
          if (!ti.has(s) && (e = ve({
            rel: "modulepreload",
            href: e
          }, t), ti.set(s, e), n.querySelector(a) === null)) {
            switch (i) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (n.querySelector(bl(s))) return;
            }
            i = n.createElement("link"), $e(i, "link", e), Ye(i), n.head.appendChild(i);
          }
        }
      }
      function TE(e, t, n) {
        ia.S(e, t, n);
        var i = Kr;
        if (i && e) {
          var a = mr(i).hoistableStyles, s = Pr(e);
          t = t || "default";
          var r = a.get(s);
          if (!r) {
            var o = {
              loading: 0,
              preload: null
            };
            if (r = i.querySelector(El(s))) o.loading = 5;
            else {
              e = ve({
                rel: "stylesheet",
                href: e,
                "data-precedence": t
              }, n), (n = ti.get(s)) && Vp(e, n);
              var l = r = i.createElement("link");
              Ye(l), $e(l, "link", e), l._p = new Promise(function(c, f) {
                l.onload = c, l.onerror = f;
              }), l.addEventListener("load", function() {
                o.loading |= 1;
              }), l.addEventListener("error", function() {
                o.loading |= 2;
              }), o.loading |= 4, Rc(r, t, i);
            }
            r = {
              type: "stylesheet",
              instance: r,
              count: 1,
              state: o
            }, a.set(s, r);
          }
        }
      }
      function AE(e, t) {
        ia.X(e, t);
        var n = Kr;
        if (n && e) {
          var i = mr(n).hoistableScripts, a = Qr(e), s = i.get(a);
          s || (s = n.querySelector(bl(a)), s || (e = ve({
            src: e,
            async: true
          }, t), (t = ti.get(a)) && kp(e, t), s = n.createElement("script"), Ye(s), $e(s, "link", e), n.head.appendChild(s)), s = {
            type: "script",
            instance: s,
            count: 1,
            state: null
          }, i.set(a, s));
        }
      }
      function RE(e, t) {
        ia.M(e, t);
        var n = Kr;
        if (n && e) {
          var i = mr(n).hoistableScripts, a = Qr(e), s = i.get(a);
          s || (s = n.querySelector(bl(a)), s || (e = ve({
            src: e,
            async: true,
            type: "module"
          }, t), (t = ti.get(a)) && kp(e, t), s = n.createElement("script"), Ye(s), $e(s, "link", e), n.head.appendChild(s)), s = {
            type: "script",
            instance: s,
            count: 1,
            state: null
          }, i.set(a, s));
        }
      }
      function L_(e, t, n, i) {
        var a = (a = ba.current) ? ou(a) : null;
        if (!a) throw Error(j(446));
        switch (e) {
          case "meta":
          case "title":
            return null;
          case "style":
            return typeof n.precedence == "string" && typeof n.href == "string" ? (t = Pr(n.href), n = mr(a).hoistableStyles, i = n.get(t), i || (i = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, n.set(t, i)), i) : {
              type: "void",
              instance: null,
              count: 0,
              state: null
            };
          case "link":
            if (n.rel === "stylesheet" && typeof n.href == "string" && typeof n.precedence == "string") {
              e = Pr(n.href);
              var s = mr(a).hoistableStyles, r = s.get(e);
              if (r || (a = a.ownerDocument || a, r = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: {
                  loading: 0,
                  preload: null
                }
              }, s.set(e, r), (s = a.querySelector(El(e))) && !s._p && (r.instance = s, r.state.loading = 5), ti.has(e) || (n = {
                rel: "preload",
                as: "style",
                href: n.href,
                crossOrigin: n.crossOrigin,
                integrity: n.integrity,
                media: n.media,
                hrefLang: n.hrefLang,
                referrerPolicy: n.referrerPolicy
              }, ti.set(e, n), s || wE(a, e, n, r.state))), t && i === null) throw Error(j(528, ""));
              return r;
            }
            if (t && i !== null) throw Error(j(529, ""));
            return null;
          case "script":
            return t = n.async, n = n.src, typeof n == "string" && t && typeof t != "function" && typeof t != "symbol" ? (t = Qr(n), n = mr(a).hoistableScripts, i = n.get(t), i || (i = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, n.set(t, i)), i) : {
              type: "void",
              instance: null,
              count: 0,
              state: null
            };
          default:
            throw Error(j(444, e));
        }
      }
      function Pr(e) {
        return 'href="' + Yn(e) + '"';
      }
      function El(e) {
        return 'link[rel="stylesheet"][' + e + "]";
      }
      function Gy(e) {
        return ve({}, e, {
          "data-precedence": e.precedence,
          precedence: null
        });
      }
      function wE(e, t, n, i) {
        e.querySelector('link[rel="preload"][as="style"][' + t + "]") ? i.loading = 1 : (t = e.createElement("link"), i.preload = t, t.addEventListener("load", function() {
          return i.loading |= 1;
        }), t.addEventListener("error", function() {
          return i.loading |= 2;
        }), $e(t, "link", n), Ye(t), e.head.appendChild(t));
      }
      function Qr(e) {
        return '[src="' + Yn(e) + '"]';
      }
      function bl(e) {
        return "script[async]" + e;
      }
      function N_(e, t, n) {
        if (t.count++, t.instance === null) switch (t.type) {
          case "style":
            var i = e.querySelector('style[data-href~="' + Yn(n.href) + '"]');
            if (i) return t.instance = i, Ye(i), i;
            var a = ve({}, n, {
              "data-href": n.href,
              "data-precedence": n.precedence,
              href: null,
              precedence: null
            });
            return i = (e.ownerDocument || e).createElement("style"), Ye(i), $e(i, "style", a), Rc(i, n.precedence, e), t.instance = i;
          case "stylesheet":
            a = Pr(n.href);
            var s = e.querySelector(El(a));
            if (s) return t.state.loading |= 4, t.instance = s, Ye(s), s;
            i = Gy(n), (a = ti.get(a)) && Vp(i, a), s = (e.ownerDocument || e).createElement("link"), Ye(s);
            var r = s;
            return r._p = new Promise(function(o, l) {
              r.onload = o, r.onerror = l;
            }), $e(s, "link", i), t.state.loading |= 4, Rc(s, n.precedence, e), t.instance = s;
          case "script":
            return s = Qr(n.src), (a = e.querySelector(bl(s))) ? (t.instance = a, Ye(a), a) : (i = n, (a = ti.get(s)) && (i = ve({}, n), kp(i, a)), e = e.ownerDocument || e, a = e.createElement("script"), Ye(a), $e(a, "link", i), e.head.appendChild(a), t.instance = a);
          case "void":
            return null;
          default:
            throw Error(j(443, t.type));
        }
        else t.type === "stylesheet" && !(t.state.loading & 4) && (i = t.instance, t.state.loading |= 4, Rc(i, n.precedence, e));
        return t.instance;
      }
      function Rc(e, t, n) {
        for (var i = n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), a = i.length ? i[i.length - 1] : null, s = a, r = 0; r < i.length; r++) {
          var o = i[r];
          if (o.dataset.precedence === t) s = o;
          else if (s !== a) break;
        }
        s ? s.parentNode.insertBefore(e, s.nextSibling) : (t = n.nodeType === 9 ? n.head : n, t.insertBefore(e, t.firstChild));
      }
      function Vp(e, t) {
        e.crossOrigin == null && (e.crossOrigin = t.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = t.referrerPolicy), e.title == null && (e.title = t.title);
      }
      function kp(e, t) {
        e.crossOrigin == null && (e.crossOrigin = t.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = t.referrerPolicy), e.integrity == null && (e.integrity = t.integrity);
      }
      var wc = null;
      function O_(e, t, n) {
        if (wc === null) {
          var i = /* @__PURE__ */ new Map(), a = wc = /* @__PURE__ */ new Map();
          a.set(n, i);
        } else a = wc, i = a.get(n), i || (i = /* @__PURE__ */ new Map(), a.set(n, i));
        if (i.has(e)) return i;
        for (i.set(e, null), n = n.getElementsByTagName(e), a = 0; a < n.length; a++) {
          var s = n[a];
          if (!(s[Wo] || s[sn] || e === "link" && s.getAttribute("rel") === "stylesheet") && s.namespaceURI !== "http://www.w3.org/2000/svg") {
            var r = s.getAttribute(t) || "";
            r = e + r;
            var o = i.get(r);
            o ? o.push(s) : i.set(r, [
              s
            ]);
          }
        }
        return i;
      }
      function P_(e, t, n) {
        e = e.ownerDocument || e, e.head.insertBefore(n, t === "title" ? e.querySelector("head > title") : null);
      }
      function CE(e, t, n) {
        if (n === 1 || t.itemProp != null) return false;
        switch (e) {
          case "meta":
          case "title":
            return true;
          case "style":
            if (typeof t.precedence != "string" || typeof t.href != "string" || t.href === "") break;
            return true;
          case "link":
            if (typeof t.rel != "string" || typeof t.href != "string" || t.href === "" || t.onLoad || t.onError) break;
            switch (t.rel) {
              case "stylesheet":
                return e = t.disabled, typeof t.precedence == "string" && e == null;
              default:
                return true;
            }
          case "script":
            if (t.async && typeof t.async != "function" && typeof t.async != "symbol" && !t.onLoad && !t.onError && t.src && typeof t.src == "string") return true;
        }
        return false;
      }
      function Vy(e) {
        return !(e.type === "stylesheet" && !(e.state.loading & 3));
      }
      var tl = null;
      function DE() {
      }
      function UE(e, t, n) {
        if (tl === null) throw Error(j(475));
        var i = tl;
        if (t.type === "stylesheet" && (typeof n.media != "string" || matchMedia(n.media).matches !== false) && !(t.state.loading & 4)) {
          if (t.instance === null) {
            var a = Pr(n.href), s = e.querySelector(El(a));
            if (s) {
              e = s._p, e !== null && typeof e == "object" && typeof e.then == "function" && (i.count++, i = lu.bind(i), e.then(i, i)), t.state.loading |= 4, t.instance = s, Ye(s);
              return;
            }
            s = e.ownerDocument || e, n = Gy(n), (a = ti.get(a)) && Vp(n, a), s = s.createElement("link"), Ye(s);
            var r = s;
            r._p = new Promise(function(o, l) {
              r.onload = o, r.onerror = l;
            }), $e(s, "link", n), t.instance = s;
          }
          i.stylesheets === null && (i.stylesheets = /* @__PURE__ */ new Map()), i.stylesheets.set(t, e), (e = t.state.preload) && !(t.state.loading & 3) && (i.count++, t = lu.bind(i), e.addEventListener("load", t), e.addEventListener("error", t));
        }
      }
      function LE() {
        if (tl === null) throw Error(j(475));
        var e = tl;
        return e.stylesheets && e.count === 0 && $h(e, e.stylesheets), 0 < e.count ? function(t) {
          var n = setTimeout(function() {
            if (e.stylesheets && $h(e, e.stylesheets), e.unsuspend) {
              var i = e.unsuspend;
              e.unsuspend = null, i();
            }
          }, 6e4);
          return e.unsuspend = t, function() {
            e.unsuspend = null, clearTimeout(n);
          };
        } : null;
      }
      function lu() {
        if (this.count--, this.count === 0) {
          if (this.stylesheets) $h(this, this.stylesheets);
          else if (this.unsuspend) {
            var e = this.unsuspend;
            this.unsuspend = null, e();
          }
        }
      }
      var cu = null;
      function $h(e, t) {
        e.stylesheets = null, e.unsuspend !== null && (e.count++, cu = /* @__PURE__ */ new Map(), t.forEach(NE, e), cu = null, lu.call(e));
      }
      function NE(e, t) {
        if (!(t.state.loading & 4)) {
          var n = cu.get(e);
          if (n) var i = n.get(null);
          else {
            n = /* @__PURE__ */ new Map(), cu.set(e, n);
            for (var a = e.querySelectorAll("link[data-precedence],style[data-precedence]"), s = 0; s < a.length; s++) {
              var r = a[s];
              (r.nodeName === "LINK" || r.getAttribute("media") !== "not all") && (n.set(r.dataset.precedence, r), i = r);
            }
            i && n.set(null, i);
          }
          a = t.instance, r = a.getAttribute("data-precedence"), s = n.get(r) || i, s === i && n.set(null, a), n.set(r, a), this.count++, i = lu.bind(this), a.addEventListener("load", i), a.addEventListener("error", i), s ? s.parentNode.insertBefore(a, s.nextSibling) : (e = e.nodeType === 9 ? e.head : e, e.insertBefore(a, e.firstChild)), t.state.loading |= 4;
        }
      }
      var el = {
        $$typeof: Vi,
        Provider: null,
        Consumer: null,
        _currentValue: os,
        _currentValue2: os,
        _threadCount: 0
      };
      function OE(e, t, n, i, a, s, r, o) {
        this.tag = 1, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = $u(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = $u(0), this.hiddenUpdates = $u(null), this.identifierPrefix = i, this.onUncaughtError = a, this.onCaughtError = s, this.onRecoverableError = r, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = o, this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function ky(e, t, n, i, a, s, r, o, l, c, f, d) {
        return e = new OE(e, t, n, r, o, l, c, d), t = 1, s === true && (t |= 24), s = Zn(3, null, null, t), e.current = s, s.stateNode = e, t = gp(), t.refCount++, e.pooledCache = t, t.refCount++, s.memoizedState = {
          element: i,
          isDehydrated: n,
          cache: t
        }, Lp(s), e;
      }
      function Xy(e) {
        return e ? (e = cr, e) : cr;
      }
      function Wy(e, t, n, i, a, s) {
        a = Xy(a), i.context === null ? i.context = a : i.pendingContext = a, i = Ta(t), i.payload = {
          element: n
        }, s = s === void 0 ? null : s, s !== null && (i.callback = s), n = Aa(e, i, t), n !== null && (hn(n, e, t), Po(n, e, t));
      }
      function z_(e, t) {
        if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
          var n = e.retryLane;
          e.retryLane = n !== 0 && n < t ? n : t;
        }
      }
      function Xp(e, t) {
        z_(e, t), (e = e.alternate) && z_(e, t);
      }
      function Yy(e) {
        if (e.tag === 13) {
          var t = Oa(e, 67108864);
          t !== null && hn(t, e, 67108864), Xp(e, 67108864);
        }
      }
      var uu = true;
      function PE(e, t, n, i) {
        var a = Lt.T;
        Lt.T = null;
        var s = ge.p;
        try {
          ge.p = 2, Wp(e, t, n, i);
        } finally {
          ge.p = s, Lt.T = a;
        }
      }
      function zE(e, t, n, i) {
        var a = Lt.T;
        Lt.T = null;
        var s = ge.p;
        try {
          ge.p = 8, Wp(e, t, n, i);
        } finally {
          ge.p = s, Lt.T = a;
        }
      }
      function Wp(e, t, n, i) {
        if (uu) {
          var a = td(i);
          if (a === null) Rf(e, t, i, fu, n), B_(e, i);
          else if (FE(a, e, t, n, i)) i.stopPropagation();
          else if (B_(e, i), t & 4 && -1 < BE.indexOf(e)) {
            for (; a !== null; ) {
              var s = jr(a);
              if (s !== null) switch (s.tag) {
                case 3:
                  if (s = s.stateNode, s.current.memoizedState.isDehydrated) {
                    var r = Qa(s.pendingLanes);
                    if (r !== 0) {
                      var o = s;
                      for (o.pendingLanes |= 2, o.entangledLanes |= 2; r; ) {
                        var l = 1 << 31 - wn(r);
                        o.entanglements[1] |= l, r &= ~l;
                      }
                      bi(s), !(be & 6) && (eu = yi() + 500, Ml(0));
                    }
                  }
                  break;
                case 13:
                  o = Oa(s, 2), o !== null && hn(o, s, 2), Nu(), Xp(s, 2);
              }
              if (s = td(i), s === null && Rf(e, t, i, fu, n), s === a) break;
              a = s;
            }
            a !== null && i.stopPropagation();
          } else Rf(e, t, i, null, n);
        }
      }
      function td(e) {
        return e = op(e), Yp(e);
      }
      var fu = null;
      function Yp(e) {
        if (fu = null, e = is(e), e !== null) {
          var t = Yr(e);
          if (t === null) e = null;
          else {
            var n = t.tag;
            if (n === 13) {
              if (e = b0(t), e !== null) return e;
              e = null;
            } else if (n === 3) {
              if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
              e = null;
            } else t !== e && (e = null);
          }
        }
        return fu = e, null;
      }
      function qy(e) {
        switch (e) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (Mx()) {
              case A0:
                return 2;
              case R0:
                return 8;
              case Gc:
              case Ex:
                return 32;
              case w0:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var ed = false, Ca = null, Da = null, Ua = null, nl = /* @__PURE__ */ new Map(), il = /* @__PURE__ */ new Map(), Sa = [], BE = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
      function B_(e, t) {
        switch (e) {
          case "focusin":
          case "focusout":
            Ca = null;
            break;
          case "dragenter":
          case "dragleave":
            Da = null;
            break;
          case "mouseover":
          case "mouseout":
            Ua = null;
            break;
          case "pointerover":
          case "pointerout":
            nl.delete(t.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            il.delete(t.pointerId);
        }
      }
      function fo(e, t, n, i, a, s) {
        return e === null || e.nativeEvent !== s ? (e = {
          blockedOn: t,
          domEventName: n,
          eventSystemFlags: i,
          nativeEvent: s,
          targetContainers: [
            a
          ]
        }, t !== null && (t = jr(t), t !== null && Yy(t)), e) : (e.eventSystemFlags |= i, t = e.targetContainers, a !== null && t.indexOf(a) === -1 && t.push(a), e);
      }
      function FE(e, t, n, i, a) {
        switch (t) {
          case "focusin":
            return Ca = fo(Ca, e, t, n, i, a), true;
          case "dragenter":
            return Da = fo(Da, e, t, n, i, a), true;
          case "mouseover":
            return Ua = fo(Ua, e, t, n, i, a), true;
          case "pointerover":
            var s = a.pointerId;
            return nl.set(s, fo(nl.get(s) || null, e, t, n, i, a)), true;
          case "gotpointercapture":
            return s = a.pointerId, il.set(s, fo(il.get(s) || null, e, t, n, i, a)), true;
        }
        return false;
      }
      function jy(e) {
        var t = is(e.target);
        if (t !== null) {
          var n = Yr(t);
          if (n !== null) {
            if (t = n.tag, t === 13) {
              if (t = b0(n), t !== null) {
                e.blockedOn = t, Lx(e.priority, function() {
                  if (n.tag === 13) {
                    var i = Cn(), a = Oa(n, i);
                    a !== null && hn(a, n, i), Xp(n, i);
                  }
                });
                return;
              }
            } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
              e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
              return;
            }
          }
        }
        e.blockedOn = null;
      }
      function Cc(e) {
        if (e.blockedOn !== null) return false;
        for (var t = e.targetContainers; 0 < t.length; ) {
          var n = td(e.nativeEvent);
          if (n === null) {
            n = e.nativeEvent;
            var i = new n.constructor(n.type, n);
            yh = i, n.target.dispatchEvent(i), yh = null;
          } else return t = jr(n), t !== null && Yy(t), e.blockedOn = n, false;
          t.shift();
        }
        return true;
      }
      function F_(e, t, n) {
        Cc(e) && n.delete(t);
      }
      function IE() {
        ed = false, Ca !== null && Cc(Ca) && (Ca = null), Da !== null && Cc(Da) && (Da = null), Ua !== null && Cc(Ua) && (Ua = null), nl.forEach(F_), il.forEach(F_);
      }
      function Vl(e, t) {
        e.blockedOn === t && (e.blockedOn = null, ed || (ed = true, He.unstable_scheduleCallback(He.unstable_NormalPriority, IE)));
      }
      var kl = null;
      function I_(e) {
        kl !== e && (kl = e, He.unstable_scheduleCallback(He.unstable_NormalPriority, function() {
          kl === e && (kl = null);
          for (var t = 0; t < e.length; t += 3) {
            var n = e[t], i = e[t + 1], a = e[t + 2];
            if (typeof i != "function") {
              if (Yp(i || n) === null) continue;
              break;
            }
            var s = jr(n);
            s !== null && (e.splice(t, 3), t -= 3, Ch(s, {
              pending: true,
              data: a,
              method: n.method,
              action: i
            }, i, a));
          }
        }));
      }
      function al(e) {
        function t(l) {
          return Vl(l, e);
        }
        Ca !== null && Vl(Ca, e), Da !== null && Vl(Da, e), Ua !== null && Vl(Ua, e), nl.forEach(t), il.forEach(t);
        for (var n = 0; n < Sa.length; n++) {
          var i = Sa[n];
          i.blockedOn === e && (i.blockedOn = null);
        }
        for (; 0 < Sa.length && (n = Sa[0], n.blockedOn === null); ) jy(n), n.blockedOn === null && Sa.shift();
        if (n = (e.ownerDocument || e).$$reactFormReplay, n != null) for (i = 0; i < n.length; i += 3) {
          var a = n[i], s = n[i + 1], r = a[yn] || null;
          if (typeof s == "function") r || I_(n);
          else if (r) {
            var o = null;
            if (s && s.hasAttribute("formAction")) {
              if (a = s, r = s[yn] || null) o = r.formAction;
              else if (Yp(a) !== null) continue;
            } else o = r.action;
            typeof o == "function" ? n[i + 1] = o : (n.splice(i, 3), i -= 3), I_(n);
          }
        }
      }
      function qp(e) {
        this._internalRoot = e;
      }
      zu.prototype.render = qp.prototype.render = function(e) {
        var t = this._internalRoot;
        if (t === null) throw Error(j(409));
        var n = t.current, i = Cn();
        Wy(n, i, e, t, null, null);
      };
      zu.prototype.unmount = qp.prototype.unmount = function() {
        var e = this._internalRoot;
        if (e !== null) {
          this._internalRoot = null;
          var t = e.containerInfo;
          e.tag === 0 && Mr(), Wy(e.current, 2, null, e, null, null), Nu(), t[qr] = null;
        }
      };
      function zu(e) {
        this._internalRoot = e;
      }
      zu.prototype.unstable_scheduleHydration = function(e) {
        if (e) {
          var t = O0();
          e = {
            blockedOn: null,
            target: e,
            priority: t
          };
          for (var n = 0; n < Sa.length && t !== 0 && t < Sa[n].priority; n++) ;
          Sa.splice(n, 0, e), n === 0 && jy(e);
        }
      };
      var H_ = y0.version;
      if (H_ !== "19.0.0") throw Error(j(527, H_, "19.0.0"));
      ge.findDOMNode = function(e) {
        var t = e._reactInternals;
        if (t === void 0) throw typeof e.render == "function" ? Error(j(188)) : (e = Object.keys(e).join(","), Error(j(268, e)));
        return e = yx(t), e = e !== null ? T0(e) : null, e = e === null ? null : e.stateNode, e;
      };
      var HE = {
        bundleType: 0,
        version: "19.0.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: Lt,
        findFiberByHostInstance: is,
        reconcilerVersion: "19.0.0"
      };
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var Xl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Xl.isDisabled && Xl.supportsFiber) try {
          dl = Xl.inject(HE), Rn = Xl;
        } catch {
        }
      }
      xu.createRoot = function(e, t) {
        if (!S0(e)) throw Error(j(299));
        var n = false, i = "", a = Wv, s = Yv, r = qv, o = null;
        return t != null && (t.unstable_strictMode === true && (n = true), t.identifierPrefix !== void 0 && (i = t.identifierPrefix), t.onUncaughtError !== void 0 && (a = t.onUncaughtError), t.onCaughtError !== void 0 && (s = t.onCaughtError), t.onRecoverableError !== void 0 && (r = t.onRecoverableError), t.unstable_transitionCallbacks !== void 0 && (o = t.unstable_transitionCallbacks)), t = ky(e, 1, false, null, null, n, i, a, s, r, o, null), e[qr] = t.current, Gp(e.nodeType === 8 ? e.parentNode : e), new qp(t);
      };
      xu.hydrateRoot = function(e, t, n) {
        if (!S0(e)) throw Error(j(299));
        var i = false, a = "", s = Wv, r = Yv, o = qv, l = null, c = null;
        return n != null && (n.unstable_strictMode === true && (i = true), n.identifierPrefix !== void 0 && (a = n.identifierPrefix), n.onUncaughtError !== void 0 && (s = n.onUncaughtError), n.onCaughtError !== void 0 && (r = n.onCaughtError), n.onRecoverableError !== void 0 && (o = n.onRecoverableError), n.unstable_transitionCallbacks !== void 0 && (l = n.unstable_transitionCallbacks), n.formState !== void 0 && (c = n.formState)), t = ky(e, 1, true, t, n ?? null, i, a, s, r, o, l, c), t.context = Xy(null), n = t.current, i = Cn(), a = Ta(i), a.callback = null, Aa(n, a, i), t.current.lanes = i, ml(t, i), bi(t), e[qr] = t.current, Gp(e), new zu(t);
      };
      xu.version = "19.0.0";
      function Zy() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Zy);
        } catch (e) {
          console.error(e);
        }
      }
      Zy(), d0.exports = xu;
      var GE = d0.exports, Jt;
      ((e) => {
        function t(i, a) {
          return i[0] === a[0] && i[1] === a[1] && i[2] === a[2];
        }
        e.compare = t;
        function n(i, a) {
          return [
            i[0] + a[0],
            i[1] + a[1],
            i[2] + a[2]
          ];
        }
        e.add = n;
      })(Jt || (Jt = {}));
      var nd;
      ((e) => {
        function t(n, i) {
          return n.sausages.find((a) => !!(Jt.compare(a.pos, i) || Jt.compare(a.pos, Jt.add(i, [
            -1,
            0,
            0
          ])) && a.orientation === "Horizontal" || Jt.compare(a.pos, Jt.add(i, [
            0,
            -1,
            0
          ])) && a.orientation === "Vertical")) ?? null;
        }
        e.getSausageAt = t;
      })(nd || (nd = {}));
      var sl;
      ((e) => {
        function t(n, i) {
          return n.sausages.find((a) => !!(Jt.compare(a.pos, i) || Jt.compare(a.pos, Jt.add(i, [
            -1,
            0,
            0
          ])) && a.orientation === "Horizontal" || Jt.compare(a.pos, Jt.add(i, [
            0,
            -1,
            0
          ])) && a.orientation === "Vertical")) ?? null;
        }
        e.getSausageAt = t;
      })(sl || (sl = {}));
      var Ky = Symbol.for("immer-nothing"), G_ = Symbol.for("immer-draftable"), re = Symbol.for("immer-state");
      function jn(e, ...t) {
        throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`);
      }
      var zr = Object.getPrototypeOf;
      function Br(e) {
        return !!e && !!e[re];
      }
      function ta(e) {
        var _a2;
        return e ? Qy(e) || Array.isArray(e) || !!e[G_] || !!((_a2 = e.constructor) == null ? void 0 : _a2[G_]) || Fu(e) || Iu(e) : false;
      }
      var VE = Object.prototype.constructor.toString();
      function Qy(e) {
        if (!e || typeof e != "object") return false;
        const t = zr(e);
        if (t === null) return true;
        const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
        return n === Object ? true : typeof n == "function" && Function.toString.call(n) === VE;
      }
      function rl(e, t) {
        Bu(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
          t(n, e[n], e);
        }) : e.forEach((n, i) => t(i, n, e));
      }
      function Bu(e) {
        const t = e[re];
        return t ? t.type_ : Array.isArray(e) ? 1 : Fu(e) ? 2 : Iu(e) ? 3 : 0;
      }
      function id(e, t) {
        return Bu(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
      }
      function Jy(e, t, n) {
        const i = Bu(e);
        i === 2 ? e.set(t, n) : i === 3 ? e.add(n) : e[t] = n;
      }
      function kE(e, t) {
        return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
      }
      function Fu(e) {
        return e instanceof Map;
      }
      function Iu(e) {
        return e instanceof Set;
      }
      function Xe(e) {
        return e.copy_ || e.base_;
      }
      function ad(e, t) {
        if (Fu(e)) return new Map(e);
        if (Iu(e)) return new Set(e);
        if (Array.isArray(e)) return Array.prototype.slice.call(e);
        const n = Qy(e);
        if (t === true || t === "class_only" && !n) {
          const i = Object.getOwnPropertyDescriptors(e);
          delete i[re];
          let a = Reflect.ownKeys(i);
          for (let s = 0; s < a.length; s++) {
            const r = a[s], o = i[r];
            o.writable === false && (o.writable = true, o.configurable = true), (o.get || o.set) && (i[r] = {
              configurable: true,
              writable: true,
              enumerable: o.enumerable,
              value: e[r]
            });
          }
          return Object.create(zr(e), i);
        } else {
          const i = zr(e);
          if (i !== null && n) return {
            ...e
          };
          const a = Object.create(i);
          return Object.assign(a, e);
        }
      }
      function jp(e, t = false) {
        return Hu(e) || Br(e) || !ta(e) || (Bu(e) > 1 && (e.set = e.add = e.clear = e.delete = XE), Object.freeze(e), t && Object.entries(e).forEach(([n, i]) => jp(i, true))), e;
      }
      function XE() {
        jn(2);
      }
      function Hu(e) {
        return Object.isFrozen(e);
      }
      var sd = {};
      function vs(e) {
        const t = sd[e];
        return t || jn(0, e), t;
      }
      function WE(e, t) {
        sd[e] || (sd[e] = t);
      }
      var ol;
      function hu() {
        return ol;
      }
      function YE(e, t) {
        return {
          drafts_: [],
          parent_: e,
          immer_: t,
          canAutoFreeze_: true,
          unfinalizedDrafts_: 0
        };
      }
      function V_(e, t) {
        t && (vs("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
      }
      function rd(e) {
        od(e), e.drafts_.forEach(qE), e.drafts_ = null;
      }
      function od(e) {
        e === ol && (ol = e.parent_);
      }
      function k_(e) {
        return ol = YE(ol, e);
      }
      function qE(e) {
        const t = e[re];
        t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = true;
      }
      function X_(e, t) {
        t.unfinalizedDrafts_ = t.drafts_.length;
        const n = t.drafts_[0];
        return e !== void 0 && e !== n ? (n[re].modified_ && (rd(t), jn(4)), ta(e) && (e = du(t, e), t.parent_ || pu(t, e)), t.patches_ && vs("Patches").generateReplacementPatches_(n[re].base_, e, t.patches_, t.inversePatches_)) : e = du(t, n, []), rd(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Ky ? e : void 0;
      }
      function du(e, t, n) {
        if (Hu(t)) return t;
        const i = t[re];
        if (!i) return rl(t, (a, s) => W_(e, i, t, a, s, n)), t;
        if (i.scope_ !== e) return t;
        if (!i.modified_) return pu(e, i.base_, true), i.base_;
        if (!i.finalized_) {
          i.finalized_ = true, i.scope_.unfinalizedDrafts_--;
          const a = i.copy_;
          let s = a, r = false;
          i.type_ === 3 && (s = new Set(a), a.clear(), r = true), rl(s, (o, l) => W_(e, i, a, o, l, n, r)), pu(e, a, false), n && e.patches_ && vs("Patches").generatePatches_(i, n, e.patches_, e.inversePatches_);
        }
        return i.copy_;
      }
      function W_(e, t, n, i, a, s, r) {
        if (Br(a)) {
          const o = s && t && t.type_ !== 3 && !id(t.assigned_, i) ? s.concat(i) : void 0, l = du(e, a, o);
          if (Jy(n, i, l), Br(l)) e.canAutoFreeze_ = false;
          else return;
        } else r && n.add(a);
        if (ta(a) && !Hu(a)) {
          if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1) return;
          du(e, a), (!t || !t.scope_.parent_) && typeof i != "symbol" && Object.prototype.propertyIsEnumerable.call(n, i) && pu(e, a);
        }
      }
      function pu(e, t, n = false) {
        !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && jp(t, n);
      }
      function jE(e, t) {
        const n = Array.isArray(e), i = {
          type_: n ? 1 : 0,
          scope_: t ? t.scope_ : hu(),
          modified_: false,
          finalized_: false,
          assigned_: {},
          parent_: t,
          base_: e,
          draft_: null,
          copy_: null,
          revoke_: null,
          isManual_: false
        };
        let a = i, s = Zp;
        n && (a = [
          i
        ], s = ll);
        const { revoke: r, proxy: o } = Proxy.revocable(a, s);
        return i.draft_ = o, i.revoke_ = r, o;
      }
      var Zp = {
        get(e, t) {
          if (t === re) return e;
          const n = Xe(e);
          if (!id(n, t)) return ZE(e, n, t);
          const i = n[t];
          return e.finalized_ || !ta(i) ? i : i === Df(e.base_, t) ? (Uf(e), e.copy_[t] = cl(i, e)) : i;
        },
        has(e, t) {
          return t in Xe(e);
        },
        ownKeys(e) {
          return Reflect.ownKeys(Xe(e));
        },
        set(e, t, n) {
          const i = $y(Xe(e), t);
          if (i == null ? void 0 : i.set) return i.set.call(e.draft_, n), true;
          if (!e.modified_) {
            const a = Df(Xe(e), t), s = a == null ? void 0 : a[re];
            if (s && s.base_ === n) return e.copy_[t] = n, e.assigned_[t] = false, true;
            if (kE(n, a) && (n !== void 0 || id(e.base_, t))) return true;
            Uf(e), Bi(e);
          }
          return e.copy_[t] === n && (n !== void 0 || t in e.copy_) || Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = true), true;
        },
        deleteProperty(e, t) {
          return Df(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = false, Uf(e), Bi(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], true;
        },
        getOwnPropertyDescriptor(e, t) {
          const n = Xe(e), i = Reflect.getOwnPropertyDescriptor(n, t);
          return i && {
            writable: true,
            configurable: e.type_ !== 1 || t !== "length",
            enumerable: i.enumerable,
            value: n[t]
          };
        },
        defineProperty() {
          jn(11);
        },
        getPrototypeOf(e) {
          return zr(e.base_);
        },
        setPrototypeOf() {
          jn(12);
        }
      }, ll = {};
      rl(Zp, (e, t) => {
        ll[e] = function() {
          return arguments[0] = arguments[0][0], t.apply(this, arguments);
        };
      });
      ll.deleteProperty = function(e, t) {
        return ll.set.call(this, e, t, void 0);
      };
      ll.set = function(e, t, n) {
        return Zp.set.call(this, e[0], t, n, e[0]);
      };
      function Df(e, t) {
        const n = e[re];
        return (n ? Xe(n) : e)[t];
      }
      function ZE(e, t, n) {
        var _a2;
        const i = $y(t, n);
        return i ? "value" in i ? i.value : (_a2 = i.get) == null ? void 0 : _a2.call(e.draft_) : void 0;
      }
      function $y(e, t) {
        if (!(t in e)) return;
        let n = zr(e);
        for (; n; ) {
          const i = Object.getOwnPropertyDescriptor(n, t);
          if (i) return i;
          n = zr(n);
        }
      }
      function Bi(e) {
        e.modified_ || (e.modified_ = true, e.parent_ && Bi(e.parent_));
      }
      function Uf(e) {
        e.copy_ || (e.copy_ = ad(e.base_, e.scope_.immer_.useStrictShallowCopy_));
      }
      var KE = class {
        constructor(e) {
          this.autoFreeze_ = true, this.useStrictShallowCopy_ = false, this.produce = (t, n, i) => {
            if (typeof t == "function" && typeof n != "function") {
              const s = n;
              n = t;
              const r = this;
              return function(l = s, ...c) {
                return r.produce(l, (f) => n.call(this, f, ...c));
              };
            }
            typeof n != "function" && jn(6), i !== void 0 && typeof i != "function" && jn(7);
            let a;
            if (ta(t)) {
              const s = k_(this), r = cl(t, void 0);
              let o = true;
              try {
                a = n(r), o = false;
              } finally {
                o ? rd(s) : od(s);
              }
              return V_(s, i), X_(a, s);
            } else if (!t || typeof t != "object") {
              if (a = n(t), a === void 0 && (a = t), a === Ky && (a = void 0), this.autoFreeze_ && jp(a, true), i) {
                const s = [], r = [];
                vs("Patches").generateReplacementPatches_(t, a, s, r), i(s, r);
              }
              return a;
            } else jn(1, t);
          }, this.produceWithPatches = (t, n) => {
            if (typeof t == "function") return (r, ...o) => this.produceWithPatches(r, (l) => t(l, ...o));
            let i, a;
            return [
              this.produce(t, n, (r, o) => {
                i = r, a = o;
              }),
              i,
              a
            ];
          }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
        }
        createDraft(e) {
          ta(e) || jn(8), Br(e) && (e = QE(e));
          const t = k_(this), n = cl(e, void 0);
          return n[re].isManual_ = true, od(t), n;
        }
        finishDraft(e, t) {
          const n = e && e[re];
          (!n || !n.isManual_) && jn(9);
          const { scope_: i } = n;
          return V_(i, t), X_(void 0, i);
        }
        setAutoFreeze(e) {
          this.autoFreeze_ = e;
        }
        setUseStrictShallowCopy(e) {
          this.useStrictShallowCopy_ = e;
        }
        applyPatches(e, t) {
          let n;
          for (n = t.length - 1; n >= 0; n--) {
            const a = t[n];
            if (a.path.length === 0 && a.op === "replace") {
              e = a.value;
              break;
            }
          }
          n > -1 && (t = t.slice(n + 1));
          const i = vs("Patches").applyPatches_;
          return Br(e) ? i(e, t) : this.produce(e, (a) => i(a, t));
        }
      };
      function cl(e, t) {
        const n = Fu(e) ? vs("MapSet").proxyMap_(e, t) : Iu(e) ? vs("MapSet").proxySet_(e, t) : jE(e, t);
        return (t ? t.scope_ : hu()).drafts_.push(n), n;
      }
      function QE(e) {
        return Br(e) || jn(10, e), tS(e);
      }
      function tS(e) {
        if (!ta(e) || Hu(e)) return e;
        const t = e[re];
        let n;
        if (t) {
          if (!t.modified_) return t.base_;
          t.finalized_ = true, n = ad(e, t.scope_.immer_.useStrictShallowCopy_);
        } else n = ad(e, true);
        return rl(n, (i, a) => {
          Jy(n, i, tS(a));
        }), t && (t.finalized_ = false), n;
      }
      function JE() {
        class e extends Map {
          constructor(l, c) {
            super(), this[re] = {
              type_: 2,
              parent_: c,
              scope_: c ? c.scope_ : hu(),
              modified_: false,
              finalized_: false,
              copy_: void 0,
              assigned_: void 0,
              base_: l,
              draft_: this,
              isManual_: false,
              revoked_: false
            };
          }
          get size() {
            return Xe(this[re]).size;
          }
          has(l) {
            return Xe(this[re]).has(l);
          }
          set(l, c) {
            const f = this[re];
            return r(f), (!Xe(f).has(l) || Xe(f).get(l) !== c) && (n(f), Bi(f), f.assigned_.set(l, true), f.copy_.set(l, c), f.assigned_.set(l, true)), this;
          }
          delete(l) {
            if (!this.has(l)) return false;
            const c = this[re];
            return r(c), n(c), Bi(c), c.base_.has(l) ? c.assigned_.set(l, false) : c.assigned_.delete(l), c.copy_.delete(l), true;
          }
          clear() {
            const l = this[re];
            r(l), Xe(l).size && (n(l), Bi(l), l.assigned_ = /* @__PURE__ */ new Map(), rl(l.base_, (c) => {
              l.assigned_.set(c, false);
            }), l.copy_.clear());
          }
          forEach(l, c) {
            const f = this[re];
            Xe(f).forEach((d, h, p) => {
              l.call(c, this.get(h), h, this);
            });
          }
          get(l) {
            const c = this[re];
            r(c);
            const f = Xe(c).get(l);
            if (c.finalized_ || !ta(f) || f !== c.base_.get(l)) return f;
            const d = cl(f, c);
            return n(c), c.copy_.set(l, d), d;
          }
          keys() {
            return Xe(this[re]).keys();
          }
          values() {
            const l = this.keys();
            return {
              [Symbol.iterator]: () => this.values(),
              next: () => {
                const c = l.next();
                return c.done ? c : {
                  done: false,
                  value: this.get(c.value)
                };
              }
            };
          }
          entries() {
            const l = this.keys();
            return {
              [Symbol.iterator]: () => this.entries(),
              next: () => {
                const c = l.next();
                if (c.done) return c;
                const f = this.get(c.value);
                return {
                  done: false,
                  value: [
                    c.value,
                    f
                  ]
                };
              }
            };
          }
          [Symbol.iterator]() {
            return this.entries();
          }
        }
        function t(o, l) {
          return new e(o, l);
        }
        function n(o) {
          o.copy_ || (o.assigned_ = /* @__PURE__ */ new Map(), o.copy_ = new Map(o.base_));
        }
        class i extends Set {
          constructor(l, c) {
            super(), this[re] = {
              type_: 3,
              parent_: c,
              scope_: c ? c.scope_ : hu(),
              modified_: false,
              finalized_: false,
              copy_: void 0,
              base_: l,
              draft_: this,
              drafts_: /* @__PURE__ */ new Map(),
              revoked_: false,
              isManual_: false
            };
          }
          get size() {
            return Xe(this[re]).size;
          }
          has(l) {
            const c = this[re];
            return r(c), c.copy_ ? !!(c.copy_.has(l) || c.drafts_.has(l) && c.copy_.has(c.drafts_.get(l))) : c.base_.has(l);
          }
          add(l) {
            const c = this[re];
            return r(c), this.has(l) || (s(c), Bi(c), c.copy_.add(l)), this;
          }
          delete(l) {
            if (!this.has(l)) return false;
            const c = this[re];
            return r(c), s(c), Bi(c), c.copy_.delete(l) || (c.drafts_.has(l) ? c.copy_.delete(c.drafts_.get(l)) : false);
          }
          clear() {
            const l = this[re];
            r(l), Xe(l).size && (s(l), Bi(l), l.copy_.clear());
          }
          values() {
            const l = this[re];
            return r(l), s(l), l.copy_.values();
          }
          entries() {
            const l = this[re];
            return r(l), s(l), l.copy_.entries();
          }
          keys() {
            return this.values();
          }
          [Symbol.iterator]() {
            return this.values();
          }
          forEach(l, c) {
            const f = this.values();
            let d = f.next();
            for (; !d.done; ) l.call(c, d.value, d.value, this), d = f.next();
          }
        }
        function a(o, l) {
          return new i(o, l);
        }
        function s(o) {
          o.copy_ || (o.copy_ = /* @__PURE__ */ new Set(), o.base_.forEach((l) => {
            if (ta(l)) {
              const c = cl(l, o);
              o.drafts_.set(l, c), o.copy_.add(c);
            } else o.copy_.add(l);
          }));
        }
        function r(o) {
          o.revoked_ && jn(3, JSON.stringify(Xe(o)));
        }
        WE("MapSet", {
          proxyMap_: t,
          proxySet_: a
        });
      }
      var Ln = new KE(), Fn = Ln.produce;
      Ln.produceWithPatches.bind(Ln);
      Ln.setAutoFreeze.bind(Ln);
      Ln.setUseStrictShallowCopy.bind(Ln);
      Ln.applyPatches.bind(Ln);
      Ln.createDraft.bind(Ln);
      Ln.finishDraft.bind(Ln);
      const $E = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3c!--%20Created%20with%20Inkscape%20(http://www.inkscape.org/)%20--%3e%3csvg%20width='48'%20height='48'%20viewBox='0%200%2012.7%2012.7'%20version='1.1'%20id='svg5'%20inkscape:version='1.2.1%20(9c6d41e410,%202022-07-14)'%20sodipodi:docname='stephen.svg'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3csodipodi:namedview%20id='namedview7'%20pagecolor='%23505050'%20bordercolor='%23eeeeee'%20borderopacity='1'%20inkscape:showpageshadow='0'%20inkscape:pageopacity='0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23505050'%20inkscape:document-units='mm'%20showgrid='true'%20inkscape:zoom='8.4359982'%20inkscape:cx='20.388814'%20inkscape:cy='37.22144'%20inkscape:window-width='1920'%20inkscape:window-height='1017'%20inkscape:window-x='1912'%20inkscape:window-y='-8'%20inkscape:window-maximized='1'%20inkscape:current-layer='layer1'%3e%3cinkscape:grid%20type='xygrid'%20id='grid4183'%20/%3e%3c/sodipodi:namedview%3e%3cdefs%20id='defs2'%20/%3e%3cg%20inkscape:label='Layer%201'%20inkscape:groupmode='layer'%20id='layer1'%3e%3ccircle%20style='fill:%23794700;stroke:%23000000;stroke-width:0.264999;fill-opacity:1;stroke-opacity:0'%20id='path5637'%20cx='6.3499999'%20cy='6.3499999'%20r='5.5562501'%20/%3e%3c/g%3e%3c/svg%3e", tb = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3c!--%20Created%20with%20Inkscape%20(http://www.inkscape.org/)%20--%3e%3csvg%20width='48'%20height='48'%20viewBox='0%200%2012.7%2012.7'%20version='1.1'%20id='svg5'%20inkscape:version='1.2.1%20(9c6d41e410,%202022-07-14)'%20sodipodi:docname='stephen_goal.svg'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3csodipodi:namedview%20id='namedview7'%20pagecolor='%23505050'%20bordercolor='%23eeeeee'%20borderopacity='1'%20inkscape:showpageshadow='0'%20inkscape:pageopacity='0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23505050'%20inkscape:document-units='mm'%20showgrid='true'%20inkscape:zoom='8.4359982'%20inkscape:cx='16.239928'%20inkscape:cy='37.33998'%20inkscape:window-width='1920'%20inkscape:window-height='1017'%20inkscape:window-x='-8'%20inkscape:window-y='-8'%20inkscape:window-maximized='1'%20inkscape:current-layer='layer1'%3e%3cinkscape:grid%20type='xygrid'%20id='grid4183'%20/%3e%3c/sodipodi:namedview%3e%3cdefs%20id='defs2'%20/%3e%3cg%20inkscape:label='Layer%201'%20inkscape:groupmode='layer'%20id='layer1'%3e%3cellipse%20style='fill:%239bffa9;fill-opacity:1;stroke:%23000000;stroke-width:0.282173;stroke-opacity:0'%20id='path5637'%20cx='6.3499999'%20cy='6.2862678'%20rx='5.9482975'%20ry='5.8845654'%20/%3e%3c/g%3e%3c/svg%3e", eb = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3c!--%20Created%20with%20Inkscape%20(http://www.inkscape.org/)%20--%3e%3csvg%20width='48'%20height='48'%20viewBox='0%200%2012.7%2012.7'%20version='1.1'%20id='svg11314'%20inkscape:version='1.2.1%20(9c6d41e410,%202022-07-14)'%20sodipodi:docname='fork.svg'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3csodipodi:namedview%20id='namedview11316'%20pagecolor='%23505050'%20bordercolor='%23eeeeee'%20borderopacity='1'%20inkscape:showpageshadow='0'%20inkscape:pageopacity='0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23505050'%20inkscape:document-units='mm'%20showgrid='true'%20inkscape:zoom='11.930303'%20inkscape:cx='18.608077'%20inkscape:cy='26.906274'%20inkscape:window-width='1920'%20inkscape:window-height='1017'%20inkscape:window-x='1912'%20inkscape:window-y='-8'%20inkscape:window-maximized='1'%20inkscape:current-layer='layer1'%3e%3cinkscape:grid%20type='xygrid'%20id='grid12524'%20dotted='true'%20originx='0'%20originy='0'%20/%3e%3c/sodipodi:namedview%3e%3cdefs%20id='defs11311'%20/%3e%3cg%20inkscape:label='Layer%201'%20inkscape:groupmode='layer'%20id='layer1'%3e%3cpath%20style='fill:%231f1d1a;fill-opacity:1;stroke:%23000000;stroke-width:0.264999;stroke-opacity:0'%20d='M%206.0854166,0.79374999%20H%206.6145832%20L%207.14375,11.1125%20l%203.175,-0.264583%200.264583,-8.7312503%20H%2011.1125%20L%2011.641667,11.90625%207.14375,12.435417%20H%205.55625%20L%201.0583333,11.90625%201.5875,2.1166667%20H%202.1166667%20L%202.38125,10.847917%205.55625,11.1125%20Z'%20id='path13669'%20sodipodi:nodetypes='ccccccccccccccc'%20/%3e%3c/g%3e%3c/svg%3e", nb = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'%20standalone='no'?%3e%3c!--%20Created%20with%20Inkscape%20(http://www.inkscape.org/)%20--%3e%3csvg%20width='48'%20height='48'%20viewBox='0%200%2012.7%2012.7'%20version='1.1'%20id='svg11314'%20inkscape:version='1.2.1%20(9c6d41e410,%202022-07-14)'%20sodipodi:docname='fork_goal.svg'%20xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'%20xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:svg='http://www.w3.org/2000/svg'%3e%3csodipodi:namedview%20id='namedview11316'%20pagecolor='%23505050'%20bordercolor='%23eeeeee'%20borderopacity='1'%20inkscape:showpageshadow='0'%20inkscape:pageopacity='0'%20inkscape:pagecheckerboard='0'%20inkscape:deskcolor='%23505050'%20inkscape:document-units='mm'%20showgrid='true'%20inkscape:zoom='11.930303'%20inkscape:cx='15.674371'%20inkscape:cy='26.990094'%20inkscape:window-width='1920'%20inkscape:window-height='1017'%20inkscape:window-x='-8'%20inkscape:window-y='-8'%20inkscape:window-maximized='1'%20inkscape:current-layer='layer1'%3e%3cinkscape:grid%20type='xygrid'%20id='grid12524'%20dotted='true'%20originx='0'%20originy='0'%20/%3e%3c/sodipodi:namedview%3e%3cdefs%20id='defs11311'%20/%3e%3cg%20inkscape:label='Layer%201'%20inkscape:groupmode='layer'%20id='layer1'%3e%3cpath%20style='fill:%239bffa9;fill-opacity:1;stroke:%23000000;stroke-width:0.28362;stroke-opacity:0'%20d='m%206.0530995,0.40655545%20h%200.593637%20L%207.2403736,10.9427%2010.802196,10.672543%2011.099014,1.7573433%20h%200.593637%20l%200.593638,9.9958297%20-5.0459154,0.540316%20H%205.4594626%20L%200.41354804,11.753173%201.0071851,1.7573433%20h%200.593637%20l%200.2968185,8.9151997%203.561822,0.270157%20z'%20id='path13669'%20sodipodi:nodetypes='ccccccccccccccc'%20/%3e%3c/g%3e%3c/svg%3e", eS = (e) => {
        var _a2, _b2, _c2, _d2, _e, _f2, _g2, _h2;
        const [t, n] = Ot.useState(1), i = new Set(e.description.ground.map((p) => JSON.stringify(p))), a = new Set(e.description.grills.map((p) => JSON.stringify(p))), s = [];
        for (let p = 0; p < e.lenZ; p++) s.push(vt.jsx("button", {
          className: `layer-control ${t === p ? "active" : null}`,
          onClick: () => {
            n(p);
          },
          children: p === 0 ? "W" : p
        }, p));
        const r = {};
        ((_a2 = e.state) == null ? void 0 : _a2.player_dir) && Jt.compare((_b2 = e.state) == null ? void 0 : _b2.player_dir, [
          1,
          0,
          0
        ]) && (r.transform = "rotate(0.25turn)"), ((_c2 = e.state) == null ? void 0 : _c2.player_dir) && Jt.compare((_d2 = e.state) == null ? void 0 : _d2.player_dir, [
          0,
          1,
          0
        ]) && (r.transform = "rotate(0.5turn)"), ((_e = e.state) == null ? void 0 : _e.player_dir) && Jt.compare((_f2 = e.state) == null ? void 0 : _f2.player_dir, [
          -1,
          0,
          0
        ]) && (r.transform = "rotate(0.75turn)");
        const o = vt.jsx("img", {
          src: $E,
          className: "icon"
        }), l = vt.jsx("img", {
          src: eb,
          className: "icon",
          style: r
        }), c = vt.jsx("img", {
          src: tb,
          className: "icon"
        }), f = {};
        Jt.compare(e.description.start_dir, [
          1,
          0,
          0
        ]) && (f.transform = "rotate(0.25turn)"), Jt.compare(e.description.start_dir, [
          0,
          1,
          0
        ]) && (f.transform = "rotate(0.5turn)"), Jt.compare(e.description.start_dir, [
          -1,
          0,
          0
        ]) && (f.transform = "rotate(0.75turn)");
        const d = vt.jsx("img", {
          src: nb,
          className: "icon",
          style: f
        }), h = [];
        for (let p = 0; p < e.lenY; p++) {
          const y = [];
          for (let S = 0; S < e.lenX; S++) {
            let m;
            i.has(JSON.stringify([
              S,
              p,
              t
            ])) || a.has(JSON.stringify([
              S,
              p,
              t
            ])) ? m = "dirt" : i.has(JSON.stringify([
              S,
              p,
              t - 1
            ])) ? m = "grass" : a.has(JSON.stringify([
              S,
              p,
              t - 1
            ])) ? m = "grill" : t > 1 ? m = "air" : m = "water", y.push(vt.jsxs("div", {
              className: `tile ${m} `,
              onDragOver: (u) => {
                u.preventDefault(), u.dataTransfer.dropEffect = "copy";
              },
              onDrop: (u) => {
                e.onDrop && e.onDrop(u, S, p, t);
              },
              onClick: () => {
                e.onClick && e.onClick(S, p, t);
              },
              children: [
                e.state !== void 0 ? (_g2 = nd.getSausageAt(e.state, [
                  S,
                  p,
                  t
                ])) == null ? void 0 : _g2.orientation[0] : (_h2 = sl.getSausageAt(e.description, [
                  S,
                  p,
                  t
                ])) == null ? void 0 : _h2.orientation[0],
                Jt.compare(e.description.start_pos, [
                  S,
                  p,
                  t
                ]) && c,
                Jt.compare(Jt.add(e.description.start_pos, e.description.start_dir), [
                  S,
                  p,
                  t
                ]) && d,
                e.state && Jt.compare(e.state.player_pos, [
                  S,
                  p,
                  t
                ]) && o,
                e.state && Jt.compare(Jt.add(e.state.player_pos, e.state.player_dir), [
                  S,
                  p,
                  t
                ]) && l
              ]
            }, S));
          }
          h.push(y);
        }
        return vt.jsxs(vt.Fragment, {
          children: [
            vt.jsx("div", {
              children: s
            }),
            vt.jsx("div", {
              className: "tilegrid",
              children: h.map((p, y) => vt.jsx("div", {
                className: "row",
                children: p.map((S) => S)
              }, y))
            })
          ]
        });
      }, ib = "/StephensSausageRollSolver/assets/stephens_sausage_roll_solver_bg-BXR93t9k.wasm", ab = async (e = {}, t) => {
        let n;
        if (t.startsWith("data:")) {
          const i = t.replace(/^data:.*?base64,/, "");
          let a;
          if (typeof Buffer == "function" && typeof Buffer.from == "function") a = Buffer.from(i, "base64");
          else if (typeof atob == "function") {
            const s = atob(i);
            a = new Uint8Array(s.length);
            for (let r = 0; r < s.length; r++) a[r] = s.charCodeAt(r);
          } else throw new Error("Cannot decode base64-encoded data URL");
          n = await WebAssembly.instantiate(a, e);
        } else {
          const i = await fetch(t), a = i.headers.get("Content-Type") || "";
          if ("instantiateStreaming" in WebAssembly && a.startsWith("application/wasm")) n = await WebAssembly.instantiateStreaming(i, e);
          else {
            const s = await i.arrayBuffer();
            n = await WebAssembly.instantiate(s, e);
          }
        }
        return n.instance.exports;
      };
      let Ze;
      function sb(e) {
        Ze = e;
      }
      function rb(e) {
        const t = Ze.__externref_table_alloc();
        return Ze.__wbindgen_export_2.set(t, e), t;
      }
      function Kp(e, t) {
        try {
          return e.apply(this, t);
        } catch (n) {
          const i = rb(n);
          Ze.__wbindgen_exn_store(i);
        }
      }
      const ob = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
      let nS = new ob("utf-8", {
        ignoreBOM: true,
        fatal: true
      });
      nS.decode();
      let Wl = null;
      function Dc() {
        return (Wl === null || Wl.byteLength === 0) && (Wl = new Uint8Array(Ze.memory.buffer)), Wl;
      }
      function Tl(e, t) {
        return e = e >>> 0, nS.decode(Dc().subarray(e, e + t));
      }
      let ul = 0;
      const lb = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
      let Uc = new lb("utf-8");
      const cb = typeof Uc.encodeInto == "function" ? function(e, t) {
        return Uc.encodeInto(e, t);
      } : function(e, t) {
        const n = Uc.encode(e);
        return t.set(n), {
          read: e.length,
          written: n.length
        };
      };
      function Qp(e, t, n) {
        if (n === void 0) {
          const o = Uc.encode(e), l = t(o.length, 1) >>> 0;
          return Dc().subarray(l, l + o.length).set(o), ul = o.length, l;
        }
        let i = e.length, a = t(i, 1) >>> 0;
        const s = Dc();
        let r = 0;
        for (; r < i; r++) {
          const o = e.charCodeAt(r);
          if (o > 127) break;
          s[a + r] = o;
        }
        if (r !== i) {
          r !== 0 && (e = e.slice(r)), a = n(a, i, i = r + e.length * 3, 1) >>> 0;
          const o = Dc().subarray(a + r, a + i), l = cb(e, o);
          r += l.written, a = n(a, i, r, 1) >>> 0;
        }
        return ul = r, a;
      }
      let Ns = null;
      function Fa() {
        return (Ns === null || Ns.buffer.detached === true || Ns.buffer.detached === void 0 && Ns.buffer !== Ze.memory.buffer) && (Ns = new DataView(Ze.memory.buffer)), Ns;
      }
      function ld(e) {
        const t = typeof e;
        if (t == "number" || t == "boolean" || e == null) return `${e}`;
        if (t == "string") return `"${e}"`;
        if (t == "symbol") {
          const a = e.description;
          return a == null ? "Symbol" : `Symbol(${a})`;
        }
        if (t == "function") {
          const a = e.name;
          return typeof a == "string" && a.length > 0 ? `Function(${a})` : "Function";
        }
        if (Array.isArray(e)) {
          const a = e.length;
          let s = "[";
          a > 0 && (s += ld(e[0]));
          for (let r = 1; r < a; r++) s += ", " + ld(e[r]);
          return s += "]", s;
        }
        const n = /\[object ([^\]]+)\]/.exec(toString.call(e));
        let i;
        if (n && n.length > 1) i = n[1];
        else return toString.call(e);
        if (i == "Object") try {
          return "Object(" + JSON.stringify(e) + ")";
        } catch {
          return "Object";
        }
        return e instanceof Error ? `${e.name}: ${e.message}
${e.stack}` : i;
      }
      function cd(e) {
        return e == null;
      }
      function Y_(e) {
        let t, n;
        try {
          const i = Ze.solve(e);
          return t = i[0], n = i[1], Tl(i[0], i[1]);
        } finally {
          Ze.__wbindgen_free(t, n, 1);
        }
      }
      function ub(e) {
        return e.buffer;
      }
      function fb() {
        return Kp(function(e, t) {
          return e.call(t);
        }, arguments);
      }
      function hb(e) {
        return e.done;
      }
      function db(e) {
        return Object.entries(e);
      }
      function pb(e, t) {
        let n, i;
        try {
          n = e, i = t, console.error(Tl(e, t));
        } finally {
          Ze.__wbindgen_free(n, i, 1);
        }
      }
      function mb(e, t) {
        return e[t >>> 0];
      }
      function _b() {
        return Kp(function(e, t) {
          return Reflect.get(e, t);
        }, arguments);
      }
      function gb(e, t) {
        return e[t];
      }
      function vb(e) {
        let t;
        try {
          t = e instanceof ArrayBuffer;
        } catch {
          t = false;
        }
        return t;
      }
      function yb(e) {
        let t;
        try {
          t = e instanceof Uint8Array;
        } catch {
          t = false;
        }
        return t;
      }
      function Sb(e) {
        return Array.isArray(e);
      }
      function xb(e) {
        return Number.isSafeInteger(e);
      }
      function Mb() {
        return Symbol.iterator;
      }
      function Eb(e) {
        return e.length;
      }
      function bb(e) {
        return e.length;
      }
      function Tb(e, t) {
        console.log(e, t);
      }
      function Ab(e) {
        return new Uint8Array(e);
      }
      function Rb() {
        return new Error();
      }
      function wb() {
        return Kp(function(e) {
          return e.next();
        }, arguments);
      }
      function Cb(e) {
        return e.next;
      }
      function Db(e, t, n) {
        e.set(t, n >>> 0);
      }
      function Ub(e, t) {
        const n = t.stack, i = Qp(n, Ze.__wbindgen_malloc, Ze.__wbindgen_realloc), a = ul;
        Fa().setInt32(e + 4 * 1, a, true), Fa().setInt32(e + 4 * 0, i, true);
      }
      function Lb(e) {
        return e.value;
      }
      function Nb(e) {
        return +e;
      }
      function Ob(e) {
        const t = e;
        return typeof t == "boolean" ? t ? 1 : 0 : 2;
      }
      function Pb(e, t) {
        const n = ld(t), i = Qp(n, Ze.__wbindgen_malloc, Ze.__wbindgen_realloc), a = ul;
        Fa().setInt32(e + 4 * 1, a, true), Fa().setInt32(e + 4 * 0, i, true);
      }
      function zb(e, t) {
        return new Error(Tl(e, t));
      }
      function Bb(e, t) {
        return e in t;
      }
      function Fb() {
        const e = Ze.__wbindgen_export_2, t = e.grow(4);
        e.set(0, void 0), e.set(t + 0, void 0), e.set(t + 1, null), e.set(t + 2, true), e.set(t + 3, false);
      }
      function Ib(e) {
        return typeof e == "function";
      }
      function Hb(e) {
        const t = e;
        return typeof t == "object" && t !== null;
      }
      function Gb(e) {
        return typeof e == "string";
      }
      function Vb(e) {
        return e === void 0;
      }
      function kb(e, t) {
        return e == t;
      }
      function Xb() {
        return Ze.memory;
      }
      function Wb(e, t) {
        const n = t, i = typeof n == "number" ? n : void 0;
        Fa().setFloat64(e + 8 * 1, cd(i) ? 0 : i, true), Fa().setInt32(e + 4 * 0, !cd(i), true);
      }
      function Yb(e, t) {
        const n = t, i = typeof n == "string" ? n : void 0;
        var a = cd(i) ? 0 : Qp(i, Ze.__wbindgen_malloc, Ze.__wbindgen_realloc), s = ul;
        Fa().setInt32(e + 4 * 1, s, true), Fa().setInt32(e + 4 * 0, a, true);
      }
      function qb(e, t) {
        return Tl(e, t);
      }
      function jb(e, t) {
        throw new Error(Tl(e, t));
      }
      URL = globalThis.URL;
      const aa = await ab({
        "./stephens_sausage_roll_solver_bg.js": {
          __wbindgen_string_new: qb,
          __wbindgen_string_get: Yb,
          __wbindgen_is_string: Gb,
          __wbindgen_is_object: Hb,
          __wbindgen_is_undefined: Vb,
          __wbindgen_in: Bb,
          __wbindgen_error_new: zb,
          __wbg_log_5f82480ac7a101b6: Tb,
          __wbindgen_jsval_loose_eq: kb,
          __wbindgen_boolean_get: Ob,
          __wbindgen_number_get: Wb,
          __wbindgen_as_number: Nb,
          __wbg_getwithrefkey_1dc361bd10053bfe: gb,
          __wbg_new_8a6f238a6ece86ea: Rb,
          __wbg_stack_0ed75d68575b0f3c: Ub,
          __wbg_error_7534b8e9a36f1ab4: pb,
          __wbg_get_9aa3dff3f0266054: mb,
          __wbg_length_d65cf0786bfc5739: bb,
          __wbindgen_is_function: Ib,
          __wbg_next_137428deb98342b0: Cb,
          __wbg_next_01dd9234a5bf6d05: wb,
          __wbg_done_f22c1561fa919baa: hb,
          __wbg_value_4c32fd138a88eee2: Lb,
          __wbg_iterator_23604bb983791576: Mb,
          __wbg_get_bbccf8970793c087: _b,
          __wbg_call_b0d8e36992d9900d: fb,
          __wbg_isArray_1ba11a930108ec51: Sb,
          __wbg_instanceof_ArrayBuffer_670ddde44cdb2602: vb,
          __wbg_isSafeInteger_12f5549b2fca23f4: xb,
          __wbg_entries_4f2bb9b0d701c0f6: db,
          __wbg_buffer_61b7ce01341d7f88: ub,
          __wbg_new_3ff5b33b1ce712df: Ab,
          __wbg_set_23d69db4e5c66a6e: Db,
          __wbg_length_65d1cd11729ced11: Eb,
          __wbg_instanceof_Uint8Array_28af5bc19d6acad8: yb,
          __wbindgen_debug_string: Pb,
          __wbindgen_throw: jb,
          __wbindgen_memory: Xb,
          __wbindgen_init_externref_table: Fb
        }
      }, ib), Zb = aa.memory, Kb = aa.solve, Qb = aa.__wbindgen_exn_store, Jb = aa.__externref_table_alloc, $b = aa.__wbindgen_export_2, tT = aa.__wbindgen_free, eT = aa.__wbindgen_malloc, nT = aa.__wbindgen_realloc, iS = aa.__wbindgen_start, iT = Object.freeze(Object.defineProperty({
        __proto__: null,
        __externref_table_alloc: Jb,
        __wbindgen_exn_store: Qb,
        __wbindgen_export_2: $b,
        __wbindgen_free: tT,
        __wbindgen_malloc: eT,
        __wbindgen_realloc: nT,
        __wbindgen_start: iS,
        memory: Zb,
        solve: Kb
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      sb(iT);
      iS();
      function aT(e) {
        return vt.jsxs("form", {
          children: [
            vt.jsxs("label", {
              children: [
                "Width",
                vt.jsx("input", {
                  type: "number",
                  onChange: (t) => {
                    e.setDimensions([
                      t.target.valueAsNumber,
                      e.dimensions[1],
                      e.dimensions[2]
                    ]);
                  },
                  defaultValue: e.dimensions[0]
                })
              ]
            }),
            vt.jsxs("label", {
              children: [
                "Height",
                vt.jsx("input", {
                  type: "number",
                  onChange: (t) => {
                    e.setDimensions([
                      e.dimensions[0],
                      t.target.valueAsNumber,
                      e.dimensions[2]
                    ]);
                  },
                  defaultValue: e.dimensions[1]
                })
              ]
            }),
            vt.jsxs("label", {
              children: [
                "Layers",
                vt.jsx("input", {
                  type: "number",
                  onChange: (t) => {
                    e.setDimensions([
                      e.dimensions[0],
                      e.dimensions[1],
                      t.target.valueAsNumber
                    ]);
                  },
                  defaultValue: e.dimensions[2]
                })
              ]
            })
          ]
        });
      }
      function sT(e) {
        return vt.jsxs("div", {
          className: "controls",
          children: [
            vt.jsx("button", {
              className: e.tool === "remove" ? "active" : "",
              onClick: () => e.setTool("remove"),
              children: "Remove"
            }),
            vt.jsx("button", {
              className: e.tool === "dirt" ? "active" : "",
              onClick: () => e.setTool("dirt"),
              children: "Dirt"
            }),
            vt.jsx("button", {
              className: e.tool === "grass" ? "active" : "",
              onClick: () => e.setTool("grass"),
              children: "Grass"
            }),
            vt.jsx("button", {
              className: e.tool === "grill" ? "active" : "",
              onClick: () => e.setTool("grill"),
              children: "Grill"
            }),
            vt.jsx("button", {
              draggable: "true",
              onDragStart: (t) => {
                t.dataTransfer.setData("internal", "horizontal");
              },
              children: "Sausage - H"
            }),
            vt.jsx("button", {
              draggable: "true",
              onDragStart: (t) => {
                t.dataTransfer.setData("internal", "vertical");
              },
              children: "Sausage - V"
            }),
            vt.jsx("button", {
              draggable: "true",
              onDragStart: (t) => {
                t.dataTransfer.setData("internal", "player");
              },
              children: "Player"
            }),
            vt.jsxs("div", {
              className: "player-direction-controls",
              children: [
                vt.jsx("button", {
                  className: Jt.compare(e.playerDir, [
                    0,
                    -1,
                    0
                  ]) ? "active" : "",
                  onClick: () => {
                    e.setPlayerDir([
                      0,
                      -1,
                      0
                    ]);
                  },
                  children: "Up"
                }),
                vt.jsx("button", {
                  className: Jt.compare(e.playerDir, [
                    -1,
                    0,
                    0
                  ]) ? "active" : "",
                  onClick: () => {
                    e.setPlayerDir([
                      -1,
                      0,
                      0
                    ]);
                  },
                  children: "Left"
                }),
                vt.jsx("button", {
                  className: Jt.compare(e.playerDir, [
                    1,
                    0,
                    0
                  ]) ? "active" : "",
                  onClick: () => {
                    e.setPlayerDir([
                      1,
                      0,
                      0
                    ]);
                  },
                  children: "right"
                }),
                vt.jsx("button", {
                  className: Jt.compare(e.playerDir, [
                    0,
                    1,
                    0
                  ]) ? "active" : "",
                  onClick: () => {
                    e.setPlayerDir([
                      0,
                      1,
                      0
                    ]);
                  },
                  children: "down"
                })
              ]
            })
          ]
        });
      }
      function rT(e) {
        const [t, n] = Ot.useState([
          10,
          10,
          3
        ]), [i, a] = Ot.useState(/* @__PURE__ */ new Set()), [s, r] = Ot.useState(/* @__PURE__ */ new Set()), [o, l] = Ot.useState("remove"), [c, f] = Ot.useState([]), [d, h] = Ot.useState([
          0,
          -1,
          0
        ]), [p, y] = Ot.useState(null), S = (() => {
          let _ = d, g = [
            ...i
          ].map((T) => JSON.parse(T)), v = [
            ...s
          ].map((T) => JSON.parse(T));
          return {
            start_pos: p ?? [
              -1,
              -1,
              -1
            ],
            start_dir: _,
            ground: g,
            grills: v,
            sausages: c
          };
        })(), m = (_) => {
          Jt.compare(_.start_dir, [
            1,
            0,
            0
          ]) && h([
            1,
            0,
            0
          ]), Jt.compare(_.start_dir, [
            -1,
            0,
            0
          ]) && h([
            -1,
            0,
            0
          ]), Jt.compare(_.start_dir, [
            0,
            1,
            0
          ]) && h([
            0,
            1,
            0
          ]), Jt.compare(_.start_dir, [
            0,
            -1,
            0
          ]) && h([
            0,
            -1,
            0
          ]), y(_.start_pos), f(_.sausages), a(new Set(_.ground.map((g) => JSON.stringify(g)))), r(new Set(_.grills.map((g) => JSON.stringify(g))));
        }, u = (_, g, v) => {
          let T = sl.getSausageAt(S, [
            _,
            g,
            v
          ]);
          T !== null && f(Fn(c, (R) => (R.filter((w) => JSON.stringify(w.pos) !== JSON.stringify(T.pos)), R))), JSON.stringify(p) === JSON.stringify([
            _,
            g,
            v
          ]) && y(null), i.has(JSON.stringify([
            _,
            g,
            v
          ])) && a(Fn(i, (R) => {
            R.delete(JSON.stringify([
              _,
              g,
              v
            ]));
          })), s.has(JSON.stringify([
            _,
            g,
            v
          ])) && r(Fn(s, (R) => {
            R.delete(JSON.stringify([
              _,
              g,
              v
            ]));
          }));
        };
        return Ot.useEffect(() => {
          var _a2;
          const _ = JSON.parse('{"start_pos":[2,2,1],"start_dir":[1,0,0],"ground":[[2,2,0],[3,2,0],[4,2,0],[4,1,0]],"grills":[[5,1,0],[5,2,0],[6,2,0],[6,1,0]],"sausages":[{"pos":[4,1,1],"cooked":[[0,0],[0,0]],"orientation":"Vertical"}]}');
          m(_), (_a2 = e.setSolution) == null ? void 0 : _a2.call(e, JSON.parse(Y_(_)));
        }, []), vt.jsxs(vt.Fragment, {
          children: [
            vt.jsx(aT, {
              dimensions: t,
              setDimensions: n
            }),
            vt.jsx("form", {
              action: (_) => {
                var _a2;
                const g = JSON.parse(((_a2 = _.get("data")) == null ? void 0 : _a2.toString()) ?? "{}");
                m(g);
              },
              children: vt.jsxs("label", {
                children: [
                  "Paste here to load a description ",
                  vt.jsx("input", {
                    type: "text",
                    name: "data"
                  })
                ]
              })
            }),
            vt.jsx(sT, {
              tool: o,
              setTool: l,
              playerDir: d,
              setPlayerDir: h
            }),
            vt.jsx(eS, {
              description: S,
              lenX: t[0],
              lenY: t[1],
              lenZ: t[2],
              onDrop: (_, g, v, T) => {
                let R = _.dataTransfer.getData("internal");
                if (R.length > 0) switch (R) {
                  case "horizontal":
                    u(g, v, T), u(g + 1, v, T), f(Fn(c, (w) => {
                      w.push({
                        pos: [
                          g,
                          v,
                          T
                        ],
                        cooked: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        orientation: "Horizontal"
                      });
                    }));
                    break;
                  case "vertical":
                    u(g, v, T), u(g, v + 1, T), f(Fn(c, (w) => {
                      w.push({
                        pos: [
                          g,
                          v,
                          T
                        ],
                        cooked: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        orientation: "Vertical"
                      });
                    }));
                    break;
                  case "player":
                    u(g, v, T), y([
                      g,
                      v,
                      T
                    ]);
                    break;
                }
              },
              onClick: (_, g, v) => {
                if (o === "remove") {
                  let T = sl.getSausageAt(S, [
                    _,
                    g,
                    v
                  ]);
                  T !== null ? f(Fn(c, (R) => R.filter((w) => !Jt.compare(w.pos, T.pos)))) : JSON.stringify(p) === JSON.stringify([
                    _,
                    g,
                    v
                  ]) ? y(null) : i.has(JSON.stringify([
                    _,
                    g,
                    v
                  ])) ? a(Fn(i, (R) => {
                    R.delete(JSON.stringify([
                      _,
                      g,
                      v
                    ]));
                  })) : i.has(JSON.stringify([
                    _,
                    g,
                    v - 1
                  ])) ? a(Fn(i, (R) => {
                    R.delete(JSON.stringify([
                      _,
                      g,
                      v - 1
                    ]));
                  })) : s.has(JSON.stringify([
                    _,
                    g,
                    v - 1
                  ])) && r(Fn(s, (R) => {
                    R.delete(JSON.stringify([
                      _,
                      g,
                      v - 1
                    ]));
                  }));
                } else o === "dirt" ? (u(_, g, v), a(Fn(i, (T) => {
                  T.add(JSON.stringify([
                    _,
                    g,
                    v
                  ]));
                }))) : o === "grass" ? v !== 0 && (u(_, g, v - 1), a(Fn(i, (T) => {
                  T.add(JSON.stringify([
                    _,
                    g,
                    v - 1
                  ]));
                }))) : o === "grill" && v !== 0 && (u(_, g, v - 1), r(Fn(s, (T) => {
                  T.add(JSON.stringify([
                    _,
                    g,
                    v - 1
                  ]));
                })));
              }
            }),
            vt.jsx("p", {
              children: "LevelDescription"
            }),
            vt.jsx("code", {
              children: JSON.stringify(S)
            }),
            vt.jsx("br", {}),
            vt.jsx("button", {
              onClick: () => {
                ((g) => g.start_pos !== null)(S) && e.setSolution(JSON.parse(Y_(S)));
              },
              children: "Show Graph"
            })
          ]
        });
      }
      const Jp = "172", Er = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      }, dr = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      }, oT = 0, q_ = 1, lT = 2, aS = 1, cT = 2, zi = 3, Ia = 0, dn = 1, Gi = 2, La = 0, br = 1, j_ = 2, Z_ = 3, K_ = 4, uT = 5, es = 100, fT = 101, hT = 102, dT = 103, pT = 104, mT = 200, _T = 201, gT = 202, vT = 203, ud = 204, fd = 205, yT = 206, ST = 207, xT = 208, MT = 209, ET = 210, bT = 211, TT = 212, AT = 213, RT = 214, hd = 0, dd = 1, pd = 2, Fr = 3, md = 4, _d = 5, gd = 6, vd = 7, sS = 0, wT = 1, CT = 2, Na = 0, DT = 1, UT = 2, LT = 3, NT = 4, OT = 5, PT = 6, zT = 7, rS = 300, Ir = 301, Hr = 302, yd = 303, Sd = 304, Gu = 306, xd = 1e3, ss = 1001, Md = 1002, Dn = 1003, BT = 1004, Yl = 1005, _i = 1006, Lf = 1007, rs = 1008, ea = 1009, oS = 1010, lS = 1011, fl = 1012, $p = 1013, ys = 1014, gi = 1015, Al = 1016, tm = 1017, em = 1018, Gr = 1020, cS = 35902, uS = 1021, fS = 1022, ci = 1023, hS = 1024, dS = 1025, Tr = 1026, Vr = 1027, nm = 1028, im = 1029, pS = 1030, am = 1031, sm = 1033, Lc = 33776, Nc = 33777, Oc = 33778, Pc = 33779, Ed = 35840, bd = 35841, Td = 35842, Ad = 35843, Rd = 36196, wd = 37492, Cd = 37496, Dd = 37808, Ud = 37809, Ld = 37810, Nd = 37811, Od = 37812, Pd = 37813, zd = 37814, Bd = 37815, Fd = 37816, Id = 37817, Hd = 37818, Gd = 37819, Vd = 37820, kd = 37821, zc = 36492, Xd = 36494, Wd = 36495, mS = 36283, Yd = 36284, qd = 36285, jd = 36286, FT = 3200, IT = 3201, _S = 0, HT = 1, xa = "", Gn = "srgb", kr = "srgb-linear", mu = "linear", le = "srgb", Os = 7680, Q_ = 519, GT = 512, VT = 513, kT = 514, gS = 515, XT = 516, WT = 517, YT = 518, qT = 519, J_ = 35044, $_ = "300 es", qi = 2e3, _u = 2001;
      class ws {
        addEventListener(t, n) {
          this._listeners === void 0 && (this._listeners = {});
          const i = this._listeners;
          i[t] === void 0 && (i[t] = []), i[t].indexOf(n) === -1 && i[t].push(n);
        }
        hasEventListener(t, n) {
          if (this._listeners === void 0) return false;
          const i = this._listeners;
          return i[t] !== void 0 && i[t].indexOf(n) !== -1;
        }
        removeEventListener(t, n) {
          if (this._listeners === void 0) return;
          const a = this._listeners[t];
          if (a !== void 0) {
            const s = a.indexOf(n);
            s !== -1 && a.splice(s, 1);
          }
        }
        dispatchEvent(t) {
          if (this._listeners === void 0) return;
          const i = this._listeners[t.type];
          if (i !== void 0) {
            t.target = this;
            const a = i.slice(0);
            for (let s = 0, r = a.length; s < r; s++) a[s].call(this, t);
            t.target = null;
          }
        }
      }
      const nn = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
      ];
      let tg = 1234567;
      const Vo = Math.PI / 180, hl = 180 / Math.PI;
      function Jr() {
        const e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
        return (nn[e & 255] + nn[e >> 8 & 255] + nn[e >> 16 & 255] + nn[e >> 24 & 255] + "-" + nn[t & 255] + nn[t >> 8 & 255] + "-" + nn[t >> 16 & 15 | 64] + nn[t >> 24 & 255] + "-" + nn[n & 63 | 128] + nn[n >> 8 & 255] + "-" + nn[n >> 16 & 255] + nn[n >> 24 & 255] + nn[i & 255] + nn[i >> 8 & 255] + nn[i >> 16 & 255] + nn[i >> 24 & 255]).toLowerCase();
      }
      function Gt(e, t, n) {
        return Math.max(t, Math.min(n, e));
      }
      function rm(e, t) {
        return (e % t + t) % t;
      }
      function jT(e, t, n, i, a) {
        return i + (e - t) * (a - i) / (n - t);
      }
      function ZT(e, t, n) {
        return e !== t ? (n - e) / (t - e) : 0;
      }
      function ko(e, t, n) {
        return (1 - n) * e + n * t;
      }
      function KT(e, t, n, i) {
        return ko(e, t, 1 - Math.exp(-n * i));
      }
      function QT(e, t = 1) {
        return t - Math.abs(rm(e, t * 2) - t);
      }
      function JT(e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e));
      }
      function $T(e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (e * 6 - 15) + 10));
      }
      function t1(e, t) {
        return e + Math.floor(Math.random() * (t - e + 1));
      }
      function e1(e, t) {
        return e + Math.random() * (t - e);
      }
      function n1(e) {
        return e * (0.5 - Math.random());
      }
      function i1(e) {
        e !== void 0 && (tg = e);
        let t = tg += 1831565813;
        return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
      function a1(e) {
        return e * Vo;
      }
      function s1(e) {
        return e * hl;
      }
      function r1(e) {
        return (e & e - 1) === 0 && e !== 0;
      }
      function o1(e) {
        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
      }
      function l1(e) {
        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
      }
      function c1(e, t, n, i, a) {
        const s = Math.cos, r = Math.sin, o = s(n / 2), l = r(n / 2), c = s((t + i) / 2), f = r((t + i) / 2), d = s((t - i) / 2), h = r((t - i) / 2), p = s((i - t) / 2), y = r((i - t) / 2);
        switch (a) {
          case "XYX":
            e.set(o * f, l * d, l * h, o * c);
            break;
          case "YZY":
            e.set(l * h, o * f, l * d, o * c);
            break;
          case "ZXZ":
            e.set(l * d, l * h, o * f, o * c);
            break;
          case "XZX":
            e.set(o * f, l * y, l * p, o * c);
            break;
          case "YXY":
            e.set(l * p, o * f, l * y, o * c);
            break;
          case "ZYZ":
            e.set(l * y, l * p, o * f, o * c);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + a);
        }
      }
      function $s(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint32Array:
            return e / 4294967295;
          case Uint16Array:
            return e / 65535;
          case Uint8Array:
            return e / 255;
          case Int32Array:
            return Math.max(e / 2147483647, -1);
          case Int16Array:
            return Math.max(e / 32767, -1);
          case Int8Array:
            return Math.max(e / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function ln(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint32Array:
            return Math.round(e * 4294967295);
          case Uint16Array:
            return Math.round(e * 65535);
          case Uint8Array:
            return Math.round(e * 255);
          case Int32Array:
            return Math.round(e * 2147483647);
          case Int16Array:
            return Math.round(e * 32767);
          case Int8Array:
            return Math.round(e * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const u1 = {
        DEG2RAD: Vo,
        RAD2DEG: hl,
        generateUUID: Jr,
        clamp: Gt,
        euclideanModulo: rm,
        mapLinear: jT,
        inverseLerp: ZT,
        lerp: ko,
        damp: KT,
        pingpong: QT,
        smoothstep: JT,
        smootherstep: $T,
        randInt: t1,
        randFloat: e1,
        randFloatSpread: n1,
        seededRandom: i1,
        degToRad: a1,
        radToDeg: s1,
        isPowerOfTwo: r1,
        ceilPowerOfTwo: o1,
        floorPowerOfTwo: l1,
        setQuaternionFromProperEuler: c1,
        normalize: ln,
        denormalize: $s
      };
      class Ut {
        constructor(t = 0, n = 0) {
          Ut.prototype.isVector2 = true, this.x = t, this.y = n;
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, n) {
          return this.x = t, this.y = n, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setComponent(t, n) {
          switch (t) {
            case 0:
              this.x = n;
              break;
            case 1:
              this.y = n;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this;
        }
        addVectors(t, n) {
          return this.x = t.x + n.x, this.y = t.y + n.y, this;
        }
        addScaledVector(t, n) {
          return this.x += t.x * n, this.y += t.y * n, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this;
        }
        subVectors(t, n) {
          return this.x = t.x - n.x, this.y = t.y - n.y, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this;
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          const n = this.x, i = this.y, a = t.elements;
          return this.x = a[0] * n + a[3] * i + a[6], this.y = a[1] * n + a[4] * i + a[7], this;
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
        }
        clamp(t, n) {
          return this.x = Gt(this.x, t.x, n.x), this.y = Gt(this.y, t.y, n.y), this;
        }
        clampScalar(t, n) {
          return this.x = Gt(this.x, t, n), this.y = Gt(this.y, t, n), this;
        }
        clampLength(t, n) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Gt(i, t, n));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(t) {
          const n = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (n === 0) return Math.PI / 2;
          const i = this.dot(t) / n;
          return Math.acos(Gt(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const n = this.x - t.x, i = this.y - t.y;
          return n * n + i * i;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, n) {
          return this.x += (t.x - this.x) * n, this.y += (t.y - this.y) * n, this;
        }
        lerpVectors(t, n, i) {
          return this.x = t.x + (n.x - t.x) * i, this.y = t.y + (n.y - t.y) * i, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, n = 0) {
          return this.x = t[n], this.y = t[n + 1], this;
        }
        toArray(t = [], n = 0) {
          return t[n] = this.x, t[n + 1] = this.y, t;
        }
        fromBufferAttribute(t, n) {
          return this.x = t.getX(n), this.y = t.getY(n), this;
        }
        rotateAround(t, n) {
          const i = Math.cos(n), a = Math.sin(n), s = this.x - t.x, r = this.y - t.y;
          return this.x = s * i - r * a + t.x, this.y = s * a + r * i + t.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Pt {
        constructor(t, n, i, a, s, r, o, l, c) {
          Pt.prototype.isMatrix3 = true, this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], t !== void 0 && this.set(t, n, i, a, s, r, o, l, c);
        }
        set(t, n, i, a, s, r, o, l, c) {
          const f = this.elements;
          return f[0] = t, f[1] = a, f[2] = o, f[3] = n, f[4] = s, f[5] = l, f[6] = i, f[7] = r, f[8] = c, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          const n = this.elements, i = t.elements;
          return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], this;
        }
        extractBasis(t, n, i) {
          return t.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(t) {
          const n = t.elements;
          return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this;
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, n) {
          const i = t.elements, a = n.elements, s = this.elements, r = i[0], o = i[3], l = i[6], c = i[1], f = i[4], d = i[7], h = i[2], p = i[5], y = i[8], S = a[0], m = a[3], u = a[6], _ = a[1], g = a[4], v = a[7], T = a[2], R = a[5], w = a[8];
          return s[0] = r * S + o * _ + l * T, s[3] = r * m + o * g + l * R, s[6] = r * u + o * v + l * w, s[1] = c * S + f * _ + d * T, s[4] = c * m + f * g + d * R, s[7] = c * u + f * v + d * w, s[2] = h * S + p * _ + y * T, s[5] = h * m + p * g + y * R, s[8] = h * u + p * v + y * w, this;
        }
        multiplyScalar(t) {
          const n = this.elements;
          return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= t, n[4] *= t, n[7] *= t, n[2] *= t, n[5] *= t, n[8] *= t, this;
        }
        determinant() {
          const t = this.elements, n = t[0], i = t[1], a = t[2], s = t[3], r = t[4], o = t[5], l = t[6], c = t[7], f = t[8];
          return n * r * f - n * o * c - i * s * f + i * o * l + a * s * c - a * r * l;
        }
        invert() {
          const t = this.elements, n = t[0], i = t[1], a = t[2], s = t[3], r = t[4], o = t[5], l = t[6], c = t[7], f = t[8], d = f * r - o * c, h = o * l - f * s, p = c * s - r * l, y = n * d + i * h + a * p;
          if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const S = 1 / y;
          return t[0] = d * S, t[1] = (a * c - f * i) * S, t[2] = (o * i - a * r) * S, t[3] = h * S, t[4] = (f * n - a * l) * S, t[5] = (a * s - o * n) * S, t[6] = p * S, t[7] = (i * l - c * n) * S, t[8] = (r * n - i * s) * S, this;
        }
        transpose() {
          let t;
          const n = this.elements;
          return t = n[1], n[1] = n[3], n[3] = t, t = n[2], n[2] = n[6], n[6] = t, t = n[5], n[5] = n[7], n[7] = t, this;
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          const n = this.elements;
          return t[0] = n[0], t[1] = n[3], t[2] = n[6], t[3] = n[1], t[4] = n[4], t[5] = n[7], t[6] = n[2], t[7] = n[5], t[8] = n[8], this;
        }
        setUvTransform(t, n, i, a, s, r, o) {
          const l = Math.cos(s), c = Math.sin(s);
          return this.set(i * l, i * c, -i * (l * r + c * o) + r + t, -a * c, a * l, -a * (-c * r + l * o) + o + n, 0, 0, 1), this;
        }
        scale(t, n) {
          return this.premultiply(Nf.makeScale(t, n)), this;
        }
        rotate(t) {
          return this.premultiply(Nf.makeRotation(-t)), this;
        }
        translate(t, n) {
          return this.premultiply(Nf.makeTranslation(t, n)), this;
        }
        makeTranslation(t, n) {
          return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, n, 0, 0, 1), this;
        }
        makeRotation(t) {
          const n = Math.cos(t), i = Math.sin(t);
          return this.set(n, -i, 0, i, n, 0, 0, 0, 1), this;
        }
        makeScale(t, n) {
          return this.set(t, 0, 0, 0, n, 0, 0, 0, 1), this;
        }
        equals(t) {
          const n = this.elements, i = t.elements;
          for (let a = 0; a < 9; a++) if (n[a] !== i[a]) return false;
          return true;
        }
        fromArray(t, n = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = t[i + n];
          return this;
        }
        toArray(t = [], n = 0) {
          const i = this.elements;
          return t[n] = i[0], t[n + 1] = i[1], t[n + 2] = i[2], t[n + 3] = i[3], t[n + 4] = i[4], t[n + 5] = i[5], t[n + 6] = i[6], t[n + 7] = i[7], t[n + 8] = i[8], t;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const Nf = new Pt();
      function vS(e) {
        for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return true;
        return false;
      }
      function gu(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e);
      }
      function f1() {
        const e = gu("canvas");
        return e.style.display = "block", e;
      }
      const eg = {};
      function tr(e) {
        e in eg || (eg[e] = true, console.warn(e));
      }
      function h1(e, t, n) {
        return new Promise(function(i, a) {
          function s() {
            switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
              case e.WAIT_FAILED:
                a();
                break;
              case e.TIMEOUT_EXPIRED:
                setTimeout(s, n);
                break;
              default:
                i();
            }
          }
          setTimeout(s, n);
        });
      }
      function d1(e) {
        const t = e.elements;
        t[2] = 0.5 * t[2] + 0.5 * t[3], t[6] = 0.5 * t[6] + 0.5 * t[7], t[10] = 0.5 * t[10] + 0.5 * t[11], t[14] = 0.5 * t[14] + 0.5 * t[15];
      }
      function p1(e) {
        const t = e.elements;
        t[11] === -1 ? (t[10] = -t[10] - 1, t[14] = -t[14]) : (t[10] = -t[10], t[14] = -t[14] + 1);
      }
      const ng = new Pt().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), ig = new Pt().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
      function m1() {
        const e = {
          enabled: true,
          workingColorSpace: kr,
          spaces: {},
          convert: function(a, s, r) {
            return this.enabled === false || s === r || !s || !r || (this.spaces[s].transfer === le && (a.r = Zi(a.r), a.g = Zi(a.g), a.b = Zi(a.b)), this.spaces[s].primaries !== this.spaces[r].primaries && (a.applyMatrix3(this.spaces[s].toXYZ), a.applyMatrix3(this.spaces[r].fromXYZ)), this.spaces[r].transfer === le && (a.r = Ar(a.r), a.g = Ar(a.g), a.b = Ar(a.b))), a;
          },
          fromWorkingColorSpace: function(a, s) {
            return this.convert(a, this.workingColorSpace, s);
          },
          toWorkingColorSpace: function(a, s) {
            return this.convert(a, s, this.workingColorSpace);
          },
          getPrimaries: function(a) {
            return this.spaces[a].primaries;
          },
          getTransfer: function(a) {
            return a === xa ? mu : this.spaces[a].transfer;
          },
          getLuminanceCoefficients: function(a, s = this.workingColorSpace) {
            return a.fromArray(this.spaces[s].luminanceCoefficients);
          },
          define: function(a) {
            Object.assign(this.spaces, a);
          },
          _getMatrix: function(a, s, r) {
            return a.copy(this.spaces[s].toXYZ).multiply(this.spaces[r].fromXYZ);
          },
          _getDrawingBufferColorSpace: function(a) {
            return this.spaces[a].outputColorSpaceConfig.drawingBufferColorSpace;
          },
          _getUnpackColorSpace: function(a = this.workingColorSpace) {
            return this.spaces[a].workingColorSpaceConfig.unpackColorSpace;
          }
        }, t = [
          0.64,
          0.33,
          0.3,
          0.6,
          0.15,
          0.06
        ], n = [
          0.2126,
          0.7152,
          0.0722
        ], i = [
          0.3127,
          0.329
        ];
        return e.define({
          [kr]: {
            primaries: t,
            whitePoint: i,
            transfer: mu,
            toXYZ: ng,
            fromXYZ: ig,
            luminanceCoefficients: n,
            workingColorSpaceConfig: {
              unpackColorSpace: Gn
            },
            outputColorSpaceConfig: {
              drawingBufferColorSpace: Gn
            }
          },
          [Gn]: {
            primaries: t,
            whitePoint: i,
            transfer: le,
            toXYZ: ng,
            fromXYZ: ig,
            luminanceCoefficients: n,
            outputColorSpaceConfig: {
              drawingBufferColorSpace: Gn
            }
          }
        }), e;
      }
      const te = m1();
      function Zi(e) {
        return e < 0.04045 ? e * 0.0773993808 : Math.pow(e * 0.9478672986 + 0.0521327014, 2.4);
      }
      function Ar(e) {
        return e < 31308e-7 ? e * 12.92 : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      let Ps;
      class _1 {
        static getDataURL(t) {
          if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
          let n;
          if (t instanceof HTMLCanvasElement) n = t;
          else {
            Ps === void 0 && (Ps = gu("canvas")), Ps.width = t.width, Ps.height = t.height;
            const i = Ps.getContext("2d");
            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), n = Ps;
          }
          return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), n.toDataURL("image/jpeg", 0.6)) : n.toDataURL("image/png");
        }
        static sRGBToLinear(t) {
          if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
            const n = gu("canvas");
            n.width = t.width, n.height = t.height;
            const i = n.getContext("2d");
            i.drawImage(t, 0, 0, t.width, t.height);
            const a = i.getImageData(0, 0, t.width, t.height), s = a.data;
            for (let r = 0; r < s.length; r++) s[r] = Zi(s[r] / 255) * 255;
            return i.putImageData(a, 0, 0), n;
          } else if (t.data) {
            const n = t.data.slice(0);
            for (let i = 0; i < n.length; i++) n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(Zi(n[i] / 255) * 255) : n[i] = Zi(n[i]);
            return {
              data: n,
              width: t.width,
              height: t.height
            };
          } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
        }
      }
      let g1 = 0;
      class yS {
        constructor(t = null) {
          this.isSource = true, Object.defineProperty(this, "id", {
            value: g1++
          }), this.uuid = Jr(), this.data = t, this.dataReady = true, this.version = 0;
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        toJSON(t) {
          const n = t === void 0 || typeof t == "string";
          if (!n && t.images[this.uuid] !== void 0) return t.images[this.uuid];
          const i = {
            uuid: this.uuid,
            url: ""
          }, a = this.data;
          if (a !== null) {
            let s;
            if (Array.isArray(a)) {
              s = [];
              for (let r = 0, o = a.length; r < o; r++) a[r].isDataTexture ? s.push(Of(a[r].image)) : s.push(Of(a[r]));
            } else s = Of(a);
            i.url = s;
          }
          return n || (t.images[this.uuid] = i), i;
        }
      }
      function Of(e) {
        return typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap ? _1.getDataURL(e) : e.data ? {
          data: Array.from(e.data),
          width: e.width,
          height: e.height,
          type: e.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let v1 = 0;
      class pn extends ws {
        constructor(t = pn.DEFAULT_IMAGE, n = pn.DEFAULT_MAPPING, i = ss, a = ss, s = _i, r = rs, o = ci, l = ea, c = pn.DEFAULT_ANISOTROPY, f = xa) {
          super(), this.isTexture = true, Object.defineProperty(this, "id", {
            value: v1++
          }), this.uuid = Jr(), this.name = "", this.source = new yS(t), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = i, this.wrapT = a, this.magFilter = s, this.minFilter = r, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new Ut(0, 0), this.repeat = new Ut(1, 1), this.center = new Ut(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Pt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = f, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
        }
        get image() {
          return this.source.data;
        }
        set image(t = null) {
          this.source.data = t;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.renderTarget = t.renderTarget, this.isRenderTargetTexture = t.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = true, this;
        }
        toJSON(t) {
          const n = t === void 0 || typeof t == "string";
          if (!n && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
          const i = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [
              this.repeat.x,
              this.repeat.y
            ],
            offset: [
              this.offset.x,
              this.offset.y
            ],
            center: [
              this.center.x,
              this.center.y
            ],
            rotation: this.rotation,
            wrap: [
              this.wrapS,
              this.wrapT
            ],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          return Object.keys(this.userData).length > 0 && (i.userData = this.userData), n || (t.textures[this.uuid] = i), i;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(t) {
          if (this.mapping !== rS) return t;
          if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
            case xd:
              t.x = t.x - Math.floor(t.x);
              break;
            case ss:
              t.x = t.x < 0 ? 0 : 1;
              break;
            case Md:
              Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
              break;
          }
          if (t.y < 0 || t.y > 1) switch (this.wrapT) {
            case xd:
              t.y = t.y - Math.floor(t.y);
              break;
            case ss:
              t.y = t.y < 0 ? 0 : 1;
              break;
            case Md:
              Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
              break;
          }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          t === true && (this.version++, this.source.needsUpdate = true);
        }
        set needsPMREMUpdate(t) {
          t === true && this.pmremVersion++;
        }
      }
      pn.DEFAULT_IMAGE = null;
      pn.DEFAULT_MAPPING = rS;
      pn.DEFAULT_ANISOTROPY = 1;
      class Ce {
        constructor(t = 0, n = 0, i = 0, a = 1) {
          Ce.prototype.isVector4 = true, this.x = t, this.y = n, this.z = i, this.w = a;
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, n, i, a) {
          return this.x = t, this.y = n, this.z = i, this.w = a, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this.z = t, this.w = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setZ(t) {
          return this.z = t, this;
        }
        setW(t) {
          return this.w = t, this;
        }
        setComponent(t, n) {
          switch (t) {
            case 0:
              this.x = n;
              break;
            case 1:
              this.y = n;
              break;
            case 2:
              this.z = n;
              break;
            case 3:
              this.w = n;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this.z += t, this.w += t, this;
        }
        addVectors(t, n) {
          return this.x = t.x + n.x, this.y = t.y + n.y, this.z = t.z + n.z, this.w = t.w + n.w, this;
        }
        addScaledVector(t, n) {
          return this.x += t.x * n, this.y += t.y * n, this.z += t.z * n, this.w += t.w * n, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
        }
        subVectors(t, n) {
          return this.x = t.x - n.x, this.y = t.y - n.y, this.z = t.z - n.z, this.w = t.w - n.w, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
        }
        applyMatrix4(t) {
          const n = this.x, i = this.y, a = this.z, s = this.w, r = t.elements;
          return this.x = r[0] * n + r[4] * i + r[8] * a + r[12] * s, this.y = r[1] * n + r[5] * i + r[9] * a + r[13] * s, this.z = r[2] * n + r[6] * i + r[10] * a + r[14] * s, this.w = r[3] * n + r[7] * i + r[11] * a + r[15] * s, this;
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          const n = Math.sqrt(1 - t.w * t.w);
          return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / n, this.y = t.y / n, this.z = t.z / n), this;
        }
        setAxisAngleFromRotationMatrix(t) {
          let n, i, a, s;
          const l = t.elements, c = l[0], f = l[4], d = l[8], h = l[1], p = l[5], y = l[9], S = l[2], m = l[6], u = l[10];
          if (Math.abs(f - h) < 0.01 && Math.abs(d - S) < 0.01 && Math.abs(y - m) < 0.01) {
            if (Math.abs(f + h) < 0.1 && Math.abs(d + S) < 0.1 && Math.abs(y + m) < 0.1 && Math.abs(c + p + u - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            n = Math.PI;
            const g = (c + 1) / 2, v = (p + 1) / 2, T = (u + 1) / 2, R = (f + h) / 4, w = (d + S) / 4, D = (y + m) / 4;
            return g > v && g > T ? g < 0.01 ? (i = 0, a = 0.707106781, s = 0.707106781) : (i = Math.sqrt(g), a = R / i, s = w / i) : v > T ? v < 0.01 ? (i = 0.707106781, a = 0, s = 0.707106781) : (a = Math.sqrt(v), i = R / a, s = D / a) : T < 0.01 ? (i = 0.707106781, a = 0.707106781, s = 0) : (s = Math.sqrt(T), i = w / s, a = D / s), this.set(i, a, s, n), this;
          }
          let _ = Math.sqrt((m - y) * (m - y) + (d - S) * (d - S) + (h - f) * (h - f));
          return Math.abs(_) < 1e-3 && (_ = 1), this.x = (m - y) / _, this.y = (d - S) / _, this.z = (h - f) / _, this.w = Math.acos((c + p + u - 1) / 2), this;
        }
        setFromMatrixPosition(t) {
          const n = t.elements;
          return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this;
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
        }
        clamp(t, n) {
          return this.x = Gt(this.x, t.x, n.x), this.y = Gt(this.y, t.y, n.y), this.z = Gt(this.z, t.z, n.z), this.w = Gt(this.w, t.w, n.w), this;
        }
        clampScalar(t, n) {
          return this.x = Gt(this.x, t, n), this.y = Gt(this.y, t, n), this.z = Gt(this.z, t, n), this.w = Gt(this.w, t, n), this;
        }
        clampLength(t, n) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Gt(i, t, n));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, n) {
          return this.x += (t.x - this.x) * n, this.y += (t.y - this.y) * n, this.z += (t.z - this.z) * n, this.w += (t.w - this.w) * n, this;
        }
        lerpVectors(t, n, i) {
          return this.x = t.x + (n.x - t.x) * i, this.y = t.y + (n.y - t.y) * i, this.z = t.z + (n.z - t.z) * i, this.w = t.w + (n.w - t.w) * i, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
        }
        fromArray(t, n = 0) {
          return this.x = t[n], this.y = t[n + 1], this.z = t[n + 2], this.w = t[n + 3], this;
        }
        toArray(t = [], n = 0) {
          return t[n] = this.x, t[n + 1] = this.y, t[n + 2] = this.z, t[n + 3] = this.w, t;
        }
        fromBufferAttribute(t, n) {
          return this.x = t.getX(n), this.y = t.getY(n), this.z = t.getZ(n), this.w = t.getW(n), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class y1 extends ws {
        constructor(t = 1, n = 1, i = {}) {
          super(), this.isRenderTarget = true, this.width = t, this.height = n, this.depth = 1, this.scissor = new Ce(0, 0, t, n), this.scissorTest = false, this.viewport = new Ce(0, 0, t, n);
          const a = {
            width: t,
            height: n,
            depth: 1
          };
          i = Object.assign({
            generateMipmaps: false,
            internalFormat: null,
            minFilter: _i,
            depthBuffer: true,
            stencilBuffer: false,
            resolveDepthBuffer: true,
            resolveStencilBuffer: true,
            depthTexture: null,
            samples: 0,
            count: 1
          }, i);
          const s = new pn(a, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
          s.flipY = false, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
          const r = i.count;
          for (let o = 0; o < r; o++) this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = true, this.textures[o].renderTarget = this;
          this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples;
        }
        get texture() {
          return this.textures[0];
        }
        set texture(t) {
          this.textures[0] = t;
        }
        set depthTexture(t) {
          this._depthTexture !== null && (this._depthTexture.renderTarget = null), t !== null && (t.renderTarget = this), this._depthTexture = t;
        }
        get depthTexture() {
          return this._depthTexture;
        }
        setSize(t, n, i = 1) {
          if (this.width !== t || this.height !== n || this.depth !== i) {
            this.width = t, this.height = n, this.depth = i;
            for (let a = 0, s = this.textures.length; a < s; a++) this.textures[a].image.width = t, this.textures[a].image.height = n, this.textures[a].image.depth = i;
            this.dispose();
          }
          this.viewport.set(0, 0, t, n), this.scissor.set(0, 0, t, n);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
          for (let i = 0, a = t.textures.length; i < a; i++) this.textures[i] = t.textures[i].clone(), this.textures[i].isRenderTargetTexture = true, this.textures[i].renderTarget = this;
          const n = Object.assign({}, t.texture.image);
          return this.texture.source = new yS(n), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class Ss extends y1 {
        constructor(t = 1, n = 1, i = {}) {
          super(t, n, i), this.isWebGLRenderTarget = true;
        }
      }
      class SS extends pn {
        constructor(t = null, n = 1, i = 1, a = 1) {
          super(null), this.isDataArrayTexture = true, this.image = {
            data: t,
            width: n,
            height: i,
            depth: a
          }, this.magFilter = Dn, this.minFilter = Dn, this.wrapR = ss, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
        }
        addLayerUpdate(t) {
          this.layerUpdates.add(t);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class S1 extends pn {
        constructor(t = null, n = 1, i = 1, a = 1) {
          super(null), this.isData3DTexture = true, this.image = {
            data: t,
            width: n,
            height: i,
            depth: a
          }, this.magFilter = Dn, this.minFilter = Dn, this.wrapR = ss, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      class xs {
        constructor(t = 0, n = 0, i = 0, a = 1) {
          this.isQuaternion = true, this._x = t, this._y = n, this._z = i, this._w = a;
        }
        static slerpFlat(t, n, i, a, s, r, o) {
          let l = i[a + 0], c = i[a + 1], f = i[a + 2], d = i[a + 3];
          const h = s[r + 0], p = s[r + 1], y = s[r + 2], S = s[r + 3];
          if (o === 0) {
            t[n + 0] = l, t[n + 1] = c, t[n + 2] = f, t[n + 3] = d;
            return;
          }
          if (o === 1) {
            t[n + 0] = h, t[n + 1] = p, t[n + 2] = y, t[n + 3] = S;
            return;
          }
          if (d !== S || l !== h || c !== p || f !== y) {
            let m = 1 - o;
            const u = l * h + c * p + f * y + d * S, _ = u >= 0 ? 1 : -1, g = 1 - u * u;
            if (g > Number.EPSILON) {
              const T = Math.sqrt(g), R = Math.atan2(T, u * _);
              m = Math.sin(m * R) / T, o = Math.sin(o * R) / T;
            }
            const v = o * _;
            if (l = l * m + h * v, c = c * m + p * v, f = f * m + y * v, d = d * m + S * v, m === 1 - o) {
              const T = 1 / Math.sqrt(l * l + c * c + f * f + d * d);
              l *= T, c *= T, f *= T, d *= T;
            }
          }
          t[n] = l, t[n + 1] = c, t[n + 2] = f, t[n + 3] = d;
        }
        static multiplyQuaternionsFlat(t, n, i, a, s, r) {
          const o = i[a], l = i[a + 1], c = i[a + 2], f = i[a + 3], d = s[r], h = s[r + 1], p = s[r + 2], y = s[r + 3];
          return t[n] = o * y + f * d + l * p - c * h, t[n + 1] = l * y + f * h + c * d - o * p, t[n + 2] = c * y + f * p + o * h - l * d, t[n + 3] = f * y - o * d - l * h - c * p, t;
        }
        get x() {
          return this._x;
        }
        set x(t) {
          this._x = t, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          this._y = t, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          this._z = t, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          this._w = t, this._onChangeCallback();
        }
        set(t, n, i, a) {
          return this._x = t, this._y = n, this._z = i, this._w = a, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
        }
        setFromEuler(t, n = true) {
          const i = t._x, a = t._y, s = t._z, r = t._order, o = Math.cos, l = Math.sin, c = o(i / 2), f = o(a / 2), d = o(s / 2), h = l(i / 2), p = l(a / 2), y = l(s / 2);
          switch (r) {
            case "XYZ":
              this._x = h * f * d + c * p * y, this._y = c * p * d - h * f * y, this._z = c * f * y + h * p * d, this._w = c * f * d - h * p * y;
              break;
            case "YXZ":
              this._x = h * f * d + c * p * y, this._y = c * p * d - h * f * y, this._z = c * f * y - h * p * d, this._w = c * f * d + h * p * y;
              break;
            case "ZXY":
              this._x = h * f * d - c * p * y, this._y = c * p * d + h * f * y, this._z = c * f * y + h * p * d, this._w = c * f * d - h * p * y;
              break;
            case "ZYX":
              this._x = h * f * d - c * p * y, this._y = c * p * d + h * f * y, this._z = c * f * y - h * p * d, this._w = c * f * d + h * p * y;
              break;
            case "YZX":
              this._x = h * f * d + c * p * y, this._y = c * p * d + h * f * y, this._z = c * f * y - h * p * d, this._w = c * f * d - h * p * y;
              break;
            case "XZY":
              this._x = h * f * d - c * p * y, this._y = c * p * d - h * f * y, this._z = c * f * y + h * p * d, this._w = c * f * d + h * p * y;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
          }
          return n === true && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, n) {
          const i = n / 2, a = Math.sin(i);
          return this._x = t.x * a, this._y = t.y * a, this._z = t.z * a, this._w = Math.cos(i), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t) {
          const n = t.elements, i = n[0], a = n[4], s = n[8], r = n[1], o = n[5], l = n[9], c = n[2], f = n[6], d = n[10], h = i + o + d;
          if (h > 0) {
            const p = 0.5 / Math.sqrt(h + 1);
            this._w = 0.25 / p, this._x = (f - l) * p, this._y = (s - c) * p, this._z = (r - a) * p;
          } else if (i > o && i > d) {
            const p = 2 * Math.sqrt(1 + i - o - d);
            this._w = (f - l) / p, this._x = 0.25 * p, this._y = (a + r) / p, this._z = (s + c) / p;
          } else if (o > d) {
            const p = 2 * Math.sqrt(1 + o - i - d);
            this._w = (s - c) / p, this._x = (a + r) / p, this._y = 0.25 * p, this._z = (l + f) / p;
          } else {
            const p = 2 * Math.sqrt(1 + d - i - o);
            this._w = (r - a) / p, this._x = (s + c) / p, this._y = (l + f) / p, this._z = 0.25 * p;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, n) {
          let i = t.dot(n) + 1;
          return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * n.z - t.z * n.y, this._y = t.z * n.x - t.x * n.z, this._z = t.x * n.y - t.y * n.x, this._w = i), this.normalize();
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(Gt(this.dot(t), -1, 1)));
        }
        rotateTowards(t, n) {
          const i = this.angleTo(t);
          if (i === 0) return this;
          const a = Math.min(1, n / i);
          return this.slerp(t, a), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(t) {
          return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let t = this.length();
          return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
        }
        multiply(t) {
          return this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, n) {
          const i = t._x, a = t._y, s = t._z, r = t._w, o = n._x, l = n._y, c = n._z, f = n._w;
          return this._x = i * f + r * o + a * c - s * l, this._y = a * f + r * l + s * o - i * c, this._z = s * f + r * c + i * l - a * o, this._w = r * f - i * o - a * l - s * c, this._onChangeCallback(), this;
        }
        slerp(t, n) {
          if (n === 0) return this;
          if (n === 1) return this.copy(t);
          const i = this._x, a = this._y, s = this._z, r = this._w;
          let o = r * t._w + i * t._x + a * t._y + s * t._z;
          if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = r, this._x = i, this._y = a, this._z = s, this;
          const l = 1 - o * o;
          if (l <= Number.EPSILON) {
            const p = 1 - n;
            return this._w = p * r + n * this._w, this._x = p * i + n * this._x, this._y = p * a + n * this._y, this._z = p * s + n * this._z, this.normalize(), this;
          }
          const c = Math.sqrt(l), f = Math.atan2(c, o), d = Math.sin((1 - n) * f) / c, h = Math.sin(n * f) / c;
          return this._w = r * d + this._w * h, this._x = i * d + this._x * h, this._y = a * d + this._y * h, this._z = s * d + this._z * h, this._onChangeCallback(), this;
        }
        slerpQuaternions(t, n, i) {
          return this.copy(t).slerp(n, i);
        }
        random() {
          const t = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), i = Math.random(), a = Math.sqrt(1 - i), s = Math.sqrt(i);
          return this.set(a * Math.sin(t), a * Math.cos(t), s * Math.sin(n), s * Math.cos(n));
        }
        equals(t) {
          return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
        }
        fromArray(t, n = 0) {
          return this._x = t[n], this._y = t[n + 1], this._z = t[n + 2], this._w = t[n + 3], this._onChangeCallback(), this;
        }
        toArray(t = [], n = 0) {
          return t[n] = this._x, t[n + 1] = this._y, t[n + 2] = this._z, t[n + 3] = this._w, t;
        }
        fromBufferAttribute(t, n) {
          return this._x = t.getX(n), this._y = t.getY(n), this._z = t.getZ(n), this._w = t.getW(n), this._onChangeCallback(), this;
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(t) {
          return this._onChangeCallback = t, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class z {
        constructor(t = 0, n = 0, i = 0) {
          z.prototype.isVector3 = true, this.x = t, this.y = n, this.z = i;
        }
        set(t, n, i) {
          return i === void 0 && (i = this.z), this.x = t, this.y = n, this.z = i, this;
        }
        setScalar(t) {
          return this.x = t, this.y = t, this.z = t, this;
        }
        setX(t) {
          return this.x = t, this;
        }
        setY(t) {
          return this.y = t, this;
        }
        setZ(t) {
          return this.z = t, this;
        }
        setComponent(t, n) {
          switch (t) {
            case 0:
              this.x = n;
              break;
            case 1:
              this.y = n;
              break;
            case 2:
              this.z = n;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return this.x = t.x, this.y = t.y, this.z = t.z, this;
        }
        add(t) {
          return this.x += t.x, this.y += t.y, this.z += t.z, this;
        }
        addScalar(t) {
          return this.x += t, this.y += t, this.z += t, this;
        }
        addVectors(t, n) {
          return this.x = t.x + n.x, this.y = t.y + n.y, this.z = t.z + n.z, this;
        }
        addScaledVector(t, n) {
          return this.x += t.x * n, this.y += t.y * n, this.z += t.z * n, this;
        }
        sub(t) {
          return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
        }
        subScalar(t) {
          return this.x -= t, this.y -= t, this.z -= t, this;
        }
        subVectors(t, n) {
          return this.x = t.x - n.x, this.y = t.y - n.y, this.z = t.z - n.z, this;
        }
        multiply(t) {
          return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
        }
        multiplyScalar(t) {
          return this.x *= t, this.y *= t, this.z *= t, this;
        }
        multiplyVectors(t, n) {
          return this.x = t.x * n.x, this.y = t.y * n.y, this.z = t.z * n.z, this;
        }
        applyEuler(t) {
          return this.applyQuaternion(ag.setFromEuler(t));
        }
        applyAxisAngle(t, n) {
          return this.applyQuaternion(ag.setFromAxisAngle(t, n));
        }
        applyMatrix3(t) {
          const n = this.x, i = this.y, a = this.z, s = t.elements;
          return this.x = s[0] * n + s[3] * i + s[6] * a, this.y = s[1] * n + s[4] * i + s[7] * a, this.z = s[2] * n + s[5] * i + s[8] * a, this;
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          const n = this.x, i = this.y, a = this.z, s = t.elements, r = 1 / (s[3] * n + s[7] * i + s[11] * a + s[15]);
          return this.x = (s[0] * n + s[4] * i + s[8] * a + s[12]) * r, this.y = (s[1] * n + s[5] * i + s[9] * a + s[13]) * r, this.z = (s[2] * n + s[6] * i + s[10] * a + s[14]) * r, this;
        }
        applyQuaternion(t) {
          const n = this.x, i = this.y, a = this.z, s = t.x, r = t.y, o = t.z, l = t.w, c = 2 * (r * a - o * i), f = 2 * (o * n - s * a), d = 2 * (s * i - r * n);
          return this.x = n + l * c + r * d - o * f, this.y = i + l * f + o * c - s * d, this.z = a + l * d + s * f - r * c, this;
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
        }
        transformDirection(t) {
          const n = this.x, i = this.y, a = this.z, s = t.elements;
          return this.x = s[0] * n + s[4] * i + s[8] * a, this.y = s[1] * n + s[5] * i + s[9] * a, this.z = s[2] * n + s[6] * i + s[10] * a, this.normalize();
        }
        divide(t) {
          return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
        }
        max(t) {
          return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
        }
        clamp(t, n) {
          return this.x = Gt(this.x, t.x, n.x), this.y = Gt(this.y, t.y, n.y), this.z = Gt(this.z, t.z, n.z), this;
        }
        clampScalar(t, n) {
          return this.x = Gt(this.x, t, n), this.y = Gt(this.y, t, n), this.z = Gt(this.z, t, n), this;
        }
        clampLength(t, n) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Gt(i, t, n));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, n) {
          return this.x += (t.x - this.x) * n, this.y += (t.y - this.y) * n, this.z += (t.z - this.z) * n, this;
        }
        lerpVectors(t, n, i) {
          return this.x = t.x + (n.x - t.x) * i, this.y = t.y + (n.y - t.y) * i, this.z = t.z + (n.z - t.z) * i, this;
        }
        cross(t) {
          return this.crossVectors(this, t);
        }
        crossVectors(t, n) {
          const i = t.x, a = t.y, s = t.z, r = n.x, o = n.y, l = n.z;
          return this.x = a * l - s * o, this.y = s * r - i * l, this.z = i * o - a * r, this;
        }
        projectOnVector(t) {
          const n = t.lengthSq();
          if (n === 0) return this.set(0, 0, 0);
          const i = t.dot(this) / n;
          return this.copy(t).multiplyScalar(i);
        }
        projectOnPlane(t) {
          return Pf.copy(this).projectOnVector(t), this.sub(Pf);
        }
        reflect(t) {
          return this.sub(Pf.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          const n = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (n === 0) return Math.PI / 2;
          const i = this.dot(t) / n;
          return Math.acos(Gt(i, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const n = this.x - t.x, i = this.y - t.y, a = this.z - t.z;
          return n * n + i * i + a * a;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, n, i) {
          const a = Math.sin(n) * t;
          return this.x = a * Math.sin(i), this.y = Math.cos(n) * t, this.z = a * Math.cos(i), this;
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, n, i) {
          return this.x = t * Math.sin(n), this.y = i, this.z = t * Math.cos(n), this;
        }
        setFromMatrixPosition(t) {
          const n = t.elements;
          return this.x = n[12], this.y = n[13], this.z = n[14], this;
        }
        setFromMatrixScale(t) {
          const n = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), a = this.setFromMatrixColumn(t, 2).length();
          return this.x = n, this.y = i, this.z = a, this;
        }
        setFromMatrixColumn(t, n) {
          return this.fromArray(t.elements, n * 4);
        }
        setFromMatrix3Column(t, n) {
          return this.fromArray(t.elements, n * 3);
        }
        setFromEuler(t) {
          return this.x = t._x, this.y = t._y, this.z = t._z, this;
        }
        setFromColor(t) {
          return this.x = t.r, this.y = t.g, this.z = t.b, this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, n = 0) {
          return this.x = t[n], this.y = t[n + 1], this.z = t[n + 2], this;
        }
        toArray(t = [], n = 0) {
          return t[n] = this.x, t[n + 1] = this.y, t[n + 2] = this.z, t;
        }
        fromBufferAttribute(t, n) {
          return this.x = t.getX(n), this.y = t.getY(n), this.z = t.getZ(n), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
          const t = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, i = Math.sqrt(1 - n * n);
          return this.x = i * Math.cos(t), this.y = n, this.z = i * Math.sin(t), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const Pf = new z(), ag = new xs();
      class Cs {
        constructor(t = new z(1 / 0, 1 / 0, 1 / 0), n = new z(-1 / 0, -1 / 0, -1 / 0)) {
          this.isBox3 = true, this.min = t, this.max = n;
        }
        set(t, n) {
          return this.min.copy(t), this.max.copy(n), this;
        }
        setFromArray(t) {
          this.makeEmpty();
          for (let n = 0, i = t.length; n < i; n += 3) this.expandByPoint(ii.fromArray(t, n));
          return this;
        }
        setFromBufferAttribute(t) {
          this.makeEmpty();
          for (let n = 0, i = t.count; n < i; n++) this.expandByPoint(ii.fromBufferAttribute(t, n));
          return this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let n = 0, i = t.length; n < i; n++) this.expandByPoint(t[n]);
          return this;
        }
        setFromCenterAndSize(t, n) {
          const i = ii.copy(n).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }
        setFromObject(t, n = false) {
          return this.makeEmpty(), this.expandByObject(t, n);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(t) {
          return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, n = false) {
          t.updateWorldMatrix(false, false);
          const i = t.geometry;
          if (i !== void 0) {
            const s = i.getAttribute("position");
            if (n === true && s !== void 0 && t.isInstancedMesh !== true) for (let r = 0, o = s.count; r < o; r++) t.isMesh === true ? t.getVertexPosition(r, ii) : ii.fromBufferAttribute(s, r), ii.applyMatrix4(t.matrixWorld), this.expandByPoint(ii);
            else t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), ql.copy(t.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), ql.copy(i.boundingBox)), ql.applyMatrix4(t.matrixWorld), this.union(ql);
          }
          const a = t.children;
          for (let s = 0, r = a.length; s < r; s++) this.expandByObject(a[s], n);
          return this;
        }
        containsPoint(t) {
          return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
        }
        containsBox(t) {
          return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
        }
        getParameter(t, n) {
          return n.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(t) {
          return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z;
        }
        intersectsSphere(t) {
          return this.clampPoint(t.center, ii), ii.distanceToSquared(t.center) <= t.radius * t.radius;
        }
        intersectsPlane(t) {
          let n, i;
          return t.normal.x > 0 ? (n = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (n = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (n += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (n += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (n += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (n += t.normal.z * this.max.z, i += t.normal.z * this.min.z), n <= -t.constant && i >= -t.constant;
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return false;
          this.getCenter(ho), jl.subVectors(this.max, ho), zs.subVectors(t.a, ho), Bs.subVectors(t.b, ho), Fs.subVectors(t.c, ho), oa.subVectors(Bs, zs), la.subVectors(Fs, Bs), Wa.subVectors(zs, Fs);
          let n = [
            0,
            -oa.z,
            oa.y,
            0,
            -la.z,
            la.y,
            0,
            -Wa.z,
            Wa.y,
            oa.z,
            0,
            -oa.x,
            la.z,
            0,
            -la.x,
            Wa.z,
            0,
            -Wa.x,
            -oa.y,
            oa.x,
            0,
            -la.y,
            la.x,
            0,
            -Wa.y,
            Wa.x,
            0
          ];
          return !zf(n, zs, Bs, Fs, jl) || (n = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], !zf(n, zs, Bs, Fs, jl)) ? false : (Zl.crossVectors(oa, la), n = [
            Zl.x,
            Zl.y,
            Zl.z
          ], zf(n, zs, Bs, Fs, jl));
        }
        clampPoint(t, n) {
          return n.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return this.clampPoint(t, ii).distanceTo(t);
        }
        getBoundingSphere(t) {
          return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(ii).length() * 0.5), t;
        }
        intersect(t) {
          return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return this.isEmpty() ? this : (Ui[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ui[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ui[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ui[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ui[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ui[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ui[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ui[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ui), this);
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      const Ui = [
        new z(),
        new z(),
        new z(),
        new z(),
        new z(),
        new z(),
        new z(),
        new z()
      ], ii = new z(), ql = new Cs(), zs = new z(), Bs = new z(), Fs = new z(), oa = new z(), la = new z(), Wa = new z(), ho = new z(), jl = new z(), Zl = new z(), Ya = new z();
      function zf(e, t, n, i, a) {
        for (let s = 0, r = e.length - 3; s <= r; s += 3) {
          Ya.fromArray(e, s);
          const o = a.x * Math.abs(Ya.x) + a.y * Math.abs(Ya.y) + a.z * Math.abs(Ya.z), l = t.dot(Ya), c = n.dot(Ya), f = i.dot(Ya);
          if (Math.max(-Math.max(l, c, f), Math.min(l, c, f)) > o) return false;
        }
        return true;
      }
      const x1 = new Cs(), po = new z(), Bf = new z();
      class $r {
        constructor(t = new z(), n = -1) {
          this.isSphere = true, this.center = t, this.radius = n;
        }
        set(t, n) {
          return this.center.copy(t), this.radius = n, this;
        }
        setFromPoints(t, n) {
          const i = this.center;
          n !== void 0 ? i.copy(n) : x1.setFromPoints(t).getCenter(i);
          let a = 0;
          for (let s = 0, r = t.length; s < r; s++) a = Math.max(a, i.distanceToSquared(t[s]));
          return this.radius = Math.sqrt(a), this;
        }
        copy(t) {
          return this.center.copy(t.center), this.radius = t.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          const n = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= n * n;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, n) {
          const i = this.center.distanceToSquared(t);
          return n.copy(t), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
        }
        getBoundingBox(t) {
          return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
        }
        applyMatrix4(t) {
          return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
          po.subVectors(t, this.center);
          const n = po.lengthSq();
          if (n > this.radius * this.radius) {
            const i = Math.sqrt(n), a = (i - this.radius) * 0.5;
            this.center.addScaledVector(po, a / i), this.radius += a;
          }
          return this;
        }
        union(t) {
          return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === true ? this.radius = Math.max(this.radius, t.radius) : (Bf.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(po.copy(t.center).add(Bf)), this.expandByPoint(po.copy(t.center).sub(Bf))), this);
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Li = new z(), Ff = new z(), Kl = new z(), ca = new z(), If = new z(), Ql = new z(), Hf = new z();
      class Vu {
        constructor(t = new z(), n = new z(0, 0, -1)) {
          this.origin = t, this.direction = n;
        }
        set(t, n) {
          return this.origin.copy(t), this.direction.copy(n), this;
        }
        copy(t) {
          return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
        }
        at(t, n) {
          return n.copy(this.origin).addScaledVector(this.direction, t);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, Li)), this;
        }
        closestPointToPoint(t, n) {
          n.subVectors(t, this.origin);
          const i = n.dot(this.direction);
          return i < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const n = Li.subVectors(t, this.origin).dot(this.direction);
          return n < 0 ? this.origin.distanceToSquared(t) : (Li.copy(this.origin).addScaledVector(this.direction, n), Li.distanceToSquared(t));
        }
        distanceSqToSegment(t, n, i, a) {
          Ff.copy(t).add(n).multiplyScalar(0.5), Kl.copy(n).sub(t).normalize(), ca.copy(this.origin).sub(Ff);
          const s = t.distanceTo(n) * 0.5, r = -this.direction.dot(Kl), o = ca.dot(this.direction), l = -ca.dot(Kl), c = ca.lengthSq(), f = Math.abs(1 - r * r);
          let d, h, p, y;
          if (f > 0) if (d = r * l - o, h = r * o - l, y = s * f, d >= 0) if (h >= -y) if (h <= y) {
            const S = 1 / f;
            d *= S, h *= S, p = d * (d + r * h + 2 * o) + h * (r * d + h + 2 * l) + c;
          } else h = s, d = Math.max(0, -(r * h + o)), p = -d * d + h * (h + 2 * l) + c;
          else h = -s, d = Math.max(0, -(r * h + o)), p = -d * d + h * (h + 2 * l) + c;
          else h <= -y ? (d = Math.max(0, -(-r * s + o)), h = d > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -d * d + h * (h + 2 * l) + c) : h <= y ? (d = 0, h = Math.min(Math.max(-s, -l), s), p = h * (h + 2 * l) + c) : (d = Math.max(0, -(r * s + o)), h = d > 0 ? s : Math.min(Math.max(-s, -l), s), p = -d * d + h * (h + 2 * l) + c);
          else h = r > 0 ? -s : s, d = Math.max(0, -(r * h + o)), p = -d * d + h * (h + 2 * l) + c;
          return i && i.copy(this.origin).addScaledVector(this.direction, d), a && a.copy(Ff).addScaledVector(Kl, h), p;
        }
        intersectSphere(t, n) {
          Li.subVectors(t.center, this.origin);
          const i = Li.dot(this.direction), a = Li.dot(Li) - i * i, s = t.radius * t.radius;
          if (a > s) return null;
          const r = Math.sqrt(s - a), o = i - r, l = i + r;
          return l < 0 ? null : o < 0 ? this.at(l, n) : this.at(o, n);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const n = t.normal.dot(this.direction);
          if (n === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
          const i = -(this.origin.dot(t.normal) + t.constant) / n;
          return i >= 0 ? i : null;
        }
        intersectPlane(t, n) {
          const i = this.distanceToPlane(t);
          return i === null ? null : this.at(i, n);
        }
        intersectsPlane(t) {
          const n = t.distanceToPoint(this.origin);
          return n === 0 || t.normal.dot(this.direction) * n < 0;
        }
        intersectBox(t, n) {
          let i, a, s, r, o, l;
          const c = 1 / this.direction.x, f = 1 / this.direction.y, d = 1 / this.direction.z, h = this.origin;
          return c >= 0 ? (i = (t.min.x - h.x) * c, a = (t.max.x - h.x) * c) : (i = (t.max.x - h.x) * c, a = (t.min.x - h.x) * c), f >= 0 ? (s = (t.min.y - h.y) * f, r = (t.max.y - h.y) * f) : (s = (t.max.y - h.y) * f, r = (t.min.y - h.y) * f), i > r || s > a || ((s > i || isNaN(i)) && (i = s), (r < a || isNaN(a)) && (a = r), d >= 0 ? (o = (t.min.z - h.z) * d, l = (t.max.z - h.z) * d) : (o = (t.max.z - h.z) * d, l = (t.min.z - h.z) * d), i > l || o > a) || ((o > i || i !== i) && (i = o), (l < a || a !== a) && (a = l), a < 0) ? null : this.at(i >= 0 ? i : a, n);
        }
        intersectsBox(t) {
          return this.intersectBox(t, Li) !== null;
        }
        intersectTriangle(t, n, i, a, s) {
          If.subVectors(n, t), Ql.subVectors(i, t), Hf.crossVectors(If, Ql);
          let r = this.direction.dot(Hf), o;
          if (r > 0) {
            if (a) return null;
            o = 1;
          } else if (r < 0) o = -1, r = -r;
          else return null;
          ca.subVectors(this.origin, t);
          const l = o * this.direction.dot(Ql.crossVectors(ca, Ql));
          if (l < 0) return null;
          const c = o * this.direction.dot(If.cross(ca));
          if (c < 0 || l + c > r) return null;
          const f = -o * ca.dot(Hf);
          return f < 0 ? null : this.at(f / r, s);
        }
        applyMatrix4(t) {
          return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
        }
        equals(t) {
          return t.origin.equals(this.origin) && t.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ie {
        constructor(t, n, i, a, s, r, o, l, c, f, d, h, p, y, S, m) {
          ie.prototype.isMatrix4 = true, this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ], t !== void 0 && this.set(t, n, i, a, s, r, o, l, c, f, d, h, p, y, S, m);
        }
        set(t, n, i, a, s, r, o, l, c, f, d, h, p, y, S, m) {
          const u = this.elements;
          return u[0] = t, u[4] = n, u[8] = i, u[12] = a, u[1] = s, u[5] = r, u[9] = o, u[13] = l, u[2] = c, u[6] = f, u[10] = d, u[14] = h, u[3] = p, u[7] = y, u[11] = S, u[15] = m, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ie().fromArray(this.elements);
        }
        copy(t) {
          const n = this.elements, i = t.elements;
          return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this;
        }
        copyPosition(t) {
          const n = this.elements, i = t.elements;
          return n[12] = i[12], n[13] = i[13], n[14] = i[14], this;
        }
        setFromMatrix3(t) {
          const n = t.elements;
          return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(t, n, i) {
          return t.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(t, n, i) {
          return this.set(t.x, n.x, i.x, 0, t.y, n.y, i.y, 0, t.z, n.z, i.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(t) {
          const n = this.elements, i = t.elements, a = 1 / Is.setFromMatrixColumn(t, 0).length(), s = 1 / Is.setFromMatrixColumn(t, 1).length(), r = 1 / Is.setFromMatrixColumn(t, 2).length();
          return n[0] = i[0] * a, n[1] = i[1] * a, n[2] = i[2] * a, n[3] = 0, n[4] = i[4] * s, n[5] = i[5] * s, n[6] = i[6] * s, n[7] = 0, n[8] = i[8] * r, n[9] = i[9] * r, n[10] = i[10] * r, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
        }
        makeRotationFromEuler(t) {
          const n = this.elements, i = t.x, a = t.y, s = t.z, r = Math.cos(i), o = Math.sin(i), l = Math.cos(a), c = Math.sin(a), f = Math.cos(s), d = Math.sin(s);
          if (t.order === "XYZ") {
            const h = r * f, p = r * d, y = o * f, S = o * d;
            n[0] = l * f, n[4] = -l * d, n[8] = c, n[1] = p + y * c, n[5] = h - S * c, n[9] = -o * l, n[2] = S - h * c, n[6] = y + p * c, n[10] = r * l;
          } else if (t.order === "YXZ") {
            const h = l * f, p = l * d, y = c * f, S = c * d;
            n[0] = h + S * o, n[4] = y * o - p, n[8] = r * c, n[1] = r * d, n[5] = r * f, n[9] = -o, n[2] = p * o - y, n[6] = S + h * o, n[10] = r * l;
          } else if (t.order === "ZXY") {
            const h = l * f, p = l * d, y = c * f, S = c * d;
            n[0] = h - S * o, n[4] = -r * d, n[8] = y + p * o, n[1] = p + y * o, n[5] = r * f, n[9] = S - h * o, n[2] = -r * c, n[6] = o, n[10] = r * l;
          } else if (t.order === "ZYX") {
            const h = r * f, p = r * d, y = o * f, S = o * d;
            n[0] = l * f, n[4] = y * c - p, n[8] = h * c + S, n[1] = l * d, n[5] = S * c + h, n[9] = p * c - y, n[2] = -c, n[6] = o * l, n[10] = r * l;
          } else if (t.order === "YZX") {
            const h = r * l, p = r * c, y = o * l, S = o * c;
            n[0] = l * f, n[4] = S - h * d, n[8] = y * d + p, n[1] = d, n[5] = r * f, n[9] = -o * f, n[2] = -c * f, n[6] = p * d + y, n[10] = h - S * d;
          } else if (t.order === "XZY") {
            const h = r * l, p = r * c, y = o * l, S = o * c;
            n[0] = l * f, n[4] = -d, n[8] = c * f, n[1] = h * d + S, n[5] = r * f, n[9] = p * d - y, n[2] = y * d - p, n[6] = o * f, n[10] = S * d + h;
          }
          return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
        }
        makeRotationFromQuaternion(t) {
          return this.compose(M1, t, E1);
        }
        lookAt(t, n, i) {
          const a = this.elements;
          return Mn.subVectors(t, n), Mn.lengthSq() === 0 && (Mn.z = 1), Mn.normalize(), ua.crossVectors(i, Mn), ua.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Mn.x += 1e-4 : Mn.z += 1e-4, Mn.normalize(), ua.crossVectors(i, Mn)), ua.normalize(), Jl.crossVectors(Mn, ua), a[0] = ua.x, a[4] = Jl.x, a[8] = Mn.x, a[1] = ua.y, a[5] = Jl.y, a[9] = Mn.y, a[2] = ua.z, a[6] = Jl.z, a[10] = Mn.z, this;
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, n) {
          const i = t.elements, a = n.elements, s = this.elements, r = i[0], o = i[4], l = i[8], c = i[12], f = i[1], d = i[5], h = i[9], p = i[13], y = i[2], S = i[6], m = i[10], u = i[14], _ = i[3], g = i[7], v = i[11], T = i[15], R = a[0], w = a[4], D = a[8], b = a[12], x = a[1], C = a[5], V = a[9], I = a[13], X = a[2], Q = a[6], L = a[10], W = a[14], B = a[3], $ = a[7], it = a[11], gt = a[15];
          return s[0] = r * R + o * x + l * X + c * B, s[4] = r * w + o * C + l * Q + c * $, s[8] = r * D + o * V + l * L + c * it, s[12] = r * b + o * I + l * W + c * gt, s[1] = f * R + d * x + h * X + p * B, s[5] = f * w + d * C + h * Q + p * $, s[9] = f * D + d * V + h * L + p * it, s[13] = f * b + d * I + h * W + p * gt, s[2] = y * R + S * x + m * X + u * B, s[6] = y * w + S * C + m * Q + u * $, s[10] = y * D + S * V + m * L + u * it, s[14] = y * b + S * I + m * W + u * gt, s[3] = _ * R + g * x + v * X + T * B, s[7] = _ * w + g * C + v * Q + T * $, s[11] = _ * D + g * V + v * L + T * it, s[15] = _ * b + g * I + v * W + T * gt, this;
        }
        multiplyScalar(t) {
          const n = this.elements;
          return n[0] *= t, n[4] *= t, n[8] *= t, n[12] *= t, n[1] *= t, n[5] *= t, n[9] *= t, n[13] *= t, n[2] *= t, n[6] *= t, n[10] *= t, n[14] *= t, n[3] *= t, n[7] *= t, n[11] *= t, n[15] *= t, this;
        }
        determinant() {
          const t = this.elements, n = t[0], i = t[4], a = t[8], s = t[12], r = t[1], o = t[5], l = t[9], c = t[13], f = t[2], d = t[6], h = t[10], p = t[14], y = t[3], S = t[7], m = t[11], u = t[15];
          return y * (+s * l * d - a * c * d - s * o * h + i * c * h + a * o * p - i * l * p) + S * (+n * l * p - n * c * h + s * r * h - a * r * p + a * c * f - s * l * f) + m * (+n * c * d - n * o * p - s * r * d + i * r * p + s * o * f - i * c * f) + u * (-a * o * f - n * l * d + n * o * h + a * r * d - i * r * h + i * l * f);
        }
        transpose() {
          const t = this.elements;
          let n;
          return n = t[1], t[1] = t[4], t[4] = n, n = t[2], t[2] = t[8], t[8] = n, n = t[6], t[6] = t[9], t[9] = n, n = t[3], t[3] = t[12], t[12] = n, n = t[7], t[7] = t[13], t[13] = n, n = t[11], t[11] = t[14], t[14] = n, this;
        }
        setPosition(t, n, i) {
          const a = this.elements;
          return t.isVector3 ? (a[12] = t.x, a[13] = t.y, a[14] = t.z) : (a[12] = t, a[13] = n, a[14] = i), this;
        }
        invert() {
          const t = this.elements, n = t[0], i = t[1], a = t[2], s = t[3], r = t[4], o = t[5], l = t[6], c = t[7], f = t[8], d = t[9], h = t[10], p = t[11], y = t[12], S = t[13], m = t[14], u = t[15], _ = d * m * c - S * h * c + S * l * p - o * m * p - d * l * u + o * h * u, g = y * h * c - f * m * c - y * l * p + r * m * p + f * l * u - r * h * u, v = f * S * c - y * d * c + y * o * p - r * S * p - f * o * u + r * d * u, T = y * d * l - f * S * l - y * o * h + r * S * h + f * o * m - r * d * m, R = n * _ + i * g + a * v + s * T;
          if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const w = 1 / R;
          return t[0] = _ * w, t[1] = (S * h * s - d * m * s - S * a * p + i * m * p + d * a * u - i * h * u) * w, t[2] = (o * m * s - S * l * s + S * a * c - i * m * c - o * a * u + i * l * u) * w, t[3] = (d * l * s - o * h * s - d * a * c + i * h * c + o * a * p - i * l * p) * w, t[4] = g * w, t[5] = (f * m * s - y * h * s + y * a * p - n * m * p - f * a * u + n * h * u) * w, t[6] = (y * l * s - r * m * s - y * a * c + n * m * c + r * a * u - n * l * u) * w, t[7] = (r * h * s - f * l * s + f * a * c - n * h * c - r * a * p + n * l * p) * w, t[8] = v * w, t[9] = (y * d * s - f * S * s - y * i * p + n * S * p + f * i * u - n * d * u) * w, t[10] = (r * S * s - y * o * s + y * i * c - n * S * c - r * i * u + n * o * u) * w, t[11] = (f * o * s - r * d * s - f * i * c + n * d * c + r * i * p - n * o * p) * w, t[12] = T * w, t[13] = (f * S * a - y * d * a + y * i * h - n * S * h - f * i * m + n * d * m) * w, t[14] = (y * o * a - r * S * a - y * i * l + n * S * l + r * i * m - n * o * m) * w, t[15] = (r * d * a - f * o * a + f * i * l - n * d * l - r * i * h + n * o * h) * w, this;
        }
        scale(t) {
          const n = this.elements, i = t.x, a = t.y, s = t.z;
          return n[0] *= i, n[4] *= a, n[8] *= s, n[1] *= i, n[5] *= a, n[9] *= s, n[2] *= i, n[6] *= a, n[10] *= s, n[3] *= i, n[7] *= a, n[11] *= s, this;
        }
        getMaxScaleOnAxis() {
          const t = this.elements, n = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], a = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(n, i, a));
        }
        makeTranslation(t, n, i) {
          return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, n, 0, 0, 1, i, 0, 0, 0, 1), this;
        }
        makeRotationX(t) {
          const n = Math.cos(t), i = Math.sin(t);
          return this.set(1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(t) {
          const n = Math.cos(t), i = Math.sin(t);
          return this.set(n, 0, i, 0, 0, 1, 0, 0, -i, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(t) {
          const n = Math.cos(t), i = Math.sin(t);
          return this.set(n, -i, 0, 0, i, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(t, n) {
          const i = Math.cos(n), a = Math.sin(n), s = 1 - i, r = t.x, o = t.y, l = t.z, c = s * r, f = s * o;
          return this.set(c * r + i, c * o - a * l, c * l + a * o, 0, c * o + a * l, f * o + i, f * l - a * r, 0, c * l - a * o, f * l + a * r, s * l * l + i, 0, 0, 0, 0, 1), this;
        }
        makeScale(t, n, i) {
          return this.set(t, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, n, i, a, s, r) {
          return this.set(1, i, s, 0, t, 1, r, 0, n, a, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, n, i) {
          const a = this.elements, s = n._x, r = n._y, o = n._z, l = n._w, c = s + s, f = r + r, d = o + o, h = s * c, p = s * f, y = s * d, S = r * f, m = r * d, u = o * d, _ = l * c, g = l * f, v = l * d, T = i.x, R = i.y, w = i.z;
          return a[0] = (1 - (S + u)) * T, a[1] = (p + v) * T, a[2] = (y - g) * T, a[3] = 0, a[4] = (p - v) * R, a[5] = (1 - (h + u)) * R, a[6] = (m + _) * R, a[7] = 0, a[8] = (y + g) * w, a[9] = (m - _) * w, a[10] = (1 - (h + S)) * w, a[11] = 0, a[12] = t.x, a[13] = t.y, a[14] = t.z, a[15] = 1, this;
        }
        decompose(t, n, i) {
          const a = this.elements;
          let s = Is.set(a[0], a[1], a[2]).length();
          const r = Is.set(a[4], a[5], a[6]).length(), o = Is.set(a[8], a[9], a[10]).length();
          this.determinant() < 0 && (s = -s), t.x = a[12], t.y = a[13], t.z = a[14], ai.copy(this);
          const c = 1 / s, f = 1 / r, d = 1 / o;
          return ai.elements[0] *= c, ai.elements[1] *= c, ai.elements[2] *= c, ai.elements[4] *= f, ai.elements[5] *= f, ai.elements[6] *= f, ai.elements[8] *= d, ai.elements[9] *= d, ai.elements[10] *= d, n.setFromRotationMatrix(ai), i.x = s, i.y = r, i.z = o, this;
        }
        makePerspective(t, n, i, a, s, r, o = qi) {
          const l = this.elements, c = 2 * s / (n - t), f = 2 * s / (i - a), d = (n + t) / (n - t), h = (i + a) / (i - a);
          let p, y;
          if (o === qi) p = -(r + s) / (r - s), y = -2 * r * s / (r - s);
          else if (o === _u) p = -r / (r - s), y = -r * s / (r - s);
          else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
          return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = f, l[9] = h, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = y, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
        }
        makeOrthographic(t, n, i, a, s, r, o = qi) {
          const l = this.elements, c = 1 / (n - t), f = 1 / (i - a), d = 1 / (r - s), h = (n + t) * c, p = (i + a) * f;
          let y, S;
          if (o === qi) y = (r + s) * d, S = -2 * d;
          else if (o === _u) y = s * d, S = -1 * d;
          else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
          return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -h, l[1] = 0, l[5] = 2 * f, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = S, l[14] = -y, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
        }
        equals(t) {
          const n = this.elements, i = t.elements;
          for (let a = 0; a < 16; a++) if (n[a] !== i[a]) return false;
          return true;
        }
        fromArray(t, n = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = t[i + n];
          return this;
        }
        toArray(t = [], n = 0) {
          const i = this.elements;
          return t[n] = i[0], t[n + 1] = i[1], t[n + 2] = i[2], t[n + 3] = i[3], t[n + 4] = i[4], t[n + 5] = i[5], t[n + 6] = i[6], t[n + 7] = i[7], t[n + 8] = i[8], t[n + 9] = i[9], t[n + 10] = i[10], t[n + 11] = i[11], t[n + 12] = i[12], t[n + 13] = i[13], t[n + 14] = i[14], t[n + 15] = i[15], t;
        }
      }
      const Is = new z(), ai = new ie(), M1 = new z(0, 0, 0), E1 = new z(1, 1, 1), ua = new z(), Jl = new z(), Mn = new z(), sg = new ie(), rg = new xs();
      class Mi {
        constructor(t = 0, n = 0, i = 0, a = Mi.DEFAULT_ORDER) {
          this.isEuler = true, this._x = t, this._y = n, this._z = i, this._order = a;
        }
        get x() {
          return this._x;
        }
        set x(t) {
          this._x = t, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          this._y = t, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          this._z = t, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          this._order = t, this._onChangeCallback();
        }
        set(t, n, i, a = this._order) {
          return this._x = t, this._y = n, this._z = i, this._order = a, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t, n = this._order, i = true) {
          const a = t.elements, s = a[0], r = a[4], o = a[8], l = a[1], c = a[5], f = a[9], d = a[2], h = a[6], p = a[10];
          switch (n) {
            case "XYZ":
              this._y = Math.asin(Gt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-f, p), this._z = Math.atan2(-r, s)) : (this._x = Math.atan2(h, c), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-Gt(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, s), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(Gt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(-d, p), this._z = Math.atan2(-r, c)) : (this._y = 0, this._z = Math.atan2(l, s));
              break;
            case "ZYX":
              this._y = Math.asin(-Gt(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(h, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-r, c));
              break;
            case "YZX":
              this._z = Math.asin(Gt(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-f, c), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(o, p));
              break;
            case "XZY":
              this._z = Math.asin(-Gt(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-f, p), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
          }
          return this._order = n, i === true && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, n, i) {
          return sg.makeRotationFromQuaternion(t), this.setFromRotationMatrix(sg, n, i);
        }
        setFromVector3(t, n = this._order) {
          return this.set(t.x, t.y, t.z, n);
        }
        reorder(t) {
          return rg.setFromEuler(this), this.setFromQuaternion(rg, t);
        }
        equals(t) {
          return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
        }
        fromArray(t) {
          return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
        }
        toArray(t = [], n = 0) {
          return t[n] = this._x, t[n + 1] = this._y, t[n + 2] = this._z, t[n + 3] = this._order, t;
        }
        _onChange(t) {
          return this._onChangeCallback = t, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      Mi.DEFAULT_ORDER = "XYZ";
      class om {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = (1 << t | 0) >>> 0;
        }
        enable(t) {
          this.mask |= 1 << t | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= 1 << t | 0;
        }
        disable(t) {
          this.mask &= ~(1 << t | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return (this.mask & t.mask) !== 0;
        }
        isEnabled(t) {
          return (this.mask & (1 << t | 0)) !== 0;
        }
      }
      let b1 = 0;
      const og = new z(), Hs = new xs(), Ni = new ie(), $l = new z(), mo = new z(), T1 = new z(), A1 = new xs(), lg = new z(1, 0, 0), cg = new z(0, 1, 0), ug = new z(0, 0, 1), fg = {
        type: "added"
      }, R1 = {
        type: "removed"
      }, Gs = {
        type: "childadded",
        child: null
      }, Gf = {
        type: "childremoved",
        child: null
      };
      class tn extends ws {
        constructor() {
          super(), this.isObject3D = true, Object.defineProperty(this, "id", {
            value: b1++
          }), this.uuid = Jr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = tn.DEFAULT_UP.clone();
          const t = new z(), n = new Mi(), i = new xs(), a = new z(1, 1, 1);
          function s() {
            i.setFromEuler(n, false);
          }
          function r() {
            n.setFromQuaternion(i, void 0, false);
          }
          n._onChange(s), i._onChange(r), Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: t
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: n
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: i
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: a
            },
            modelViewMatrix: {
              value: new ie()
            },
            normalMatrix: {
              value: new Pt()
            }
          }), this.matrix = new ie(), this.matrixWorld = new ie(), this.matrixAutoUpdate = tn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = tn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new om(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
        }
        onBeforeShadow() {
        }
        onAfterShadow() {
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, n) {
          this.quaternion.setFromAxisAngle(t, n);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, true);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, n) {
          return Hs.setFromAxisAngle(t, n), this.quaternion.multiply(Hs), this;
        }
        rotateOnWorldAxis(t, n) {
          return Hs.setFromAxisAngle(t, n), this.quaternion.premultiply(Hs), this;
        }
        rotateX(t) {
          return this.rotateOnAxis(lg, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(cg, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(ug, t);
        }
        translateOnAxis(t, n) {
          return og.copy(t).applyQuaternion(this.quaternion), this.position.add(og.multiplyScalar(n)), this;
        }
        translateX(t) {
          return this.translateOnAxis(lg, t);
        }
        translateY(t) {
          return this.translateOnAxis(cg, t);
        }
        translateZ(t) {
          return this.translateOnAxis(ug, t);
        }
        localToWorld(t) {
          return this.updateWorldMatrix(true, false), t.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t) {
          return this.updateWorldMatrix(true, false), t.applyMatrix4(Ni.copy(this.matrixWorld).invert());
        }
        lookAt(t, n, i) {
          t.isVector3 ? $l.copy(t) : $l.set(t, n, i);
          const a = this.parent;
          this.updateWorldMatrix(true, false), mo.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ni.lookAt(mo, $l, this.up) : Ni.lookAt($l, mo, this.up), this.quaternion.setFromRotationMatrix(Ni), a && (Ni.extractRotation(a.matrixWorld), Hs.setFromRotationMatrix(Ni), this.quaternion.premultiply(Hs.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
            return this;
          }
          return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(fg), Gs.child = t, this.dispatchEvent(Gs), Gs.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
          }
          const n = this.children.indexOf(t);
          return n !== -1 && (t.parent = null, this.children.splice(n, 1), t.dispatchEvent(R1), Gf.child = t, this.dispatchEvent(Gf), Gf.child = null), this;
        }
        removeFromParent() {
          const t = this.parent;
          return t !== null && t.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(t) {
          return this.updateWorldMatrix(true, false), Ni.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(true, false), Ni.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ni), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(false, true), t.dispatchEvent(fg), Gs.child = t, this.dispatchEvent(Gs), Gs.child = null, this;
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, n) {
          if (this[t] === n) return this;
          for (let i = 0, a = this.children.length; i < a; i++) {
            const r = this.children[i].getObjectByProperty(t, n);
            if (r !== void 0) return r;
          }
        }
        getObjectsByProperty(t, n, i = []) {
          this[t] === n && i.push(this);
          const a = this.children;
          for (let s = 0, r = a.length; s < r; s++) a[s].getObjectsByProperty(t, n, i);
          return i;
        }
        getWorldPosition(t) {
          return this.updateWorldMatrix(true, false), t.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(t) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(mo, t, T1), t;
        }
        getWorldScale(t) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(mo, A1, t), t;
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(true, false);
          const n = this.matrixWorld.elements;
          return t.set(n[8], n[9], n[10]).normalize();
        }
        raycast() {
        }
        traverse(t) {
          t(this);
          const n = this.children;
          for (let i = 0, a = n.length; i < a; i++) n[i].traverse(t);
        }
        traverseVisible(t) {
          if (this.visible === false) return;
          t(this);
          const n = this.children;
          for (let i = 0, a = n.length; i < a; i++) n[i].traverseVisible(t);
        }
        traverseAncestors(t) {
          const n = this.parent;
          n !== null && (t(n), n.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, t = true);
          const n = this.children;
          for (let i = 0, a = n.length; i < a; i++) n[i].updateMatrixWorld(t);
        }
        updateWorldMatrix(t, n) {
          const i = this.parent;
          if (t === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === true) {
            const a = this.children;
            for (let s = 0, r = a.length; s < r; s++) a[s].updateWorldMatrix(false, true);
          }
        }
        toJSON(t) {
          const n = t === void 0 || typeof t == "string", i = {};
          n && (t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          }, i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
          });
          const a = {};
          a.uuid = this.uuid, a.type = this.type, this.name !== "" && (a.name = this.name), this.castShadow === true && (a.castShadow = true), this.receiveShadow === true && (a.receiveShadow = true), this.visible === false && (a.visible = false), this.frustumCulled === false && (a.frustumCulled = false), this.renderOrder !== 0 && (a.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), a.up = this.up.toArray(), this.matrixAutoUpdate === false && (a.matrixAutoUpdate = false), this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (a.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (a.type = "BatchedMesh", a.perObjectFrustumCulled = this.perObjectFrustumCulled, a.sortObjects = this.sortObjects, a.drawRanges = this._drawRanges, a.reservedRanges = this._reservedRanges, a.visibility = this._visibility, a.active = this._active, a.bounds = this._bounds.map((o) => ({
            boxInitialized: o.boxInitialized,
            boxMin: o.box.min.toArray(),
            boxMax: o.box.max.toArray(),
            sphereInitialized: o.sphereInitialized,
            sphereRadius: o.sphere.radius,
            sphereCenter: o.sphere.center.toArray()
          })), a.maxInstanceCount = this._maxInstanceCount, a.maxVertexCount = this._maxVertexCount, a.maxIndexCount = this._maxIndexCount, a.geometryInitialized = this._geometryInitialized, a.geometryCount = this._geometryCount, a.matricesTexture = this._matricesTexture.toJSON(t), this._colorsTexture !== null && (a.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (a.boundingSphere = {
            center: a.boundingSphere.center.toArray(),
            radius: a.boundingSphere.radius
          }), this.boundingBox !== null && (a.boundingBox = {
            min: a.boundingBox.min.toArray(),
            max: a.boundingBox.max.toArray()
          }));
          function s(o, l) {
            return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(t)), l.uuid;
          }
          if (this.isScene) this.background && (this.background.isColor ? a.background = this.background.toJSON() : this.background.isTexture && (a.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (a.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            a.geometry = s(t.geometries, this.geometry);
            const o = this.geometry.parameters;
            if (o !== void 0 && o.shapes !== void 0) {
              const l = o.shapes;
              if (Array.isArray(l)) for (let c = 0, f = l.length; c < f; c++) {
                const d = l[c];
                s(t.shapes, d);
              }
              else s(t.shapes, l);
            }
          }
          if (this.isSkinnedMesh && (a.bindMode = this.bindMode, a.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), a.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
            const o = [];
            for (let l = 0, c = this.material.length; l < c; l++) o.push(s(t.materials, this.material[l]));
            a.material = o;
          } else a.material = s(t.materials, this.material);
          if (this.children.length > 0) {
            a.children = [];
            for (let o = 0; o < this.children.length; o++) a.children.push(this.children[o].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            a.animations = [];
            for (let o = 0; o < this.animations.length; o++) {
              const l = this.animations[o];
              a.animations.push(s(t.animations, l));
            }
          }
          if (n) {
            const o = r(t.geometries), l = r(t.materials), c = r(t.textures), f = r(t.images), d = r(t.shapes), h = r(t.skeletons), p = r(t.animations), y = r(t.nodes);
            o.length > 0 && (i.geometries = o), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), f.length > 0 && (i.images = f), d.length > 0 && (i.shapes = d), h.length > 0 && (i.skeletons = h), p.length > 0 && (i.animations = p), y.length > 0 && (i.nodes = y);
          }
          return i.object = a, i;
          function r(o) {
            const l = [];
            for (const c in o) {
              const f = o[c];
              delete f.metadata, l.push(f);
            }
            return l;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, n = true) {
          if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), n === true) for (let i = 0; i < t.children.length; i++) {
            const a = t.children[i];
            this.add(a.clone());
          }
          return this;
        }
      }
      tn.DEFAULT_UP = new z(0, 1, 0);
      tn.DEFAULT_MATRIX_AUTO_UPDATE = true;
      tn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
      const si = new z(), Oi = new z(), Vf = new z(), Pi = new z(), Vs = new z(), ks = new z(), hg = new z(), kf = new z(), Xf = new z(), Wf = new z(), Yf = new Ce(), qf = new Ce(), jf = new Ce();
      class li {
        constructor(t = new z(), n = new z(), i = new z()) {
          this.a = t, this.b = n, this.c = i;
        }
        static getNormal(t, n, i, a) {
          a.subVectors(i, n), si.subVectors(t, n), a.cross(si);
          const s = a.lengthSq();
          return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0);
        }
        static getBarycoord(t, n, i, a, s) {
          si.subVectors(a, n), Oi.subVectors(i, n), Vf.subVectors(t, n);
          const r = si.dot(si), o = si.dot(Oi), l = si.dot(Vf), c = Oi.dot(Oi), f = Oi.dot(Vf), d = r * c - o * o;
          if (d === 0) return s.set(0, 0, 0), null;
          const h = 1 / d, p = (c * l - o * f) * h, y = (r * f - o * l) * h;
          return s.set(1 - p - y, y, p);
        }
        static containsPoint(t, n, i, a) {
          return this.getBarycoord(t, n, i, a, Pi) === null ? false : Pi.x >= 0 && Pi.y >= 0 && Pi.x + Pi.y <= 1;
        }
        static getInterpolation(t, n, i, a, s, r, o, l) {
          return this.getBarycoord(t, n, i, a, Pi) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, Pi.x), l.addScaledVector(r, Pi.y), l.addScaledVector(o, Pi.z), l);
        }
        static getInterpolatedAttribute(t, n, i, a, s, r) {
          return Yf.setScalar(0), qf.setScalar(0), jf.setScalar(0), Yf.fromBufferAttribute(t, n), qf.fromBufferAttribute(t, i), jf.fromBufferAttribute(t, a), r.setScalar(0), r.addScaledVector(Yf, s.x), r.addScaledVector(qf, s.y), r.addScaledVector(jf, s.z), r;
        }
        static isFrontFacing(t, n, i, a) {
          return si.subVectors(i, n), Oi.subVectors(t, n), si.cross(Oi).dot(a) < 0;
        }
        set(t, n, i) {
          return this.a.copy(t), this.b.copy(n), this.c.copy(i), this;
        }
        setFromPointsAndIndices(t, n, i, a) {
          return this.a.copy(t[n]), this.b.copy(t[i]), this.c.copy(t[a]), this;
        }
        setFromAttributeAndIndices(t, n, i, a) {
          return this.a.fromBufferAttribute(t, n), this.b.fromBufferAttribute(t, i), this.c.fromBufferAttribute(t, a), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return si.subVectors(this.c, this.b), Oi.subVectors(this.a, this.b), si.cross(Oi).length() * 0.5;
        }
        getMidpoint(t) {
          return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return li.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, n) {
          return li.getBarycoord(t, this.a, this.b, this.c, n);
        }
        getInterpolation(t, n, i, a, s) {
          return li.getInterpolation(t, this.a, this.b, this.c, n, i, a, s);
        }
        containsPoint(t) {
          return li.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return li.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, n) {
          const i = this.a, a = this.b, s = this.c;
          let r, o;
          Vs.subVectors(a, i), ks.subVectors(s, i), kf.subVectors(t, i);
          const l = Vs.dot(kf), c = ks.dot(kf);
          if (l <= 0 && c <= 0) return n.copy(i);
          Xf.subVectors(t, a);
          const f = Vs.dot(Xf), d = ks.dot(Xf);
          if (f >= 0 && d <= f) return n.copy(a);
          const h = l * d - f * c;
          if (h <= 0 && l >= 0 && f <= 0) return r = l / (l - f), n.copy(i).addScaledVector(Vs, r);
          Wf.subVectors(t, s);
          const p = Vs.dot(Wf), y = ks.dot(Wf);
          if (y >= 0 && p <= y) return n.copy(s);
          const S = p * c - l * y;
          if (S <= 0 && c >= 0 && y <= 0) return o = c / (c - y), n.copy(i).addScaledVector(ks, o);
          const m = f * y - p * d;
          if (m <= 0 && d - f >= 0 && p - y >= 0) return hg.subVectors(s, a), o = (d - f) / (d - f + (p - y)), n.copy(a).addScaledVector(hg, o);
          const u = 1 / (m + S + h);
          return r = S * u, o = h * u, n.copy(i).addScaledVector(Vs, r).addScaledVector(ks, o);
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      }
      const xS = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      }, fa = {
        h: 0,
        s: 0,
        l: 0
      }, tc = {
        h: 0,
        s: 0,
        l: 0
      };
      function Zf(e, t, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * 6 * (2 / 3 - n) : e;
      }
      class It {
        constructor(t, n, i) {
          return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(t, n, i);
        }
        set(t, n, i) {
          if (n === void 0 && i === void 0) {
            const a = t;
            a && a.isColor ? this.copy(a) : typeof a == "number" ? this.setHex(a) : typeof a == "string" && this.setStyle(a);
          } else this.setRGB(t, n, i);
          return this;
        }
        setScalar(t) {
          return this.r = t, this.g = t, this.b = t, this;
        }
        setHex(t, n = Gn) {
          return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, te.toWorkingColorSpace(this, n), this;
        }
        setRGB(t, n, i, a = te.workingColorSpace) {
          return this.r = t, this.g = n, this.b = i, te.toWorkingColorSpace(this, a), this;
        }
        setHSL(t, n, i, a = te.workingColorSpace) {
          if (t = rm(t, 1), n = Gt(n, 0, 1), i = Gt(i, 0, 1), n === 0) this.r = this.g = this.b = i;
          else {
            const s = i <= 0.5 ? i * (1 + n) : i + n - i * n, r = 2 * i - s;
            this.r = Zf(r, s, t + 1 / 3), this.g = Zf(r, s, t), this.b = Zf(r, s, t - 1 / 3);
          }
          return te.toWorkingColorSpace(this, a), this;
        }
        setStyle(t, n = Gn) {
          function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
          }
          let a;
          if (a = /^(\w+)\(([^\)]*)\)/.exec(t)) {
            let s;
            const r = a[1], o = a[2];
            switch (r) {
              case "rgb":
              case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, n);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, n);
                break;
              case "hsl":
              case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, n);
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + t);
            }
          } else if (a = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const s = a[1], r = s.length;
            if (r === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, n);
            if (r === 6) return this.setHex(parseInt(s, 16), n);
            console.warn("THREE.Color: Invalid hex color " + t);
          } else if (t && t.length > 0) return this.setColorName(t, n);
          return this;
        }
        setColorName(t, n = Gn) {
          const i = xS[t.toLowerCase()];
          return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + t), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return this.r = t.r, this.g = t.g, this.b = t.b, this;
        }
        copySRGBToLinear(t) {
          return this.r = Zi(t.r), this.g = Zi(t.g), this.b = Zi(t.b), this;
        }
        copyLinearToSRGB(t) {
          return this.r = Ar(t.r), this.g = Ar(t.g), this.b = Ar(t.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(t = Gn) {
          return te.fromWorkingColorSpace(an.copy(this), t), Math.round(Gt(an.r * 255, 0, 255)) * 65536 + Math.round(Gt(an.g * 255, 0, 255)) * 256 + Math.round(Gt(an.b * 255, 0, 255));
        }
        getHexString(t = Gn) {
          return ("000000" + this.getHex(t).toString(16)).slice(-6);
        }
        getHSL(t, n = te.workingColorSpace) {
          te.fromWorkingColorSpace(an.copy(this), n);
          const i = an.r, a = an.g, s = an.b, r = Math.max(i, a, s), o = Math.min(i, a, s);
          let l, c;
          const f = (o + r) / 2;
          if (o === r) l = 0, c = 0;
          else {
            const d = r - o;
            switch (c = f <= 0.5 ? d / (r + o) : d / (2 - r - o), r) {
              case i:
                l = (a - s) / d + (a < s ? 6 : 0);
                break;
              case a:
                l = (s - i) / d + 2;
                break;
              case s:
                l = (i - a) / d + 4;
                break;
            }
            l /= 6;
          }
          return t.h = l, t.s = c, t.l = f, t;
        }
        getRGB(t, n = te.workingColorSpace) {
          return te.fromWorkingColorSpace(an.copy(this), n), t.r = an.r, t.g = an.g, t.b = an.b, t;
        }
        getStyle(t = Gn) {
          te.fromWorkingColorSpace(an.copy(this), t);
          const n = an.r, i = an.g, a = an.b;
          return t !== Gn ? `color(${t} ${n.toFixed(3)} ${i.toFixed(3)} ${a.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(a * 255)})`;
        }
        offsetHSL(t, n, i) {
          return this.getHSL(fa), this.setHSL(fa.h + t, fa.s + n, fa.l + i);
        }
        add(t) {
          return this.r += t.r, this.g += t.g, this.b += t.b, this;
        }
        addColors(t, n) {
          return this.r = t.r + n.r, this.g = t.g + n.g, this.b = t.b + n.b, this;
        }
        addScalar(t) {
          return this.r += t, this.g += t, this.b += t, this;
        }
        sub(t) {
          return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
        }
        multiply(t) {
          return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
        }
        multiplyScalar(t) {
          return this.r *= t, this.g *= t, this.b *= t, this;
        }
        lerp(t, n) {
          return this.r += (t.r - this.r) * n, this.g += (t.g - this.g) * n, this.b += (t.b - this.b) * n, this;
        }
        lerpColors(t, n, i) {
          return this.r = t.r + (n.r - t.r) * i, this.g = t.g + (n.g - t.g) * i, this.b = t.b + (n.b - t.b) * i, this;
        }
        lerpHSL(t, n) {
          this.getHSL(fa), t.getHSL(tc);
          const i = ko(fa.h, tc.h, n), a = ko(fa.s, tc.s, n), s = ko(fa.l, tc.l, n);
          return this.setHSL(i, a, s), this;
        }
        setFromVector3(t) {
          return this.r = t.x, this.g = t.y, this.b = t.z, this;
        }
        applyMatrix3(t) {
          const n = this.r, i = this.g, a = this.b, s = t.elements;
          return this.r = s[0] * n + s[3] * i + s[6] * a, this.g = s[1] * n + s[4] * i + s[7] * a, this.b = s[2] * n + s[5] * i + s[8] * a, this;
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, n = 0) {
          return this.r = t[n], this.g = t[n + 1], this.b = t[n + 2], this;
        }
        toArray(t = [], n = 0) {
          return t[n] = this.r, t[n + 1] = this.g, t[n + 2] = this.b, t;
        }
        fromBufferAttribute(t, n) {
          return this.r = t.getX(n), this.g = t.getY(n), this.b = t.getZ(n), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const an = new It();
      It.NAMES = xS;
      let w1 = 0;
      class to extends ws {
        constructor() {
          super(), this.isMaterial = true, Object.defineProperty(this, "id", {
            value: w1++
          }), this.uuid = Jr(), this.name = "", this.type = "Material", this.blending = br, this.side = Ia, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = ud, this.blendDst = fd, this.blendEquation = es, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new It(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Fr, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Q_, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Os, this.stencilZFail = Os, this.stencilZPass = Os, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t) {
          this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (t !== void 0) for (const n in t) {
            const i = t[n];
            if (i === void 0) {
              console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
              continue;
            }
            const a = this[n];
            if (a === void 0) {
              console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
              continue;
            }
            a && a.isColor ? a.set(i) : a && a.isVector3 && i && i.isVector3 ? a.copy(i) : this[n] = i;
          }
        }
        toJSON(t) {
          const n = t === void 0 || typeof t == "string";
          n && (t = {
            textures: {},
            images: {}
          });
          const i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== br && (i.blending = this.blending), this.side !== Ia && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== ud && (i.blendSrc = this.blendSrc), this.blendDst !== fd && (i.blendDst = this.blendDst), this.blendEquation !== es && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Fr && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Q_ && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Os && (i.stencilFail = this.stencilFail), this.stencilZFail !== Os && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Os && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
          function a(s) {
            const r = [];
            for (const o in s) {
              const l = s[o];
              delete l.metadata, r.push(l);
            }
            return r;
          }
          if (n) {
            const s = a(t.textures), r = a(t.images);
            s.length > 0 && (i.textures = s), r.length > 0 && (i.images = r);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
          const n = t.clippingPlanes;
          let i = null;
          if (n !== null) {
            const a = n.length;
            i = new Array(a);
            for (let s = 0; s !== a; ++s) i[s] = n[s].clone();
          }
          return this.clippingPlanes = i, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      }
      class MS extends to {
        constructor(t) {
          super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new It(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Mi(), this.combine = sS, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
        }
      }
      const Ne = new z(), ec = new Ut();
      class fi {
        constructor(t, n, i = false) {
          if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = true, this.name = "", this.array = t, this.itemSize = n, this.count = t !== void 0 ? t.length / n : 0, this.normalized = i, this.usage = J_, this.updateRanges = [], this.gpuType = gi, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(t) {
          t === true && this.version++;
        }
        setUsage(t) {
          return this.usage = t, this;
        }
        addUpdateRange(t, n) {
          this.updateRanges.push({
            start: t,
            count: n
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(t) {
          return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
        }
        copyAt(t, n, i) {
          t *= this.itemSize, i *= n.itemSize;
          for (let a = 0, s = this.itemSize; a < s; a++) this.array[t + a] = n.array[i + a];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        applyMatrix3(t) {
          if (this.itemSize === 2) for (let n = 0, i = this.count; n < i; n++) ec.fromBufferAttribute(this, n), ec.applyMatrix3(t), this.setXY(n, ec.x, ec.y);
          else if (this.itemSize === 3) for (let n = 0, i = this.count; n < i; n++) Ne.fromBufferAttribute(this, n), Ne.applyMatrix3(t), this.setXYZ(n, Ne.x, Ne.y, Ne.z);
          return this;
        }
        applyMatrix4(t) {
          for (let n = 0, i = this.count; n < i; n++) Ne.fromBufferAttribute(this, n), Ne.applyMatrix4(t), this.setXYZ(n, Ne.x, Ne.y, Ne.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let n = 0, i = this.count; n < i; n++) Ne.fromBufferAttribute(this, n), Ne.applyNormalMatrix(t), this.setXYZ(n, Ne.x, Ne.y, Ne.z);
          return this;
        }
        transformDirection(t) {
          for (let n = 0, i = this.count; n < i; n++) Ne.fromBufferAttribute(this, n), Ne.transformDirection(t), this.setXYZ(n, Ne.x, Ne.y, Ne.z);
          return this;
        }
        set(t, n = 0) {
          return this.array.set(t, n), this;
        }
        getComponent(t, n) {
          let i = this.array[t * this.itemSize + n];
          return this.normalized && (i = $s(i, this.array)), i;
        }
        setComponent(t, n, i) {
          return this.normalized && (i = ln(i, this.array)), this.array[t * this.itemSize + n] = i, this;
        }
        getX(t) {
          let n = this.array[t * this.itemSize];
          return this.normalized && (n = $s(n, this.array)), n;
        }
        setX(t, n) {
          return this.normalized && (n = ln(n, this.array)), this.array[t * this.itemSize] = n, this;
        }
        getY(t) {
          let n = this.array[t * this.itemSize + 1];
          return this.normalized && (n = $s(n, this.array)), n;
        }
        setY(t, n) {
          return this.normalized && (n = ln(n, this.array)), this.array[t * this.itemSize + 1] = n, this;
        }
        getZ(t) {
          let n = this.array[t * this.itemSize + 2];
          return this.normalized && (n = $s(n, this.array)), n;
        }
        setZ(t, n) {
          return this.normalized && (n = ln(n, this.array)), this.array[t * this.itemSize + 2] = n, this;
        }
        getW(t) {
          let n = this.array[t * this.itemSize + 3];
          return this.normalized && (n = $s(n, this.array)), n;
        }
        setW(t, n) {
          return this.normalized && (n = ln(n, this.array)), this.array[t * this.itemSize + 3] = n, this;
        }
        setXY(t, n, i) {
          return t *= this.itemSize, this.normalized && (n = ln(n, this.array), i = ln(i, this.array)), this.array[t + 0] = n, this.array[t + 1] = i, this;
        }
        setXYZ(t, n, i, a) {
          return t *= this.itemSize, this.normalized && (n = ln(n, this.array), i = ln(i, this.array), a = ln(a, this.array)), this.array[t + 0] = n, this.array[t + 1] = i, this.array[t + 2] = a, this;
        }
        setXYZW(t, n, i, a, s) {
          return t *= this.itemSize, this.normalized && (n = ln(n, this.array), i = ln(i, this.array), a = ln(a, this.array), s = ln(s, this.array)), this.array[t + 0] = n, this.array[t + 1] = i, this.array[t + 2] = a, this.array[t + 3] = s, this;
        }
        onUpload(t) {
          return this.onUploadCallback = t, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          return this.name !== "" && (t.name = this.name), this.usage !== J_ && (t.usage = this.usage), t;
        }
      }
      class ES extends fi {
        constructor(t, n, i) {
          super(new Uint16Array(t), n, i);
        }
      }
      class bS extends fi {
        constructor(t, n, i) {
          super(new Uint32Array(t), n, i);
        }
      }
      class Jn extends fi {
        constructor(t, n, i) {
          super(new Float32Array(t), n, i);
        }
      }
      let C1 = 0;
      const In = new ie(), Kf = new tn(), Xs = new z(), En = new Cs(), _o = new Cs(), ke = new z();
      class Ti extends ws {
        constructor() {
          super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
            value: C1++
          }), this.uuid = Jr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
          }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return Array.isArray(t) ? this.index = new (vS(t) ? bS : ES)(t, 1) : this.index = t, this;
        }
        setIndirect(t) {
          return this.indirect = t, this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, n) {
          return this.attributes[t] = n, this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return this.attributes[t] !== void 0;
        }
        addGroup(t, n, i = 0) {
          this.groups.push({
            start: t,
            count: n,
            materialIndex: i
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, n) {
          this.drawRange.start = t, this.drawRange.count = n;
        }
        applyMatrix4(t) {
          const n = this.attributes.position;
          n !== void 0 && (n.applyMatrix4(t), n.needsUpdate = true);
          const i = this.attributes.normal;
          if (i !== void 0) {
            const s = new Pt().getNormalMatrix(t);
            i.applyNormalMatrix(s), i.needsUpdate = true;
          }
          const a = this.attributes.tangent;
          return a !== void 0 && (a.transformDirection(t), a.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(t) {
          return In.makeRotationFromQuaternion(t), this.applyMatrix4(In), this;
        }
        rotateX(t) {
          return In.makeRotationX(t), this.applyMatrix4(In), this;
        }
        rotateY(t) {
          return In.makeRotationY(t), this.applyMatrix4(In), this;
        }
        rotateZ(t) {
          return In.makeRotationZ(t), this.applyMatrix4(In), this;
        }
        translate(t, n, i) {
          return In.makeTranslation(t, n, i), this.applyMatrix4(In), this;
        }
        scale(t, n, i) {
          return In.makeScale(t, n, i), this.applyMatrix4(In), this;
        }
        lookAt(t) {
          return Kf.lookAt(t), Kf.updateMatrix(), this.applyMatrix4(Kf.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(Xs).negate(), this.translate(Xs.x, Xs.y, Xs.z), this;
        }
        setFromPoints(t) {
          const n = this.getAttribute("position");
          if (n === void 0) {
            const i = [];
            for (let a = 0, s = t.length; a < s; a++) {
              const r = t[a];
              i.push(r.x, r.y, r.z || 0);
            }
            this.setAttribute("position", new Jn(i, 3));
          } else {
            const i = Math.min(t.length, n.count);
            for (let a = 0; a < i; a++) {
              const s = t[a];
              n.setXYZ(a, s.x, s.y, s.z || 0);
            }
            t.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = true;
          }
          return this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new Cs());
          const t = this.attributes.position, n = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new z(-1 / 0, -1 / 0, -1 / 0), new z(1 / 0, 1 / 0, 1 / 0));
            return;
          }
          if (t !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(t), n) for (let i = 0, a = n.length; i < a; i++) {
              const s = n[i];
              En.setFromBufferAttribute(s), this.morphTargetsRelative ? (ke.addVectors(this.boundingBox.min, En.min), this.boundingBox.expandByPoint(ke), ke.addVectors(this.boundingBox.max, En.max), this.boundingBox.expandByPoint(ke)) : (this.boundingBox.expandByPoint(En.min), this.boundingBox.expandByPoint(En.max));
            }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new $r());
          const t = this.attributes.position, n = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new z(), 1 / 0);
            return;
          }
          if (t) {
            const i = this.boundingSphere.center;
            if (En.setFromBufferAttribute(t), n) for (let s = 0, r = n.length; s < r; s++) {
              const o = n[s];
              _o.setFromBufferAttribute(o), this.morphTargetsRelative ? (ke.addVectors(En.min, _o.min), En.expandByPoint(ke), ke.addVectors(En.max, _o.max), En.expandByPoint(ke)) : (En.expandByPoint(_o.min), En.expandByPoint(_o.max));
            }
            En.getCenter(i);
            let a = 0;
            for (let s = 0, r = t.count; s < r; s++) ke.fromBufferAttribute(t, s), a = Math.max(a, i.distanceToSquared(ke));
            if (n) for (let s = 0, r = n.length; s < r; s++) {
              const o = n[s], l = this.morphTargetsRelative;
              for (let c = 0, f = o.count; c < f; c++) ke.fromBufferAttribute(o, c), l && (Xs.fromBufferAttribute(t, c), ke.add(Xs)), a = Math.max(a, i.distanceToSquared(ke));
            }
            this.boundingSphere.radius = Math.sqrt(a), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const t = this.index, n = this.attributes;
          if (t === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const i = n.position, a = n.normal, s = n.uv;
          this.hasAttribute("tangent") === false && this.setAttribute("tangent", new fi(new Float32Array(4 * i.count), 4));
          const r = this.getAttribute("tangent"), o = [], l = [];
          for (let D = 0; D < i.count; D++) o[D] = new z(), l[D] = new z();
          const c = new z(), f = new z(), d = new z(), h = new Ut(), p = new Ut(), y = new Ut(), S = new z(), m = new z();
          function u(D, b, x) {
            c.fromBufferAttribute(i, D), f.fromBufferAttribute(i, b), d.fromBufferAttribute(i, x), h.fromBufferAttribute(s, D), p.fromBufferAttribute(s, b), y.fromBufferAttribute(s, x), f.sub(c), d.sub(c), p.sub(h), y.sub(h);
            const C = 1 / (p.x * y.y - y.x * p.y);
            isFinite(C) && (S.copy(f).multiplyScalar(y.y).addScaledVector(d, -p.y).multiplyScalar(C), m.copy(d).multiplyScalar(p.x).addScaledVector(f, -y.x).multiplyScalar(C), o[D].add(S), o[b].add(S), o[x].add(S), l[D].add(m), l[b].add(m), l[x].add(m));
          }
          let _ = this.groups;
          _.length === 0 && (_ = [
            {
              start: 0,
              count: t.count
            }
          ]);
          for (let D = 0, b = _.length; D < b; ++D) {
            const x = _[D], C = x.start, V = x.count;
            for (let I = C, X = C + V; I < X; I += 3) u(t.getX(I + 0), t.getX(I + 1), t.getX(I + 2));
          }
          const g = new z(), v = new z(), T = new z(), R = new z();
          function w(D) {
            T.fromBufferAttribute(a, D), R.copy(T);
            const b = o[D];
            g.copy(b), g.sub(T.multiplyScalar(T.dot(b))).normalize(), v.crossVectors(R, b);
            const C = v.dot(l[D]) < 0 ? -1 : 1;
            r.setXYZW(D, g.x, g.y, g.z, C);
          }
          for (let D = 0, b = _.length; D < b; ++D) {
            const x = _[D], C = x.start, V = x.count;
            for (let I = C, X = C + V; I < X; I += 3) w(t.getX(I + 0)), w(t.getX(I + 1)), w(t.getX(I + 2));
          }
        }
        computeVertexNormals() {
          const t = this.index, n = this.getAttribute("position");
          if (n !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new fi(new Float32Array(n.count * 3), 3), this.setAttribute("normal", i);
            else for (let h = 0, p = i.count; h < p; h++) i.setXYZ(h, 0, 0, 0);
            const a = new z(), s = new z(), r = new z(), o = new z(), l = new z(), c = new z(), f = new z(), d = new z();
            if (t) for (let h = 0, p = t.count; h < p; h += 3) {
              const y = t.getX(h + 0), S = t.getX(h + 1), m = t.getX(h + 2);
              a.fromBufferAttribute(n, y), s.fromBufferAttribute(n, S), r.fromBufferAttribute(n, m), f.subVectors(r, s), d.subVectors(a, s), f.cross(d), o.fromBufferAttribute(i, y), l.fromBufferAttribute(i, S), c.fromBufferAttribute(i, m), o.add(f), l.add(f), c.add(f), i.setXYZ(y, o.x, o.y, o.z), i.setXYZ(S, l.x, l.y, l.z), i.setXYZ(m, c.x, c.y, c.z);
            }
            else for (let h = 0, p = n.count; h < p; h += 3) a.fromBufferAttribute(n, h + 0), s.fromBufferAttribute(n, h + 1), r.fromBufferAttribute(n, h + 2), f.subVectors(r, s), d.subVectors(a, s), f.cross(d), i.setXYZ(h + 0, f.x, f.y, f.z), i.setXYZ(h + 1, f.x, f.y, f.z), i.setXYZ(h + 2, f.x, f.y, f.z);
            this.normalizeNormals(), i.needsUpdate = true;
          }
        }
        normalizeNormals() {
          const t = this.attributes.normal;
          for (let n = 0, i = t.count; n < i; n++) ke.fromBufferAttribute(t, n), ke.normalize(), t.setXYZ(n, ke.x, ke.y, ke.z);
        }
        toNonIndexed() {
          function t(o, l) {
            const c = o.array, f = o.itemSize, d = o.normalized, h = new c.constructor(l.length * f);
            let p = 0, y = 0;
            for (let S = 0, m = l.length; S < m; S++) {
              o.isInterleavedBufferAttribute ? p = l[S] * o.data.stride + o.offset : p = l[S] * f;
              for (let u = 0; u < f; u++) h[y++] = c[p++];
            }
            return new fi(h, f, d);
          }
          if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const n = new Ti(), i = this.index.array, a = this.attributes;
          for (const o in a) {
            const l = a[o], c = t(l, i);
            n.setAttribute(o, c);
          }
          const s = this.morphAttributes;
          for (const o in s) {
            const l = [], c = s[o];
            for (let f = 0, d = c.length; f < d; f++) {
              const h = c[f], p = t(h, i);
              l.push(p);
            }
            n.morphAttributes[o] = l;
          }
          n.morphTargetsRelative = this.morphTargetsRelative;
          const r = this.groups;
          for (let o = 0, l = r.length; o < l; o++) {
            const c = r[o];
            n.addGroup(c.start, c.count, c.materialIndex);
          }
          return n;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (t[c] = l[c]);
            return t;
          }
          t.data = {
            attributes: {}
          };
          const n = this.index;
          n !== null && (t.data.index = {
            type: n.array.constructor.name,
            array: Array.prototype.slice.call(n.array)
          });
          const i = this.attributes;
          for (const l in i) {
            const c = i[l];
            t.data.attributes[l] = c.toJSON(t.data);
          }
          const a = {};
          let s = false;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l], f = [];
            for (let d = 0, h = c.length; d < h; d++) {
              const p = c[d];
              f.push(p.toJSON(t.data));
            }
            f.length > 0 && (a[l] = f, s = true);
          }
          s && (t.data.morphAttributes = a, t.data.morphTargetsRelative = this.morphTargetsRelative);
          const r = this.groups;
          r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)));
          const o = this.boundingSphere;
          return o !== null && (t.data.boundingSphere = {
            center: o.center.toArray(),
            radius: o.radius
          }), t;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const n = {};
          this.name = t.name;
          const i = t.index;
          i !== null && this.setIndex(i.clone(n));
          const a = t.attributes;
          for (const c in a) {
            const f = a[c];
            this.setAttribute(c, f.clone(n));
          }
          const s = t.morphAttributes;
          for (const c in s) {
            const f = [], d = s[c];
            for (let h = 0, p = d.length; h < p; h++) f.push(d[h].clone(n));
            this.morphAttributes[c] = f;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          const r = t.groups;
          for (let c = 0, f = r.length; c < f; c++) {
            const d = r[c];
            this.addGroup(d.start, d.count, d.materialIndex);
          }
          const o = t.boundingBox;
          o !== null && (this.boundingBox = o.clone());
          const l = t.boundingSphere;
          return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      const dg = new ie(), qa = new Vu(), nc = new $r(), pg = new z(), ic = new z(), ac = new z(), sc = new z(), Qf = new z(), rc = new z(), mg = new z(), oc = new z();
      class Qn extends tn {
        constructor(t = new Ti(), n = new MS()) {
          super(), this.isMesh = true, this.type = "Mesh", this.geometry = t, this.material = n, this.updateMorphTargets();
        }
        copy(t, n) {
          return super.copy(t, n), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        updateMorphTargets() {
          const n = this.geometry.morphAttributes, i = Object.keys(n);
          if (i.length > 0) {
            const a = n[i[0]];
            if (a !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let s = 0, r = a.length; s < r; s++) {
                const o = a[s].name || String(s);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
              }
            }
          }
        }
        getVertexPosition(t, n) {
          const i = this.geometry, a = i.attributes.position, s = i.morphAttributes.position, r = i.morphTargetsRelative;
          n.fromBufferAttribute(a, t);
          const o = this.morphTargetInfluences;
          if (s && o) {
            rc.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
              const f = o[l], d = s[l];
              f !== 0 && (Qf.fromBufferAttribute(d, t), r ? rc.addScaledVector(Qf, f) : rc.addScaledVector(Qf.sub(n), f));
            }
            n.add(rc);
          }
          return n;
        }
        raycast(t, n) {
          const i = this.geometry, a = this.material, s = this.matrixWorld;
          a !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), nc.copy(i.boundingSphere), nc.applyMatrix4(s), qa.copy(t.ray).recast(t.near), !(nc.containsPoint(qa.origin) === false && (qa.intersectSphere(nc, pg) === null || qa.origin.distanceToSquared(pg) > (t.far - t.near) ** 2)) && (dg.copy(s).invert(), qa.copy(t.ray).applyMatrix4(dg), !(i.boundingBox !== null && qa.intersectsBox(i.boundingBox) === false) && this._computeIntersections(t, n, qa)));
        }
        _computeIntersections(t, n, i) {
          let a;
          const s = this.geometry, r = this.material, o = s.index, l = s.attributes.position, c = s.attributes.uv, f = s.attributes.uv1, d = s.attributes.normal, h = s.groups, p = s.drawRange;
          if (o !== null) if (Array.isArray(r)) for (let y = 0, S = h.length; y < S; y++) {
            const m = h[y], u = r[m.materialIndex], _ = Math.max(m.start, p.start), g = Math.min(o.count, Math.min(m.start + m.count, p.start + p.count));
            for (let v = _, T = g; v < T; v += 3) {
              const R = o.getX(v), w = o.getX(v + 1), D = o.getX(v + 2);
              a = lc(this, u, t, i, c, f, d, R, w, D), a && (a.faceIndex = Math.floor(v / 3), a.face.materialIndex = m.materialIndex, n.push(a));
            }
          }
          else {
            const y = Math.max(0, p.start), S = Math.min(o.count, p.start + p.count);
            for (let m = y, u = S; m < u; m += 3) {
              const _ = o.getX(m), g = o.getX(m + 1), v = o.getX(m + 2);
              a = lc(this, r, t, i, c, f, d, _, g, v), a && (a.faceIndex = Math.floor(m / 3), n.push(a));
            }
          }
          else if (l !== void 0) if (Array.isArray(r)) for (let y = 0, S = h.length; y < S; y++) {
            const m = h[y], u = r[m.materialIndex], _ = Math.max(m.start, p.start), g = Math.min(l.count, Math.min(m.start + m.count, p.start + p.count));
            for (let v = _, T = g; v < T; v += 3) {
              const R = v, w = v + 1, D = v + 2;
              a = lc(this, u, t, i, c, f, d, R, w, D), a && (a.faceIndex = Math.floor(v / 3), a.face.materialIndex = m.materialIndex, n.push(a));
            }
          }
          else {
            const y = Math.max(0, p.start), S = Math.min(l.count, p.start + p.count);
            for (let m = y, u = S; m < u; m += 3) {
              const _ = m, g = m + 1, v = m + 2;
              a = lc(this, r, t, i, c, f, d, _, g, v), a && (a.faceIndex = Math.floor(m / 3), n.push(a));
            }
          }
        }
      }
      function D1(e, t, n, i, a, s, r, o) {
        let l;
        if (t.side === dn ? l = i.intersectTriangle(r, s, a, true, o) : l = i.intersectTriangle(a, s, r, t.side === Ia, o), l === null) return null;
        oc.copy(o), oc.applyMatrix4(e.matrixWorld);
        const c = n.ray.origin.distanceTo(oc);
        return c < n.near || c > n.far ? null : {
          distance: c,
          point: oc.clone(),
          object: e
        };
      }
      function lc(e, t, n, i, a, s, r, o, l, c) {
        e.getVertexPosition(o, ic), e.getVertexPosition(l, ac), e.getVertexPosition(c, sc);
        const f = D1(e, t, n, i, ic, ac, sc, mg);
        if (f) {
          const d = new z();
          li.getBarycoord(mg, ic, ac, sc, d), a && (f.uv = li.getInterpolatedAttribute(a, o, l, c, d, new Ut())), s && (f.uv1 = li.getInterpolatedAttribute(s, o, l, c, d, new Ut())), r && (f.normal = li.getInterpolatedAttribute(r, o, l, c, d, new z()), f.normal.dot(i.direction) > 0 && f.normal.multiplyScalar(-1));
          const h = {
            a: o,
            b: l,
            c,
            normal: new z(),
            materialIndex: 0
          };
          li.getNormal(ic, ac, sc, h.normal), f.face = h, f.barycoord = d;
        }
        return f;
      }
      class eo extends Ti {
        constructor(t = 1, n = 1, i = 1, a = 1, s = 1, r = 1) {
          super(), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: n,
            depth: i,
            widthSegments: a,
            heightSegments: s,
            depthSegments: r
          };
          const o = this;
          a = Math.floor(a), s = Math.floor(s), r = Math.floor(r);
          const l = [], c = [], f = [], d = [];
          let h = 0, p = 0;
          y("z", "y", "x", -1, -1, i, n, t, r, s, 0), y("z", "y", "x", 1, -1, i, n, -t, r, s, 1), y("x", "z", "y", 1, 1, t, i, n, a, r, 2), y("x", "z", "y", 1, -1, t, i, -n, a, r, 3), y("x", "y", "z", 1, -1, t, n, i, a, s, 4), y("x", "y", "z", -1, -1, t, n, -i, a, s, 5), this.setIndex(l), this.setAttribute("position", new Jn(c, 3)), this.setAttribute("normal", new Jn(f, 3)), this.setAttribute("uv", new Jn(d, 2));
          function y(S, m, u, _, g, v, T, R, w, D, b) {
            const x = v / w, C = T / D, V = v / 2, I = T / 2, X = R / 2, Q = w + 1, L = D + 1;
            let W = 0, B = 0;
            const $ = new z();
            for (let it = 0; it < L; it++) {
              const gt = it * C - I;
              for (let Dt = 0; Dt < Q; Dt++) {
                const ne = Dt * x - V;
                $[S] = ne * _, $[m] = gt * g, $[u] = X, c.push($.x, $.y, $.z), $[S] = 0, $[m] = 0, $[u] = R > 0 ? 1 : -1, f.push($.x, $.y, $.z), d.push(Dt / w), d.push(1 - it / D), W += 1;
              }
            }
            for (let it = 0; it < D; it++) for (let gt = 0; gt < w; gt++) {
              const Dt = h + gt + Q * it, ne = h + gt + Q * (it + 1), Y = h + (gt + 1) + Q * (it + 1), nt = h + (gt + 1) + Q * it;
              l.push(Dt, ne, nt), l.push(ne, Y, nt), B += 6;
            }
            o.addGroup(p, B, b), p += B, h += W;
          }
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new eo(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
        }
      }
      function Xr(e) {
        const t = {};
        for (const n in e) {
          t[n] = {};
          for (const i in e[n]) {
            const a = e[n][i];
            a && (a.isColor || a.isMatrix3 || a.isMatrix4 || a.isVector2 || a.isVector3 || a.isVector4 || a.isTexture || a.isQuaternion) ? a.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[n][i] = null) : t[n][i] = a.clone() : Array.isArray(a) ? t[n][i] = a.slice() : t[n][i] = a;
          }
        }
        return t;
      }
      function cn(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
          const i = Xr(e[n]);
          for (const a in i) t[a] = i[a];
        }
        return t;
      }
      function U1(e) {
        const t = [];
        for (let n = 0; n < e.length; n++) t.push(e[n].clone());
        return t;
      }
      function TS(e) {
        const t = e.getRenderTarget();
        return t === null ? e.outputColorSpace : t.isXRRenderTarget === true ? t.texture.colorSpace : te.workingColorSpace;
      }
      const AS = {
        clone: Xr,
        merge: cn
      };
      var L1 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, N1 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class na extends to {
        constructor(t) {
          super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = L1, this.fragmentShader = N1, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
            clipCullDistance: false,
            multiDraw: false
          }, this.defaultAttributeValues = {
            color: [
              1,
              1,
              1
            ],
            uv: [
              0,
              0
            ],
            uv1: [
              0,
              0
            ]
          }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t !== void 0 && this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Xr(t.uniforms), this.uniformsGroups = U1(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
        }
        toJSON(t) {
          const n = super.toJSON(t);
          n.glslVersion = this.glslVersion, n.uniforms = {};
          for (const a in this.uniforms) {
            const r = this.uniforms[a].value;
            r && r.isTexture ? n.uniforms[a] = {
              type: "t",
              value: r.toJSON(t).uuid
            } : r && r.isColor ? n.uniforms[a] = {
              type: "c",
              value: r.getHex()
            } : r && r.isVector2 ? n.uniforms[a] = {
              type: "v2",
              value: r.toArray()
            } : r && r.isVector3 ? n.uniforms[a] = {
              type: "v3",
              value: r.toArray()
            } : r && r.isVector4 ? n.uniforms[a] = {
              type: "v4",
              value: r.toArray()
            } : r && r.isMatrix3 ? n.uniforms[a] = {
              type: "m3",
              value: r.toArray()
            } : r && r.isMatrix4 ? n.uniforms[a] = {
              type: "m4",
              value: r.toArray()
            } : n.uniforms[a] = {
              value: r
            };
          }
          Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
          const i = {};
          for (const a in this.extensions) this.extensions[a] === true && (i[a] = true);
          return Object.keys(i).length > 0 && (n.extensions = i), n;
        }
      }
      class RS extends tn {
        constructor() {
          super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new ie(), this.projectionMatrix = new ie(), this.projectionMatrixInverse = new ie(), this.coordinateSystem = qi;
        }
        copy(t, n) {
          return super.copy(t, n), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
        }
        getWorldDirection(t) {
          return super.getWorldDirection(t).negate();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, n) {
          super.updateWorldMatrix(t, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const ha = new z(), _g = new Ut(), gg = new Ut();
      class Wn extends RS {
        constructor(t = 50, n = 1, i = 0.1, a = 2e3) {
          super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = i, this.far = a, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(t, n) {
          return super.copy(t, n), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
        }
        setFocalLength(t) {
          const n = 0.5 * this.getFilmHeight() / t;
          this.fov = hl * 2 * Math.atan(n), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t = Math.tan(Vo * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / t;
        }
        getEffectiveFOV() {
          return hl * 2 * Math.atan(Math.tan(Vo * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(t, n, i) {
          ha.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(ha.x, ha.y).multiplyScalar(-t / ha.z), ha.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(ha.x, ha.y).multiplyScalar(-t / ha.z);
        }
        getViewSize(t, n) {
          return this.getViewBounds(t, _g, gg), n.subVectors(gg, _g);
        }
        setViewOffset(t, n, i, a, s, r) {
          this.aspect = t / n, this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = a, this.view.width = s, this.view.height = r, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = this.near;
          let n = t * Math.tan(Vo * 0.5 * this.fov) / this.zoom, i = 2 * n, a = this.aspect * i, s = -0.5 * a;
          const r = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = r.fullWidth, c = r.fullHeight;
            s += r.offsetX * a / l, n -= r.offsetY * i / c, a *= r.width / l, i *= r.height / c;
          }
          const o = this.filmOffset;
          o !== 0 && (s += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + a, n, n - i, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const n = super.toJSON(t);
          return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
        }
      }
      const Ws = -90, Ys = 1;
      class O1 extends tn {
        constructor(t, n, i) {
          super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
          const a = new Wn(Ws, Ys, t, n);
          a.layers = this.layers, this.add(a);
          const s = new Wn(Ws, Ys, t, n);
          s.layers = this.layers, this.add(s);
          const r = new Wn(Ws, Ys, t, n);
          r.layers = this.layers, this.add(r);
          const o = new Wn(Ws, Ys, t, n);
          o.layers = this.layers, this.add(o);
          const l = new Wn(Ws, Ys, t, n);
          l.layers = this.layers, this.add(l);
          const c = new Wn(Ws, Ys, t, n);
          c.layers = this.layers, this.add(c);
        }
        updateCoordinateSystem() {
          const t = this.coordinateSystem, n = this.children.concat(), [i, a, s, r, o, l] = n;
          for (const c of n) this.remove(c);
          if (t === qi) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), a.up.set(0, 1, 0), a.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), r.up.set(0, 0, 1), r.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
          else if (t === _u) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), a.up.set(0, -1, 0), a.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), r.up.set(0, 0, -1), r.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
          else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
          for (const c of n) this.add(c), c.updateMatrixWorld();
        }
        update(t, n) {
          this.parent === null && this.updateMatrixWorld();
          const { renderTarget: i, activeMipmapLevel: a } = this;
          this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
          const [s, r, o, l, c, f] = this.children, d = t.getRenderTarget(), h = t.getActiveCubeFace(), p = t.getActiveMipmapLevel(), y = t.xr.enabled;
          t.xr.enabled = false;
          const S = i.texture.generateMipmaps;
          i.texture.generateMipmaps = false, t.setRenderTarget(i, 0, a), t.render(n, s), t.setRenderTarget(i, 1, a), t.render(n, r), t.setRenderTarget(i, 2, a), t.render(n, o), t.setRenderTarget(i, 3, a), t.render(n, l), t.setRenderTarget(i, 4, a), t.render(n, c), i.texture.generateMipmaps = S, t.setRenderTarget(i, 5, a), t.render(n, f), t.setRenderTarget(d, h, p), t.xr.enabled = y, i.texture.needsPMREMUpdate = true;
        }
      }
      class wS extends pn {
        constructor(t, n, i, a, s, r, o, l, c, f) {
          t = t !== void 0 ? t : [], n = n !== void 0 ? n : Ir, super(t, n, i, a, s, r, o, l, c, f), this.isCubeTexture = true, this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      }
      class P1 extends Ss {
        constructor(t = 1, n = {}) {
          super(t, t, n), this.isWebGLCubeRenderTarget = true;
          const i = {
            width: t,
            height: t,
            depth: 1
          }, a = [
            i,
            i,
            i,
            i,
            i,
            i
          ];
          this.texture = new wS(a, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : false, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : _i;
        }
        fromEquirectangularTexture(t, n) {
          this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
          const i = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          }, a = new eo(5, 5, 5), s = new na({
            name: "CubemapFromEquirect",
            uniforms: Xr(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: dn,
            blending: La
          });
          s.uniforms.tEquirect.value = n;
          const r = new Qn(a, s), o = n.minFilter;
          return n.minFilter === rs && (n.minFilter = _i), new O1(1, 10, this).update(t, r), n.minFilter = o, r.geometry.dispose(), r.material.dispose(), this;
        }
        clear(t, n, i, a) {
          const s = t.getRenderTarget();
          for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(n, i, a);
          t.setRenderTarget(s);
        }
      }
      class z1 extends tn {
        constructor() {
          super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Mi(), this.environmentIntensity = 1, this.environmentRotation = new Mi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        copy(t, n) {
          return super.copy(t, n), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
        }
        toJSON(t) {
          const n = super.toJSON(t);
          return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n;
        }
      }
      class B1 extends pn {
        constructor(t = null, n = 1, i = 1, a, s, r, o, l, c = Dn, f = Dn, d, h) {
          super(null, r, o, l, c, f, a, s, d, h), this.isDataTexture = true, this.image = {
            data: t,
            width: n,
            height: i
          }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      class vg extends fi {
        constructor(t, n, i, a = 1) {
          super(t, n, i), this.isInstancedBufferAttribute = true, this.meshPerAttribute = a;
        }
        copy(t) {
          return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
        }
        toJSON() {
          const t = super.toJSON();
          return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = true, t;
        }
      }
      const qs = new ie(), yg = new ie(), cc = [], Sg = new Cs(), F1 = new ie(), go = new Qn(), vo = new $r();
      class I1 extends Qn {
        constructor(t, n, i) {
          super(t, n), this.isInstancedMesh = true, this.instanceMatrix = new vg(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
          for (let a = 0; a < i; a++) this.setMatrixAt(a, F1);
        }
        computeBoundingBox() {
          const t = this.geometry, n = this.count;
          this.boundingBox === null && (this.boundingBox = new Cs()), t.boundingBox === null && t.computeBoundingBox(), this.boundingBox.makeEmpty();
          for (let i = 0; i < n; i++) this.getMatrixAt(i, qs), Sg.copy(t.boundingBox).applyMatrix4(qs), this.boundingBox.union(Sg);
        }
        computeBoundingSphere() {
          const t = this.geometry, n = this.count;
          this.boundingSphere === null && (this.boundingSphere = new $r()), t.boundingSphere === null && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
          for (let i = 0; i < n; i++) this.getMatrixAt(i, qs), vo.copy(t.boundingSphere).applyMatrix4(qs), this.boundingSphere.union(vo);
        }
        copy(t, n) {
          return super.copy(t, n), this.instanceMatrix.copy(t.instanceMatrix), t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
        }
        getColorAt(t, n) {
          n.fromArray(this.instanceColor.array, t * 3);
        }
        getMatrixAt(t, n) {
          n.fromArray(this.instanceMatrix.array, t * 16);
        }
        getMorphAt(t, n) {
          const i = n.morphTargetInfluences, a = this.morphTexture.source.data.data, s = i.length + 1, r = t * s + 1;
          for (let o = 0; o < i.length; o++) i[o] = a[r + o];
        }
        raycast(t, n) {
          const i = this.matrixWorld, a = this.count;
          if (go.geometry = this.geometry, go.material = this.material, go.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), vo.copy(this.boundingSphere), vo.applyMatrix4(i), t.ray.intersectsSphere(vo) !== false)) for (let s = 0; s < a; s++) {
            this.getMatrixAt(s, qs), yg.multiplyMatrices(i, qs), go.matrixWorld = yg, go.raycast(t, cc);
            for (let r = 0, o = cc.length; r < o; r++) {
              const l = cc[r];
              l.instanceId = s, l.object = this, n.push(l);
            }
            cc.length = 0;
          }
        }
        setColorAt(t, n) {
          this.instanceColor === null && (this.instanceColor = new vg(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), n.toArray(this.instanceColor.array, t * 3);
        }
        setMatrixAt(t, n) {
          n.toArray(this.instanceMatrix.array, t * 16);
        }
        setMorphAt(t, n) {
          const i = n.morphTargetInfluences, a = i.length + 1;
          this.morphTexture === null && (this.morphTexture = new B1(new Float32Array(a * this.count), a, this.count, nm, gi));
          const s = this.morphTexture.source.data.data;
          let r = 0;
          for (let c = 0; c < i.length; c++) r += i[c];
          const o = this.geometry.morphTargetsRelative ? 1 : 1 - r, l = a * t;
          s[l] = o, s.set(i, l + 1);
        }
        updateMorphTargets() {
        }
        dispose() {
          return this.dispatchEvent({
            type: "dispose"
          }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
        }
      }
      const Jf = new z(), H1 = new z(), G1 = new Pt();
      class _a {
        constructor(t = new z(1, 0, 0), n = 0) {
          this.isPlane = true, this.normal = t, this.constant = n;
        }
        set(t, n) {
          return this.normal.copy(t), this.constant = n, this;
        }
        setComponents(t, n, i, a) {
          return this.normal.set(t, n, i), this.constant = a, this;
        }
        setFromNormalAndCoplanarPoint(t, n) {
          return this.normal.copy(t), this.constant = -n.dot(this.normal), this;
        }
        setFromCoplanarPoints(t, n, i) {
          const a = Jf.subVectors(i, n).cross(H1.subVectors(t, n)).normalize();
          return this.setFromNormalAndCoplanarPoint(a, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), this.constant = t.constant, this;
        }
        normalize() {
          const t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), this.constant *= t, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, n) {
          return n.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
        }
        intersectLine(t, n) {
          const i = t.delta(Jf), a = this.normal.dot(i);
          if (a === 0) return this.distanceToPoint(t.start) === 0 ? n.copy(t.start) : null;
          const s = -(t.start.dot(this.normal) + this.constant) / a;
          return s < 0 || s > 1 ? null : n.copy(t.start).addScaledVector(i, s);
        }
        intersectsLine(t) {
          const n = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end);
          return n < 0 && i > 0 || i < 0 && n > 0;
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, n) {
          const i = n || G1.getNormalMatrix(t), a = this.coplanarPoint(Jf).applyMatrix4(t), s = this.normal.applyMatrix3(i).normalize();
          return this.constant = -a.dot(s), this;
        }
        translate(t) {
          return this.constant -= t.dot(this.normal), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const ja = new $r(), uc = new z();
      class lm {
        constructor(t = new _a(), n = new _a(), i = new _a(), a = new _a(), s = new _a(), r = new _a()) {
          this.planes = [
            t,
            n,
            i,
            a,
            s,
            r
          ];
        }
        set(t, n, i, a, s, r) {
          const o = this.planes;
          return o[0].copy(t), o[1].copy(n), o[2].copy(i), o[3].copy(a), o[4].copy(s), o[5].copy(r), this;
        }
        copy(t) {
          const n = this.planes;
          for (let i = 0; i < 6; i++) n[i].copy(t.planes[i]);
          return this;
        }
        setFromProjectionMatrix(t, n = qi) {
          const i = this.planes, a = t.elements, s = a[0], r = a[1], o = a[2], l = a[3], c = a[4], f = a[5], d = a[6], h = a[7], p = a[8], y = a[9], S = a[10], m = a[11], u = a[12], _ = a[13], g = a[14], v = a[15];
          if (i[0].setComponents(l - s, h - c, m - p, v - u).normalize(), i[1].setComponents(l + s, h + c, m + p, v + u).normalize(), i[2].setComponents(l + r, h + f, m + y, v + _).normalize(), i[3].setComponents(l - r, h - f, m - y, v - _).normalize(), i[4].setComponents(l - o, h - d, m - S, v - g).normalize(), n === qi) i[5].setComponents(l + o, h + d, m + S, v + g).normalize();
          else if (n === _u) i[5].setComponents(o, d, S, g).normalize();
          else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
          return this;
        }
        intersectsObject(t) {
          if (t.boundingSphere !== void 0) t.boundingSphere === null && t.computeBoundingSphere(), ja.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
          else {
            const n = t.geometry;
            n.boundingSphere === null && n.computeBoundingSphere(), ja.copy(n.boundingSphere).applyMatrix4(t.matrixWorld);
          }
          return this.intersectsSphere(ja);
        }
        intersectsSprite(t) {
          return ja.center.set(0, 0, 0), ja.radius = 0.7071067811865476, ja.applyMatrix4(t.matrixWorld), this.intersectsSphere(ja);
        }
        intersectsSphere(t) {
          const n = this.planes, i = t.center, a = -t.radius;
          for (let s = 0; s < 6; s++) if (n[s].distanceToPoint(i) < a) return false;
          return true;
        }
        intersectsBox(t) {
          const n = this.planes;
          for (let i = 0; i < 6; i++) {
            const a = n[i];
            if (uc.x = a.normal.x > 0 ? t.max.x : t.min.x, uc.y = a.normal.y > 0 ? t.max.y : t.min.y, uc.z = a.normal.z > 0 ? t.max.z : t.min.z, a.distanceToPoint(uc) < 0) return false;
          }
          return true;
        }
        containsPoint(t) {
          const n = this.planes;
          for (let i = 0; i < 6; i++) if (n[i].distanceToPoint(t) < 0) return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class CS extends to {
        constructor(t) {
          super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new It(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
        }
      }
      const vu = new z(), yu = new z(), xg = new ie(), yo = new Vu(), fc = new $r(), $f = new z(), Mg = new z();
      class V1 extends tn {
        constructor(t = new Ti(), n = new CS()) {
          super(), this.isLine = true, this.type = "Line", this.geometry = t, this.material = n, this.updateMorphTargets();
        }
        copy(t, n) {
          return super.copy(t, n), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.index === null) {
            const n = t.attributes.position, i = [
              0
            ];
            for (let a = 1, s = n.count; a < s; a++) vu.fromBufferAttribute(n, a - 1), yu.fromBufferAttribute(n, a), i[a] = i[a - 1], i[a] += vu.distanceTo(yu);
            t.setAttribute("lineDistance", new Jn(i, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(t, n) {
          const i = this.geometry, a = this.matrixWorld, s = t.params.Line.threshold, r = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), fc.copy(i.boundingSphere), fc.applyMatrix4(a), fc.radius += s, t.ray.intersectsSphere(fc) === false) return;
          xg.copy(a).invert(), yo.copy(t.ray).applyMatrix4(xg);
          const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = this.isLineSegments ? 2 : 1, f = i.index, h = i.attributes.position;
          if (f !== null) {
            const p = Math.max(0, r.start), y = Math.min(f.count, r.start + r.count);
            for (let S = p, m = y - 1; S < m; S += c) {
              const u = f.getX(S), _ = f.getX(S + 1), g = hc(this, t, yo, l, u, _);
              g && n.push(g);
            }
            if (this.isLineLoop) {
              const S = f.getX(y - 1), m = f.getX(p), u = hc(this, t, yo, l, S, m);
              u && n.push(u);
            }
          } else {
            const p = Math.max(0, r.start), y = Math.min(h.count, r.start + r.count);
            for (let S = p, m = y - 1; S < m; S += c) {
              const u = hc(this, t, yo, l, S, S + 1);
              u && n.push(u);
            }
            if (this.isLineLoop) {
              const S = hc(this, t, yo, l, y - 1, p);
              S && n.push(S);
            }
          }
        }
        updateMorphTargets() {
          const n = this.geometry.morphAttributes, i = Object.keys(n);
          if (i.length > 0) {
            const a = n[i[0]];
            if (a !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let s = 0, r = a.length; s < r; s++) {
                const o = a[s].name || String(s);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
              }
            }
          }
        }
      }
      function hc(e, t, n, i, a, s) {
        const r = e.geometry.attributes.position;
        if (vu.fromBufferAttribute(r, a), yu.fromBufferAttribute(r, s), n.distanceSqToSegment(vu, yu, $f, Mg) > i) return;
        $f.applyMatrix4(e.matrixWorld);
        const l = t.ray.origin.distanceTo($f);
        if (!(l < t.near || l > t.far)) return {
          distance: l,
          point: Mg.clone().applyMatrix4(e.matrixWorld),
          index: a,
          face: null,
          faceIndex: null,
          barycoord: null,
          object: e
        };
      }
      const Eg = new z(), bg = new z();
      class k1 extends V1 {
        constructor(t, n) {
          super(t, n), this.isLineSegments = true, this.type = "LineSegments";
        }
        computeLineDistances() {
          const t = this.geometry;
          if (t.index === null) {
            const n = t.attributes.position, i = [];
            for (let a = 0, s = n.count; a < s; a += 2) Eg.fromBufferAttribute(n, a), bg.fromBufferAttribute(n, a + 1), i[a] = a === 0 ? 0 : i[a - 1], i[a + 1] = i[a] + Eg.distanceTo(bg);
            t.setAttribute("lineDistance", new Jn(i, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class dc extends tn {
        constructor() {
          super(), this.isGroup = true, this.type = "Group";
        }
      }
      class DS extends pn {
        constructor(t, n, i, a, s, r, o, l, c, f = Tr) {
          if (f !== Tr && f !== Vr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          i === void 0 && f === Tr && (i = ys), i === void 0 && f === Vr && (i = Gr), super(null, a, s, r, o, l, f, i, c), this.isDepthTexture = true, this.image = {
            width: t,
            height: n
          }, this.magFilter = o !== void 0 ? o : Dn, this.minFilter = l !== void 0 ? l : Dn, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
        }
        copy(t) {
          return super.copy(t), this.compareFunction = t.compareFunction, this;
        }
        toJSON(t) {
          const n = super.toJSON(t);
          return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
        }
      }
      class ku extends Ti {
        constructor(t = 1, n = 1, i = 1, a = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: n,
            widthSegments: i,
            heightSegments: a
          };
          const s = t / 2, r = n / 2, o = Math.floor(i), l = Math.floor(a), c = o + 1, f = l + 1, d = t / o, h = n / l, p = [], y = [], S = [], m = [];
          for (let u = 0; u < f; u++) {
            const _ = u * h - r;
            for (let g = 0; g < c; g++) {
              const v = g * d - s;
              y.push(v, -_, 0), S.push(0, 0, 1), m.push(g / o), m.push(1 - u / l);
            }
          }
          for (let u = 0; u < l; u++) for (let _ = 0; _ < o; _++) {
            const g = _ + c * u, v = _ + c * (u + 1), T = _ + 1 + c * (u + 1), R = _ + 1 + c * u;
            p.push(g, v, R), p.push(v, T, R);
          }
          this.setIndex(p), this.setAttribute("position", new Jn(y, 3)), this.setAttribute("normal", new Jn(S, 3)), this.setAttribute("uv", new Jn(m, 2));
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new ku(t.width, t.height, t.widthSegments, t.heightSegments);
        }
      }
      class cm extends Ti {
        constructor(t = 1, n = 32, i = 16, a = 0, s = Math.PI * 2, r = 0, o = Math.PI) {
          super(), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: n,
            heightSegments: i,
            phiStart: a,
            phiLength: s,
            thetaStart: r,
            thetaLength: o
          }, n = Math.max(3, Math.floor(n)), i = Math.max(2, Math.floor(i));
          const l = Math.min(r + o, Math.PI);
          let c = 0;
          const f = [], d = new z(), h = new z(), p = [], y = [], S = [], m = [];
          for (let u = 0; u <= i; u++) {
            const _ = [], g = u / i;
            let v = 0;
            u === 0 && r === 0 ? v = 0.5 / n : u === i && l === Math.PI && (v = -0.5 / n);
            for (let T = 0; T <= n; T++) {
              const R = T / n;
              d.x = -t * Math.cos(a + R * s) * Math.sin(r + g * o), d.y = t * Math.cos(r + g * o), d.z = t * Math.sin(a + R * s) * Math.sin(r + g * o), y.push(d.x, d.y, d.z), h.copy(d).normalize(), S.push(h.x, h.y, h.z), m.push(R + v, 1 - g), _.push(c++);
            }
            f.push(_);
          }
          for (let u = 0; u < i; u++) for (let _ = 0; _ < n; _++) {
            const g = f[u][_ + 1], v = f[u][_], T = f[u + 1][_], R = f[u + 1][_ + 1];
            (u !== 0 || r > 0) && p.push(g, v, R), (u !== i - 1 || l < Math.PI) && p.push(v, T, R);
          }
          this.setIndex(p), this.setAttribute("position", new Jn(y, 3)), this.setAttribute("normal", new Jn(S, 3)), this.setAttribute("uv", new Jn(m, 2));
        }
        copy(t) {
          return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
        }
        static fromJSON(t) {
          return new cm(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
        }
      }
      class X1 extends to {
        constructor(t) {
          super(), this.isMeshStandardMaterial = true, this.type = "MeshStandardMaterial", this.defines = {
            STANDARD: ""
          }, this.color = new It(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new It(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _S, this.normalScale = new Ut(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Mi(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.defines = {
            STANDARD: ""
          }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
        }
      }
      class W1 extends to {
        constructor(t) {
          super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = FT, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
        }
      }
      class Y1 extends to {
        constructor(t) {
          super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
        }
        copy(t) {
          return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
        }
      }
      class US extends tn {
        constructor(t, n = 1) {
          super(), this.isLight = true, this.type = "Light", this.color = new It(t), this.intensity = n;
        }
        dispose() {
        }
        copy(t, n) {
          return super.copy(t, n), this.color.copy(t.color), this.intensity = t.intensity, this;
        }
        toJSON(t) {
          const n = super.toJSON(t);
          return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (n.object.target = this.target.uuid), n;
        }
      }
      const th = new ie(), Tg = new z(), Ag = new z();
      class q1 {
        constructor(t) {
          this.camera = t, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ut(512, 512), this.map = null, this.mapPass = null, this.matrix = new ie(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new lm(), this._frameExtents = new Ut(1, 1), this._viewportCount = 1, this._viewports = [
            new Ce(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t) {
          const n = this.camera, i = this.matrix;
          Tg.setFromMatrixPosition(t.matrixWorld), n.position.copy(Tg), Ag.setFromMatrixPosition(t.target.matrixWorld), n.lookAt(Ag), n.updateMatrixWorld(), th.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(th), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(th);
        }
        getViewport(t) {
          return this._viewports[t];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(t) {
          return this.camera = t.camera.clone(), this.intensity = t.intensity, this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t = {};
          return this.intensity !== 1 && (t.intensity = this.intensity), this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(false).object, delete t.camera.matrix, t;
        }
      }
      class LS extends RS {
        constructor(t = -1, n = 1, i = 1, a = -1, s = 0.1, r = 2e3) {
          super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = n, this.top = i, this.bottom = a, this.near = s, this.far = r, this.updateProjectionMatrix();
        }
        copy(t, n) {
          return super.copy(t, n), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
        }
        setViewOffset(t, n, i, a, s, r) {
          this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = a, this.view.width = s, this.view.height = r, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, a = (this.top + this.bottom) / 2;
          let s = i - t, r = i + t, o = a + n, l = a - n;
          if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom, f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX, r = s + c * this.view.width, o -= f * this.view.offsetY, l = o - f * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(s, r, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const n = super.toJSON(t);
          return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
        }
      }
      class j1 extends q1 {
        constructor() {
          super(new LS(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
        }
      }
      class Z1 extends US {
        constructor(t, n) {
          super(t, n), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(tn.DEFAULT_UP), this.updateMatrix(), this.target = new tn(), this.shadow = new j1();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t) {
          return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
        }
      }
      class K1 extends US {
        constructor(t, n) {
          super(t, n), this.isAmbientLight = true, this.type = "AmbientLight";
        }
      }
      class Q1 extends Wn {
        constructor(t = []) {
          super(), this.isArrayCamera = true, this.cameras = t;
        }
      }
      const Rg = new ie();
      class J1 {
        constructor(t, n, i = 0, a = 1 / 0) {
          this.ray = new Vu(t, n), this.near = i, this.far = a, this.camera = null, this.layers = new om(), this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(t, n) {
          this.ray.set(t, n);
        }
        setFromCamera(t, n) {
          n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
        }
        setFromXRController(t) {
          return Rg.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Rg), this;
        }
        intersectObject(t, n = true, i = []) {
          return Zd(t, this, i, n), i.sort(wg), i;
        }
        intersectObjects(t, n = true, i = []) {
          for (let a = 0, s = t.length; a < s; a++) Zd(t[a], this, i, n);
          return i.sort(wg), i;
        }
      }
      function wg(e, t) {
        return e.distance - t.distance;
      }
      function Zd(e, t, n, i) {
        let a = true;
        if (e.layers.test(t.layers) && e.raycast(t, n) === false && (a = false), a === true && i === true) {
          const s = e.children;
          for (let r = 0, o = s.length; r < o; r++) Zd(s[r], t, n, true);
        }
      }
      class Cg {
        constructor(t = 1, n = 0, i = 0) {
          return this.radius = t, this.phi = n, this.theta = i, this;
        }
        set(t, n, i) {
          return this.radius = t, this.phi = n, this.theta = i, this;
        }
        copy(t) {
          return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
        }
        makeSafe() {
          return this.phi = Gt(this.phi, 1e-6, Math.PI - 1e-6), this;
        }
        setFromVector3(t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        }
        setFromCartesianCoords(t, n, i) {
          return this.radius = Math.sqrt(t * t + n * n + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(Gt(n / this.radius, -1, 1))), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class $1 extends ws {
        constructor(t, n = null) {
          super(), this.object = t, this.domElement = n, this.enabled = true, this.state = -1, this.keys = {}, this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
          }, this.touches = {
            ONE: null,
            TWO: null
          };
        }
        connect() {
        }
        disconnect() {
        }
        dispose() {
        }
        update() {
        }
      }
      function Dg(e, t, n, i) {
        const a = tA(i);
        switch (n) {
          case uS:
            return e * t;
          case hS:
            return e * t;
          case dS:
            return e * t * 2;
          case nm:
            return e * t / a.components * a.byteLength;
          case im:
            return e * t / a.components * a.byteLength;
          case pS:
            return e * t * 2 / a.components * a.byteLength;
          case am:
            return e * t * 2 / a.components * a.byteLength;
          case fS:
            return e * t * 3 / a.components * a.byteLength;
          case ci:
            return e * t * 4 / a.components * a.byteLength;
          case sm:
            return e * t * 4 / a.components * a.byteLength;
          case Lc:
          case Nc:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case Oc:
          case Pc:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case bd:
          case Ad:
            return Math.max(e, 16) * Math.max(t, 8) / 4;
          case Ed:
          case Td:
            return Math.max(e, 8) * Math.max(t, 8) / 2;
          case Rd:
          case wd:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case Cd:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Dd:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Ud:
            return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
          case Ld:
            return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
          case Nd:
            return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
          case Od:
            return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
          case Pd:
            return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
          case zd:
            return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
          case Bd:
            return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
          case Fd:
            return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
          case Id:
            return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
          case Hd:
            return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
          case Gd:
            return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
          case Vd:
            return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
          case kd:
            return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
          case zc:
          case Xd:
          case Wd:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
          case mS:
          case Yd:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
          case qd:
          case jd:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${n} format.`);
      }
      function tA(e) {
        switch (e) {
          case ea:
          case oS:
            return {
              byteLength: 1,
              components: 1
            };
          case fl:
          case lS:
          case Al:
            return {
              byteLength: 2,
              components: 1
            };
          case tm:
          case em:
            return {
              byteLength: 2,
              components: 4
            };
          case ys:
          case $p:
          case gi:
            return {
              byteLength: 4,
              components: 1
            };
          case cS:
            return {
              byteLength: 4,
              components: 3
            };
        }
        throw new Error(`Unknown texture type ${e}.`);
      }
      typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: Jp
        }
      }));
      typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Jp);
      function NS() {
        let e = null, t = false, n = null, i = null;
        function a(s, r) {
          n(s, r), i = e.requestAnimationFrame(a);
        }
        return {
          start: function() {
            t !== true && n !== null && (i = e.requestAnimationFrame(a), t = true);
          },
          stop: function() {
            e.cancelAnimationFrame(i), t = false;
          },
          setAnimationLoop: function(s) {
            n = s;
          },
          setContext: function(s) {
            e = s;
          }
        };
      }
      function eA(e) {
        const t = /* @__PURE__ */ new WeakMap();
        function n(o, l) {
          const c = o.array, f = o.usage, d = c.byteLength, h = e.createBuffer();
          e.bindBuffer(l, h), e.bufferData(l, c, f), o.onUploadCallback();
          let p;
          if (c instanceof Float32Array) p = e.FLOAT;
          else if (c instanceof Uint16Array) o.isFloat16BufferAttribute ? p = e.HALF_FLOAT : p = e.UNSIGNED_SHORT;
          else if (c instanceof Int16Array) p = e.SHORT;
          else if (c instanceof Uint32Array) p = e.UNSIGNED_INT;
          else if (c instanceof Int32Array) p = e.INT;
          else if (c instanceof Int8Array) p = e.BYTE;
          else if (c instanceof Uint8Array) p = e.UNSIGNED_BYTE;
          else if (c instanceof Uint8ClampedArray) p = e.UNSIGNED_BYTE;
          else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
          return {
            buffer: h,
            type: p,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: o.version,
            size: d
          };
        }
        function i(o, l, c) {
          const f = l.array, d = l.updateRanges;
          if (e.bindBuffer(c, o), d.length === 0) e.bufferSubData(c, 0, f);
          else {
            d.sort((p, y) => p.start - y.start);
            let h = 0;
            for (let p = 1; p < d.length; p++) {
              const y = d[h], S = d[p];
              S.start <= y.start + y.count + 1 ? y.count = Math.max(y.count, S.start + S.count - y.start) : (++h, d[h] = S);
            }
            d.length = h + 1;
            for (let p = 0, y = d.length; p < y; p++) {
              const S = d[p];
              e.bufferSubData(c, S.start * f.BYTES_PER_ELEMENT, f, S.start, S.count);
            }
            l.clearUpdateRanges();
          }
          l.onUploadCallback();
        }
        function a(o) {
          return o.isInterleavedBufferAttribute && (o = o.data), t.get(o);
        }
        function s(o) {
          o.isInterleavedBufferAttribute && (o = o.data);
          const l = t.get(o);
          l && (e.deleteBuffer(l.buffer), t.delete(o));
        }
        function r(o, l) {
          if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
            const f = t.get(o);
            (!f || f.version < o.version) && t.set(o, {
              buffer: o.buffer,
              type: o.type,
              bytesPerElement: o.elementSize,
              version: o.version
            });
            return;
          }
          const c = t.get(o);
          if (c === void 0) t.set(o, n(o, l));
          else if (c.version < o.version) {
            if (c.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(c.buffer, o, l), c.version = o.version;
          }
        }
        return {
          get: a,
          remove: s,
          update: r
        };
      }
      var nA = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, iA = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, aA = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, sA = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, rA = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, oA = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, lA = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, cA = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, uA = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, fA = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, hA = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, dA = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, pA = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, mA = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, _A = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, gA = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, vA = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, yA = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, SA = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, xA = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, MA = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, EA = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, bA = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, TA = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, AA = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, RA = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, wA = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, CA = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, DA = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, UA = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, LA = "gl_FragColor = linearToOutputTexel( gl_FragColor );", NA = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, OA = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, PA = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, zA = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, BA = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, FA = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, IA = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, HA = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, GA = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, VA = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, kA = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, XA = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, WA = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, YA = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, qA = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, jA = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, ZA = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, KA = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, QA = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, JA = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, $A = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, t2 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, e2 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, n2 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, i2 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, a2 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, s2 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, r2 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, o2 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, l2 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, c2 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, u2 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, f2 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, h2 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, d2 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, p2 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, m2 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, _2 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, g2 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, v2 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, y2 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, S2 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, x2 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, M2 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, E2 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, b2 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, T2 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, A2 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, R2 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, w2 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, C2 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, D2 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, U2 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, L2 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, N2 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, O2 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, P2 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, z2 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, B2 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, F2 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, I2 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, H2 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, G2 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, V2 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, k2 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, X2 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, W2 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Y2 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, q2 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, j2 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Z2 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, K2 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Q2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, J2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, $2 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, tR = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const eR = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, nR = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, iR = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, aR = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, sR = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, rR = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, oR = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, lR = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, cR = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, uR = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, fR = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, hR = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, dR = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, pR = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, mR = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, _R = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, gR = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, vR = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, yR = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, SR = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xR = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, MR = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, ER = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, bR = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, TR = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, AR = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, RR = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, wR = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, CR = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, DR = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, UR = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, LR = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, NR = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, OR = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Bt = {
        alphahash_fragment: nA,
        alphahash_pars_fragment: iA,
        alphamap_fragment: aA,
        alphamap_pars_fragment: sA,
        alphatest_fragment: rA,
        alphatest_pars_fragment: oA,
        aomap_fragment: lA,
        aomap_pars_fragment: cA,
        batching_pars_vertex: uA,
        batching_vertex: fA,
        begin_vertex: hA,
        beginnormal_vertex: dA,
        bsdfs: pA,
        iridescence_fragment: mA,
        bumpmap_pars_fragment: _A,
        clipping_planes_fragment: gA,
        clipping_planes_pars_fragment: vA,
        clipping_planes_pars_vertex: yA,
        clipping_planes_vertex: SA,
        color_fragment: xA,
        color_pars_fragment: MA,
        color_pars_vertex: EA,
        color_vertex: bA,
        common: TA,
        cube_uv_reflection_fragment: AA,
        defaultnormal_vertex: RA,
        displacementmap_pars_vertex: wA,
        displacementmap_vertex: CA,
        emissivemap_fragment: DA,
        emissivemap_pars_fragment: UA,
        colorspace_fragment: LA,
        colorspace_pars_fragment: NA,
        envmap_fragment: OA,
        envmap_common_pars_fragment: PA,
        envmap_pars_fragment: zA,
        envmap_pars_vertex: BA,
        envmap_physical_pars_fragment: jA,
        envmap_vertex: FA,
        fog_vertex: IA,
        fog_pars_vertex: HA,
        fog_fragment: GA,
        fog_pars_fragment: VA,
        gradientmap_pars_fragment: kA,
        lightmap_pars_fragment: XA,
        lights_lambert_fragment: WA,
        lights_lambert_pars_fragment: YA,
        lights_pars_begin: qA,
        lights_toon_fragment: ZA,
        lights_toon_pars_fragment: KA,
        lights_phong_fragment: QA,
        lights_phong_pars_fragment: JA,
        lights_physical_fragment: $A,
        lights_physical_pars_fragment: t2,
        lights_fragment_begin: e2,
        lights_fragment_maps: n2,
        lights_fragment_end: i2,
        logdepthbuf_fragment: a2,
        logdepthbuf_pars_fragment: s2,
        logdepthbuf_pars_vertex: r2,
        logdepthbuf_vertex: o2,
        map_fragment: l2,
        map_pars_fragment: c2,
        map_particle_fragment: u2,
        map_particle_pars_fragment: f2,
        metalnessmap_fragment: h2,
        metalnessmap_pars_fragment: d2,
        morphinstance_vertex: p2,
        morphcolor_vertex: m2,
        morphnormal_vertex: _2,
        morphtarget_pars_vertex: g2,
        morphtarget_vertex: v2,
        normal_fragment_begin: y2,
        normal_fragment_maps: S2,
        normal_pars_fragment: x2,
        normal_pars_vertex: M2,
        normal_vertex: E2,
        normalmap_pars_fragment: b2,
        clearcoat_normal_fragment_begin: T2,
        clearcoat_normal_fragment_maps: A2,
        clearcoat_pars_fragment: R2,
        iridescence_pars_fragment: w2,
        opaque_fragment: C2,
        packing: D2,
        premultiplied_alpha_fragment: U2,
        project_vertex: L2,
        dithering_fragment: N2,
        dithering_pars_fragment: O2,
        roughnessmap_fragment: P2,
        roughnessmap_pars_fragment: z2,
        shadowmap_pars_fragment: B2,
        shadowmap_pars_vertex: F2,
        shadowmap_vertex: I2,
        shadowmask_pars_fragment: H2,
        skinbase_vertex: G2,
        skinning_pars_vertex: V2,
        skinning_vertex: k2,
        skinnormal_vertex: X2,
        specularmap_fragment: W2,
        specularmap_pars_fragment: Y2,
        tonemapping_fragment: q2,
        tonemapping_pars_fragment: j2,
        transmission_fragment: Z2,
        transmission_pars_fragment: K2,
        uv_pars_fragment: Q2,
        uv_pars_vertex: J2,
        uv_vertex: $2,
        worldpos_vertex: tR,
        background_vert: eR,
        background_frag: nR,
        backgroundCube_vert: iR,
        backgroundCube_frag: aR,
        cube_vert: sR,
        cube_frag: rR,
        depth_vert: oR,
        depth_frag: lR,
        distanceRGBA_vert: cR,
        distanceRGBA_frag: uR,
        equirect_vert: fR,
        equirect_frag: hR,
        linedashed_vert: dR,
        linedashed_frag: pR,
        meshbasic_vert: mR,
        meshbasic_frag: _R,
        meshlambert_vert: gR,
        meshlambert_frag: vR,
        meshmatcap_vert: yR,
        meshmatcap_frag: SR,
        meshnormal_vert: xR,
        meshnormal_frag: MR,
        meshphong_vert: ER,
        meshphong_frag: bR,
        meshphysical_vert: TR,
        meshphysical_frag: AR,
        meshtoon_vert: RR,
        meshtoon_frag: wR,
        points_vert: CR,
        points_frag: DR,
        shadow_vert: UR,
        shadow_frag: LR,
        sprite_vert: NR,
        sprite_frag: OR
      }, at = {
        common: {
          diffuse: {
            value: new It(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new Pt()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Pt()
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          },
          specularMapTransform: {
            value: new Pt()
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          envMapRotation: {
            value: new Pt()
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          },
          aoMapTransform: {
            value: new Pt()
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          },
          lightMapTransform: {
            value: new Pt()
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpMapTransform: {
            value: new Pt()
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalMapTransform: {
            value: new Pt()
          },
          normalScale: {
            value: new Ut(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementMapTransform: {
            value: new Pt()
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          },
          emissiveMapTransform: {
            value: new Pt()
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          },
          metalnessMapTransform: {
            value: new Pt()
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          },
          roughnessMapTransform: {
            value: new Pt()
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new It(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotLightMap: {
            value: []
          },
          spotShadowMap: {
            value: []
          },
          spotLightMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new It(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Pt()
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Pt()
          }
        },
        sprite: {
          diffuse: {
            value: new It(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new Ut(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new Pt()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Pt()
          },
          alphaTest: {
            value: 0
          }
        }
      }, di = {
        basic: {
          uniforms: cn([
            at.common,
            at.specularmap,
            at.envmap,
            at.aomap,
            at.lightmap,
            at.fog
          ]),
          vertexShader: Bt.meshbasic_vert,
          fragmentShader: Bt.meshbasic_frag
        },
        lambert: {
          uniforms: cn([
            at.common,
            at.specularmap,
            at.envmap,
            at.aomap,
            at.lightmap,
            at.emissivemap,
            at.bumpmap,
            at.normalmap,
            at.displacementmap,
            at.fog,
            at.lights,
            {
              emissive: {
                value: new It(0)
              }
            }
          ]),
          vertexShader: Bt.meshlambert_vert,
          fragmentShader: Bt.meshlambert_frag
        },
        phong: {
          uniforms: cn([
            at.common,
            at.specularmap,
            at.envmap,
            at.aomap,
            at.lightmap,
            at.emissivemap,
            at.bumpmap,
            at.normalmap,
            at.displacementmap,
            at.fog,
            at.lights,
            {
              emissive: {
                value: new It(0)
              },
              specular: {
                value: new It(1118481)
              },
              shininess: {
                value: 30
              }
            }
          ]),
          vertexShader: Bt.meshphong_vert,
          fragmentShader: Bt.meshphong_frag
        },
        standard: {
          uniforms: cn([
            at.common,
            at.envmap,
            at.aomap,
            at.lightmap,
            at.emissivemap,
            at.bumpmap,
            at.normalmap,
            at.displacementmap,
            at.roughnessmap,
            at.metalnessmap,
            at.fog,
            at.lights,
            {
              emissive: {
                value: new It(0)
              },
              roughness: {
                value: 1
              },
              metalness: {
                value: 0
              },
              envMapIntensity: {
                value: 1
              }
            }
          ]),
          vertexShader: Bt.meshphysical_vert,
          fragmentShader: Bt.meshphysical_frag
        },
        toon: {
          uniforms: cn([
            at.common,
            at.aomap,
            at.lightmap,
            at.emissivemap,
            at.bumpmap,
            at.normalmap,
            at.displacementmap,
            at.gradientmap,
            at.fog,
            at.lights,
            {
              emissive: {
                value: new It(0)
              }
            }
          ]),
          vertexShader: Bt.meshtoon_vert,
          fragmentShader: Bt.meshtoon_frag
        },
        matcap: {
          uniforms: cn([
            at.common,
            at.bumpmap,
            at.normalmap,
            at.displacementmap,
            at.fog,
            {
              matcap: {
                value: null
              }
            }
          ]),
          vertexShader: Bt.meshmatcap_vert,
          fragmentShader: Bt.meshmatcap_frag
        },
        points: {
          uniforms: cn([
            at.points,
            at.fog
          ]),
          vertexShader: Bt.points_vert,
          fragmentShader: Bt.points_frag
        },
        dashed: {
          uniforms: cn([
            at.common,
            at.fog,
            {
              scale: {
                value: 1
              },
              dashSize: {
                value: 1
              },
              totalSize: {
                value: 2
              }
            }
          ]),
          vertexShader: Bt.linedashed_vert,
          fragmentShader: Bt.linedashed_frag
        },
        depth: {
          uniforms: cn([
            at.common,
            at.displacementmap
          ]),
          vertexShader: Bt.depth_vert,
          fragmentShader: Bt.depth_frag
        },
        normal: {
          uniforms: cn([
            at.common,
            at.bumpmap,
            at.normalmap,
            at.displacementmap,
            {
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: Bt.meshnormal_vert,
          fragmentShader: Bt.meshnormal_frag
        },
        sprite: {
          uniforms: cn([
            at.sprite,
            at.fog
          ]),
          vertexShader: Bt.sprite_vert,
          fragmentShader: Bt.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Pt()
            },
            t2D: {
              value: null
            },
            backgroundIntensity: {
              value: 1
            }
          },
          vertexShader: Bt.background_vert,
          fragmentShader: Bt.background_frag
        },
        backgroundCube: {
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            },
            backgroundBlurriness: {
              value: 0
            },
            backgroundIntensity: {
              value: 1
            },
            backgroundRotation: {
              value: new Pt()
            }
          },
          vertexShader: Bt.backgroundCube_vert,
          fragmentShader: Bt.backgroundCube_frag
        },
        cube: {
          uniforms: {
            tCube: {
              value: null
            },
            tFlip: {
              value: -1
            },
            opacity: {
              value: 1
            }
          },
          vertexShader: Bt.cube_vert,
          fragmentShader: Bt.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: Bt.equirect_vert,
          fragmentShader: Bt.equirect_frag
        },
        distanceRGBA: {
          uniforms: cn([
            at.common,
            at.displacementmap,
            {
              referencePosition: {
                value: new z()
              },
              nearDistance: {
                value: 1
              },
              farDistance: {
                value: 1e3
              }
            }
          ]),
          vertexShader: Bt.distanceRGBA_vert,
          fragmentShader: Bt.distanceRGBA_frag
        },
        shadow: {
          uniforms: cn([
            at.lights,
            at.fog,
            {
              color: {
                value: new It(0)
              },
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: Bt.shadow_vert,
          fragmentShader: Bt.shadow_frag
        }
      };
      di.physical = {
        uniforms: cn([
          di.standard.uniforms,
          {
            clearcoat: {
              value: 0
            },
            clearcoatMap: {
              value: null
            },
            clearcoatMapTransform: {
              value: new Pt()
            },
            clearcoatNormalMap: {
              value: null
            },
            clearcoatNormalMapTransform: {
              value: new Pt()
            },
            clearcoatNormalScale: {
              value: new Ut(1, 1)
            },
            clearcoatRoughness: {
              value: 0
            },
            clearcoatRoughnessMap: {
              value: null
            },
            clearcoatRoughnessMapTransform: {
              value: new Pt()
            },
            dispersion: {
              value: 0
            },
            iridescence: {
              value: 0
            },
            iridescenceMap: {
              value: null
            },
            iridescenceMapTransform: {
              value: new Pt()
            },
            iridescenceIOR: {
              value: 1.3
            },
            iridescenceThicknessMinimum: {
              value: 100
            },
            iridescenceThicknessMaximum: {
              value: 400
            },
            iridescenceThicknessMap: {
              value: null
            },
            iridescenceThicknessMapTransform: {
              value: new Pt()
            },
            sheen: {
              value: 0
            },
            sheenColor: {
              value: new It(0)
            },
            sheenColorMap: {
              value: null
            },
            sheenColorMapTransform: {
              value: new Pt()
            },
            sheenRoughness: {
              value: 1
            },
            sheenRoughnessMap: {
              value: null
            },
            sheenRoughnessMapTransform: {
              value: new Pt()
            },
            transmission: {
              value: 0
            },
            transmissionMap: {
              value: null
            },
            transmissionMapTransform: {
              value: new Pt()
            },
            transmissionSamplerSize: {
              value: new Ut()
            },
            transmissionSamplerMap: {
              value: null
            },
            thickness: {
              value: 0
            },
            thicknessMap: {
              value: null
            },
            thicknessMapTransform: {
              value: new Pt()
            },
            attenuationDistance: {
              value: 0
            },
            attenuationColor: {
              value: new It(0)
            },
            specularColor: {
              value: new It(1, 1, 1)
            },
            specularColorMap: {
              value: null
            },
            specularColorMapTransform: {
              value: new Pt()
            },
            specularIntensity: {
              value: 1
            },
            specularIntensityMap: {
              value: null
            },
            specularIntensityMapTransform: {
              value: new Pt()
            },
            anisotropyVector: {
              value: new Ut()
            },
            anisotropyMap: {
              value: null
            },
            anisotropyMapTransform: {
              value: new Pt()
            }
          }
        ]),
        vertexShader: Bt.meshphysical_vert,
        fragmentShader: Bt.meshphysical_frag
      };
      const pc = {
        r: 0,
        b: 0,
        g: 0
      }, Za = new Mi(), PR = new ie();
      function zR(e, t, n, i, a, s, r) {
        const o = new It(0);
        let l = s === true ? 0 : 1, c, f, d = null, h = 0, p = null;
        function y(g) {
          let v = g.isScene === true ? g.background : null;
          return v && v.isTexture && (v = (g.backgroundBlurriness > 0 ? n : t).get(v)), v;
        }
        function S(g) {
          let v = false;
          const T = y(g);
          T === null ? u(o, l) : T && T.isColor && (u(T, 1), v = true);
          const R = e.xr.getEnvironmentBlendMode();
          R === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, r) : R === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, r), (e.autoClear || v) && (i.buffers.depth.setTest(true), i.buffers.depth.setMask(true), i.buffers.color.setMask(true), e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil));
        }
        function m(g, v) {
          const T = y(v);
          T && (T.isCubeTexture || T.mapping === Gu) ? (f === void 0 && (f = new Qn(new eo(1, 1, 1), new na({
            name: "BackgroundCubeMaterial",
            uniforms: Xr(di.backgroundCube.uniforms),
            vertexShader: di.backgroundCube.vertexShader,
            fragmentShader: di.backgroundCube.fragmentShader,
            side: dn,
            depthTest: false,
            depthWrite: false,
            fog: false
          })), f.geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function(R, w, D) {
            this.matrixWorld.copyPosition(D.matrixWorld);
          }, Object.defineProperty(f.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          }), a.update(f)), Za.copy(v.backgroundRotation), Za.x *= -1, Za.y *= -1, Za.z *= -1, T.isCubeTexture && T.isRenderTargetTexture === false && (Za.y *= -1, Za.z *= -1), f.material.uniforms.envMap.value = T, f.material.uniforms.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === false ? -1 : 1, f.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, f.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, f.material.uniforms.backgroundRotation.value.setFromMatrix4(PR.makeRotationFromEuler(Za)), f.material.toneMapped = te.getTransfer(T.colorSpace) !== le, (d !== T || h !== T.version || p !== e.toneMapping) && (f.material.needsUpdate = true, d = T, h = T.version, p = e.toneMapping), f.layers.enableAll(), g.unshift(f, f.geometry, f.material, 0, 0, null)) : T && T.isTexture && (c === void 0 && (c = new Qn(new ku(2, 2), new na({
            name: "BackgroundMaterial",
            uniforms: Xr(di.background.uniforms),
            vertexShader: di.background.vertexShader,
            fragmentShader: di.background.fragmentShader,
            side: Ia,
            depthTest: false,
            depthWrite: false,
            fog: false
          })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          }), a.update(c)), c.material.uniforms.t2D.value = T, c.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, c.material.toneMapped = te.getTransfer(T.colorSpace) !== le, T.matrixAutoUpdate === true && T.updateMatrix(), c.material.uniforms.uvTransform.value.copy(T.matrix), (d !== T || h !== T.version || p !== e.toneMapping) && (c.material.needsUpdate = true, d = T, h = T.version, p = e.toneMapping), c.layers.enableAll(), g.unshift(c, c.geometry, c.material, 0, 0, null));
        }
        function u(g, v) {
          g.getRGB(pc, TS(e)), i.buffers.color.setClear(pc.r, pc.g, pc.b, v, r);
        }
        function _() {
          f !== void 0 && (f.geometry.dispose(), f.material.dispose()), c !== void 0 && (c.geometry.dispose(), c.material.dispose());
        }
        return {
          getClearColor: function() {
            return o;
          },
          setClearColor: function(g, v = 1) {
            o.set(g), l = v, u(o, l);
          },
          getClearAlpha: function() {
            return l;
          },
          setClearAlpha: function(g) {
            l = g, u(o, l);
          },
          render: S,
          addToRenderList: m,
          dispose: _
        };
      }
      function BR(e, t) {
        const n = e.getParameter(e.MAX_VERTEX_ATTRIBS), i = {}, a = h(null);
        let s = a, r = false;
        function o(x, C, V, I, X) {
          let Q = false;
          const L = d(I, V, C);
          s !== L && (s = L, c(s.object)), Q = p(x, I, V, X), Q && y(x, I, V, X), X !== null && t.update(X, e.ELEMENT_ARRAY_BUFFER), (Q || r) && (r = false, v(x, C, V, I), X !== null && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(X).buffer));
        }
        function l() {
          return e.createVertexArray();
        }
        function c(x) {
          return e.bindVertexArray(x);
        }
        function f(x) {
          return e.deleteVertexArray(x);
        }
        function d(x, C, V) {
          const I = V.wireframe === true;
          let X = i[x.id];
          X === void 0 && (X = {}, i[x.id] = X);
          let Q = X[C.id];
          Q === void 0 && (Q = {}, X[C.id] = Q);
          let L = Q[I];
          return L === void 0 && (L = h(l()), Q[I] = L), L;
        }
        function h(x) {
          const C = [], V = [], I = [];
          for (let X = 0; X < n; X++) C[X] = 0, V[X] = 0, I[X] = 0;
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: C,
            enabledAttributes: V,
            attributeDivisors: I,
            object: x,
            attributes: {},
            index: null
          };
        }
        function p(x, C, V, I) {
          const X = s.attributes, Q = C.attributes;
          let L = 0;
          const W = V.getAttributes();
          for (const B in W) if (W[B].location >= 0) {
            const it = X[B];
            let gt = Q[B];
            if (gt === void 0 && (B === "instanceMatrix" && x.instanceMatrix && (gt = x.instanceMatrix), B === "instanceColor" && x.instanceColor && (gt = x.instanceColor)), it === void 0 || it.attribute !== gt || gt && it.data !== gt.data) return true;
            L++;
          }
          return s.attributesNum !== L || s.index !== I;
        }
        function y(x, C, V, I) {
          const X = {}, Q = C.attributes;
          let L = 0;
          const W = V.getAttributes();
          for (const B in W) if (W[B].location >= 0) {
            let it = Q[B];
            it === void 0 && (B === "instanceMatrix" && x.instanceMatrix && (it = x.instanceMatrix), B === "instanceColor" && x.instanceColor && (it = x.instanceColor));
            const gt = {};
            gt.attribute = it, it && it.data && (gt.data = it.data), X[B] = gt, L++;
          }
          s.attributes = X, s.attributesNum = L, s.index = I;
        }
        function S() {
          const x = s.newAttributes;
          for (let C = 0, V = x.length; C < V; C++) x[C] = 0;
        }
        function m(x) {
          u(x, 0);
        }
        function u(x, C) {
          const V = s.newAttributes, I = s.enabledAttributes, X = s.attributeDivisors;
          V[x] = 1, I[x] === 0 && (e.enableVertexAttribArray(x), I[x] = 1), X[x] !== C && (e.vertexAttribDivisor(x, C), X[x] = C);
        }
        function _() {
          const x = s.newAttributes, C = s.enabledAttributes;
          for (let V = 0, I = C.length; V < I; V++) C[V] !== x[V] && (e.disableVertexAttribArray(V), C[V] = 0);
        }
        function g(x, C, V, I, X, Q, L) {
          L === true ? e.vertexAttribIPointer(x, C, V, X, Q) : e.vertexAttribPointer(x, C, V, I, X, Q);
        }
        function v(x, C, V, I) {
          S();
          const X = I.attributes, Q = V.getAttributes(), L = C.defaultAttributeValues;
          for (const W in Q) {
            const B = Q[W];
            if (B.location >= 0) {
              let $ = X[W];
              if ($ === void 0 && (W === "instanceMatrix" && x.instanceMatrix && ($ = x.instanceMatrix), W === "instanceColor" && x.instanceColor && ($ = x.instanceColor)), $ !== void 0) {
                const it = $.normalized, gt = $.itemSize, Dt = t.get($);
                if (Dt === void 0) continue;
                const ne = Dt.buffer, Y = Dt.type, nt = Dt.bytesPerElement, _t = Y === e.INT || Y === e.UNSIGNED_INT || $.gpuType === $p;
                if ($.isInterleavedBufferAttribute) {
                  const ot = $.data, Tt = ot.stride, wt = $.offset;
                  if (ot.isInstancedInterleavedBuffer) {
                    for (let Vt = 0; Vt < B.locationSize; Vt++) u(B.location + Vt, ot.meshPerAttribute);
                    x.isInstancedMesh !== true && I._maxInstanceCount === void 0 && (I._maxInstanceCount = ot.meshPerAttribute * ot.count);
                  } else for (let Vt = 0; Vt < B.locationSize; Vt++) m(B.location + Vt);
                  e.bindBuffer(e.ARRAY_BUFFER, ne);
                  for (let Vt = 0; Vt < B.locationSize; Vt++) g(B.location + Vt, gt / B.locationSize, Y, it, Tt * nt, (wt + gt / B.locationSize * Vt) * nt, _t);
                } else {
                  if ($.isInstancedBufferAttribute) {
                    for (let ot = 0; ot < B.locationSize; ot++) u(B.location + ot, $.meshPerAttribute);
                    x.isInstancedMesh !== true && I._maxInstanceCount === void 0 && (I._maxInstanceCount = $.meshPerAttribute * $.count);
                  } else for (let ot = 0; ot < B.locationSize; ot++) m(B.location + ot);
                  e.bindBuffer(e.ARRAY_BUFFER, ne);
                  for (let ot = 0; ot < B.locationSize; ot++) g(B.location + ot, gt / B.locationSize, Y, it, gt * nt, gt / B.locationSize * ot * nt, _t);
                }
              } else if (L !== void 0) {
                const it = L[W];
                if (it !== void 0) switch (it.length) {
                  case 2:
                    e.vertexAttrib2fv(B.location, it);
                    break;
                  case 3:
                    e.vertexAttrib3fv(B.location, it);
                    break;
                  case 4:
                    e.vertexAttrib4fv(B.location, it);
                    break;
                  default:
                    e.vertexAttrib1fv(B.location, it);
                }
              }
            }
          }
          _();
        }
        function T() {
          D();
          for (const x in i) {
            const C = i[x];
            for (const V in C) {
              const I = C[V];
              for (const X in I) f(I[X].object), delete I[X];
              delete C[V];
            }
            delete i[x];
          }
        }
        function R(x) {
          if (i[x.id] === void 0) return;
          const C = i[x.id];
          for (const V in C) {
            const I = C[V];
            for (const X in I) f(I[X].object), delete I[X];
            delete C[V];
          }
          delete i[x.id];
        }
        function w(x) {
          for (const C in i) {
            const V = i[C];
            if (V[x.id] === void 0) continue;
            const I = V[x.id];
            for (const X in I) f(I[X].object), delete I[X];
            delete V[x.id];
          }
        }
        function D() {
          b(), r = true, s !== a && (s = a, c(s.object));
        }
        function b() {
          a.geometry = null, a.program = null, a.wireframe = false;
        }
        return {
          setup: o,
          reset: D,
          resetDefaultState: b,
          dispose: T,
          releaseStatesOfGeometry: R,
          releaseStatesOfProgram: w,
          initAttributes: S,
          enableAttribute: m,
          disableUnusedAttributes: _
        };
      }
      function FR(e, t, n) {
        let i;
        function a(c) {
          i = c;
        }
        function s(c, f) {
          e.drawArrays(i, c, f), n.update(f, i, 1);
        }
        function r(c, f, d) {
          d !== 0 && (e.drawArraysInstanced(i, c, f, d), n.update(f, i, d));
        }
        function o(c, f, d) {
          if (d === 0) return;
          t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, f, 0, d);
          let p = 0;
          for (let y = 0; y < d; y++) p += f[y];
          n.update(p, i, 1);
        }
        function l(c, f, d, h) {
          if (d === 0) return;
          const p = t.get("WEBGL_multi_draw");
          if (p === null) for (let y = 0; y < c.length; y++) r(c[y], f[y], h[y]);
          else {
            p.multiDrawArraysInstancedWEBGL(i, c, 0, f, 0, h, 0, d);
            let y = 0;
            for (let S = 0; S < d; S++) y += f[S] * h[S];
            n.update(y, i, 1);
          }
        }
        this.setMode = a, this.render = s, this.renderInstances = r, this.renderMultiDraw = o, this.renderMultiDrawInstances = l;
      }
      function IR(e, t, n, i) {
        let a;
        function s() {
          if (a !== void 0) return a;
          if (t.has("EXT_texture_filter_anisotropic") === true) {
            const w = t.get("EXT_texture_filter_anisotropic");
            a = e.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else a = 0;
          return a;
        }
        function r(w) {
          return !(w !== ci && i.convert(w) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function o(w) {
          const D = w === Al && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
          return !(w !== ea && i.convert(w) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && w !== gi && !D);
        }
        function l(w) {
          if (w === "highp") {
            if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
            w = "mediump";
          }
          return w === "mediump" && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let c = n.precision !== void 0 ? n.precision : "highp";
        const f = l(c);
        f !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", f, "instead."), c = f);
        const d = n.logarithmicDepthBuffer === true, h = n.reverseDepthBuffer === true && t.has("EXT_clip_control"), p = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), y = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), S = e.getParameter(e.MAX_TEXTURE_SIZE), m = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), u = e.getParameter(e.MAX_VERTEX_ATTRIBS), _ = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), g = e.getParameter(e.MAX_VARYING_VECTORS), v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), T = y > 0, R = e.getParameter(e.MAX_SAMPLES);
        return {
          isWebGL2: true,
          getMaxAnisotropy: s,
          getMaxPrecision: l,
          textureFormatReadable: r,
          textureTypeReadable: o,
          precision: c,
          logarithmicDepthBuffer: d,
          reverseDepthBuffer: h,
          maxTextures: p,
          maxVertexTextures: y,
          maxTextureSize: S,
          maxCubemapSize: m,
          maxAttributes: u,
          maxVertexUniforms: _,
          maxVaryings: g,
          maxFragmentUniforms: v,
          vertexTextures: T,
          maxSamples: R
        };
      }
      function HR(e) {
        const t = this;
        let n = null, i = 0, a = false, s = false;
        const r = new _a(), o = new Pt(), l = {
          value: null,
          needsUpdate: false
        };
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, h) {
          const p = d.length !== 0 || h || i !== 0 || a;
          return a = h, i = d.length, p;
        }, this.beginShadows = function() {
          s = true, f(null);
        }, this.endShadows = function() {
          s = false;
        }, this.setGlobalState = function(d, h) {
          n = f(d, h, 0);
        }, this.setState = function(d, h, p) {
          const y = d.clippingPlanes, S = d.clipIntersection, m = d.clipShadows, u = e.get(d);
          if (!a || y === null || y.length === 0 || s && !m) s ? f(null) : c();
          else {
            const _ = s ? 0 : i, g = _ * 4;
            let v = u.clippingState || null;
            l.value = v, v = f(y, h, g, p);
            for (let T = 0; T !== g; ++T) v[T] = n[T];
            u.clippingState = v, this.numIntersection = S ? this.numPlanes : 0, this.numPlanes += _;
          }
        };
        function c() {
          l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0;
        }
        function f(d, h, p, y) {
          const S = d !== null ? d.length : 0;
          let m = null;
          if (S !== 0) {
            if (m = l.value, y !== true || m === null) {
              const u = p + S * 4, _ = h.matrixWorldInverse;
              o.getNormalMatrix(_), (m === null || m.length < u) && (m = new Float32Array(u));
              for (let g = 0, v = p; g !== S; ++g, v += 4) r.copy(d[g]).applyMatrix4(_, o), r.normal.toArray(m, v), m[v + 3] = r.constant;
            }
            l.value = m, l.needsUpdate = true;
          }
          return t.numPlanes = S, t.numIntersection = 0, m;
        }
      }
      function GR(e) {
        let t = /* @__PURE__ */ new WeakMap();
        function n(r, o) {
          return o === yd ? r.mapping = Ir : o === Sd && (r.mapping = Hr), r;
        }
        function i(r) {
          if (r && r.isTexture) {
            const o = r.mapping;
            if (o === yd || o === Sd) if (t.has(r)) {
              const l = t.get(r).texture;
              return n(l, r.mapping);
            } else {
              const l = r.image;
              if (l && l.height > 0) {
                const c = new P1(l.height);
                return c.fromEquirectangularTexture(e, r), t.set(r, c), r.addEventListener("dispose", a), n(c.texture, r.mapping);
              } else return null;
            }
          }
          return r;
        }
        function a(r) {
          const o = r.target;
          o.removeEventListener("dispose", a);
          const l = t.get(o);
          l !== void 0 && (t.delete(o), l.dispose());
        }
        function s() {
          t = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: i,
          dispose: s
        };
      }
      const pr = 4, Ug = [
        0.125,
        0.215,
        0.35,
        0.446,
        0.526,
        0.582
      ], ns = 20, eh = new LS(), Lg = new It();
      let nh = null, ih = 0, ah = 0, sh = false;
      const $a = (1 + Math.sqrt(5)) / 2, js = 1 / $a, Ng = [
        new z(-$a, js, 0),
        new z($a, js, 0),
        new z(-js, 0, $a),
        new z(js, 0, $a),
        new z(0, $a, -js),
        new z(0, $a, js),
        new z(-1, 1, -1),
        new z(1, 1, -1),
        new z(-1, 1, 1),
        new z(1, 1, 1)
      ];
      class Og {
        constructor(t) {
          this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, n = 0, i = 0.1, a = 100) {
          nh = this._renderer.getRenderTarget(), ih = this._renderer.getActiveCubeFace(), ah = this._renderer.getActiveMipmapLevel(), sh = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(256);
          const s = this._allocateTargets();
          return s.depthBuffer = true, this._sceneToCubeUV(t, i, a, s), n > 0 && this._blur(s, 0, 0, n), this._applyPMREM(s), this._cleanup(s), s;
        }
        fromEquirectangular(t, n = null) {
          return this._fromTexture(t, n);
        }
        fromCubemap(t, n = null) {
          return this._fromTexture(t, n);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null && (this._cubemapMaterial = Bg(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null && (this._equirectMaterial = zg(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(t) {
          this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
          for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose();
        }
        _cleanup(t) {
          this._renderer.setRenderTarget(nh, ih, ah), this._renderer.xr.enabled = sh, t.scissorTest = false, mc(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t, n) {
          t.mapping === Ir || t.mapping === Hr ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), nh = this._renderer.getRenderTarget(), ih = this._renderer.getActiveCubeFace(), ah = this._renderer.getActiveMipmapLevel(), sh = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
          const i = n || this._allocateTargets();
          return this._textureToCubeUV(t, i), this._applyPMREM(i), this._cleanup(i), i;
        }
        _allocateTargets() {
          const t = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, i = {
            magFilter: _i,
            minFilter: _i,
            generateMipmaps: false,
            type: Al,
            format: ci,
            colorSpace: kr,
            depthBuffer: false
          }, a = Pg(t, n, i);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== n) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Pg(t, n, i);
            const { _lodMax: s } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = VR(s)), this._blurMaterial = kR(s, t, n);
          }
          return a;
        }
        _compileMaterial(t) {
          const n = new Qn(this._lodPlanes[0], t);
          this._renderer.compile(n, eh);
        }
        _sceneToCubeUV(t, n, i, a) {
          const o = new Wn(90, 1, n, i), l = [
            1,
            -1,
            1,
            1,
            1,
            1
          ], c = [
            1,
            1,
            1,
            -1,
            -1,
            -1
          ], f = this._renderer, d = f.autoClear, h = f.toneMapping;
          f.getClearColor(Lg), f.toneMapping = Na, f.autoClear = false;
          const p = new MS({
            name: "PMREM.Background",
            side: dn,
            depthWrite: false,
            depthTest: false
          }), y = new Qn(new eo(), p);
          let S = false;
          const m = t.background;
          m ? m.isColor && (p.color.copy(m), t.background = null, S = true) : (p.color.copy(Lg), S = true);
          for (let u = 0; u < 6; u++) {
            const _ = u % 3;
            _ === 0 ? (o.up.set(0, l[u], 0), o.lookAt(c[u], 0, 0)) : _ === 1 ? (o.up.set(0, 0, l[u]), o.lookAt(0, c[u], 0)) : (o.up.set(0, l[u], 0), o.lookAt(0, 0, c[u]));
            const g = this._cubeSize;
            mc(a, _ * g, u > 2 ? g : 0, g, g), f.setRenderTarget(a), S && f.render(y, o), f.render(t, o);
          }
          y.geometry.dispose(), y.material.dispose(), f.toneMapping = h, f.autoClear = d, t.background = m;
        }
        _textureToCubeUV(t, n) {
          const i = this._renderer, a = t.mapping === Ir || t.mapping === Hr;
          a ? (this._cubemapMaterial === null && (this._cubemapMaterial = Bg()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = zg());
          const s = a ? this._cubemapMaterial : this._equirectMaterial, r = new Qn(this._lodPlanes[0], s), o = s.uniforms;
          o.envMap.value = t;
          const l = this._cubeSize;
          mc(n, 0, 0, 3 * l, 2 * l), i.setRenderTarget(n), i.render(r, eh);
        }
        _applyPMREM(t) {
          const n = this._renderer, i = n.autoClear;
          n.autoClear = false;
          const a = this._lodPlanes.length;
          for (let s = 1; s < a; s++) {
            const r = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = Ng[(a - s - 1) % Ng.length];
            this._blur(t, s - 1, s, r, o);
          }
          n.autoClear = i;
        }
        _blur(t, n, i, a, s) {
          const r = this._pingPongRenderTarget;
          this._halfBlur(t, r, n, i, a, "latitudinal", s), this._halfBlur(r, t, i, i, a, "longitudinal", s);
        }
        _halfBlur(t, n, i, a, s, r, o) {
          const l = this._renderer, c = this._blurMaterial;
          r !== "latitudinal" && r !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
          const f = 3, d = new Qn(this._lodPlanes[a], c), h = c.uniforms, p = this._sizeLods[i] - 1, y = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * ns - 1), S = s / y, m = isFinite(s) ? 1 + Math.floor(f * S) : ns;
          m > ns && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${ns}`);
          const u = [];
          let _ = 0;
          for (let w = 0; w < ns; ++w) {
            const D = w / S, b = Math.exp(-D * D / 2);
            u.push(b), w === 0 ? _ += b : w < m && (_ += 2 * b);
          }
          for (let w = 0; w < u.length; w++) u[w] = u[w] / _;
          h.envMap.value = t.texture, h.samples.value = m, h.weights.value = u, h.latitudinal.value = r === "latitudinal", o && (h.poleAxis.value = o);
          const { _lodMax: g } = this;
          h.dTheta.value = y, h.mipInt.value = g - i;
          const v = this._sizeLods[a], T = 3 * v * (a > g - pr ? a - g + pr : 0), R = 4 * (this._cubeSize - v);
          mc(n, T, R, 3 * v, 2 * v), l.setRenderTarget(n), l.render(d, eh);
        }
      }
      function VR(e) {
        const t = [], n = [], i = [];
        let a = e;
        const s = e - pr + 1 + Ug.length;
        for (let r = 0; r < s; r++) {
          const o = Math.pow(2, a);
          n.push(o);
          let l = 1 / o;
          r > e - pr ? l = Ug[r - e + pr - 1] : r === 0 && (l = 0), i.push(l);
          const c = 1 / (o - 2), f = -c, d = 1 + c, h = [
            f,
            f,
            d,
            f,
            d,
            d,
            f,
            f,
            d,
            d,
            f,
            d
          ], p = 6, y = 6, S = 3, m = 2, u = 1, _ = new Float32Array(S * y * p), g = new Float32Array(m * y * p), v = new Float32Array(u * y * p);
          for (let R = 0; R < p; R++) {
            const w = R % 3 * 2 / 3 - 1, D = R > 2 ? 0 : -1, b = [
              w,
              D,
              0,
              w + 2 / 3,
              D,
              0,
              w + 2 / 3,
              D + 1,
              0,
              w,
              D,
              0,
              w + 2 / 3,
              D + 1,
              0,
              w,
              D + 1,
              0
            ];
            _.set(b, S * y * R), g.set(h, m * y * R);
            const x = [
              R,
              R,
              R,
              R,
              R,
              R
            ];
            v.set(x, u * y * R);
          }
          const T = new Ti();
          T.setAttribute("position", new fi(_, S)), T.setAttribute("uv", new fi(g, m)), T.setAttribute("faceIndex", new fi(v, u)), t.push(T), a > pr && a--;
        }
        return {
          lodPlanes: t,
          sizeLods: n,
          sigmas: i
        };
      }
      function Pg(e, t, n) {
        const i = new Ss(e, t, n);
        return i.texture.mapping = Gu, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
      }
      function mc(e, t, n, i, a) {
        e.viewport.set(t, n, i, a), e.scissor.set(t, n, i, a);
      }
      function kR(e, t, n) {
        const i = new Float32Array(ns), a = new z(0, 1, 0);
        return new na({
          name: "SphericalGaussianBlur",
          defines: {
            n: ns,
            CUBEUV_TEXEL_WIDTH: 1 / t,
            CUBEUV_TEXEL_HEIGHT: 1 / n,
            CUBEUV_MAX_MIP: `${e}.0`
          },
          uniforms: {
            envMap: {
              value: null
            },
            samples: {
              value: 1
            },
            weights: {
              value: i
            },
            latitudinal: {
              value: false
            },
            dTheta: {
              value: 0
            },
            mipInt: {
              value: 0
            },
            poleAxis: {
              value: a
            }
          },
          vertexShader: um(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: La,
          depthTest: false,
          depthWrite: false
        });
      }
      function zg() {
        return new na({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: {
              value: null
            }
          },
          vertexShader: um(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: La,
          depthTest: false,
          depthWrite: false
        });
      }
      function Bg() {
        return new na({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            }
          },
          vertexShader: um(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: La,
          depthTest: false,
          depthWrite: false
        });
      }
      function um() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function XR(e) {
        let t = /* @__PURE__ */ new WeakMap(), n = null;
        function i(o) {
          if (o && o.isTexture) {
            const l = o.mapping, c = l === yd || l === Sd, f = l === Ir || l === Hr;
            if (c || f) {
              let d = t.get(o);
              const h = d !== void 0 ? d.texture.pmremVersion : 0;
              if (o.isRenderTargetTexture && o.pmremVersion !== h) return n === null && (n = new Og(e)), d = c ? n.fromEquirectangular(o, d) : n.fromCubemap(o, d), d.texture.pmremVersion = o.pmremVersion, t.set(o, d), d.texture;
              if (d !== void 0) return d.texture;
              {
                const p = o.image;
                return c && p && p.height > 0 || f && p && a(p) ? (n === null && (n = new Og(e)), d = c ? n.fromEquirectangular(o) : n.fromCubemap(o), d.texture.pmremVersion = o.pmremVersion, t.set(o, d), o.addEventListener("dispose", s), d.texture) : null;
              }
            }
          }
          return o;
        }
        function a(o) {
          let l = 0;
          const c = 6;
          for (let f = 0; f < c; f++) o[f] !== void 0 && l++;
          return l === c;
        }
        function s(o) {
          const l = o.target;
          l.removeEventListener("dispose", s);
          const c = t.get(l);
          c !== void 0 && (t.delete(l), c.dispose());
        }
        function r() {
          t = /* @__PURE__ */ new WeakMap(), n !== null && (n.dispose(), n = null);
        }
        return {
          get: i,
          dispose: r
        };
      }
      function WR(e) {
        const t = {};
        function n(i) {
          if (t[i] !== void 0) return t[i];
          let a;
          switch (i) {
            case "WEBGL_depth_texture":
              a = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              a = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              a = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              a = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              a = e.getExtension(i);
          }
          return t[i] = a, a;
        }
        return {
          has: function(i) {
            return n(i) !== null;
          },
          init: function() {
            n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent");
          },
          get: function(i) {
            const a = n(i);
            return a === null && tr("THREE.WebGLRenderer: " + i + " extension not supported."), a;
          }
        };
      }
      function YR(e, t, n, i) {
        const a = {}, s = /* @__PURE__ */ new WeakMap();
        function r(d) {
          const h = d.target;
          h.index !== null && t.remove(h.index);
          for (const y in h.attributes) t.remove(h.attributes[y]);
          h.removeEventListener("dispose", r), delete a[h.id];
          const p = s.get(h);
          p && (t.remove(p), s.delete(h)), i.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === true && delete h._maxInstanceCount, n.memory.geometries--;
        }
        function o(d, h) {
          return a[h.id] === true || (h.addEventListener("dispose", r), a[h.id] = true, n.memory.geometries++), h;
        }
        function l(d) {
          const h = d.attributes;
          for (const p in h) t.update(h[p], e.ARRAY_BUFFER);
        }
        function c(d) {
          const h = [], p = d.index, y = d.attributes.position;
          let S = 0;
          if (p !== null) {
            const _ = p.array;
            S = p.version;
            for (let g = 0, v = _.length; g < v; g += 3) {
              const T = _[g + 0], R = _[g + 1], w = _[g + 2];
              h.push(T, R, R, w, w, T);
            }
          } else if (y !== void 0) {
            const _ = y.array;
            S = y.version;
            for (let g = 0, v = _.length / 3 - 1; g < v; g += 3) {
              const T = g + 0, R = g + 1, w = g + 2;
              h.push(T, R, R, w, w, T);
            }
          } else return;
          const m = new (vS(h) ? bS : ES)(h, 1);
          m.version = S;
          const u = s.get(d);
          u && t.remove(u), s.set(d, m);
        }
        function f(d) {
          const h = s.get(d);
          if (h) {
            const p = d.index;
            p !== null && h.version < p.version && c(d);
          } else c(d);
          return s.get(d);
        }
        return {
          get: o,
          update: l,
          getWireframeAttribute: f
        };
      }
      function qR(e, t, n) {
        let i;
        function a(h) {
          i = h;
        }
        let s, r;
        function o(h) {
          s = h.type, r = h.bytesPerElement;
        }
        function l(h, p) {
          e.drawElements(i, p, s, h * r), n.update(p, i, 1);
        }
        function c(h, p, y) {
          y !== 0 && (e.drawElementsInstanced(i, p, s, h * r, y), n.update(p, i, y));
        }
        function f(h, p, y) {
          if (y === 0) return;
          t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, p, 0, s, h, 0, y);
          let m = 0;
          for (let u = 0; u < y; u++) m += p[u];
          n.update(m, i, 1);
        }
        function d(h, p, y, S) {
          if (y === 0) return;
          const m = t.get("WEBGL_multi_draw");
          if (m === null) for (let u = 0; u < h.length; u++) c(h[u] / r, p[u], S[u]);
          else {
            m.multiDrawElementsInstancedWEBGL(i, p, 0, s, h, 0, S, 0, y);
            let u = 0;
            for (let _ = 0; _ < y; _++) u += p[_] * S[_];
            n.update(u, i, 1);
          }
        }
        this.setMode = a, this.setIndex = o, this.render = l, this.renderInstances = c, this.renderMultiDraw = f, this.renderMultiDrawInstances = d;
      }
      function jR(e) {
        const t = {
          geometries: 0,
          textures: 0
        }, n = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function i(s, r, o) {
          switch (n.calls++, r) {
            case e.TRIANGLES:
              n.triangles += o * (s / 3);
              break;
            case e.LINES:
              n.lines += o * (s / 2);
              break;
            case e.LINE_STRIP:
              n.lines += o * (s - 1);
              break;
            case e.LINE_LOOP:
              n.lines += o * s;
              break;
            case e.POINTS:
              n.points += o * s;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", r);
              break;
          }
        }
        function a() {
          n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
        }
        return {
          memory: t,
          render: n,
          programs: null,
          autoReset: true,
          reset: a,
          update: i
        };
      }
      function ZR(e, t, n) {
        const i = /* @__PURE__ */ new WeakMap(), a = new Ce();
        function s(r, o, l) {
          const c = r.morphTargetInfluences, f = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, d = f !== void 0 ? f.length : 0;
          let h = i.get(o);
          if (h === void 0 || h.count !== d) {
            let b = function() {
              w.dispose(), i.delete(o), o.removeEventListener("dispose", b);
            };
            h !== void 0 && h.texture.dispose();
            const p = o.morphAttributes.position !== void 0, y = o.morphAttributes.normal !== void 0, S = o.morphAttributes.color !== void 0, m = o.morphAttributes.position || [], u = o.morphAttributes.normal || [], _ = o.morphAttributes.color || [];
            let g = 0;
            p === true && (g = 1), y === true && (g = 2), S === true && (g = 3);
            let v = o.attributes.position.count * g, T = 1;
            v > t.maxTextureSize && (T = Math.ceil(v / t.maxTextureSize), v = t.maxTextureSize);
            const R = new Float32Array(v * T * 4 * d), w = new SS(R, v, T, d);
            w.type = gi, w.needsUpdate = true;
            const D = g * 4;
            for (let x = 0; x < d; x++) {
              const C = m[x], V = u[x], I = _[x], X = v * T * 4 * x;
              for (let Q = 0; Q < C.count; Q++) {
                const L = Q * D;
                p === true && (a.fromBufferAttribute(C, Q), R[X + L + 0] = a.x, R[X + L + 1] = a.y, R[X + L + 2] = a.z, R[X + L + 3] = 0), y === true && (a.fromBufferAttribute(V, Q), R[X + L + 4] = a.x, R[X + L + 5] = a.y, R[X + L + 6] = a.z, R[X + L + 7] = 0), S === true && (a.fromBufferAttribute(I, Q), R[X + L + 8] = a.x, R[X + L + 9] = a.y, R[X + L + 10] = a.z, R[X + L + 11] = I.itemSize === 4 ? a.w : 1);
              }
            }
            h = {
              count: d,
              texture: w,
              size: new Ut(v, T)
            }, i.set(o, h), o.addEventListener("dispose", b);
          }
          if (r.isInstancedMesh === true && r.morphTexture !== null) l.getUniforms().setValue(e, "morphTexture", r.morphTexture, n);
          else {
            let p = 0;
            for (let S = 0; S < c.length; S++) p += c[S];
            const y = o.morphTargetsRelative ? 1 : 1 - p;
            l.getUniforms().setValue(e, "morphTargetBaseInfluence", y), l.getUniforms().setValue(e, "morphTargetInfluences", c);
          }
          l.getUniforms().setValue(e, "morphTargetsTexture", h.texture, n), l.getUniforms().setValue(e, "morphTargetsTextureSize", h.size);
        }
        return {
          update: s
        };
      }
      function KR(e, t, n, i) {
        let a = /* @__PURE__ */ new WeakMap();
        function s(l) {
          const c = i.render.frame, f = l.geometry, d = t.get(l, f);
          if (a.get(d) !== c && (t.update(d), a.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === false && l.addEventListener("dispose", o), a.get(l) !== c && (n.update(l.instanceMatrix, e.ARRAY_BUFFER), l.instanceColor !== null && n.update(l.instanceColor, e.ARRAY_BUFFER), a.set(l, c))), l.isSkinnedMesh) {
            const h = l.skeleton;
            a.get(h) !== c && (h.update(), a.set(h, c));
          }
          return d;
        }
        function r() {
          a = /* @__PURE__ */ new WeakMap();
        }
        function o(l) {
          const c = l.target;
          c.removeEventListener("dispose", o), n.remove(c.instanceMatrix), c.instanceColor !== null && n.remove(c.instanceColor);
        }
        return {
          update: s,
          dispose: r
        };
      }
      const OS = new pn(), Fg = new DS(1, 1), PS = new SS(), zS = new S1(), BS = new wS(), Ig = [], Hg = [], Gg = new Float32Array(16), Vg = new Float32Array(9), kg = new Float32Array(4);
      function no(e, t, n) {
        const i = e[0];
        if (i <= 0 || i > 0) return e;
        const a = t * n;
        let s = Ig[a];
        if (s === void 0 && (s = new Float32Array(a), Ig[a] = s), t !== 0) {
          i.toArray(s, 0);
          for (let r = 1, o = 0; r !== t; ++r) o += n, e[r].toArray(s, o);
        }
        return s;
      }
      function Ge(e, t) {
        if (e.length !== t.length) return false;
        for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return false;
        return true;
      }
      function Ve(e, t) {
        for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
      }
      function Xu(e, t) {
        let n = Hg[t];
        n === void 0 && (n = new Int32Array(t), Hg[t] = n);
        for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
        return n;
      }
      function QR(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t);
      }
      function JR(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y) && (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
          if (Ge(n, t)) return;
          e.uniform2fv(this.addr, t), Ve(n, t);
        }
      }
      function $R(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else if (t.r !== void 0) (n[0] !== t.r || n[1] !== t.g || n[2] !== t.b) && (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
        else {
          if (Ge(n, t)) return;
          e.uniform3fv(this.addr, t), Ve(n, t);
        }
      }
      function tw(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
          if (Ge(n, t)) return;
          e.uniform4fv(this.addr, t), Ve(n, t);
        }
      }
      function ew(e, t) {
        const n = this.cache, i = t.elements;
        if (i === void 0) {
          if (Ge(n, t)) return;
          e.uniformMatrix2fv(this.addr, false, t), Ve(n, t);
        } else {
          if (Ge(n, i)) return;
          kg.set(i), e.uniformMatrix2fv(this.addr, false, kg), Ve(n, i);
        }
      }
      function nw(e, t) {
        const n = this.cache, i = t.elements;
        if (i === void 0) {
          if (Ge(n, t)) return;
          e.uniformMatrix3fv(this.addr, false, t), Ve(n, t);
        } else {
          if (Ge(n, i)) return;
          Vg.set(i), e.uniformMatrix3fv(this.addr, false, Vg), Ve(n, i);
        }
      }
      function iw(e, t) {
        const n = this.cache, i = t.elements;
        if (i === void 0) {
          if (Ge(n, t)) return;
          e.uniformMatrix4fv(this.addr, false, t), Ve(n, t);
        } else {
          if (Ge(n, i)) return;
          Gg.set(i), e.uniformMatrix4fv(this.addr, false, Gg), Ve(n, i);
        }
      }
      function aw(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t);
      }
      function sw(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y) && (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
          if (Ge(n, t)) return;
          e.uniform2iv(this.addr, t), Ve(n, t);
        }
      }
      function rw(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else {
          if (Ge(n, t)) return;
          e.uniform3iv(this.addr, t), Ve(n, t);
        }
      }
      function ow(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
          if (Ge(n, t)) return;
          e.uniform4iv(this.addr, t), Ve(n, t);
        }
      }
      function lw(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t);
      }
      function cw(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y) && (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
        else {
          if (Ge(n, t)) return;
          e.uniform2uiv(this.addr, t), Ve(n, t);
        }
      }
      function uw(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z) && (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
        else {
          if (Ge(n, t)) return;
          e.uniform3uiv(this.addr, t), Ve(n, t);
        }
      }
      function fw(e, t) {
        const n = this.cache;
        if (t.x !== void 0) (n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w) && (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
        else {
          if (Ge(n, t)) return;
          e.uniform4uiv(this.addr, t), Ve(n, t);
        }
      }
      function hw(e, t, n) {
        const i = this.cache, a = n.allocateTextureUnit();
        i[0] !== a && (e.uniform1i(this.addr, a), i[0] = a);
        let s;
        this.type === e.SAMPLER_2D_SHADOW ? (Fg.compareFunction = gS, s = Fg) : s = OS, n.setTexture2D(t || s, a);
      }
      function dw(e, t, n) {
        const i = this.cache, a = n.allocateTextureUnit();
        i[0] !== a && (e.uniform1i(this.addr, a), i[0] = a), n.setTexture3D(t || zS, a);
      }
      function pw(e, t, n) {
        const i = this.cache, a = n.allocateTextureUnit();
        i[0] !== a && (e.uniform1i(this.addr, a), i[0] = a), n.setTextureCube(t || BS, a);
      }
      function mw(e, t, n) {
        const i = this.cache, a = n.allocateTextureUnit();
        i[0] !== a && (e.uniform1i(this.addr, a), i[0] = a), n.setTexture2DArray(t || PS, a);
      }
      function _w(e) {
        switch (e) {
          case 5126:
            return QR;
          case 35664:
            return JR;
          case 35665:
            return $R;
          case 35666:
            return tw;
          case 35674:
            return ew;
          case 35675:
            return nw;
          case 35676:
            return iw;
          case 5124:
          case 35670:
            return aw;
          case 35667:
          case 35671:
            return sw;
          case 35668:
          case 35672:
            return rw;
          case 35669:
          case 35673:
            return ow;
          case 5125:
            return lw;
          case 36294:
            return cw;
          case 36295:
            return uw;
          case 36296:
            return fw;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return hw;
          case 35679:
          case 36299:
          case 36307:
            return dw;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return pw;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return mw;
        }
      }
      function gw(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function vw(e, t) {
        const n = no(t, this.size, 2);
        e.uniform2fv(this.addr, n);
      }
      function yw(e, t) {
        const n = no(t, this.size, 3);
        e.uniform3fv(this.addr, n);
      }
      function Sw(e, t) {
        const n = no(t, this.size, 4);
        e.uniform4fv(this.addr, n);
      }
      function xw(e, t) {
        const n = no(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, false, n);
      }
      function Mw(e, t) {
        const n = no(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, false, n);
      }
      function Ew(e, t) {
        const n = no(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, false, n);
      }
      function bw(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function Tw(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function Aw(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function Rw(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function ww(e, t) {
        e.uniform1uiv(this.addr, t);
      }
      function Cw(e, t) {
        e.uniform2uiv(this.addr, t);
      }
      function Dw(e, t) {
        e.uniform3uiv(this.addr, t);
      }
      function Uw(e, t) {
        e.uniform4uiv(this.addr, t);
      }
      function Lw(e, t, n) {
        const i = this.cache, a = t.length, s = Xu(n, a);
        Ge(i, s) || (e.uniform1iv(this.addr, s), Ve(i, s));
        for (let r = 0; r !== a; ++r) n.setTexture2D(t[r] || OS, s[r]);
      }
      function Nw(e, t, n) {
        const i = this.cache, a = t.length, s = Xu(n, a);
        Ge(i, s) || (e.uniform1iv(this.addr, s), Ve(i, s));
        for (let r = 0; r !== a; ++r) n.setTexture3D(t[r] || zS, s[r]);
      }
      function Ow(e, t, n) {
        const i = this.cache, a = t.length, s = Xu(n, a);
        Ge(i, s) || (e.uniform1iv(this.addr, s), Ve(i, s));
        for (let r = 0; r !== a; ++r) n.setTextureCube(t[r] || BS, s[r]);
      }
      function Pw(e, t, n) {
        const i = this.cache, a = t.length, s = Xu(n, a);
        Ge(i, s) || (e.uniform1iv(this.addr, s), Ve(i, s));
        for (let r = 0; r !== a; ++r) n.setTexture2DArray(t[r] || PS, s[r]);
      }
      function zw(e) {
        switch (e) {
          case 5126:
            return gw;
          case 35664:
            return vw;
          case 35665:
            return yw;
          case 35666:
            return Sw;
          case 35674:
            return xw;
          case 35675:
            return Mw;
          case 35676:
            return Ew;
          case 5124:
          case 35670:
            return bw;
          case 35667:
          case 35671:
            return Tw;
          case 35668:
          case 35672:
            return Aw;
          case 35669:
          case 35673:
            return Rw;
          case 5125:
            return ww;
          case 36294:
            return Cw;
          case 36295:
            return Dw;
          case 36296:
            return Uw;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return Lw;
          case 35679:
          case 36299:
          case 36307:
            return Nw;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Ow;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return Pw;
        }
      }
      class Bw {
        constructor(t, n, i) {
          this.id = t, this.addr = i, this.cache = [], this.type = n.type, this.setValue = _w(n.type);
        }
      }
      class Fw {
        constructor(t, n, i) {
          this.id = t, this.addr = i, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = zw(n.type);
        }
      }
      class Iw {
        constructor(t) {
          this.id = t, this.seq = [], this.map = {};
        }
        setValue(t, n, i) {
          const a = this.seq;
          for (let s = 0, r = a.length; s !== r; ++s) {
            const o = a[s];
            o.setValue(t, n[o.id], i);
          }
        }
      }
      const rh = /(\w+)(\])?(\[|\.)?/g;
      function Xg(e, t) {
        e.seq.push(t), e.map[t.id] = t;
      }
      function Hw(e, t, n) {
        const i = e.name, a = i.length;
        for (rh.lastIndex = 0; ; ) {
          const s = rh.exec(i), r = rh.lastIndex;
          let o = s[1];
          const l = s[2] === "]", c = s[3];
          if (l && (o = o | 0), c === void 0 || c === "[" && r + 2 === a) {
            Xg(n, c === void 0 ? new Bw(o, e, t) : new Fw(o, e, t));
            break;
          } else {
            let d = n.map[o];
            d === void 0 && (d = new Iw(o), Xg(n, d)), n = d;
          }
        }
      }
      class Bc {
        constructor(t, n) {
          this.seq = [], this.map = {};
          const i = t.getProgramParameter(n, t.ACTIVE_UNIFORMS);
          for (let a = 0; a < i; ++a) {
            const s = t.getActiveUniform(n, a), r = t.getUniformLocation(n, s.name);
            Hw(s, r, this);
          }
        }
        setValue(t, n, i, a) {
          const s = this.map[n];
          s !== void 0 && s.setValue(t, i, a);
        }
        setOptional(t, n, i) {
          const a = n[i];
          a !== void 0 && this.setValue(t, i, a);
        }
        static upload(t, n, i, a) {
          for (let s = 0, r = n.length; s !== r; ++s) {
            const o = n[s], l = i[o.id];
            l.needsUpdate !== false && o.setValue(t, l.value, a);
          }
        }
        static seqWithValue(t, n) {
          const i = [];
          for (let a = 0, s = t.length; a !== s; ++a) {
            const r = t[a];
            r.id in n && i.push(r);
          }
          return i;
        }
      }
      function Wg(e, t, n) {
        const i = e.createShader(t);
        return e.shaderSource(i, n), e.compileShader(i), i;
      }
      const Gw = 37297;
      let Vw = 0;
      function kw(e, t) {
        const n = e.split(`
`), i = [], a = Math.max(t - 6, 0), s = Math.min(t + 6, n.length);
        for (let r = a; r < s; r++) {
          const o = r + 1;
          i.push(`${o === t ? ">" : " "} ${o}: ${n[r]}`);
        }
        return i.join(`
`);
      }
      const Yg = new Pt();
      function Xw(e) {
        te._getMatrix(Yg, te.workingColorSpace, e);
        const t = `mat3( ${Yg.elements.map((n) => n.toFixed(4))} )`;
        switch (te.getTransfer(e)) {
          case mu:
            return [
              t,
              "LinearTransferOETF"
            ];
          case le:
            return [
              t,
              "sRGBTransferOETF"
            ];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported color space: ", e), [
              t,
              "LinearTransferOETF"
            ];
        }
      }
      function qg(e, t, n) {
        const i = e.getShaderParameter(t, e.COMPILE_STATUS), a = e.getShaderInfoLog(t).trim();
        if (i && a === "") return "";
        const s = /ERROR: 0:(\d+)/.exec(a);
        if (s) {
          const r = parseInt(s[1]);
          return n.toUpperCase() + `

` + a + `

` + kw(e.getShaderSource(t), r);
        } else return a;
      }
      function Ww(e, t) {
        const n = Xw(t);
        return [
          `vec4 ${e}( vec4 value ) {`,
          `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
          "}"
        ].join(`
`);
      }
      function Yw(e, t) {
        let n;
        switch (t) {
          case DT:
            n = "Linear";
            break;
          case UT:
            n = "Reinhard";
            break;
          case LT:
            n = "Cineon";
            break;
          case NT:
            n = "ACESFilmic";
            break;
          case PT:
            n = "AgX";
            break;
          case zT:
            n = "Neutral";
            break;
          case OT:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear";
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
      }
      const _c = new z();
      function qw() {
        te.getLuminanceCoefficients(_c);
        const e = _c.x.toFixed(4), t = _c.y.toFixed(4), n = _c.z.toFixed(4);
        return [
          "float luminance( const in vec3 rgb ) {",
          `	const vec3 weights = vec3( ${e}, ${t}, ${n} );`,
          "	return dot( weights, rgb );",
          "}"
        ].join(`
`);
      }
      function jw(e) {
        return [
          e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
          e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(To).join(`
`);
      }
      function Zw(e) {
        const t = [];
        for (const n in e) {
          const i = e[n];
          i !== false && t.push("#define " + n + " " + i);
        }
        return t.join(`
`);
      }
      function Kw(e, t) {
        const n = {}, i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
        for (let a = 0; a < i; a++) {
          const s = e.getActiveAttrib(t, a), r = s.name;
          let o = 1;
          s.type === e.FLOAT_MAT2 && (o = 2), s.type === e.FLOAT_MAT3 && (o = 3), s.type === e.FLOAT_MAT4 && (o = 4), n[r] = {
            type: s.type,
            location: e.getAttribLocation(t, r),
            locationSize: o
          };
        }
        return n;
      }
      function To(e) {
        return e !== "";
      }
      function jg(e, t) {
        const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function Zg(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
      }
      const Qw = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Kd(e) {
        return e.replace(Qw, $w);
      }
      const Jw = /* @__PURE__ */ new Map();
      function $w(e, t) {
        let n = Bt[t];
        if (n === void 0) {
          const i = Jw.get(t);
          if (i !== void 0) n = Bt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, i);
          else throw new Error("Can not resolve #include <" + t + ">");
        }
        return Kd(n);
      }
      const tC = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Kg(e) {
        return e.replace(tC, eC);
      }
      function eC(e, t, n, i) {
        let a = "";
        for (let s = parseInt(t); s < parseInt(n); s++) a += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
        return a;
      }
      function Qg(e) {
        let t = `precision ${e.precision} float;
	precision ${e.precision} int;
	precision ${e.precision} sampler2D;
	precision ${e.precision} samplerCube;
	precision ${e.precision} sampler3D;
	precision ${e.precision} sampler2DArray;
	precision ${e.precision} sampler2DShadow;
	precision ${e.precision} samplerCubeShadow;
	precision ${e.precision} sampler2DArrayShadow;
	precision ${e.precision} isampler2D;
	precision ${e.precision} isampler3D;
	precision ${e.precision} isamplerCube;
	precision ${e.precision} isampler2DArray;
	precision ${e.precision} usampler2D;
	precision ${e.precision} usampler3D;
	precision ${e.precision} usamplerCube;
	precision ${e.precision} usampler2DArray;
	`;
        return e.precision === "highp" ? t += `
#define HIGH_PRECISION` : e.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : e.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
      }
      function nC(e) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return e.shadowMapType === aS ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === cT ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === zi && (t = "SHADOWMAP_TYPE_VSM"), t;
      }
      function iC(e) {
        let t = "ENVMAP_TYPE_CUBE";
        if (e.envMap) switch (e.envMapMode) {
          case Ir:
          case Hr:
            t = "ENVMAP_TYPE_CUBE";
            break;
          case Gu:
            t = "ENVMAP_TYPE_CUBE_UV";
            break;
        }
        return t;
      }
      function aC(e) {
        let t = "ENVMAP_MODE_REFLECTION";
        if (e.envMap) switch (e.envMapMode) {
          case Hr:
            t = "ENVMAP_MODE_REFRACTION";
            break;
        }
        return t;
      }
      function sC(e) {
        let t = "ENVMAP_BLENDING_NONE";
        if (e.envMap) switch (e.combine) {
          case sS:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case wT:
            t = "ENVMAP_BLENDING_MIX";
            break;
          case CT:
            t = "ENVMAP_BLENDING_ADD";
            break;
        }
        return t;
      }
      function rC(e) {
        const t = e.envMapCubeUVHeight;
        if (t === null) return null;
        const n = Math.log2(t) - 2, i = 1 / t;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
          texelHeight: i,
          maxMip: n
        };
      }
      function oC(e, t, n, i) {
        const a = e.getContext(), s = n.defines;
        let r = n.vertexShader, o = n.fragmentShader;
        const l = nC(n), c = iC(n), f = aC(n), d = sC(n), h = rC(n), p = jw(n), y = Zw(s), S = a.createProgram();
        let m, u, _ = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
        n.isRawShaderMaterial ? (m = [
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          y
        ].filter(To).join(`
`), m.length > 0 && (m += `
`), u = [
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          y
        ].filter(To).join(`
`), u.length > 0 && (u += `
`)) : (m = [
          Qg(n),
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          y,
          n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
          n.batching ? "#define USE_BATCHING" : "",
          n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
          n.instancing ? "#define USE_INSTANCING" : "",
          n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + f : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.anisotropy ? "#define USE_ANISOTROPY" : "",
          n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.alphaHash ? "#define USE_ALPHAHASH" : "",
          n.transmission ? "#define USE_TRANSMISSION" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          n.mapUv ? "#define MAP_UV " + n.mapUv : "",
          n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
          n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
          n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
          n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
          n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
          n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
          n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
          n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
          n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
          n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
          n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
          n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "",
          n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "",
          n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
          n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "",
          n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
          n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "",
          n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
          n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
          n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "",
          n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
          n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
          n.vertexTangents && n.flatShading === false ? "#define USE_TANGENT" : "",
          n.vertexColors ? "#define USE_COLOR" : "",
          n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          n.vertexUv1s ? "#define USE_UV1" : "",
          n.vertexUv2s ? "#define USE_UV2" : "",
          n.vertexUv3s ? "#define USE_UV3" : "",
          n.pointsUvs ? "#define USE_POINTS_UV" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.skinning ? "#define USE_SKINNING" : "",
          n.morphTargets ? "#define USE_MORPHTARGETS" : "",
          n.morphNormals && n.flatShading === false ? "#define USE_MORPHNORMALS" : "",
          n.morphColors ? "#define USE_MORPHCOLORS" : "",
          n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "",
          n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + l : "",
          n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "	attribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "	attribute vec3 instanceColor;",
          "#endif",
          "#ifdef USE_INSTANCING_MORPH",
          "	uniform sampler2D morphTexture;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "	attribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "	attribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "	attribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "	attribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "	attribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "	attribute vec3 color;",
          "#endif",
          "#ifdef USE_SKINNING",
          "	attribute vec4 skinIndex;",
          "	attribute vec4 skinWeight;",
          "#endif",
          `
`
        ].filter(To).join(`
`), u = [
          Qg(n),
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          y,
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
          n.map ? "#define USE_MAP" : "",
          n.matcap ? "#define USE_MATCAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + c : "",
          n.envMap ? "#define " + f : "",
          n.envMap ? "#define " + d : "",
          h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
          h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
          h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.anisotropy ? "#define USE_ANISOTROPY" : "",
          n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          n.clearcoat ? "#define USE_CLEARCOAT" : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.dispersion ? "#define USE_DISPERSION" : "",
          n.iridescence ? "#define USE_IRIDESCENCE" : "",
          n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.alphaTest ? "#define USE_ALPHATEST" : "",
          n.alphaHash ? "#define USE_ALPHAHASH" : "",
          n.sheen ? "#define USE_SHEEN" : "",
          n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          n.transmission ? "#define USE_TRANSMISSION" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          n.vertexTangents && n.flatShading === false ? "#define USE_TANGENT" : "",
          n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "",
          n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          n.vertexUv1s ? "#define USE_UV1" : "",
          n.vertexUv2s ? "#define USE_UV2" : "",
          n.vertexUv3s ? "#define USE_UV3" : "",
          n.pointsUvs ? "#define USE_POINTS_UV" : "",
          n.gradientMap ? "#define USE_GRADIENTMAP" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + l : "",
          n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          n.toneMapping !== Na ? "#define TONE_MAPPING" : "",
          n.toneMapping !== Na ? Bt.tonemapping_pars_fragment : "",
          n.toneMapping !== Na ? Yw("toneMapping", n.toneMapping) : "",
          n.dithering ? "#define DITHERING" : "",
          n.opaque ? "#define OPAQUE" : "",
          Bt.colorspace_pars_fragment,
          Ww("linearToOutputTexel", n.outputColorSpace),
          qw(),
          n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
          `
`
        ].filter(To).join(`
`)), r = Kd(r), r = jg(r, n), r = Zg(r, n), o = Kd(o), o = jg(o, n), o = Zg(o, n), r = Kg(r), o = Kg(o), n.isRawShaderMaterial !== true && (_ = `#version 300 es
`, m = [
          p,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture"
        ].join(`
`) + `
` + m, u = [
          "#define varying in",
          n.glslVersion === $_ ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
          n.glslVersion === $_ ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + u);
        const g = _ + m + r, v = _ + u + o, T = Wg(a, a.VERTEX_SHADER, g), R = Wg(a, a.FRAGMENT_SHADER, v);
        a.attachShader(S, T), a.attachShader(S, R), n.index0AttributeName !== void 0 ? a.bindAttribLocation(S, 0, n.index0AttributeName) : n.morphTargets === true && a.bindAttribLocation(S, 0, "position"), a.linkProgram(S);
        function w(C) {
          if (e.debug.checkShaderErrors) {
            const V = a.getProgramInfoLog(S).trim(), I = a.getShaderInfoLog(T).trim(), X = a.getShaderInfoLog(R).trim();
            let Q = true, L = true;
            if (a.getProgramParameter(S, a.LINK_STATUS) === false) if (Q = false, typeof e.debug.onShaderError == "function") e.debug.onShaderError(a, S, T, R);
            else {
              const W = qg(a, T, "vertex"), B = qg(a, R, "fragment");
              console.error("THREE.WebGLProgram: Shader Error " + a.getError() + " - VALIDATE_STATUS " + a.getProgramParameter(S, a.VALIDATE_STATUS) + `

Material Name: ` + C.name + `
Material Type: ` + C.type + `

Program Info Log: ` + V + `
` + W + `
` + B);
            }
            else V !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", V) : (I === "" || X === "") && (L = false);
            L && (C.diagnostics = {
              runnable: Q,
              programLog: V,
              vertexShader: {
                log: I,
                prefix: m
              },
              fragmentShader: {
                log: X,
                prefix: u
              }
            });
          }
          a.deleteShader(T), a.deleteShader(R), D = new Bc(a, S), b = Kw(a, S);
        }
        let D;
        this.getUniforms = function() {
          return D === void 0 && w(this), D;
        };
        let b;
        this.getAttributes = function() {
          return b === void 0 && w(this), b;
        };
        let x = n.rendererExtensionParallelShaderCompile === false;
        return this.isReady = function() {
          return x === false && (x = a.getProgramParameter(S, Gw)), x;
        }, this.destroy = function() {
          i.releaseStatesOfProgram(this), a.deleteProgram(S), this.program = void 0;
        }, this.type = n.shaderType, this.name = n.shaderName, this.id = Vw++, this.cacheKey = t, this.usedTimes = 1, this.program = S, this.vertexShader = T, this.fragmentShader = R, this;
      }
      let lC = 0;
      class cC {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
        }
        update(t) {
          const n = t.vertexShader, i = t.fragmentShader, a = this._getShaderStage(n), s = this._getShaderStage(i), r = this._getShaderCacheForMaterial(t);
          return r.has(a) === false && (r.add(a), a.usedTimes++), r.has(s) === false && (r.add(s), s.usedTimes++), this;
        }
        remove(t) {
          const n = this.materialCache.get(t);
          for (const i of n) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
          return this.materialCache.delete(t), this;
        }
        getVertexShaderID(t) {
          return this._getShaderStage(t.vertexShader).id;
        }
        getFragmentShaderID(t) {
          return this._getShaderStage(t.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(t) {
          const n = this.materialCache;
          let i = n.get(t);
          return i === void 0 && (i = /* @__PURE__ */ new Set(), n.set(t, i)), i;
        }
        _getShaderStage(t) {
          const n = this.shaderCache;
          let i = n.get(t);
          return i === void 0 && (i = new uC(t), n.set(t, i)), i;
        }
      }
      class uC {
        constructor(t) {
          this.id = lC++, this.code = t, this.usedTimes = 0;
        }
      }
      function fC(e, t, n, i, a, s, r) {
        const o = new om(), l = new cC(), c = /* @__PURE__ */ new Set(), f = [], d = a.logarithmicDepthBuffer, h = a.vertexTextures;
        let p = a.precision;
        const y = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        function S(b) {
          return c.add(b), b === 0 ? "uv" : `uv${b}`;
        }
        function m(b, x, C, V, I) {
          const X = V.fog, Q = I.geometry, L = b.isMeshStandardMaterial ? V.environment : null, W = (b.isMeshStandardMaterial ? n : t).get(b.envMap || L), B = W && W.mapping === Gu ? W.image.height : null, $ = y[b.type];
          b.precision !== null && (p = a.getMaxPrecision(b.precision), p !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", p, "instead."));
          const it = Q.morphAttributes.position || Q.morphAttributes.normal || Q.morphAttributes.color, gt = it !== void 0 ? it.length : 0;
          let Dt = 0;
          Q.morphAttributes.position !== void 0 && (Dt = 1), Q.morphAttributes.normal !== void 0 && (Dt = 2), Q.morphAttributes.color !== void 0 && (Dt = 3);
          let ne, Y, nt, _t;
          if ($) {
            const oe = di[$];
            ne = oe.vertexShader, Y = oe.fragmentShader;
          } else ne = b.vertexShader, Y = b.fragmentShader, l.update(b), nt = l.getVertexShaderID(b), _t = l.getFragmentShaderID(b);
          const ot = e.getRenderTarget(), Tt = e.state.buffers.depth.getReversed(), wt = I.isInstancedMesh === true, Vt = I.isBatchedMesh === true, xe = !!b.map, Zt = !!b.matcap, De = !!W, U = !!b.aoMap, Nn = !!b.lightMap, Wt = !!b.bumpMap, Yt = !!b.normalMap, xt = !!b.displacementMap, _e = !!b.emissiveMap, St = !!b.metalnessMap, A = !!b.roughnessMap, M = b.anisotropy > 0, F = b.clearcoat > 0, Z = b.dispersion > 0, J = b.iridescence > 0, q = b.sheen > 0, yt = b.transmission > 0, lt = M && !!b.anisotropyMap, ht = F && !!b.clearcoatMap, Kt = F && !!b.clearcoatNormalMap, et = F && !!b.clearcoatRoughnessMap, dt = J && !!b.iridescenceMap, bt = J && !!b.iridescenceThicknessMap, At = q && !!b.sheenColorMap, pt = q && !!b.sheenRoughnessMap, qt = !!b.specularMap, zt = !!b.specularColorMap, de = !!b.specularIntensityMap, N = yt && !!b.transmissionMap, st = yt && !!b.thicknessMap, k = !!b.gradientMap, K = !!b.alphaMap, ut = b.alphaTest > 0, ct = !!b.alphaHash, Nt = !!b.extensions;
          let Te = Na;
          b.toneMapped && (ot === null || ot.isXRRenderTarget === true) && (Te = e.toneMapping);
          const en = {
            shaderID: $,
            shaderType: b.type,
            shaderName: b.name,
            vertexShader: ne,
            fragmentShader: Y,
            defines: b.defines,
            customVertexShaderID: nt,
            customFragmentShaderID: _t,
            isRawShaderMaterial: b.isRawShaderMaterial === true,
            glslVersion: b.glslVersion,
            precision: p,
            batching: Vt,
            batchingColor: Vt && I._colorsTexture !== null,
            instancing: wt,
            instancingColor: wt && I.instanceColor !== null,
            instancingMorph: wt && I.morphTexture !== null,
            supportsVertexTextures: h,
            outputColorSpace: ot === null ? e.outputColorSpace : ot.isXRRenderTarget === true ? ot.texture.colorSpace : kr,
            alphaToCoverage: !!b.alphaToCoverage,
            map: xe,
            matcap: Zt,
            envMap: De,
            envMapMode: De && W.mapping,
            envMapCubeUVHeight: B,
            aoMap: U,
            lightMap: Nn,
            bumpMap: Wt,
            normalMap: Yt,
            displacementMap: h && xt,
            emissiveMap: _e,
            normalMapObjectSpace: Yt && b.normalMapType === HT,
            normalMapTangentSpace: Yt && b.normalMapType === _S,
            metalnessMap: St,
            roughnessMap: A,
            anisotropy: M,
            anisotropyMap: lt,
            clearcoat: F,
            clearcoatMap: ht,
            clearcoatNormalMap: Kt,
            clearcoatRoughnessMap: et,
            dispersion: Z,
            iridescence: J,
            iridescenceMap: dt,
            iridescenceThicknessMap: bt,
            sheen: q,
            sheenColorMap: At,
            sheenRoughnessMap: pt,
            specularMap: qt,
            specularColorMap: zt,
            specularIntensityMap: de,
            transmission: yt,
            transmissionMap: N,
            thicknessMap: st,
            gradientMap: k,
            opaque: b.transparent === false && b.blending === br && b.alphaToCoverage === false,
            alphaMap: K,
            alphaTest: ut,
            alphaHash: ct,
            combine: b.combine,
            mapUv: xe && S(b.map.channel),
            aoMapUv: U && S(b.aoMap.channel),
            lightMapUv: Nn && S(b.lightMap.channel),
            bumpMapUv: Wt && S(b.bumpMap.channel),
            normalMapUv: Yt && S(b.normalMap.channel),
            displacementMapUv: xt && S(b.displacementMap.channel),
            emissiveMapUv: _e && S(b.emissiveMap.channel),
            metalnessMapUv: St && S(b.metalnessMap.channel),
            roughnessMapUv: A && S(b.roughnessMap.channel),
            anisotropyMapUv: lt && S(b.anisotropyMap.channel),
            clearcoatMapUv: ht && S(b.clearcoatMap.channel),
            clearcoatNormalMapUv: Kt && S(b.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: et && S(b.clearcoatRoughnessMap.channel),
            iridescenceMapUv: dt && S(b.iridescenceMap.channel),
            iridescenceThicknessMapUv: bt && S(b.iridescenceThicknessMap.channel),
            sheenColorMapUv: At && S(b.sheenColorMap.channel),
            sheenRoughnessMapUv: pt && S(b.sheenRoughnessMap.channel),
            specularMapUv: qt && S(b.specularMap.channel),
            specularColorMapUv: zt && S(b.specularColorMap.channel),
            specularIntensityMapUv: de && S(b.specularIntensityMap.channel),
            transmissionMapUv: N && S(b.transmissionMap.channel),
            thicknessMapUv: st && S(b.thicknessMap.channel),
            alphaMapUv: K && S(b.alphaMap.channel),
            vertexTangents: !!Q.attributes.tangent && (Yt || M),
            vertexColors: b.vertexColors,
            vertexAlphas: b.vertexColors === true && !!Q.attributes.color && Q.attributes.color.itemSize === 4,
            pointsUvs: I.isPoints === true && !!Q.attributes.uv && (xe || K),
            fog: !!X,
            useFog: b.fog === true,
            fogExp2: !!X && X.isFogExp2,
            flatShading: b.flatShading === true,
            sizeAttenuation: b.sizeAttenuation === true,
            logarithmicDepthBuffer: d,
            reverseDepthBuffer: Tt,
            skinning: I.isSkinnedMesh === true,
            morphTargets: Q.morphAttributes.position !== void 0,
            morphNormals: Q.morphAttributes.normal !== void 0,
            morphColors: Q.morphAttributes.color !== void 0,
            morphTargetsCount: gt,
            morphTextureStride: Dt,
            numDirLights: x.directional.length,
            numPointLights: x.point.length,
            numSpotLights: x.spot.length,
            numSpotLightMaps: x.spotLightMap.length,
            numRectAreaLights: x.rectArea.length,
            numHemiLights: x.hemi.length,
            numDirLightShadows: x.directionalShadowMap.length,
            numPointLightShadows: x.pointShadowMap.length,
            numSpotLightShadows: x.spotShadowMap.length,
            numSpotLightShadowsWithMaps: x.numSpotLightShadowsWithMaps,
            numLightProbes: x.numLightProbes,
            numClippingPlanes: r.numPlanes,
            numClipIntersection: r.numIntersection,
            dithering: b.dithering,
            shadowMapEnabled: e.shadowMap.enabled && C.length > 0,
            shadowMapType: e.shadowMap.type,
            toneMapping: Te,
            decodeVideoTexture: xe && b.map.isVideoTexture === true && te.getTransfer(b.map.colorSpace) === le,
            decodeVideoTextureEmissive: _e && b.emissiveMap.isVideoTexture === true && te.getTransfer(b.emissiveMap.colorSpace) === le,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === Gi,
            flipSided: b.side === dn,
            useDepthPacking: b.depthPacking >= 0,
            depthPacking: b.depthPacking || 0,
            index0AttributeName: b.index0AttributeName,
            extensionClipCullDistance: Nt && b.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Nt && b.extensions.multiDraw === true || Vt) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: b.customProgramCacheKey()
          };
          return en.vertexUv1s = c.has(1), en.vertexUv2s = c.has(2), en.vertexUv3s = c.has(3), c.clear(), en;
        }
        function u(b) {
          const x = [];
          if (b.shaderID ? x.push(b.shaderID) : (x.push(b.customVertexShaderID), x.push(b.customFragmentShaderID)), b.defines !== void 0) for (const C in b.defines) x.push(C), x.push(b.defines[C]);
          return b.isRawShaderMaterial === false && (_(x, b), g(x, b), x.push(e.outputColorSpace)), x.push(b.customProgramCacheKey), x.join();
        }
        function _(b, x) {
          b.push(x.precision), b.push(x.outputColorSpace), b.push(x.envMapMode), b.push(x.envMapCubeUVHeight), b.push(x.mapUv), b.push(x.alphaMapUv), b.push(x.lightMapUv), b.push(x.aoMapUv), b.push(x.bumpMapUv), b.push(x.normalMapUv), b.push(x.displacementMapUv), b.push(x.emissiveMapUv), b.push(x.metalnessMapUv), b.push(x.roughnessMapUv), b.push(x.anisotropyMapUv), b.push(x.clearcoatMapUv), b.push(x.clearcoatNormalMapUv), b.push(x.clearcoatRoughnessMapUv), b.push(x.iridescenceMapUv), b.push(x.iridescenceThicknessMapUv), b.push(x.sheenColorMapUv), b.push(x.sheenRoughnessMapUv), b.push(x.specularMapUv), b.push(x.specularColorMapUv), b.push(x.specularIntensityMapUv), b.push(x.transmissionMapUv), b.push(x.thicknessMapUv), b.push(x.combine), b.push(x.fogExp2), b.push(x.sizeAttenuation), b.push(x.morphTargetsCount), b.push(x.morphAttributeCount), b.push(x.numDirLights), b.push(x.numPointLights), b.push(x.numSpotLights), b.push(x.numSpotLightMaps), b.push(x.numHemiLights), b.push(x.numRectAreaLights), b.push(x.numDirLightShadows), b.push(x.numPointLightShadows), b.push(x.numSpotLightShadows), b.push(x.numSpotLightShadowsWithMaps), b.push(x.numLightProbes), b.push(x.shadowMapType), b.push(x.toneMapping), b.push(x.numClippingPlanes), b.push(x.numClipIntersection), b.push(x.depthPacking);
        }
        function g(b, x) {
          o.disableAll(), x.supportsVertexTextures && o.enable(0), x.instancing && o.enable(1), x.instancingColor && o.enable(2), x.instancingMorph && o.enable(3), x.matcap && o.enable(4), x.envMap && o.enable(5), x.normalMapObjectSpace && o.enable(6), x.normalMapTangentSpace && o.enable(7), x.clearcoat && o.enable(8), x.iridescence && o.enable(9), x.alphaTest && o.enable(10), x.vertexColors && o.enable(11), x.vertexAlphas && o.enable(12), x.vertexUv1s && o.enable(13), x.vertexUv2s && o.enable(14), x.vertexUv3s && o.enable(15), x.vertexTangents && o.enable(16), x.anisotropy && o.enable(17), x.alphaHash && o.enable(18), x.batching && o.enable(19), x.dispersion && o.enable(20), x.batchingColor && o.enable(21), b.push(o.mask), o.disableAll(), x.fog && o.enable(0), x.useFog && o.enable(1), x.flatShading && o.enable(2), x.logarithmicDepthBuffer && o.enable(3), x.reverseDepthBuffer && o.enable(4), x.skinning && o.enable(5), x.morphTargets && o.enable(6), x.morphNormals && o.enable(7), x.morphColors && o.enable(8), x.premultipliedAlpha && o.enable(9), x.shadowMapEnabled && o.enable(10), x.doubleSided && o.enable(11), x.flipSided && o.enable(12), x.useDepthPacking && o.enable(13), x.dithering && o.enable(14), x.transmission && o.enable(15), x.sheen && o.enable(16), x.opaque && o.enable(17), x.pointsUvs && o.enable(18), x.decodeVideoTexture && o.enable(19), x.decodeVideoTextureEmissive && o.enable(20), x.alphaToCoverage && o.enable(21), b.push(o.mask);
        }
        function v(b) {
          const x = y[b.type];
          let C;
          if (x) {
            const V = di[x];
            C = AS.clone(V.uniforms);
          } else C = b.uniforms;
          return C;
        }
        function T(b, x) {
          let C;
          for (let V = 0, I = f.length; V < I; V++) {
            const X = f[V];
            if (X.cacheKey === x) {
              C = X, ++C.usedTimes;
              break;
            }
          }
          return C === void 0 && (C = new oC(e, x, b, s), f.push(C)), C;
        }
        function R(b) {
          if (--b.usedTimes === 0) {
            const x = f.indexOf(b);
            f[x] = f[f.length - 1], f.pop(), b.destroy();
          }
        }
        function w(b) {
          l.remove(b);
        }
        function D() {
          l.dispose();
        }
        return {
          getParameters: m,
          getProgramCacheKey: u,
          getUniforms: v,
          acquireProgram: T,
          releaseProgram: R,
          releaseShaderCache: w,
          programs: f,
          dispose: D
        };
      }
      function hC() {
        let e = /* @__PURE__ */ new WeakMap();
        function t(r) {
          return e.has(r);
        }
        function n(r) {
          let o = e.get(r);
          return o === void 0 && (o = {}, e.set(r, o)), o;
        }
        function i(r) {
          e.delete(r);
        }
        function a(r, o, l) {
          e.get(r)[o] = l;
        }
        function s() {
          e = /* @__PURE__ */ new WeakMap();
        }
        return {
          has: t,
          get: n,
          remove: i,
          update: a,
          dispose: s
        };
      }
      function dC(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id;
      }
      function Jg(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id;
      }
      function $g() {
        const e = [];
        let t = 0;
        const n = [], i = [], a = [];
        function s() {
          t = 0, n.length = 0, i.length = 0, a.length = 0;
        }
        function r(d, h, p, y, S, m) {
          let u = e[t];
          return u === void 0 ? (u = {
            id: d.id,
            object: d,
            geometry: h,
            material: p,
            groupOrder: y,
            renderOrder: d.renderOrder,
            z: S,
            group: m
          }, e[t] = u) : (u.id = d.id, u.object = d, u.geometry = h, u.material = p, u.groupOrder = y, u.renderOrder = d.renderOrder, u.z = S, u.group = m), t++, u;
        }
        function o(d, h, p, y, S, m) {
          const u = r(d, h, p, y, S, m);
          p.transmission > 0 ? i.push(u) : p.transparent === true ? a.push(u) : n.push(u);
        }
        function l(d, h, p, y, S, m) {
          const u = r(d, h, p, y, S, m);
          p.transmission > 0 ? i.unshift(u) : p.transparent === true ? a.unshift(u) : n.unshift(u);
        }
        function c(d, h) {
          n.length > 1 && n.sort(d || dC), i.length > 1 && i.sort(h || Jg), a.length > 1 && a.sort(h || Jg);
        }
        function f() {
          for (let d = t, h = e.length; d < h; d++) {
            const p = e[d];
            if (p.id === null) break;
            p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
          }
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: a,
          init: s,
          push: o,
          unshift: l,
          finish: f,
          sort: c
        };
      }
      function pC() {
        let e = /* @__PURE__ */ new WeakMap();
        function t(i, a) {
          const s = e.get(i);
          let r;
          return s === void 0 ? (r = new $g(), e.set(i, [
            r
          ])) : a >= s.length ? (r = new $g(), s.push(r)) : r = s[a], r;
        }
        function n() {
          e = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: t,
          dispose: n
        };
      }
      function mC() {
        const e = {};
        return {
          get: function(t) {
            if (e[t.id] !== void 0) return e[t.id];
            let n;
            switch (t.type) {
              case "DirectionalLight":
                n = {
                  direction: new z(),
                  color: new It()
                };
                break;
              case "SpotLight":
                n = {
                  position: new z(),
                  direction: new z(),
                  color: new It(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                n = {
                  position: new z(),
                  color: new It(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new z(),
                  skyColor: new It(),
                  groundColor: new It()
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new It(),
                  position: new z(),
                  halfWidth: new z(),
                  halfHeight: new z()
                };
                break;
            }
            return e[t.id] = n, n;
          }
        };
      }
      function _C() {
        const e = {};
        return {
          get: function(t) {
            if (e[t.id] !== void 0) return e[t.id];
            let n;
            switch (t.type) {
              case "DirectionalLight":
                n = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ut()
                };
                break;
              case "SpotLight":
                n = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ut()
                };
                break;
              case "PointLight":
                n = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Ut(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            return e[t.id] = n, n;
          }
        };
      }
      let gC = 0;
      function vC(e, t) {
        return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0);
      }
      function yC(e) {
        const t = new mC(), n = _C(), i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
          },
          ambient: [
            0,
            0,
            0
          ],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotLightMap: [],
          spotShadow: [],
          spotShadowMap: [],
          spotLightMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numSpotLightShadowsWithMaps: 0,
          numLightProbes: 0
        };
        for (let c = 0; c < 9; c++) i.probe.push(new z());
        const a = new z(), s = new ie(), r = new ie();
        function o(c) {
          let f = 0, d = 0, h = 0;
          for (let b = 0; b < 9; b++) i.probe[b].set(0, 0, 0);
          let p = 0, y = 0, S = 0, m = 0, u = 0, _ = 0, g = 0, v = 0, T = 0, R = 0, w = 0;
          c.sort(vC);
          for (let b = 0, x = c.length; b < x; b++) {
            const C = c[b], V = C.color, I = C.intensity, X = C.distance, Q = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
            if (C.isAmbientLight) f += V.r * I, d += V.g * I, h += V.b * I;
            else if (C.isLightProbe) {
              for (let L = 0; L < 9; L++) i.probe[L].addScaledVector(C.sh.coefficients[L], I);
              w++;
            } else if (C.isDirectionalLight) {
              const L = t.get(C);
              if (L.color.copy(C.color).multiplyScalar(C.intensity), C.castShadow) {
                const W = C.shadow, B = n.get(C);
                B.shadowIntensity = W.intensity, B.shadowBias = W.bias, B.shadowNormalBias = W.normalBias, B.shadowRadius = W.radius, B.shadowMapSize = W.mapSize, i.directionalShadow[p] = B, i.directionalShadowMap[p] = Q, i.directionalShadowMatrix[p] = C.shadow.matrix, _++;
              }
              i.directional[p] = L, p++;
            } else if (C.isSpotLight) {
              const L = t.get(C);
              L.position.setFromMatrixPosition(C.matrixWorld), L.color.copy(V).multiplyScalar(I), L.distance = X, L.coneCos = Math.cos(C.angle), L.penumbraCos = Math.cos(C.angle * (1 - C.penumbra)), L.decay = C.decay, i.spot[S] = L;
              const W = C.shadow;
              if (C.map && (i.spotLightMap[T] = C.map, T++, W.updateMatrices(C), C.castShadow && R++), i.spotLightMatrix[S] = W.matrix, C.castShadow) {
                const B = n.get(C);
                B.shadowIntensity = W.intensity, B.shadowBias = W.bias, B.shadowNormalBias = W.normalBias, B.shadowRadius = W.radius, B.shadowMapSize = W.mapSize, i.spotShadow[S] = B, i.spotShadowMap[S] = Q, v++;
              }
              S++;
            } else if (C.isRectAreaLight) {
              const L = t.get(C);
              L.color.copy(V).multiplyScalar(I), L.halfWidth.set(C.width * 0.5, 0, 0), L.halfHeight.set(0, C.height * 0.5, 0), i.rectArea[m] = L, m++;
            } else if (C.isPointLight) {
              const L = t.get(C);
              if (L.color.copy(C.color).multiplyScalar(C.intensity), L.distance = C.distance, L.decay = C.decay, C.castShadow) {
                const W = C.shadow, B = n.get(C);
                B.shadowIntensity = W.intensity, B.shadowBias = W.bias, B.shadowNormalBias = W.normalBias, B.shadowRadius = W.radius, B.shadowMapSize = W.mapSize, B.shadowCameraNear = W.camera.near, B.shadowCameraFar = W.camera.far, i.pointShadow[y] = B, i.pointShadowMap[y] = Q, i.pointShadowMatrix[y] = C.shadow.matrix, g++;
              }
              i.point[y] = L, y++;
            } else if (C.isHemisphereLight) {
              const L = t.get(C);
              L.skyColor.copy(C.color).multiplyScalar(I), L.groundColor.copy(C.groundColor).multiplyScalar(I), i.hemi[u] = L, u++;
            }
          }
          m > 0 && (e.has("OES_texture_float_linear") === true ? (i.rectAreaLTC1 = at.LTC_FLOAT_1, i.rectAreaLTC2 = at.LTC_FLOAT_2) : (i.rectAreaLTC1 = at.LTC_HALF_1, i.rectAreaLTC2 = at.LTC_HALF_2)), i.ambient[0] = f, i.ambient[1] = d, i.ambient[2] = h;
          const D = i.hash;
          (D.directionalLength !== p || D.pointLength !== y || D.spotLength !== S || D.rectAreaLength !== m || D.hemiLength !== u || D.numDirectionalShadows !== _ || D.numPointShadows !== g || D.numSpotShadows !== v || D.numSpotMaps !== T || D.numLightProbes !== w) && (i.directional.length = p, i.spot.length = S, i.rectArea.length = m, i.point.length = y, i.hemi.length = u, i.directionalShadow.length = _, i.directionalShadowMap.length = _, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = _, i.pointShadowMatrix.length = g, i.spotLightMatrix.length = v + T - R, i.spotLightMap.length = T, i.numSpotLightShadowsWithMaps = R, i.numLightProbes = w, D.directionalLength = p, D.pointLength = y, D.spotLength = S, D.rectAreaLength = m, D.hemiLength = u, D.numDirectionalShadows = _, D.numPointShadows = g, D.numSpotShadows = v, D.numSpotMaps = T, D.numLightProbes = w, i.version = gC++);
        }
        function l(c, f) {
          let d = 0, h = 0, p = 0, y = 0, S = 0;
          const m = f.matrixWorldInverse;
          for (let u = 0, _ = c.length; u < _; u++) {
            const g = c[u];
            if (g.isDirectionalLight) {
              const v = i.directional[d];
              v.direction.setFromMatrixPosition(g.matrixWorld), a.setFromMatrixPosition(g.target.matrixWorld), v.direction.sub(a), v.direction.transformDirection(m), d++;
            } else if (g.isSpotLight) {
              const v = i.spot[p];
              v.position.setFromMatrixPosition(g.matrixWorld), v.position.applyMatrix4(m), v.direction.setFromMatrixPosition(g.matrixWorld), a.setFromMatrixPosition(g.target.matrixWorld), v.direction.sub(a), v.direction.transformDirection(m), p++;
            } else if (g.isRectAreaLight) {
              const v = i.rectArea[y];
              v.position.setFromMatrixPosition(g.matrixWorld), v.position.applyMatrix4(m), r.identity(), s.copy(g.matrixWorld), s.premultiply(m), r.extractRotation(s), v.halfWidth.set(g.width * 0.5, 0, 0), v.halfHeight.set(0, g.height * 0.5, 0), v.halfWidth.applyMatrix4(r), v.halfHeight.applyMatrix4(r), y++;
            } else if (g.isPointLight) {
              const v = i.point[h];
              v.position.setFromMatrixPosition(g.matrixWorld), v.position.applyMatrix4(m), h++;
            } else if (g.isHemisphereLight) {
              const v = i.hemi[S];
              v.direction.setFromMatrixPosition(g.matrixWorld), v.direction.transformDirection(m), S++;
            }
          }
        }
        return {
          setup: o,
          setupView: l,
          state: i
        };
      }
      function t0(e) {
        const t = new yC(e), n = [], i = [];
        function a(f) {
          c.camera = f, n.length = 0, i.length = 0;
        }
        function s(f) {
          n.push(f);
        }
        function r(f) {
          i.push(f);
        }
        function o() {
          t.setup(n);
        }
        function l(f) {
          t.setupView(n, f);
        }
        const c = {
          lightsArray: n,
          shadowsArray: i,
          camera: null,
          lights: t,
          transmissionRenderTarget: {}
        };
        return {
          init: a,
          state: c,
          setupLights: o,
          setupLightsView: l,
          pushLight: s,
          pushShadow: r
        };
      }
      function SC(e) {
        let t = /* @__PURE__ */ new WeakMap();
        function n(a, s = 0) {
          const r = t.get(a);
          let o;
          return r === void 0 ? (o = new t0(e), t.set(a, [
            o
          ])) : s >= r.length ? (o = new t0(e), r.push(o)) : o = r[s], o;
        }
        function i() {
          t = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: n,
          dispose: i
        };
      }
      const xC = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, MC = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function EC(e, t, n) {
        let i = new lm();
        const a = new Ut(), s = new Ut(), r = new Ce(), o = new W1({
          depthPacking: IT
        }), l = new Y1(), c = {}, f = n.maxTextureSize, d = {
          [Ia]: dn,
          [dn]: Ia,
          [Gi]: Gi
        }, h = new na({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new Ut()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: xC,
          fragmentShader: MC
        }), p = h.clone();
        p.defines.HORIZONTAL_PASS = 1;
        const y = new Ti();
        y.setAttribute("position", new fi(new Float32Array([
          -1,
          -1,
          0.5,
          3,
          -1,
          0.5,
          -1,
          3,
          0.5
        ]), 3));
        const S = new Qn(y, h), m = this;
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = aS;
        let u = this.type;
        this.render = function(R, w, D) {
          if (m.enabled === false || m.autoUpdate === false && m.needsUpdate === false || R.length === 0) return;
          const b = e.getRenderTarget(), x = e.getActiveCubeFace(), C = e.getActiveMipmapLevel(), V = e.state;
          V.setBlending(La), V.buffers.color.setClear(1, 1, 1, 1), V.buffers.depth.setTest(true), V.setScissorTest(false);
          const I = u !== zi && this.type === zi, X = u === zi && this.type !== zi;
          for (let Q = 0, L = R.length; Q < L; Q++) {
            const W = R[Q], B = W.shadow;
            if (B === void 0) {
              console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
              continue;
            }
            if (B.autoUpdate === false && B.needsUpdate === false) continue;
            a.copy(B.mapSize);
            const $ = B.getFrameExtents();
            if (a.multiply($), s.copy(B.mapSize), (a.x > f || a.y > f) && (a.x > f && (s.x = Math.floor(f / $.x), a.x = s.x * $.x, B.mapSize.x = s.x), a.y > f && (s.y = Math.floor(f / $.y), a.y = s.y * $.y, B.mapSize.y = s.y)), B.map === null || I === true || X === true) {
              const gt = this.type !== zi ? {
                minFilter: Dn,
                magFilter: Dn
              } : {};
              B.map !== null && B.map.dispose(), B.map = new Ss(a.x, a.y, gt), B.map.texture.name = W.name + ".shadowMap", B.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(B.map), e.clear();
            const it = B.getViewportCount();
            for (let gt = 0; gt < it; gt++) {
              const Dt = B.getViewport(gt);
              r.set(s.x * Dt.x, s.y * Dt.y, s.x * Dt.z, s.y * Dt.w), V.viewport(r), B.updateMatrices(W, gt), i = B.getFrustum(), v(w, D, B.camera, W, this.type);
            }
            B.isPointLightShadow !== true && this.type === zi && _(B, D), B.needsUpdate = false;
          }
          u = this.type, m.needsUpdate = false, e.setRenderTarget(b, x, C);
        };
        function _(R, w) {
          const D = t.update(S);
          h.defines.VSM_SAMPLES !== R.blurSamples && (h.defines.VSM_SAMPLES = R.blurSamples, p.defines.VSM_SAMPLES = R.blurSamples, h.needsUpdate = true, p.needsUpdate = true), R.mapPass === null && (R.mapPass = new Ss(a.x, a.y)), h.uniforms.shadow_pass.value = R.map.texture, h.uniforms.resolution.value = R.mapSize, h.uniforms.radius.value = R.radius, e.setRenderTarget(R.mapPass), e.clear(), e.renderBufferDirect(w, null, D, h, S, null), p.uniforms.shadow_pass.value = R.mapPass.texture, p.uniforms.resolution.value = R.mapSize, p.uniforms.radius.value = R.radius, e.setRenderTarget(R.map), e.clear(), e.renderBufferDirect(w, null, D, p, S, null);
        }
        function g(R, w, D, b) {
          let x = null;
          const C = D.isPointLight === true ? R.customDistanceMaterial : R.customDepthMaterial;
          if (C !== void 0) x = C;
          else if (x = D.isPointLight === true ? l : o, e.localClippingEnabled && w.clipShadows === true && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
            const V = x.uuid, I = w.uuid;
            let X = c[V];
            X === void 0 && (X = {}, c[V] = X);
            let Q = X[I];
            Q === void 0 && (Q = x.clone(), X[I] = Q, w.addEventListener("dispose", T)), x = Q;
          }
          if (x.visible = w.visible, x.wireframe = w.wireframe, b === zi ? x.side = w.shadowSide !== null ? w.shadowSide : w.side : x.side = w.shadowSide !== null ? w.shadowSide : d[w.side], x.alphaMap = w.alphaMap, x.alphaTest = w.alphaTest, x.map = w.map, x.clipShadows = w.clipShadows, x.clippingPlanes = w.clippingPlanes, x.clipIntersection = w.clipIntersection, x.displacementMap = w.displacementMap, x.displacementScale = w.displacementScale, x.displacementBias = w.displacementBias, x.wireframeLinewidth = w.wireframeLinewidth, x.linewidth = w.linewidth, D.isPointLight === true && x.isMeshDistanceMaterial === true) {
            const V = e.properties.get(x);
            V.light = D;
          }
          return x;
        }
        function v(R, w, D, b, x) {
          if (R.visible === false) return;
          if (R.layers.test(w.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && x === zi) && (!R.frustumCulled || i.intersectsObject(R))) {
            R.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse, R.matrixWorld);
            const I = t.update(R), X = R.material;
            if (Array.isArray(X)) {
              const Q = I.groups;
              for (let L = 0, W = Q.length; L < W; L++) {
                const B = Q[L], $ = X[B.materialIndex];
                if ($ && $.visible) {
                  const it = g(R, $, b, x);
                  R.onBeforeShadow(e, R, w, D, I, it, B), e.renderBufferDirect(D, null, I, it, R, B), R.onAfterShadow(e, R, w, D, I, it, B);
                }
              }
            } else if (X.visible) {
              const Q = g(R, X, b, x);
              R.onBeforeShadow(e, R, w, D, I, Q, null), e.renderBufferDirect(D, null, I, Q, R, null), R.onAfterShadow(e, R, w, D, I, Q, null);
            }
          }
          const V = R.children;
          for (let I = 0, X = V.length; I < X; I++) v(V[I], w, D, b, x);
        }
        function T(R) {
          R.target.removeEventListener("dispose", T);
          for (const D in c) {
            const b = c[D], x = R.target.uuid;
            x in b && (b[x].dispose(), delete b[x]);
          }
        }
      }
      const bC = {
        [hd]: dd,
        [pd]: gd,
        [md]: vd,
        [Fr]: _d,
        [dd]: hd,
        [gd]: pd,
        [vd]: md,
        [_d]: Fr
      };
      function TC(e, t) {
        function n() {
          let N = false;
          const st = new Ce();
          let k = null;
          const K = new Ce(0, 0, 0, 0);
          return {
            setMask: function(ut) {
              k !== ut && !N && (e.colorMask(ut, ut, ut, ut), k = ut);
            },
            setLocked: function(ut) {
              N = ut;
            },
            setClear: function(ut, ct, Nt, Te, en) {
              en === true && (ut *= Te, ct *= Te, Nt *= Te), st.set(ut, ct, Nt, Te), K.equals(st) === false && (e.clearColor(ut, ct, Nt, Te), K.copy(st));
            },
            reset: function() {
              N = false, k = null, K.set(-1, 0, 0, 0);
            }
          };
        }
        function i() {
          let N = false, st = false, k = null, K = null, ut = null;
          return {
            setReversed: function(ct) {
              if (st !== ct) {
                const Nt = t.get("EXT_clip_control");
                st ? Nt.clipControlEXT(Nt.LOWER_LEFT_EXT, Nt.ZERO_TO_ONE_EXT) : Nt.clipControlEXT(Nt.LOWER_LEFT_EXT, Nt.NEGATIVE_ONE_TO_ONE_EXT);
                const Te = ut;
                ut = null, this.setClear(Te);
              }
              st = ct;
            },
            getReversed: function() {
              return st;
            },
            setTest: function(ct) {
              ct ? ot(e.DEPTH_TEST) : Tt(e.DEPTH_TEST);
            },
            setMask: function(ct) {
              k !== ct && !N && (e.depthMask(ct), k = ct);
            },
            setFunc: function(ct) {
              if (st && (ct = bC[ct]), K !== ct) {
                switch (ct) {
                  case hd:
                    e.depthFunc(e.NEVER);
                    break;
                  case dd:
                    e.depthFunc(e.ALWAYS);
                    break;
                  case pd:
                    e.depthFunc(e.LESS);
                    break;
                  case Fr:
                    e.depthFunc(e.LEQUAL);
                    break;
                  case md:
                    e.depthFunc(e.EQUAL);
                    break;
                  case _d:
                    e.depthFunc(e.GEQUAL);
                    break;
                  case gd:
                    e.depthFunc(e.GREATER);
                    break;
                  case vd:
                    e.depthFunc(e.NOTEQUAL);
                    break;
                  default:
                    e.depthFunc(e.LEQUAL);
                }
                K = ct;
              }
            },
            setLocked: function(ct) {
              N = ct;
            },
            setClear: function(ct) {
              ut !== ct && (st && (ct = 1 - ct), e.clearDepth(ct), ut = ct);
            },
            reset: function() {
              N = false, k = null, K = null, ut = null, st = false;
            }
          };
        }
        function a() {
          let N = false, st = null, k = null, K = null, ut = null, ct = null, Nt = null, Te = null, en = null;
          return {
            setTest: function(oe) {
              N || (oe ? ot(e.STENCIL_TEST) : Tt(e.STENCIL_TEST));
            },
            setMask: function(oe) {
              st !== oe && !N && (e.stencilMask(oe), st = oe);
            },
            setFunc: function(oe, ei, Ai) {
              (k !== oe || K !== ei || ut !== Ai) && (e.stencilFunc(oe, ei, Ai), k = oe, K = ei, ut = Ai);
            },
            setOp: function(oe, ei, Ai) {
              (ct !== oe || Nt !== ei || Te !== Ai) && (e.stencilOp(oe, ei, Ai), ct = oe, Nt = ei, Te = Ai);
            },
            setLocked: function(oe) {
              N = oe;
            },
            setClear: function(oe) {
              en !== oe && (e.clearStencil(oe), en = oe);
            },
            reset: function() {
              N = false, st = null, k = null, K = null, ut = null, ct = null, Nt = null, Te = null, en = null;
            }
          };
        }
        const s = new n(), r = new i(), o = new a(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
        let f = {}, d = {}, h = /* @__PURE__ */ new WeakMap(), p = [], y = null, S = false, m = null, u = null, _ = null, g = null, v = null, T = null, R = null, w = new It(0, 0, 0), D = 0, b = false, x = null, C = null, V = null, I = null, X = null;
        const Q = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let L = false, W = 0;
        const B = e.getParameter(e.VERSION);
        B.indexOf("WebGL") !== -1 ? (W = parseFloat(/^WebGL (\d)/.exec(B)[1]), L = W >= 1) : B.indexOf("OpenGL ES") !== -1 && (W = parseFloat(/^OpenGL ES (\d)/.exec(B)[1]), L = W >= 2);
        let $ = null, it = {};
        const gt = e.getParameter(e.SCISSOR_BOX), Dt = e.getParameter(e.VIEWPORT), ne = new Ce().fromArray(gt), Y = new Ce().fromArray(Dt);
        function nt(N, st, k, K) {
          const ut = new Uint8Array(4), ct = e.createTexture();
          e.bindTexture(N, ct), e.texParameteri(N, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(N, e.TEXTURE_MAG_FILTER, e.NEAREST);
          for (let Nt = 0; Nt < k; Nt++) N === e.TEXTURE_3D || N === e.TEXTURE_2D_ARRAY ? e.texImage3D(st, 0, e.RGBA, 1, 1, K, 0, e.RGBA, e.UNSIGNED_BYTE, ut) : e.texImage2D(st + Nt, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, ut);
          return ct;
        }
        const _t = {};
        _t[e.TEXTURE_2D] = nt(e.TEXTURE_2D, e.TEXTURE_2D, 1), _t[e.TEXTURE_CUBE_MAP] = nt(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), _t[e.TEXTURE_2D_ARRAY] = nt(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), _t[e.TEXTURE_3D] = nt(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1), s.setClear(0, 0, 0, 1), r.setClear(1), o.setClear(0), ot(e.DEPTH_TEST), r.setFunc(Fr), Wt(false), Yt(q_), ot(e.CULL_FACE), U(La);
        function ot(N) {
          f[N] !== true && (e.enable(N), f[N] = true);
        }
        function Tt(N) {
          f[N] !== false && (e.disable(N), f[N] = false);
        }
        function wt(N, st) {
          return d[N] !== st ? (e.bindFramebuffer(N, st), d[N] = st, N === e.DRAW_FRAMEBUFFER && (d[e.FRAMEBUFFER] = st), N === e.FRAMEBUFFER && (d[e.DRAW_FRAMEBUFFER] = st), true) : false;
        }
        function Vt(N, st) {
          let k = p, K = false;
          if (N) {
            k = h.get(st), k === void 0 && (k = [], h.set(st, k));
            const ut = N.textures;
            if (k.length !== ut.length || k[0] !== e.COLOR_ATTACHMENT0) {
              for (let ct = 0, Nt = ut.length; ct < Nt; ct++) k[ct] = e.COLOR_ATTACHMENT0 + ct;
              k.length = ut.length, K = true;
            }
          } else k[0] !== e.BACK && (k[0] = e.BACK, K = true);
          K && e.drawBuffers(k);
        }
        function xe(N) {
          return y !== N ? (e.useProgram(N), y = N, true) : false;
        }
        const Zt = {
          [es]: e.FUNC_ADD,
          [fT]: e.FUNC_SUBTRACT,
          [hT]: e.FUNC_REVERSE_SUBTRACT
        };
        Zt[dT] = e.MIN, Zt[pT] = e.MAX;
        const De = {
          [mT]: e.ZERO,
          [_T]: e.ONE,
          [gT]: e.SRC_COLOR,
          [ud]: e.SRC_ALPHA,
          [ET]: e.SRC_ALPHA_SATURATE,
          [xT]: e.DST_COLOR,
          [yT]: e.DST_ALPHA,
          [vT]: e.ONE_MINUS_SRC_COLOR,
          [fd]: e.ONE_MINUS_SRC_ALPHA,
          [MT]: e.ONE_MINUS_DST_COLOR,
          [ST]: e.ONE_MINUS_DST_ALPHA,
          [bT]: e.CONSTANT_COLOR,
          [TT]: e.ONE_MINUS_CONSTANT_COLOR,
          [AT]: e.CONSTANT_ALPHA,
          [RT]: e.ONE_MINUS_CONSTANT_ALPHA
        };
        function U(N, st, k, K, ut, ct, Nt, Te, en, oe) {
          if (N === La) {
            S === true && (Tt(e.BLEND), S = false);
            return;
          }
          if (S === false && (ot(e.BLEND), S = true), N !== uT) {
            if (N !== m || oe !== b) {
              if ((u !== es || v !== es) && (e.blendEquation(e.FUNC_ADD), u = es, v = es), oe) switch (N) {
                case br:
                  e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                  break;
                case j_:
                  e.blendFunc(e.ONE, e.ONE);
                  break;
                case Z_:
                  e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                  break;
                case K_:
                  e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", N);
                  break;
              }
              else switch (N) {
                case br:
                  e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                  break;
                case j_:
                  e.blendFunc(e.SRC_ALPHA, e.ONE);
                  break;
                case Z_:
                  e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                  break;
                case K_:
                  e.blendFunc(e.ZERO, e.SRC_COLOR);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", N);
                  break;
              }
              _ = null, g = null, T = null, R = null, w.set(0, 0, 0), D = 0, m = N, b = oe;
            }
            return;
          }
          ut = ut || st, ct = ct || k, Nt = Nt || K, (st !== u || ut !== v) && (e.blendEquationSeparate(Zt[st], Zt[ut]), u = st, v = ut), (k !== _ || K !== g || ct !== T || Nt !== R) && (e.blendFuncSeparate(De[k], De[K], De[ct], De[Nt]), _ = k, g = K, T = ct, R = Nt), (Te.equals(w) === false || en !== D) && (e.blendColor(Te.r, Te.g, Te.b, en), w.copy(Te), D = en), m = N, b = false;
        }
        function Nn(N, st) {
          N.side === Gi ? Tt(e.CULL_FACE) : ot(e.CULL_FACE);
          let k = N.side === dn;
          st && (k = !k), Wt(k), N.blending === br && N.transparent === false ? U(La) : U(N.blending, N.blendEquation, N.blendSrc, N.blendDst, N.blendEquationAlpha, N.blendSrcAlpha, N.blendDstAlpha, N.blendColor, N.blendAlpha, N.premultipliedAlpha), r.setFunc(N.depthFunc), r.setTest(N.depthTest), r.setMask(N.depthWrite), s.setMask(N.colorWrite);
          const K = N.stencilWrite;
          o.setTest(K), K && (o.setMask(N.stencilWriteMask), o.setFunc(N.stencilFunc, N.stencilRef, N.stencilFuncMask), o.setOp(N.stencilFail, N.stencilZFail, N.stencilZPass)), _e(N.polygonOffset, N.polygonOffsetFactor, N.polygonOffsetUnits), N.alphaToCoverage === true ? ot(e.SAMPLE_ALPHA_TO_COVERAGE) : Tt(e.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function Wt(N) {
          x !== N && (N ? e.frontFace(e.CW) : e.frontFace(e.CCW), x = N);
        }
        function Yt(N) {
          N !== oT ? (ot(e.CULL_FACE), N !== C && (N === q_ ? e.cullFace(e.BACK) : N === lT ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : Tt(e.CULL_FACE), C = N;
        }
        function xt(N) {
          N !== V && (L && e.lineWidth(N), V = N);
        }
        function _e(N, st, k) {
          N ? (ot(e.POLYGON_OFFSET_FILL), (I !== st || X !== k) && (e.polygonOffset(st, k), I = st, X = k)) : Tt(e.POLYGON_OFFSET_FILL);
        }
        function St(N) {
          N ? ot(e.SCISSOR_TEST) : Tt(e.SCISSOR_TEST);
        }
        function A(N) {
          N === void 0 && (N = e.TEXTURE0 + Q - 1), $ !== N && (e.activeTexture(N), $ = N);
        }
        function M(N, st, k) {
          k === void 0 && ($ === null ? k = e.TEXTURE0 + Q - 1 : k = $);
          let K = it[k];
          K === void 0 && (K = {
            type: void 0,
            texture: void 0
          }, it[k] = K), (K.type !== N || K.texture !== st) && ($ !== k && (e.activeTexture(k), $ = k), e.bindTexture(N, st || _t[N]), K.type = N, K.texture = st);
        }
        function F() {
          const N = it[$];
          N !== void 0 && N.type !== void 0 && (e.bindTexture(N.type, null), N.type = void 0, N.texture = void 0);
        }
        function Z() {
          try {
            e.compressedTexImage2D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function J() {
          try {
            e.compressedTexImage3D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function q() {
          try {
            e.texSubImage2D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function yt() {
          try {
            e.texSubImage3D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function lt() {
          try {
            e.compressedTexSubImage2D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function ht() {
          try {
            e.compressedTexSubImage3D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function Kt() {
          try {
            e.texStorage2D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function et() {
          try {
            e.texStorage3D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function dt() {
          try {
            e.texImage2D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function bt() {
          try {
            e.texImage3D.apply(e, arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function At(N) {
          ne.equals(N) === false && (e.scissor(N.x, N.y, N.z, N.w), ne.copy(N));
        }
        function pt(N) {
          Y.equals(N) === false && (e.viewport(N.x, N.y, N.z, N.w), Y.copy(N));
        }
        function qt(N, st) {
          let k = c.get(st);
          k === void 0 && (k = /* @__PURE__ */ new WeakMap(), c.set(st, k));
          let K = k.get(N);
          K === void 0 && (K = e.getUniformBlockIndex(st, N.name), k.set(N, K));
        }
        function zt(N, st) {
          const K = c.get(st).get(N);
          l.get(st) !== K && (e.uniformBlockBinding(st, K, N.__bindingPointIndex), l.set(st, K));
        }
        function de() {
          e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(true, true, true, true), e.clearColor(0, 0, 0, 0), e.depthMask(true), e.depthFunc(e.LESS), r.setReversed(false), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), f = {}, $ = null, it = {}, d = {}, h = /* @__PURE__ */ new WeakMap(), p = [], y = null, S = false, m = null, u = null, _ = null, g = null, v = null, T = null, R = null, w = new It(0, 0, 0), D = 0, b = false, x = null, C = null, V = null, I = null, X = null, ne.set(0, 0, e.canvas.width, e.canvas.height), Y.set(0, 0, e.canvas.width, e.canvas.height), s.reset(), r.reset(), o.reset();
        }
        return {
          buffers: {
            color: s,
            depth: r,
            stencil: o
          },
          enable: ot,
          disable: Tt,
          bindFramebuffer: wt,
          drawBuffers: Vt,
          useProgram: xe,
          setBlending: U,
          setMaterial: Nn,
          setFlipSided: Wt,
          setCullFace: Yt,
          setLineWidth: xt,
          setPolygonOffset: _e,
          setScissorTest: St,
          activeTexture: A,
          bindTexture: M,
          unbindTexture: F,
          compressedTexImage2D: Z,
          compressedTexImage3D: J,
          texImage2D: dt,
          texImage3D: bt,
          updateUBOMapping: qt,
          uniformBlockBinding: zt,
          texStorage2D: Kt,
          texStorage3D: et,
          texSubImage2D: q,
          texSubImage3D: yt,
          compressedTexSubImage2D: lt,
          compressedTexSubImage3D: ht,
          scissor: At,
          viewport: pt,
          reset: de
        };
      }
      function AC(e, t, n, i, a, s, r) {
        const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), c = new Ut(), f = /* @__PURE__ */ new WeakMap();
        let d;
        const h = /* @__PURE__ */ new WeakMap();
        let p = false;
        try {
          p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {
        }
        function y(A, M) {
          return p ? new OffscreenCanvas(A, M) : gu("canvas");
        }
        function S(A, M, F) {
          let Z = 1;
          const J = St(A);
          if ((J.width > F || J.height > F) && (Z = F / Math.max(J.width, J.height)), Z < 1) if (typeof HTMLImageElement < "u" && A instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && A instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && A instanceof ImageBitmap || typeof VideoFrame < "u" && A instanceof VideoFrame) {
            const q = Math.floor(Z * J.width), yt = Math.floor(Z * J.height);
            d === void 0 && (d = y(q, yt));
            const lt = M ? y(q, yt) : d;
            return lt.width = q, lt.height = yt, lt.getContext("2d").drawImage(A, 0, 0, q, yt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + J.width + "x" + J.height + ") to (" + q + "x" + yt + ")."), lt;
          } else return "data" in A && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + J.width + "x" + J.height + ")."), A;
          return A;
        }
        function m(A) {
          return A.generateMipmaps;
        }
        function u(A) {
          e.generateMipmap(A);
        }
        function _(A) {
          return A.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : A.isWebGL3DRenderTarget ? e.TEXTURE_3D : A.isWebGLArrayRenderTarget || A.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D;
        }
        function g(A, M, F, Z, J = false) {
          if (A !== null) {
            if (e[A] !== void 0) return e[A];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + A + "'");
          }
          let q = M;
          if (M === e.RED && (F === e.FLOAT && (q = e.R32F), F === e.HALF_FLOAT && (q = e.R16F), F === e.UNSIGNED_BYTE && (q = e.R8)), M === e.RED_INTEGER && (F === e.UNSIGNED_BYTE && (q = e.R8UI), F === e.UNSIGNED_SHORT && (q = e.R16UI), F === e.UNSIGNED_INT && (q = e.R32UI), F === e.BYTE && (q = e.R8I), F === e.SHORT && (q = e.R16I), F === e.INT && (q = e.R32I)), M === e.RG && (F === e.FLOAT && (q = e.RG32F), F === e.HALF_FLOAT && (q = e.RG16F), F === e.UNSIGNED_BYTE && (q = e.RG8)), M === e.RG_INTEGER && (F === e.UNSIGNED_BYTE && (q = e.RG8UI), F === e.UNSIGNED_SHORT && (q = e.RG16UI), F === e.UNSIGNED_INT && (q = e.RG32UI), F === e.BYTE && (q = e.RG8I), F === e.SHORT && (q = e.RG16I), F === e.INT && (q = e.RG32I)), M === e.RGB_INTEGER && (F === e.UNSIGNED_BYTE && (q = e.RGB8UI), F === e.UNSIGNED_SHORT && (q = e.RGB16UI), F === e.UNSIGNED_INT && (q = e.RGB32UI), F === e.BYTE && (q = e.RGB8I), F === e.SHORT && (q = e.RGB16I), F === e.INT && (q = e.RGB32I)), M === e.RGBA_INTEGER && (F === e.UNSIGNED_BYTE && (q = e.RGBA8UI), F === e.UNSIGNED_SHORT && (q = e.RGBA16UI), F === e.UNSIGNED_INT && (q = e.RGBA32UI), F === e.BYTE && (q = e.RGBA8I), F === e.SHORT && (q = e.RGBA16I), F === e.INT && (q = e.RGBA32I)), M === e.RGB && F === e.UNSIGNED_INT_5_9_9_9_REV && (q = e.RGB9_E5), M === e.RGBA) {
            const yt = J ? mu : te.getTransfer(Z);
            F === e.FLOAT && (q = e.RGBA32F), F === e.HALF_FLOAT && (q = e.RGBA16F), F === e.UNSIGNED_BYTE && (q = yt === le ? e.SRGB8_ALPHA8 : e.RGBA8), F === e.UNSIGNED_SHORT_4_4_4_4 && (q = e.RGBA4), F === e.UNSIGNED_SHORT_5_5_5_1 && (q = e.RGB5_A1);
          }
          return (q === e.R16F || q === e.R32F || q === e.RG16F || q === e.RG32F || q === e.RGBA16F || q === e.RGBA32F) && t.get("EXT_color_buffer_float"), q;
        }
        function v(A, M) {
          let F;
          return A ? M === null || M === ys || M === Gr ? F = e.DEPTH24_STENCIL8 : M === gi ? F = e.DEPTH32F_STENCIL8 : M === fl && (F = e.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === ys || M === Gr ? F = e.DEPTH_COMPONENT24 : M === gi ? F = e.DEPTH_COMPONENT32F : M === fl && (F = e.DEPTH_COMPONENT16), F;
        }
        function T(A, M) {
          return m(A) === true || A.isFramebufferTexture && A.minFilter !== Dn && A.minFilter !== _i ? Math.log2(Math.max(M.width, M.height)) + 1 : A.mipmaps !== void 0 && A.mipmaps.length > 0 ? A.mipmaps.length : A.isCompressedTexture && Array.isArray(A.image) ? M.mipmaps.length : 1;
        }
        function R(A) {
          const M = A.target;
          M.removeEventListener("dispose", R), D(M), M.isVideoTexture && f.delete(M);
        }
        function w(A) {
          const M = A.target;
          M.removeEventListener("dispose", w), x(M);
        }
        function D(A) {
          const M = i.get(A);
          if (M.__webglInit === void 0) return;
          const F = A.source, Z = h.get(F);
          if (Z) {
            const J = Z[M.__cacheKey];
            J.usedTimes--, J.usedTimes === 0 && b(A), Object.keys(Z).length === 0 && h.delete(F);
          }
          i.remove(A);
        }
        function b(A) {
          const M = i.get(A);
          e.deleteTexture(M.__webglTexture);
          const F = A.source, Z = h.get(F);
          delete Z[M.__cacheKey], r.memory.textures--;
        }
        function x(A) {
          const M = i.get(A);
          if (A.depthTexture && (A.depthTexture.dispose(), i.remove(A.depthTexture)), A.isWebGLCubeRenderTarget) for (let Z = 0; Z < 6; Z++) {
            if (Array.isArray(M.__webglFramebuffer[Z])) for (let J = 0; J < M.__webglFramebuffer[Z].length; J++) e.deleteFramebuffer(M.__webglFramebuffer[Z][J]);
            else e.deleteFramebuffer(M.__webglFramebuffer[Z]);
            M.__webglDepthbuffer && e.deleteRenderbuffer(M.__webglDepthbuffer[Z]);
          }
          else {
            if (Array.isArray(M.__webglFramebuffer)) for (let Z = 0; Z < M.__webglFramebuffer.length; Z++) e.deleteFramebuffer(M.__webglFramebuffer[Z]);
            else e.deleteFramebuffer(M.__webglFramebuffer);
            if (M.__webglDepthbuffer && e.deleteRenderbuffer(M.__webglDepthbuffer), M.__webglMultisampledFramebuffer && e.deleteFramebuffer(M.__webglMultisampledFramebuffer), M.__webglColorRenderbuffer) for (let Z = 0; Z < M.__webglColorRenderbuffer.length; Z++) M.__webglColorRenderbuffer[Z] && e.deleteRenderbuffer(M.__webglColorRenderbuffer[Z]);
            M.__webglDepthRenderbuffer && e.deleteRenderbuffer(M.__webglDepthRenderbuffer);
          }
          const F = A.textures;
          for (let Z = 0, J = F.length; Z < J; Z++) {
            const q = i.get(F[Z]);
            q.__webglTexture && (e.deleteTexture(q.__webglTexture), r.memory.textures--), i.remove(F[Z]);
          }
          i.remove(A);
        }
        let C = 0;
        function V() {
          C = 0;
        }
        function I() {
          const A = C;
          return A >= a.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + A + " texture units while this GPU supports only " + a.maxTextures), C += 1, A;
        }
        function X(A) {
          const M = [];
          return M.push(A.wrapS), M.push(A.wrapT), M.push(A.wrapR || 0), M.push(A.magFilter), M.push(A.minFilter), M.push(A.anisotropy), M.push(A.internalFormat), M.push(A.format), M.push(A.type), M.push(A.generateMipmaps), M.push(A.premultiplyAlpha), M.push(A.flipY), M.push(A.unpackAlignment), M.push(A.colorSpace), M.join();
        }
        function Q(A, M) {
          const F = i.get(A);
          if (A.isVideoTexture && xt(A), A.isRenderTargetTexture === false && A.version > 0 && F.__version !== A.version) {
            const Z = A.image;
            if (Z === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Z.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
              Y(F, A, M);
              return;
            }
          }
          n.bindTexture(e.TEXTURE_2D, F.__webglTexture, e.TEXTURE0 + M);
        }
        function L(A, M) {
          const F = i.get(A);
          if (A.version > 0 && F.__version !== A.version) {
            Y(F, A, M);
            return;
          }
          n.bindTexture(e.TEXTURE_2D_ARRAY, F.__webglTexture, e.TEXTURE0 + M);
        }
        function W(A, M) {
          const F = i.get(A);
          if (A.version > 0 && F.__version !== A.version) {
            Y(F, A, M);
            return;
          }
          n.bindTexture(e.TEXTURE_3D, F.__webglTexture, e.TEXTURE0 + M);
        }
        function B(A, M) {
          const F = i.get(A);
          if (A.version > 0 && F.__version !== A.version) {
            nt(F, A, M);
            return;
          }
          n.bindTexture(e.TEXTURE_CUBE_MAP, F.__webglTexture, e.TEXTURE0 + M);
        }
        const $ = {
          [xd]: e.REPEAT,
          [ss]: e.CLAMP_TO_EDGE,
          [Md]: e.MIRRORED_REPEAT
        }, it = {
          [Dn]: e.NEAREST,
          [BT]: e.NEAREST_MIPMAP_NEAREST,
          [Yl]: e.NEAREST_MIPMAP_LINEAR,
          [_i]: e.LINEAR,
          [Lf]: e.LINEAR_MIPMAP_NEAREST,
          [rs]: e.LINEAR_MIPMAP_LINEAR
        }, gt = {
          [GT]: e.NEVER,
          [qT]: e.ALWAYS,
          [VT]: e.LESS,
          [gS]: e.LEQUAL,
          [kT]: e.EQUAL,
          [YT]: e.GEQUAL,
          [XT]: e.GREATER,
          [WT]: e.NOTEQUAL
        };
        function Dt(A, M) {
          if (M.type === gi && t.has("OES_texture_float_linear") === false && (M.magFilter === _i || M.magFilter === Lf || M.magFilter === Yl || M.magFilter === rs || M.minFilter === _i || M.minFilter === Lf || M.minFilter === Yl || M.minFilter === rs) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), e.texParameteri(A, e.TEXTURE_WRAP_S, $[M.wrapS]), e.texParameteri(A, e.TEXTURE_WRAP_T, $[M.wrapT]), (A === e.TEXTURE_3D || A === e.TEXTURE_2D_ARRAY) && e.texParameteri(A, e.TEXTURE_WRAP_R, $[M.wrapR]), e.texParameteri(A, e.TEXTURE_MAG_FILTER, it[M.magFilter]), e.texParameteri(A, e.TEXTURE_MIN_FILTER, it[M.minFilter]), M.compareFunction && (e.texParameteri(A, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(A, e.TEXTURE_COMPARE_FUNC, gt[M.compareFunction])), t.has("EXT_texture_filter_anisotropic") === true) {
            if (M.magFilter === Dn || M.minFilter !== Yl && M.minFilter !== rs || M.type === gi && t.has("OES_texture_float_linear") === false) return;
            if (M.anisotropy > 1 || i.get(M).__currentAnisotropy) {
              const F = t.get("EXT_texture_filter_anisotropic");
              e.texParameterf(A, F.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, a.getMaxAnisotropy())), i.get(M).__currentAnisotropy = M.anisotropy;
            }
          }
        }
        function ne(A, M) {
          let F = false;
          A.__webglInit === void 0 && (A.__webglInit = true, M.addEventListener("dispose", R));
          const Z = M.source;
          let J = h.get(Z);
          J === void 0 && (J = {}, h.set(Z, J));
          const q = X(M);
          if (q !== A.__cacheKey) {
            J[q] === void 0 && (J[q] = {
              texture: e.createTexture(),
              usedTimes: 0
            }, r.memory.textures++, F = true), J[q].usedTimes++;
            const yt = J[A.__cacheKey];
            yt !== void 0 && (J[A.__cacheKey].usedTimes--, yt.usedTimes === 0 && b(M)), A.__cacheKey = q, A.__webglTexture = J[q].texture;
          }
          return F;
        }
        function Y(A, M, F) {
          let Z = e.TEXTURE_2D;
          (M.isDataArrayTexture || M.isCompressedArrayTexture) && (Z = e.TEXTURE_2D_ARRAY), M.isData3DTexture && (Z = e.TEXTURE_3D);
          const J = ne(A, M), q = M.source;
          n.bindTexture(Z, A.__webglTexture, e.TEXTURE0 + F);
          const yt = i.get(q);
          if (q.version !== yt.__version || J === true) {
            n.activeTexture(e.TEXTURE0 + F);
            const lt = te.getPrimaries(te.workingColorSpace), ht = M.colorSpace === xa ? null : te.getPrimaries(M.colorSpace), Kt = M.colorSpace === xa || lt === ht ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, M.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, M.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, Kt);
            let et = S(M.image, false, a.maxTextureSize);
            et = _e(M, et);
            const dt = s.convert(M.format, M.colorSpace), bt = s.convert(M.type);
            let At = g(M.internalFormat, dt, bt, M.colorSpace, M.isVideoTexture);
            Dt(Z, M);
            let pt;
            const qt = M.mipmaps, zt = M.isVideoTexture !== true, de = yt.__version === void 0 || J === true, N = q.dataReady, st = T(M, et);
            if (M.isDepthTexture) At = v(M.format === Vr, M.type), de && (zt ? n.texStorage2D(e.TEXTURE_2D, 1, At, et.width, et.height) : n.texImage2D(e.TEXTURE_2D, 0, At, et.width, et.height, 0, dt, bt, null));
            else if (M.isDataTexture) if (qt.length > 0) {
              zt && de && n.texStorage2D(e.TEXTURE_2D, st, At, qt[0].width, qt[0].height);
              for (let k = 0, K = qt.length; k < K; k++) pt = qt[k], zt ? N && n.texSubImage2D(e.TEXTURE_2D, k, 0, 0, pt.width, pt.height, dt, bt, pt.data) : n.texImage2D(e.TEXTURE_2D, k, At, pt.width, pt.height, 0, dt, bt, pt.data);
              M.generateMipmaps = false;
            } else zt ? (de && n.texStorage2D(e.TEXTURE_2D, st, At, et.width, et.height), N && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, et.width, et.height, dt, bt, et.data)) : n.texImage2D(e.TEXTURE_2D, 0, At, et.width, et.height, 0, dt, bt, et.data);
            else if (M.isCompressedTexture) if (M.isCompressedArrayTexture) {
              zt && de && n.texStorage3D(e.TEXTURE_2D_ARRAY, st, At, qt[0].width, qt[0].height, et.depth);
              for (let k = 0, K = qt.length; k < K; k++) if (pt = qt[k], M.format !== ci) if (dt !== null) if (zt) {
                if (N) if (M.layerUpdates.size > 0) {
                  const ut = Dg(pt.width, pt.height, M.format, M.type);
                  for (const ct of M.layerUpdates) {
                    const Nt = pt.data.subarray(ct * ut / pt.data.BYTES_PER_ELEMENT, (ct + 1) * ut / pt.data.BYTES_PER_ELEMENT);
                    n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, k, 0, 0, ct, pt.width, pt.height, 1, dt, Nt);
                  }
                  M.clearLayerUpdates();
                } else n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, k, 0, 0, 0, pt.width, pt.height, et.depth, dt, pt.data);
              } else n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, k, At, pt.width, pt.height, et.depth, 0, pt.data, 0, 0);
              else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              else zt ? N && n.texSubImage3D(e.TEXTURE_2D_ARRAY, k, 0, 0, 0, pt.width, pt.height, et.depth, dt, bt, pt.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, k, At, pt.width, pt.height, et.depth, 0, dt, bt, pt.data);
            } else {
              zt && de && n.texStorage2D(e.TEXTURE_2D, st, At, qt[0].width, qt[0].height);
              for (let k = 0, K = qt.length; k < K; k++) pt = qt[k], M.format !== ci ? dt !== null ? zt ? N && n.compressedTexSubImage2D(e.TEXTURE_2D, k, 0, 0, pt.width, pt.height, dt, pt.data) : n.compressedTexImage2D(e.TEXTURE_2D, k, At, pt.width, pt.height, 0, pt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : zt ? N && n.texSubImage2D(e.TEXTURE_2D, k, 0, 0, pt.width, pt.height, dt, bt, pt.data) : n.texImage2D(e.TEXTURE_2D, k, At, pt.width, pt.height, 0, dt, bt, pt.data);
            }
            else if (M.isDataArrayTexture) if (zt) {
              if (de && n.texStorage3D(e.TEXTURE_2D_ARRAY, st, At, et.width, et.height, et.depth), N) if (M.layerUpdates.size > 0) {
                const k = Dg(et.width, et.height, M.format, M.type);
                for (const K of M.layerUpdates) {
                  const ut = et.data.subarray(K * k / et.data.BYTES_PER_ELEMENT, (K + 1) * k / et.data.BYTES_PER_ELEMENT);
                  n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, K, et.width, et.height, 1, dt, bt, ut);
                }
                M.clearLayerUpdates();
              } else n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, et.width, et.height, et.depth, dt, bt, et.data);
            } else n.texImage3D(e.TEXTURE_2D_ARRAY, 0, At, et.width, et.height, et.depth, 0, dt, bt, et.data);
            else if (M.isData3DTexture) zt ? (de && n.texStorage3D(e.TEXTURE_3D, st, At, et.width, et.height, et.depth), N && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, et.width, et.height, et.depth, dt, bt, et.data)) : n.texImage3D(e.TEXTURE_3D, 0, At, et.width, et.height, et.depth, 0, dt, bt, et.data);
            else if (M.isFramebufferTexture) {
              if (de) if (zt) n.texStorage2D(e.TEXTURE_2D, st, At, et.width, et.height);
              else {
                let k = et.width, K = et.height;
                for (let ut = 0; ut < st; ut++) n.texImage2D(e.TEXTURE_2D, ut, At, k, K, 0, dt, bt, null), k >>= 1, K >>= 1;
              }
            } else if (qt.length > 0) {
              if (zt && de) {
                const k = St(qt[0]);
                n.texStorage2D(e.TEXTURE_2D, st, At, k.width, k.height);
              }
              for (let k = 0, K = qt.length; k < K; k++) pt = qt[k], zt ? N && n.texSubImage2D(e.TEXTURE_2D, k, 0, 0, dt, bt, pt) : n.texImage2D(e.TEXTURE_2D, k, At, dt, bt, pt);
              M.generateMipmaps = false;
            } else if (zt) {
              if (de) {
                const k = St(et);
                n.texStorage2D(e.TEXTURE_2D, st, At, k.width, k.height);
              }
              N && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, dt, bt, et);
            } else n.texImage2D(e.TEXTURE_2D, 0, At, dt, bt, et);
            m(M) && u(Z), yt.__version = q.version, M.onUpdate && M.onUpdate(M);
          }
          A.__version = M.version;
        }
        function nt(A, M, F) {
          if (M.image.length !== 6) return;
          const Z = ne(A, M), J = M.source;
          n.bindTexture(e.TEXTURE_CUBE_MAP, A.__webglTexture, e.TEXTURE0 + F);
          const q = i.get(J);
          if (J.version !== q.__version || Z === true) {
            n.activeTexture(e.TEXTURE0 + F);
            const yt = te.getPrimaries(te.workingColorSpace), lt = M.colorSpace === xa ? null : te.getPrimaries(M.colorSpace), ht = M.colorSpace === xa || yt === lt ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, M.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, M.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, ht);
            const Kt = M.isCompressedTexture || M.image[0].isCompressedTexture, et = M.image[0] && M.image[0].isDataTexture, dt = [];
            for (let K = 0; K < 6; K++) !Kt && !et ? dt[K] = S(M.image[K], true, a.maxCubemapSize) : dt[K] = et ? M.image[K].image : M.image[K], dt[K] = _e(M, dt[K]);
            const bt = dt[0], At = s.convert(M.format, M.colorSpace), pt = s.convert(M.type), qt = g(M.internalFormat, At, pt, M.colorSpace), zt = M.isVideoTexture !== true, de = q.__version === void 0 || Z === true, N = J.dataReady;
            let st = T(M, bt);
            Dt(e.TEXTURE_CUBE_MAP, M);
            let k;
            if (Kt) {
              zt && de && n.texStorage2D(e.TEXTURE_CUBE_MAP, st, qt, bt.width, bt.height);
              for (let K = 0; K < 6; K++) {
                k = dt[K].mipmaps;
                for (let ut = 0; ut < k.length; ut++) {
                  const ct = k[ut];
                  M.format !== ci ? At !== null ? zt ? N && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, ut, 0, 0, ct.width, ct.height, At, ct.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, ut, qt, ct.width, ct.height, 0, ct.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : zt ? N && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, ut, 0, 0, ct.width, ct.height, At, pt, ct.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, ut, qt, ct.width, ct.height, 0, At, pt, ct.data);
                }
              }
            } else {
              if (k = M.mipmaps, zt && de) {
                k.length > 0 && st++;
                const K = St(dt[0]);
                n.texStorage2D(e.TEXTURE_CUBE_MAP, st, qt, K.width, K.height);
              }
              for (let K = 0; K < 6; K++) if (et) {
                zt ? N && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, 0, 0, dt[K].width, dt[K].height, At, pt, dt[K].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, qt, dt[K].width, dt[K].height, 0, At, pt, dt[K].data);
                for (let ut = 0; ut < k.length; ut++) {
                  const Nt = k[ut].image[K].image;
                  zt ? N && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, ut + 1, 0, 0, Nt.width, Nt.height, At, pt, Nt.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, ut + 1, qt, Nt.width, Nt.height, 0, At, pt, Nt.data);
                }
              } else {
                zt ? N && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, 0, 0, At, pt, dt[K]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, qt, At, pt, dt[K]);
                for (let ut = 0; ut < k.length; ut++) {
                  const ct = k[ut];
                  zt ? N && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, ut + 1, 0, 0, At, pt, ct.image[K]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + K, ut + 1, qt, At, pt, ct.image[K]);
                }
              }
            }
            m(M) && u(e.TEXTURE_CUBE_MAP), q.__version = J.version, M.onUpdate && M.onUpdate(M);
          }
          A.__version = M.version;
        }
        function _t(A, M, F, Z, J, q) {
          const yt = s.convert(F.format, F.colorSpace), lt = s.convert(F.type), ht = g(F.internalFormat, yt, lt, F.colorSpace), Kt = i.get(M), et = i.get(F);
          if (et.__renderTarget = M, !Kt.__hasExternalTextures) {
            const dt = Math.max(1, M.width >> q), bt = Math.max(1, M.height >> q);
            J === e.TEXTURE_3D || J === e.TEXTURE_2D_ARRAY ? n.texImage3D(J, q, ht, dt, bt, M.depth, 0, yt, lt, null) : n.texImage2D(J, q, ht, dt, bt, 0, yt, lt, null);
          }
          n.bindFramebuffer(e.FRAMEBUFFER, A), Yt(M) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, Z, J, et.__webglTexture, 0, Wt(M)) : (J === e.TEXTURE_2D || J >= e.TEXTURE_CUBE_MAP_POSITIVE_X && J <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, Z, J, et.__webglTexture, q), n.bindFramebuffer(e.FRAMEBUFFER, null);
        }
        function ot(A, M, F) {
          if (e.bindRenderbuffer(e.RENDERBUFFER, A), M.depthBuffer) {
            const Z = M.depthTexture, J = Z && Z.isDepthTexture ? Z.type : null, q = v(M.stencilBuffer, J), yt = M.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, lt = Wt(M);
            Yt(M) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, lt, q, M.width, M.height) : F ? e.renderbufferStorageMultisample(e.RENDERBUFFER, lt, q, M.width, M.height) : e.renderbufferStorage(e.RENDERBUFFER, q, M.width, M.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, yt, e.RENDERBUFFER, A);
          } else {
            const Z = M.textures;
            for (let J = 0; J < Z.length; J++) {
              const q = Z[J], yt = s.convert(q.format, q.colorSpace), lt = s.convert(q.type), ht = g(q.internalFormat, yt, lt, q.colorSpace), Kt = Wt(M);
              F && Yt(M) === false ? e.renderbufferStorageMultisample(e.RENDERBUFFER, Kt, ht, M.width, M.height) : Yt(M) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, Kt, ht, M.width, M.height) : e.renderbufferStorage(e.RENDERBUFFER, ht, M.width, M.height);
            }
          }
          e.bindRenderbuffer(e.RENDERBUFFER, null);
        }
        function Tt(A, M) {
          if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
          if (n.bindFramebuffer(e.FRAMEBUFFER, A), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          const Z = i.get(M.depthTexture);
          Z.__renderTarget = M, (!Z.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = true), Q(M.depthTexture, 0);
          const J = Z.__webglTexture, q = Wt(M);
          if (M.depthTexture.format === Tr) Yt(M) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, J, 0, q) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, J, 0);
          else if (M.depthTexture.format === Vr) Yt(M) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, J, 0, q) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, J, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function wt(A) {
          const M = i.get(A), F = A.isWebGLCubeRenderTarget === true;
          if (M.__boundDepthTexture !== A.depthTexture) {
            const Z = A.depthTexture;
            if (M.__depthDisposeCallback && M.__depthDisposeCallback(), Z) {
              const J = () => {
                delete M.__boundDepthTexture, delete M.__depthDisposeCallback, Z.removeEventListener("dispose", J);
              };
              Z.addEventListener("dispose", J), M.__depthDisposeCallback = J;
            }
            M.__boundDepthTexture = Z;
          }
          if (A.depthTexture && !M.__autoAllocateDepthBuffer) {
            if (F) throw new Error("target.depthTexture not supported in Cube render targets");
            Tt(M.__webglFramebuffer, A);
          } else if (F) {
            M.__webglDepthbuffer = [];
            for (let Z = 0; Z < 6; Z++) if (n.bindFramebuffer(e.FRAMEBUFFER, M.__webglFramebuffer[Z]), M.__webglDepthbuffer[Z] === void 0) M.__webglDepthbuffer[Z] = e.createRenderbuffer(), ot(M.__webglDepthbuffer[Z], A, false);
            else {
              const J = A.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, q = M.__webglDepthbuffer[Z];
              e.bindRenderbuffer(e.RENDERBUFFER, q), e.framebufferRenderbuffer(e.FRAMEBUFFER, J, e.RENDERBUFFER, q);
            }
          } else if (n.bindFramebuffer(e.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer === void 0) M.__webglDepthbuffer = e.createRenderbuffer(), ot(M.__webglDepthbuffer, A, false);
          else {
            const Z = A.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, J = M.__webglDepthbuffer;
            e.bindRenderbuffer(e.RENDERBUFFER, J), e.framebufferRenderbuffer(e.FRAMEBUFFER, Z, e.RENDERBUFFER, J);
          }
          n.bindFramebuffer(e.FRAMEBUFFER, null);
        }
        function Vt(A, M, F) {
          const Z = i.get(A);
          M !== void 0 && _t(Z.__webglFramebuffer, A, A.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), F !== void 0 && wt(A);
        }
        function xe(A) {
          const M = A.texture, F = i.get(A), Z = i.get(M);
          A.addEventListener("dispose", w);
          const J = A.textures, q = A.isWebGLCubeRenderTarget === true, yt = J.length > 1;
          if (yt || (Z.__webglTexture === void 0 && (Z.__webglTexture = e.createTexture()), Z.__version = M.version, r.memory.textures++), q) {
            F.__webglFramebuffer = [];
            for (let lt = 0; lt < 6; lt++) if (M.mipmaps && M.mipmaps.length > 0) {
              F.__webglFramebuffer[lt] = [];
              for (let ht = 0; ht < M.mipmaps.length; ht++) F.__webglFramebuffer[lt][ht] = e.createFramebuffer();
            } else F.__webglFramebuffer[lt] = e.createFramebuffer();
          } else {
            if (M.mipmaps && M.mipmaps.length > 0) {
              F.__webglFramebuffer = [];
              for (let lt = 0; lt < M.mipmaps.length; lt++) F.__webglFramebuffer[lt] = e.createFramebuffer();
            } else F.__webglFramebuffer = e.createFramebuffer();
            if (yt) for (let lt = 0, ht = J.length; lt < ht; lt++) {
              const Kt = i.get(J[lt]);
              Kt.__webglTexture === void 0 && (Kt.__webglTexture = e.createTexture(), r.memory.textures++);
            }
            if (A.samples > 0 && Yt(A) === false) {
              F.__webglMultisampledFramebuffer = e.createFramebuffer(), F.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, F.__webglMultisampledFramebuffer);
              for (let lt = 0; lt < J.length; lt++) {
                const ht = J[lt];
                F.__webglColorRenderbuffer[lt] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, F.__webglColorRenderbuffer[lt]);
                const Kt = s.convert(ht.format, ht.colorSpace), et = s.convert(ht.type), dt = g(ht.internalFormat, Kt, et, ht.colorSpace, A.isXRRenderTarget === true), bt = Wt(A);
                e.renderbufferStorageMultisample(e.RENDERBUFFER, bt, dt, A.width, A.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + lt, e.RENDERBUFFER, F.__webglColorRenderbuffer[lt]);
              }
              e.bindRenderbuffer(e.RENDERBUFFER, null), A.depthBuffer && (F.__webglDepthRenderbuffer = e.createRenderbuffer(), ot(F.__webglDepthRenderbuffer, A, true)), n.bindFramebuffer(e.FRAMEBUFFER, null);
            }
          }
          if (q) {
            n.bindTexture(e.TEXTURE_CUBE_MAP, Z.__webglTexture), Dt(e.TEXTURE_CUBE_MAP, M);
            for (let lt = 0; lt < 6; lt++) if (M.mipmaps && M.mipmaps.length > 0) for (let ht = 0; ht < M.mipmaps.length; ht++) _t(F.__webglFramebuffer[lt][ht], A, M, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + lt, ht);
            else _t(F.__webglFramebuffer[lt], A, M, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + lt, 0);
            m(M) && u(e.TEXTURE_CUBE_MAP), n.unbindTexture();
          } else if (yt) {
            for (let lt = 0, ht = J.length; lt < ht; lt++) {
              const Kt = J[lt], et = i.get(Kt);
              n.bindTexture(e.TEXTURE_2D, et.__webglTexture), Dt(e.TEXTURE_2D, Kt), _t(F.__webglFramebuffer, A, Kt, e.COLOR_ATTACHMENT0 + lt, e.TEXTURE_2D, 0), m(Kt) && u(e.TEXTURE_2D);
            }
            n.unbindTexture();
          } else {
            let lt = e.TEXTURE_2D;
            if ((A.isWebGL3DRenderTarget || A.isWebGLArrayRenderTarget) && (lt = A.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), n.bindTexture(lt, Z.__webglTexture), Dt(lt, M), M.mipmaps && M.mipmaps.length > 0) for (let ht = 0; ht < M.mipmaps.length; ht++) _t(F.__webglFramebuffer[ht], A, M, e.COLOR_ATTACHMENT0, lt, ht);
            else _t(F.__webglFramebuffer, A, M, e.COLOR_ATTACHMENT0, lt, 0);
            m(M) && u(lt), n.unbindTexture();
          }
          A.depthBuffer && wt(A);
        }
        function Zt(A) {
          const M = A.textures;
          for (let F = 0, Z = M.length; F < Z; F++) {
            const J = M[F];
            if (m(J)) {
              const q = _(A), yt = i.get(J).__webglTexture;
              n.bindTexture(q, yt), u(q), n.unbindTexture();
            }
          }
        }
        const De = [], U = [];
        function Nn(A) {
          if (A.samples > 0) {
            if (Yt(A) === false) {
              const M = A.textures, F = A.width, Z = A.height;
              let J = e.COLOR_BUFFER_BIT;
              const q = A.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT, yt = i.get(A), lt = M.length > 1;
              if (lt) for (let ht = 0; ht < M.length; ht++) n.bindFramebuffer(e.FRAMEBUFFER, yt.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + ht, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, yt.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + ht, e.TEXTURE_2D, null, 0);
              n.bindFramebuffer(e.READ_FRAMEBUFFER, yt.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, yt.__webglFramebuffer);
              for (let ht = 0; ht < M.length; ht++) {
                if (A.resolveDepthBuffer && (A.depthBuffer && (J |= e.DEPTH_BUFFER_BIT), A.stencilBuffer && A.resolveStencilBuffer && (J |= e.STENCIL_BUFFER_BIT)), lt) {
                  e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, yt.__webglColorRenderbuffer[ht]);
                  const Kt = i.get(M[ht]).__webglTexture;
                  e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, Kt, 0);
                }
                e.blitFramebuffer(0, 0, F, Z, 0, 0, F, Z, J, e.NEAREST), l === true && (De.length = 0, U.length = 0, De.push(e.COLOR_ATTACHMENT0 + ht), A.depthBuffer && A.resolveDepthBuffer === false && (De.push(q), U.push(q), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, U)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, De));
              }
              if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), lt) for (let ht = 0; ht < M.length; ht++) {
                n.bindFramebuffer(e.FRAMEBUFFER, yt.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + ht, e.RENDERBUFFER, yt.__webglColorRenderbuffer[ht]);
                const Kt = i.get(M[ht]).__webglTexture;
                n.bindFramebuffer(e.FRAMEBUFFER, yt.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + ht, e.TEXTURE_2D, Kt, 0);
              }
              n.bindFramebuffer(e.DRAW_FRAMEBUFFER, yt.__webglMultisampledFramebuffer);
            } else if (A.depthBuffer && A.resolveDepthBuffer === false && l) {
              const M = A.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
              e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [
                M
              ]);
            }
          }
        }
        function Wt(A) {
          return Math.min(a.maxSamples, A.samples);
        }
        function Yt(A) {
          const M = i.get(A);
          return A.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === true && M.__useRenderToTexture !== false;
        }
        function xt(A) {
          const M = r.render.frame;
          f.get(A) !== M && (f.set(A, M), A.update());
        }
        function _e(A, M) {
          const F = A.colorSpace, Z = A.format, J = A.type;
          return A.isCompressedTexture === true || A.isVideoTexture === true || F !== kr && F !== xa && (te.getTransfer(F) === le ? (Z !== ci || J !== ea) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", F)), M;
        }
        function St(A) {
          return typeof HTMLImageElement < "u" && A instanceof HTMLImageElement ? (c.width = A.naturalWidth || A.width, c.height = A.naturalHeight || A.height) : typeof VideoFrame < "u" && A instanceof VideoFrame ? (c.width = A.displayWidth, c.height = A.displayHeight) : (c.width = A.width, c.height = A.height), c;
        }
        this.allocateTextureUnit = I, this.resetTextureUnits = V, this.setTexture2D = Q, this.setTexture2DArray = L, this.setTexture3D = W, this.setTextureCube = B, this.rebindTextures = Vt, this.setupRenderTarget = xe, this.updateRenderTargetMipmap = Zt, this.updateMultisampleRenderTarget = Nn, this.setupDepthRenderbuffer = wt, this.setupFrameBufferTexture = _t, this.useMultisampledRTT = Yt;
      }
      function RC(e, t) {
        function n(i, a = xa) {
          let s;
          const r = te.getTransfer(a);
          if (i === ea) return e.UNSIGNED_BYTE;
          if (i === tm) return e.UNSIGNED_SHORT_4_4_4_4;
          if (i === em) return e.UNSIGNED_SHORT_5_5_5_1;
          if (i === cS) return e.UNSIGNED_INT_5_9_9_9_REV;
          if (i === oS) return e.BYTE;
          if (i === lS) return e.SHORT;
          if (i === fl) return e.UNSIGNED_SHORT;
          if (i === $p) return e.INT;
          if (i === ys) return e.UNSIGNED_INT;
          if (i === gi) return e.FLOAT;
          if (i === Al) return e.HALF_FLOAT;
          if (i === uS) return e.ALPHA;
          if (i === fS) return e.RGB;
          if (i === ci) return e.RGBA;
          if (i === hS) return e.LUMINANCE;
          if (i === dS) return e.LUMINANCE_ALPHA;
          if (i === Tr) return e.DEPTH_COMPONENT;
          if (i === Vr) return e.DEPTH_STENCIL;
          if (i === nm) return e.RED;
          if (i === im) return e.RED_INTEGER;
          if (i === pS) return e.RG;
          if (i === am) return e.RG_INTEGER;
          if (i === sm) return e.RGBA_INTEGER;
          if (i === Lc || i === Nc || i === Oc || i === Pc) if (r === le) if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
            if (i === Lc) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (i === Nc) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (i === Oc) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (i === Pc) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else return null;
          else if (s = t.get("WEBGL_compressed_texture_s3tc"), s !== null) {
            if (i === Lc) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (i === Nc) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (i === Oc) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (i === Pc) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else return null;
          if (i === Ed || i === bd || i === Td || i === Ad) if (s = t.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
            if (i === Ed) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (i === bd) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (i === Td) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (i === Ad) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else return null;
          if (i === Rd || i === wd || i === Cd) if (s = t.get("WEBGL_compressed_texture_etc"), s !== null) {
            if (i === Rd || i === wd) return r === le ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
            if (i === Cd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
          } else return null;
          if (i === Dd || i === Ud || i === Ld || i === Nd || i === Od || i === Pd || i === zd || i === Bd || i === Fd || i === Id || i === Hd || i === Gd || i === Vd || i === kd) if (s = t.get("WEBGL_compressed_texture_astc"), s !== null) {
            if (i === Dd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (i === Ud) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (i === Ld) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (i === Nd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (i === Od) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (i === Pd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (i === zd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (i === Bd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (i === Fd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (i === Id) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (i === Hd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (i === Gd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (i === Vd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (i === kd) return r === le ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
          } else return null;
          if (i === zc || i === Xd || i === Wd) if (s = t.get("EXT_texture_compression_bptc"), s !== null) {
            if (i === zc) return r === le ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            if (i === Xd) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
            if (i === Wd) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
          } else return null;
          if (i === mS || i === Yd || i === qd || i === jd) if (s = t.get("EXT_texture_compression_rgtc"), s !== null) {
            if (i === zc) return s.COMPRESSED_RED_RGTC1_EXT;
            if (i === Yd) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (i === qd) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (i === jd) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          } else return null;
          return i === Gr ? e.UNSIGNED_INT_24_8 : e[i] !== void 0 ? e[i] : null;
        }
        return {
          convert: n
        };
      }
      const wC = {
        type: "move"
      };
      class oh {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return this._hand === null && (this._hand = new dc(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
            pinching: false
          }), this._hand;
        }
        getTargetRaySpace() {
          return this._targetRay === null && (this._targetRay = new dc(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new z(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new z()), this._targetRay;
        }
        getGripSpace() {
          return this._grip === null && (this._grip = new dc(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new z(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new z()), this._grip;
        }
        dispatchEvent(t) {
          return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
        }
        connect(t) {
          if (t && t.hand) {
            const n = this._hand;
            if (n) for (const i of t.hand.values()) this._getHandJoint(n, i);
          }
          return this.dispatchEvent({
            type: "connected",
            data: t
          }), this;
        }
        disconnect(t) {
          return this.dispatchEvent({
            type: "disconnected",
            data: t
          }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
        }
        update(t, n, i) {
          let a = null, s = null, r = null;
          const o = this._targetRay, l = this._grip, c = this._hand;
          if (t && n.session.visibilityState !== "visible-blurred") {
            if (c && t.hand) {
              r = true;
              for (const S of t.hand.values()) {
                const m = n.getJointPose(S, i), u = this._getHandJoint(c, S);
                m !== null && (u.matrix.fromArray(m.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = true, u.jointRadius = m.radius), u.visible = m !== null;
              }
              const f = c.joints["index-finger-tip"], d = c.joints["thumb-tip"], h = f.position.distanceTo(d.position), p = 0.02, y = 5e-3;
              c.inputState.pinching && h > p + y ? (c.inputState.pinching = false, this.dispatchEvent({
                type: "pinchend",
                handedness: t.handedness,
                target: this
              })) : !c.inputState.pinching && h <= p - y && (c.inputState.pinching = true, this.dispatchEvent({
                type: "pinchstart",
                handedness: t.handedness,
                target: this
              }));
            } else l !== null && t.gripSpace && (s = n.getPose(t.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, s.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = false, s.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = false));
            o !== null && (a = n.getPose(t.targetRaySpace, i), a === null && s !== null && (a = s), a !== null && (o.matrix.fromArray(a.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = true, a.linearVelocity ? (o.hasLinearVelocity = true, o.linearVelocity.copy(a.linearVelocity)) : o.hasLinearVelocity = false, a.angularVelocity ? (o.hasAngularVelocity = true, o.angularVelocity.copy(a.angularVelocity)) : o.hasAngularVelocity = false, this.dispatchEvent(wC)));
          }
          return o !== null && (o.visible = a !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = r !== null), this;
        }
        _getHandJoint(t, n) {
          if (t.joints[n.jointName] === void 0) {
            const i = new dc();
            i.matrixAutoUpdate = false, i.visible = false, t.joints[n.jointName] = i, t.add(i);
          }
          return t.joints[n.jointName];
        }
      }
      const CC = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, DC = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
      class UC {
        constructor() {
          this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(t, n, i) {
          if (this.texture === null) {
            const a = new pn(), s = t.properties.get(a);
            s.__webglTexture = n.texture, (n.depthNear !== i.depthNear || n.depthFar !== i.depthFar) && (this.depthNear = n.depthNear, this.depthFar = n.depthFar), this.texture = a;
          }
        }
        getMesh(t) {
          if (this.texture !== null && this.mesh === null) {
            const n = t.cameras[0].viewport, i = new na({
              vertexShader: CC,
              fragmentShader: DC,
              uniforms: {
                depthColor: {
                  value: this.texture
                },
                depthWidth: {
                  value: n.z
                },
                depthHeight: {
                  value: n.w
                }
              }
            });
            this.mesh = new Qn(new ku(20, 20), i);
          }
          return this.mesh;
        }
        reset() {
          this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class LC extends ws {
        constructor(t, n) {
          super();
          const i = this;
          let a = null, s = 1, r = null, o = "local-floor", l = 1, c = null, f = null, d = null, h = null, p = null, y = null;
          const S = new UC(), m = n.getContextAttributes();
          let u = null, _ = null;
          const g = [], v = [], T = new Ut();
          let R = null;
          const w = new Wn();
          w.viewport = new Ce();
          const D = new Wn();
          D.viewport = new Ce();
          const b = [
            w,
            D
          ], x = new Q1();
          let C = null, V = null;
          this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(Y) {
            let nt = g[Y];
            return nt === void 0 && (nt = new oh(), g[Y] = nt), nt.getTargetRaySpace();
          }, this.getControllerGrip = function(Y) {
            let nt = g[Y];
            return nt === void 0 && (nt = new oh(), g[Y] = nt), nt.getGripSpace();
          }, this.getHand = function(Y) {
            let nt = g[Y];
            return nt === void 0 && (nt = new oh(), g[Y] = nt), nt.getHandSpace();
          };
          function I(Y) {
            const nt = v.indexOf(Y.inputSource);
            if (nt === -1) return;
            const _t = g[nt];
            _t !== void 0 && (_t.update(Y.inputSource, Y.frame, c || r), _t.dispatchEvent({
              type: Y.type,
              data: Y.inputSource
            }));
          }
          function X() {
            a.removeEventListener("select", I), a.removeEventListener("selectstart", I), a.removeEventListener("selectend", I), a.removeEventListener("squeeze", I), a.removeEventListener("squeezestart", I), a.removeEventListener("squeezeend", I), a.removeEventListener("end", X), a.removeEventListener("inputsourceschange", Q);
            for (let Y = 0; Y < g.length; Y++) {
              const nt = v[Y];
              nt !== null && (v[Y] = null, g[Y].disconnect(nt));
            }
            C = null, V = null, S.reset(), t.setRenderTarget(u), p = null, h = null, d = null, a = null, _ = null, ne.stop(), i.isPresenting = false, t.setPixelRatio(R), t.setSize(T.width, T.height, false), i.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(Y) {
            s = Y, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function(Y) {
            o = Y, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function() {
            return c || r;
          }, this.setReferenceSpace = function(Y) {
            c = Y;
          }, this.getBaseLayer = function() {
            return h !== null ? h : p;
          }, this.getBinding = function() {
            return d;
          }, this.getFrame = function() {
            return y;
          }, this.getSession = function() {
            return a;
          }, this.setSession = async function(Y) {
            if (a = Y, a !== null) {
              if (u = t.getRenderTarget(), a.addEventListener("select", I), a.addEventListener("selectstart", I), a.addEventListener("selectend", I), a.addEventListener("squeeze", I), a.addEventListener("squeezestart", I), a.addEventListener("squeezeend", I), a.addEventListener("end", X), a.addEventListener("inputsourceschange", Q), m.xrCompatible !== true && await n.makeXRCompatible(), R = t.getPixelRatio(), t.getSize(T), a.enabledFeatures !== void 0 && a.enabledFeatures.includes("layers")) {
                let _t = null, ot = null, Tt = null;
                m.depth && (Tt = m.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, _t = m.stencil ? Vr : Tr, ot = m.stencil ? Gr : ys);
                const wt = {
                  colorFormat: n.RGBA8,
                  depthFormat: Tt,
                  scaleFactor: s
                };
                d = new XRWebGLBinding(a, n), h = d.createProjectionLayer(wt), a.updateRenderState({
                  layers: [
                    h
                  ]
                }), t.setPixelRatio(1), t.setSize(h.textureWidth, h.textureHeight, false), _ = new Ss(h.textureWidth, h.textureHeight, {
                  format: ci,
                  type: ea,
                  depthTexture: new DS(h.textureWidth, h.textureHeight, ot, void 0, void 0, void 0, void 0, void 0, void 0, _t),
                  stencilBuffer: m.stencil,
                  colorSpace: t.outputColorSpace,
                  samples: m.antialias ? 4 : 0,
                  resolveDepthBuffer: h.ignoreDepthValues === false
                });
              } else {
                const _t = {
                  antialias: m.antialias,
                  alpha: true,
                  depth: m.depth,
                  stencil: m.stencil,
                  framebufferScaleFactor: s
                };
                p = new XRWebGLLayer(a, n, _t), a.updateRenderState({
                  baseLayer: p
                }), t.setPixelRatio(1), t.setSize(p.framebufferWidth, p.framebufferHeight, false), _ = new Ss(p.framebufferWidth, p.framebufferHeight, {
                  format: ci,
                  type: ea,
                  colorSpace: t.outputColorSpace,
                  stencilBuffer: m.stencil
                });
              }
              _.isXRRenderTarget = true, this.setFoveation(l), c = null, r = await a.requestReferenceSpace(o), ne.setContext(a), ne.start(), i.isPresenting = true, i.dispatchEvent({
                type: "sessionstart"
              });
            }
          }, this.getEnvironmentBlendMode = function() {
            if (a !== null) return a.environmentBlendMode;
          }, this.getDepthTexture = function() {
            return S.getDepthTexture();
          };
          function Q(Y) {
            for (let nt = 0; nt < Y.removed.length; nt++) {
              const _t = Y.removed[nt], ot = v.indexOf(_t);
              ot >= 0 && (v[ot] = null, g[ot].disconnect(_t));
            }
            for (let nt = 0; nt < Y.added.length; nt++) {
              const _t = Y.added[nt];
              let ot = v.indexOf(_t);
              if (ot === -1) {
                for (let wt = 0; wt < g.length; wt++) if (wt >= v.length) {
                  v.push(_t), ot = wt;
                  break;
                } else if (v[wt] === null) {
                  v[wt] = _t, ot = wt;
                  break;
                }
                if (ot === -1) break;
              }
              const Tt = g[ot];
              Tt && Tt.connect(_t);
            }
          }
          const L = new z(), W = new z();
          function B(Y, nt, _t) {
            L.setFromMatrixPosition(nt.matrixWorld), W.setFromMatrixPosition(_t.matrixWorld);
            const ot = L.distanceTo(W), Tt = nt.projectionMatrix.elements, wt = _t.projectionMatrix.elements, Vt = Tt[14] / (Tt[10] - 1), xe = Tt[14] / (Tt[10] + 1), Zt = (Tt[9] + 1) / Tt[5], De = (Tt[9] - 1) / Tt[5], U = (Tt[8] - 1) / Tt[0], Nn = (wt[8] + 1) / wt[0], Wt = Vt * U, Yt = Vt * Nn, xt = ot / (-U + Nn), _e = xt * -U;
            if (nt.matrixWorld.decompose(Y.position, Y.quaternion, Y.scale), Y.translateX(_e), Y.translateZ(xt), Y.matrixWorld.compose(Y.position, Y.quaternion, Y.scale), Y.matrixWorldInverse.copy(Y.matrixWorld).invert(), Tt[10] === -1) Y.projectionMatrix.copy(nt.projectionMatrix), Y.projectionMatrixInverse.copy(nt.projectionMatrixInverse);
            else {
              const St = Vt + xt, A = xe + xt, M = Wt - _e, F = Yt + (ot - _e), Z = Zt * xe / A * St, J = De * xe / A * St;
              Y.projectionMatrix.makePerspective(M, F, Z, J, St, A), Y.projectionMatrixInverse.copy(Y.projectionMatrix).invert();
            }
          }
          function $(Y, nt) {
            nt === null ? Y.matrixWorld.copy(Y.matrix) : Y.matrixWorld.multiplyMatrices(nt.matrixWorld, Y.matrix), Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
          }
          this.updateCamera = function(Y) {
            if (a === null) return;
            let nt = Y.near, _t = Y.far;
            S.texture !== null && (S.depthNear > 0 && (nt = S.depthNear), S.depthFar > 0 && (_t = S.depthFar)), x.near = D.near = w.near = nt, x.far = D.far = w.far = _t, (C !== x.near || V !== x.far) && (a.updateRenderState({
              depthNear: x.near,
              depthFar: x.far
            }), C = x.near, V = x.far), w.layers.mask = Y.layers.mask | 2, D.layers.mask = Y.layers.mask | 4, x.layers.mask = w.layers.mask | D.layers.mask;
            const ot = Y.parent, Tt = x.cameras;
            $(x, ot);
            for (let wt = 0; wt < Tt.length; wt++) $(Tt[wt], ot);
            Tt.length === 2 ? B(x, w, D) : x.projectionMatrix.copy(w.projectionMatrix), it(Y, x, ot);
          };
          function it(Y, nt, _t) {
            _t === null ? Y.matrix.copy(nt.matrixWorld) : (Y.matrix.copy(_t.matrixWorld), Y.matrix.invert(), Y.matrix.multiply(nt.matrixWorld)), Y.matrix.decompose(Y.position, Y.quaternion, Y.scale), Y.updateMatrixWorld(true), Y.projectionMatrix.copy(nt.projectionMatrix), Y.projectionMatrixInverse.copy(nt.projectionMatrixInverse), Y.isPerspectiveCamera && (Y.fov = hl * 2 * Math.atan(1 / Y.projectionMatrix.elements[5]), Y.zoom = 1);
          }
          this.getCamera = function() {
            return x;
          }, this.getFoveation = function() {
            if (!(h === null && p === null)) return l;
          }, this.setFoveation = function(Y) {
            l = Y, h !== null && (h.fixedFoveation = Y), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = Y);
          }, this.hasDepthSensing = function() {
            return S.texture !== null;
          }, this.getDepthSensingMesh = function() {
            return S.getMesh(x);
          };
          let gt = null;
          function Dt(Y, nt) {
            if (f = nt.getViewerPose(c || r), y = nt, f !== null) {
              const _t = f.views;
              p !== null && (t.setRenderTargetFramebuffer(_, p.framebuffer), t.setRenderTarget(_));
              let ot = false;
              _t.length !== x.cameras.length && (x.cameras.length = 0, ot = true);
              for (let wt = 0; wt < _t.length; wt++) {
                const Vt = _t[wt];
                let xe = null;
                if (p !== null) xe = p.getViewport(Vt);
                else {
                  const De = d.getViewSubImage(h, Vt);
                  xe = De.viewport, wt === 0 && (t.setRenderTargetTextures(_, De.colorTexture, h.ignoreDepthValues ? void 0 : De.depthStencilTexture), t.setRenderTarget(_));
                }
                let Zt = b[wt];
                Zt === void 0 && (Zt = new Wn(), Zt.layers.enable(wt), Zt.viewport = new Ce(), b[wt] = Zt), Zt.matrix.fromArray(Vt.transform.matrix), Zt.matrix.decompose(Zt.position, Zt.quaternion, Zt.scale), Zt.projectionMatrix.fromArray(Vt.projectionMatrix), Zt.projectionMatrixInverse.copy(Zt.projectionMatrix).invert(), Zt.viewport.set(xe.x, xe.y, xe.width, xe.height), wt === 0 && (x.matrix.copy(Zt.matrix), x.matrix.decompose(x.position, x.quaternion, x.scale)), ot === true && x.cameras.push(Zt);
              }
              const Tt = a.enabledFeatures;
              if (Tt && Tt.includes("depth-sensing")) {
                const wt = d.getDepthInformation(_t[0]);
                wt && wt.isValid && wt.texture && S.init(t, wt, a.renderState);
              }
            }
            for (let _t = 0; _t < g.length; _t++) {
              const ot = v[_t], Tt = g[_t];
              ot !== null && Tt !== void 0 && Tt.update(ot, nt, c || r);
            }
            gt && gt(Y, nt), nt.detectedPlanes && i.dispatchEvent({
              type: "planesdetected",
              data: nt
            }), y = null;
          }
          const ne = new NS();
          ne.setAnimationLoop(Dt), this.setAnimationLoop = function(Y) {
            gt = Y;
          }, this.dispose = function() {
          };
        }
      }
      const Ka = new Mi(), NC = new ie();
      function OC(e, t) {
        function n(m, u) {
          m.matrixAutoUpdate === true && m.updateMatrix(), u.value.copy(m.matrix);
        }
        function i(m, u) {
          u.color.getRGB(m.fogColor.value, TS(e)), u.isFog ? (m.fogNear.value = u.near, m.fogFar.value = u.far) : u.isFogExp2 && (m.fogDensity.value = u.density);
        }
        function a(m, u, _, g, v) {
          u.isMeshBasicMaterial || u.isMeshLambertMaterial ? s(m, u) : u.isMeshToonMaterial ? (s(m, u), d(m, u)) : u.isMeshPhongMaterial ? (s(m, u), f(m, u)) : u.isMeshStandardMaterial ? (s(m, u), h(m, u), u.isMeshPhysicalMaterial && p(m, u, v)) : u.isMeshMatcapMaterial ? (s(m, u), y(m, u)) : u.isMeshDepthMaterial ? s(m, u) : u.isMeshDistanceMaterial ? (s(m, u), S(m, u)) : u.isMeshNormalMaterial ? s(m, u) : u.isLineBasicMaterial ? (r(m, u), u.isLineDashedMaterial && o(m, u)) : u.isPointsMaterial ? l(m, u, _, g) : u.isSpriteMaterial ? c(m, u) : u.isShadowMaterial ? (m.color.value.copy(u.color), m.opacity.value = u.opacity) : u.isShaderMaterial && (u.uniformsNeedUpdate = false);
        }
        function s(m, u) {
          m.opacity.value = u.opacity, u.color && m.diffuse.value.copy(u.color), u.emissive && m.emissive.value.copy(u.emissive).multiplyScalar(u.emissiveIntensity), u.map && (m.map.value = u.map, n(u.map, m.mapTransform)), u.alphaMap && (m.alphaMap.value = u.alphaMap, n(u.alphaMap, m.alphaMapTransform)), u.bumpMap && (m.bumpMap.value = u.bumpMap, n(u.bumpMap, m.bumpMapTransform), m.bumpScale.value = u.bumpScale, u.side === dn && (m.bumpScale.value *= -1)), u.normalMap && (m.normalMap.value = u.normalMap, n(u.normalMap, m.normalMapTransform), m.normalScale.value.copy(u.normalScale), u.side === dn && m.normalScale.value.negate()), u.displacementMap && (m.displacementMap.value = u.displacementMap, n(u.displacementMap, m.displacementMapTransform), m.displacementScale.value = u.displacementScale, m.displacementBias.value = u.displacementBias), u.emissiveMap && (m.emissiveMap.value = u.emissiveMap, n(u.emissiveMap, m.emissiveMapTransform)), u.specularMap && (m.specularMap.value = u.specularMap, n(u.specularMap, m.specularMapTransform)), u.alphaTest > 0 && (m.alphaTest.value = u.alphaTest);
          const _ = t.get(u), g = _.envMap, v = _.envMapRotation;
          g && (m.envMap.value = g, Ka.copy(v), Ka.x *= -1, Ka.y *= -1, Ka.z *= -1, g.isCubeTexture && g.isRenderTargetTexture === false && (Ka.y *= -1, Ka.z *= -1), m.envMapRotation.value.setFromMatrix4(NC.makeRotationFromEuler(Ka)), m.flipEnvMap.value = g.isCubeTexture && g.isRenderTargetTexture === false ? -1 : 1, m.reflectivity.value = u.reflectivity, m.ior.value = u.ior, m.refractionRatio.value = u.refractionRatio), u.lightMap && (m.lightMap.value = u.lightMap, m.lightMapIntensity.value = u.lightMapIntensity, n(u.lightMap, m.lightMapTransform)), u.aoMap && (m.aoMap.value = u.aoMap, m.aoMapIntensity.value = u.aoMapIntensity, n(u.aoMap, m.aoMapTransform));
        }
        function r(m, u) {
          m.diffuse.value.copy(u.color), m.opacity.value = u.opacity, u.map && (m.map.value = u.map, n(u.map, m.mapTransform));
        }
        function o(m, u) {
          m.dashSize.value = u.dashSize, m.totalSize.value = u.dashSize + u.gapSize, m.scale.value = u.scale;
        }
        function l(m, u, _, g) {
          m.diffuse.value.copy(u.color), m.opacity.value = u.opacity, m.size.value = u.size * _, m.scale.value = g * 0.5, u.map && (m.map.value = u.map, n(u.map, m.uvTransform)), u.alphaMap && (m.alphaMap.value = u.alphaMap, n(u.alphaMap, m.alphaMapTransform)), u.alphaTest > 0 && (m.alphaTest.value = u.alphaTest);
        }
        function c(m, u) {
          m.diffuse.value.copy(u.color), m.opacity.value = u.opacity, m.rotation.value = u.rotation, u.map && (m.map.value = u.map, n(u.map, m.mapTransform)), u.alphaMap && (m.alphaMap.value = u.alphaMap, n(u.alphaMap, m.alphaMapTransform)), u.alphaTest > 0 && (m.alphaTest.value = u.alphaTest);
        }
        function f(m, u) {
          m.specular.value.copy(u.specular), m.shininess.value = Math.max(u.shininess, 1e-4);
        }
        function d(m, u) {
          u.gradientMap && (m.gradientMap.value = u.gradientMap);
        }
        function h(m, u) {
          m.metalness.value = u.metalness, u.metalnessMap && (m.metalnessMap.value = u.metalnessMap, n(u.metalnessMap, m.metalnessMapTransform)), m.roughness.value = u.roughness, u.roughnessMap && (m.roughnessMap.value = u.roughnessMap, n(u.roughnessMap, m.roughnessMapTransform)), u.envMap && (m.envMapIntensity.value = u.envMapIntensity);
        }
        function p(m, u, _) {
          m.ior.value = u.ior, u.sheen > 0 && (m.sheenColor.value.copy(u.sheenColor).multiplyScalar(u.sheen), m.sheenRoughness.value = u.sheenRoughness, u.sheenColorMap && (m.sheenColorMap.value = u.sheenColorMap, n(u.sheenColorMap, m.sheenColorMapTransform)), u.sheenRoughnessMap && (m.sheenRoughnessMap.value = u.sheenRoughnessMap, n(u.sheenRoughnessMap, m.sheenRoughnessMapTransform))), u.clearcoat > 0 && (m.clearcoat.value = u.clearcoat, m.clearcoatRoughness.value = u.clearcoatRoughness, u.clearcoatMap && (m.clearcoatMap.value = u.clearcoatMap, n(u.clearcoatMap, m.clearcoatMapTransform)), u.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = u.clearcoatRoughnessMap, n(u.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)), u.clearcoatNormalMap && (m.clearcoatNormalMap.value = u.clearcoatNormalMap, n(u.clearcoatNormalMap, m.clearcoatNormalMapTransform), m.clearcoatNormalScale.value.copy(u.clearcoatNormalScale), u.side === dn && m.clearcoatNormalScale.value.negate())), u.dispersion > 0 && (m.dispersion.value = u.dispersion), u.iridescence > 0 && (m.iridescence.value = u.iridescence, m.iridescenceIOR.value = u.iridescenceIOR, m.iridescenceThicknessMinimum.value = u.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = u.iridescenceThicknessRange[1], u.iridescenceMap && (m.iridescenceMap.value = u.iridescenceMap, n(u.iridescenceMap, m.iridescenceMapTransform)), u.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = u.iridescenceThicknessMap, n(u.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))), u.transmission > 0 && (m.transmission.value = u.transmission, m.transmissionSamplerMap.value = _.texture, m.transmissionSamplerSize.value.set(_.width, _.height), u.transmissionMap && (m.transmissionMap.value = u.transmissionMap, n(u.transmissionMap, m.transmissionMapTransform)), m.thickness.value = u.thickness, u.thicknessMap && (m.thicknessMap.value = u.thicknessMap, n(u.thicknessMap, m.thicknessMapTransform)), m.attenuationDistance.value = u.attenuationDistance, m.attenuationColor.value.copy(u.attenuationColor)), u.anisotropy > 0 && (m.anisotropyVector.value.set(u.anisotropy * Math.cos(u.anisotropyRotation), u.anisotropy * Math.sin(u.anisotropyRotation)), u.anisotropyMap && (m.anisotropyMap.value = u.anisotropyMap, n(u.anisotropyMap, m.anisotropyMapTransform))), m.specularIntensity.value = u.specularIntensity, m.specularColor.value.copy(u.specularColor), u.specularColorMap && (m.specularColorMap.value = u.specularColorMap, n(u.specularColorMap, m.specularColorMapTransform)), u.specularIntensityMap && (m.specularIntensityMap.value = u.specularIntensityMap, n(u.specularIntensityMap, m.specularIntensityMapTransform));
        }
        function y(m, u) {
          u.matcap && (m.matcap.value = u.matcap);
        }
        function S(m, u) {
          const _ = t.get(u).light;
          m.referencePosition.value.setFromMatrixPosition(_.matrixWorld), m.nearDistance.value = _.shadow.camera.near, m.farDistance.value = _.shadow.camera.far;
        }
        return {
          refreshFogUniforms: i,
          refreshMaterialUniforms: a
        };
      }
      function PC(e, t, n, i) {
        let a = {}, s = {}, r = [];
        const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
        function l(_, g) {
          const v = g.program;
          i.uniformBlockBinding(_, v);
        }
        function c(_, g) {
          let v = a[_.id];
          v === void 0 && (y(_), v = f(_), a[_.id] = v, _.addEventListener("dispose", m));
          const T = g.program;
          i.updateUBOMapping(_, T);
          const R = t.render.frame;
          s[_.id] !== R && (h(_), s[_.id] = R);
        }
        function f(_) {
          const g = d();
          _.__bindingPointIndex = g;
          const v = e.createBuffer(), T = _.__size, R = _.usage;
          return e.bindBuffer(e.UNIFORM_BUFFER, v), e.bufferData(e.UNIFORM_BUFFER, T, R), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, g, v), v;
        }
        function d() {
          for (let _ = 0; _ < o; _++) if (r.indexOf(_) === -1) return r.push(_), _;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function h(_) {
          const g = a[_.id], v = _.uniforms, T = _.__cache;
          e.bindBuffer(e.UNIFORM_BUFFER, g);
          for (let R = 0, w = v.length; R < w; R++) {
            const D = Array.isArray(v[R]) ? v[R] : [
              v[R]
            ];
            for (let b = 0, x = D.length; b < x; b++) {
              const C = D[b];
              if (p(C, R, b, T) === true) {
                const V = C.__offset, I = Array.isArray(C.value) ? C.value : [
                  C.value
                ];
                let X = 0;
                for (let Q = 0; Q < I.length; Q++) {
                  const L = I[Q], W = S(L);
                  typeof L == "number" || typeof L == "boolean" ? (C.__data[0] = L, e.bufferSubData(e.UNIFORM_BUFFER, V + X, C.__data)) : L.isMatrix3 ? (C.__data[0] = L.elements[0], C.__data[1] = L.elements[1], C.__data[2] = L.elements[2], C.__data[3] = 0, C.__data[4] = L.elements[3], C.__data[5] = L.elements[4], C.__data[6] = L.elements[5], C.__data[7] = 0, C.__data[8] = L.elements[6], C.__data[9] = L.elements[7], C.__data[10] = L.elements[8], C.__data[11] = 0) : (L.toArray(C.__data, X), X += W.storage / Float32Array.BYTES_PER_ELEMENT);
                }
                e.bufferSubData(e.UNIFORM_BUFFER, V, C.__data);
              }
            }
          }
          e.bindBuffer(e.UNIFORM_BUFFER, null);
        }
        function p(_, g, v, T) {
          const R = _.value, w = g + "_" + v;
          if (T[w] === void 0) return typeof R == "number" || typeof R == "boolean" ? T[w] = R : T[w] = R.clone(), true;
          {
            const D = T[w];
            if (typeof R == "number" || typeof R == "boolean") {
              if (D !== R) return T[w] = R, true;
            } else if (D.equals(R) === false) return D.copy(R), true;
          }
          return false;
        }
        function y(_) {
          const g = _.uniforms;
          let v = 0;
          const T = 16;
          for (let w = 0, D = g.length; w < D; w++) {
            const b = Array.isArray(g[w]) ? g[w] : [
              g[w]
            ];
            for (let x = 0, C = b.length; x < C; x++) {
              const V = b[x], I = Array.isArray(V.value) ? V.value : [
                V.value
              ];
              for (let X = 0, Q = I.length; X < Q; X++) {
                const L = I[X], W = S(L), B = v % T, $ = B % W.boundary, it = B + $;
                v += $, it !== 0 && T - it < W.storage && (v += T - it), V.__data = new Float32Array(W.storage / Float32Array.BYTES_PER_ELEMENT), V.__offset = v, v += W.storage;
              }
            }
          }
          const R = v % T;
          return R > 0 && (v += T - R), _.__size = v, _.__cache = {}, this;
        }
        function S(_) {
          const g = {
            boundary: 0,
            storage: 0
          };
          return typeof _ == "number" || typeof _ == "boolean" ? (g.boundary = 4, g.storage = 4) : _.isVector2 ? (g.boundary = 8, g.storage = 8) : _.isVector3 || _.isColor ? (g.boundary = 16, g.storage = 12) : _.isVector4 ? (g.boundary = 16, g.storage = 16) : _.isMatrix3 ? (g.boundary = 48, g.storage = 48) : _.isMatrix4 ? (g.boundary = 64, g.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), g;
        }
        function m(_) {
          const g = _.target;
          g.removeEventListener("dispose", m);
          const v = r.indexOf(g.__bindingPointIndex);
          r.splice(v, 1), e.deleteBuffer(a[g.id]), delete a[g.id], delete s[g.id];
        }
        function u() {
          for (const _ in a) e.deleteBuffer(a[_]);
          r = [], a = {}, s = {};
        }
        return {
          bind: l,
          update: c,
          dispose: u
        };
      }
      class zC {
        constructor(t = {}) {
          const { canvas: n = f1(), context: i = null, depth: a = true, stencil: s = false, alpha: r = false, antialias: o = false, premultipliedAlpha: l = true, preserveDrawingBuffer: c = false, powerPreference: f = "default", failIfMajorPerformanceCaveat: d = false, reverseDepthBuffer: h = false } = t;
          this.isWebGLRenderer = true;
          let p;
          if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            p = i.getContextAttributes().alpha;
          } else p = r;
          const y = new Uint32Array(4), S = new Int32Array(4);
          let m = null, u = null;
          const _ = [], g = [];
          this.domElement = n, this.debug = {
            checkShaderErrors: true,
            onShaderError: null
          }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Gn, this.toneMapping = Na, this.toneMappingExposure = 1;
          const v = this;
          let T = false, R = 0, w = 0, D = null, b = -1, x = null;
          const C = new Ce(), V = new Ce();
          let I = null;
          const X = new It(0);
          let Q = 0, L = n.width, W = n.height, B = 1, $ = null, it = null;
          const gt = new Ce(0, 0, L, W), Dt = new Ce(0, 0, L, W);
          let ne = false;
          const Y = new lm();
          let nt = false, _t = false;
          this.transmissionResolutionScale = 1;
          const ot = new ie(), Tt = new ie(), wt = new z(), Vt = new Ce(), xe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: true
          };
          let Zt = false;
          function De() {
            return D === null ? B : 1;
          }
          let U = i;
          function Nn(E, O) {
            return n.getContext(E, O);
          }
          try {
            const E = {
              alpha: true,
              depth: a,
              stencil: s,
              antialias: o,
              premultipliedAlpha: l,
              preserveDrawingBuffer: c,
              powerPreference: f,
              failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${Jp}`), n.addEventListener("webglcontextlost", K, false), n.addEventListener("webglcontextrestored", ut, false), n.addEventListener("webglcontextcreationerror", ct, false), U === null) {
              const O = "webgl2";
              if (U = Nn(O, E), U === null) throw Nn(O) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            }
          } catch (E) {
            throw console.error("THREE.WebGLRenderer: " + E.message), E;
          }
          let Wt, Yt, xt, _e, St, A, M, F, Z, J, q, yt, lt, ht, Kt, et, dt, bt, At, pt, qt, zt, de, N;
          function st() {
            Wt = new WR(U), Wt.init(), zt = new RC(U, Wt), Yt = new IR(U, Wt, t, zt), xt = new TC(U, Wt), Yt.reverseDepthBuffer && h && xt.buffers.depth.setReversed(true), _e = new jR(U), St = new hC(), A = new AC(U, Wt, xt, St, Yt, zt, _e), M = new GR(v), F = new XR(v), Z = new eA(U), de = new BR(U, Z), J = new YR(U, Z, _e, de), q = new KR(U, J, Z, _e), At = new ZR(U, Yt, A), et = new HR(St), yt = new fC(v, M, F, Wt, Yt, de, et), lt = new OC(v, St), ht = new pC(), Kt = new SC(Wt), bt = new zR(v, M, F, xt, q, p, l), dt = new EC(v, q, Yt), N = new PC(U, _e, Yt, xt), pt = new FR(U, Wt, _e), qt = new qR(U, Wt, _e), _e.programs = yt.programs, v.capabilities = Yt, v.extensions = Wt, v.properties = St, v.renderLists = ht, v.shadowMap = dt, v.state = xt, v.info = _e;
          }
          st();
          const k = new LC(v, U);
          this.xr = k, this.getContext = function() {
            return U;
          }, this.getContextAttributes = function() {
            return U.getContextAttributes();
          }, this.forceContextLoss = function() {
            const E = Wt.get("WEBGL_lose_context");
            E && E.loseContext();
          }, this.forceContextRestore = function() {
            const E = Wt.get("WEBGL_lose_context");
            E && E.restoreContext();
          }, this.getPixelRatio = function() {
            return B;
          }, this.setPixelRatio = function(E) {
            E !== void 0 && (B = E, this.setSize(L, W, false));
          }, this.getSize = function(E) {
            return E.set(L, W);
          }, this.setSize = function(E, O, H = true) {
            if (k.isPresenting) {
              console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
              return;
            }
            L = E, W = O, n.width = Math.floor(E * B), n.height = Math.floor(O * B), H === true && (n.style.width = E + "px", n.style.height = O + "px"), this.setViewport(0, 0, E, O);
          }, this.getDrawingBufferSize = function(E) {
            return E.set(L * B, W * B).floor();
          }, this.setDrawingBufferSize = function(E, O, H) {
            L = E, W = O, B = H, n.width = Math.floor(E * H), n.height = Math.floor(O * H), this.setViewport(0, 0, E, O);
          }, this.getCurrentViewport = function(E) {
            return E.copy(C);
          }, this.getViewport = function(E) {
            return E.copy(gt);
          }, this.setViewport = function(E, O, H, G) {
            E.isVector4 ? gt.set(E.x, E.y, E.z, E.w) : gt.set(E, O, H, G), xt.viewport(C.copy(gt).multiplyScalar(B).round());
          }, this.getScissor = function(E) {
            return E.copy(Dt);
          }, this.setScissor = function(E, O, H, G) {
            E.isVector4 ? Dt.set(E.x, E.y, E.z, E.w) : Dt.set(E, O, H, G), xt.scissor(V.copy(Dt).multiplyScalar(B).round());
          }, this.getScissorTest = function() {
            return ne;
          }, this.setScissorTest = function(E) {
            xt.setScissorTest(ne = E);
          }, this.setOpaqueSort = function(E) {
            $ = E;
          }, this.setTransparentSort = function(E) {
            it = E;
          }, this.getClearColor = function(E) {
            return E.copy(bt.getClearColor());
          }, this.setClearColor = function() {
            bt.setClearColor.apply(bt, arguments);
          }, this.getClearAlpha = function() {
            return bt.getClearAlpha();
          }, this.setClearAlpha = function() {
            bt.setClearAlpha.apply(bt, arguments);
          }, this.clear = function(E = true, O = true, H = true) {
            let G = 0;
            if (E) {
              let P = false;
              if (D !== null) {
                const tt = D.texture.format;
                P = tt === sm || tt === am || tt === im;
              }
              if (P) {
                const tt = D.texture.type, rt = tt === ea || tt === ys || tt === fl || tt === Gr || tt === tm || tt === em, ft = bt.getClearColor(), mt = bt.getClearAlpha(), Rt = ft.r, Ct = ft.g, Mt = ft.b;
                rt ? (y[0] = Rt, y[1] = Ct, y[2] = Mt, y[3] = mt, U.clearBufferuiv(U.COLOR, 0, y)) : (S[0] = Rt, S[1] = Ct, S[2] = Mt, S[3] = mt, U.clearBufferiv(U.COLOR, 0, S));
              } else G |= U.COLOR_BUFFER_BIT;
            }
            O && (G |= U.DEPTH_BUFFER_BIT), H && (G |= U.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), U.clear(G);
          }, this.clearColor = function() {
            this.clear(true, false, false);
          }, this.clearDepth = function() {
            this.clear(false, true, false);
          }, this.clearStencil = function() {
            this.clear(false, false, true);
          }, this.dispose = function() {
            n.removeEventListener("webglcontextlost", K, false), n.removeEventListener("webglcontextrestored", ut, false), n.removeEventListener("webglcontextcreationerror", ct, false), bt.dispose(), ht.dispose(), Kt.dispose(), St.dispose(), M.dispose(), F.dispose(), q.dispose(), de.dispose(), N.dispose(), yt.dispose(), k.dispose(), k.removeEventListener("sessionstart", hm), k.removeEventListener("sessionend", dm), Va.stop();
          };
          function K(E) {
            E.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = true;
          }
          function ut() {
            console.log("THREE.WebGLRenderer: Context Restored."), T = false;
            const E = _e.autoReset, O = dt.enabled, H = dt.autoUpdate, G = dt.needsUpdate, P = dt.type;
            st(), _e.autoReset = E, dt.enabled = O, dt.autoUpdate = H, dt.needsUpdate = G, dt.type = P;
          }
          function ct(E) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", E.statusMessage);
          }
          function Nt(E) {
            const O = E.target;
            O.removeEventListener("dispose", Nt), Te(O);
          }
          function Te(E) {
            en(E), St.remove(E);
          }
          function en(E) {
            const O = St.get(E).programs;
            O !== void 0 && (O.forEach(function(H) {
              yt.releaseProgram(H);
            }), E.isShaderMaterial && yt.releaseShaderCache(E));
          }
          this.renderBufferDirect = function(E, O, H, G, P, tt) {
            O === null && (O = xe);
            const rt = P.isMesh && P.matrixWorld.determinant() < 0, ft = IS(E, O, H, G, P);
            xt.setMaterial(G, rt);
            let mt = H.index, Rt = 1;
            if (G.wireframe === true) {
              if (mt = J.getWireframeAttribute(H), mt === void 0) return;
              Rt = 2;
            }
            const Ct = H.drawRange, Mt = H.attributes.position;
            let Qt = Ct.start * Rt, ae = (Ct.start + Ct.count) * Rt;
            tt !== null && (Qt = Math.max(Qt, tt.start * Rt), ae = Math.min(ae, (tt.start + tt.count) * Rt)), mt !== null ? (Qt = Math.max(Qt, 0), ae = Math.min(ae, mt.count)) : Mt != null && (Qt = Math.max(Qt, 0), ae = Math.min(ae, Mt.count));
            const Le = ae - Qt;
            if (Le < 0 || Le === 1 / 0) return;
            de.setup(P, G, ft, H, mt);
            let Ae, $t = pt;
            if (mt !== null && (Ae = Z.get(mt), $t = qt, $t.setIndex(Ae)), P.isMesh) G.wireframe === true ? (xt.setLineWidth(G.wireframeLinewidth * De()), $t.setMode(U.LINES)) : $t.setMode(U.TRIANGLES);
            else if (P.isLine) {
              let Et = G.linewidth;
              Et === void 0 && (Et = 1), xt.setLineWidth(Et * De()), P.isLineSegments ? $t.setMode(U.LINES) : P.isLineLoop ? $t.setMode(U.LINE_LOOP) : $t.setMode(U.LINE_STRIP);
            } else P.isPoints ? $t.setMode(U.POINTS) : P.isSprite && $t.setMode(U.TRIANGLES);
            if (P.isBatchedMesh) if (P._multiDrawInstances !== null) $t.renderMultiDrawInstances(P._multiDrawStarts, P._multiDrawCounts, P._multiDrawCount, P._multiDrawInstances);
            else if (Wt.get("WEBGL_multi_draw")) $t.renderMultiDraw(P._multiDrawStarts, P._multiDrawCounts, P._multiDrawCount);
            else {
              const Et = P._multiDrawStarts, Ke = P._multiDrawCounts, se = P._multiDrawCount, ni = mt ? Z.get(mt).bytesPerElement : 1, Ds = St.get(G).currentProgram.getUniforms();
              for (let xn = 0; xn < se; xn++) Ds.setValue(U, "_gl_DrawID", xn), $t.render(Et[xn] / ni, Ke[xn]);
            }
            else if (P.isInstancedMesh) $t.renderInstances(Qt, Le, P.count);
            else if (H.isInstancedBufferGeometry) {
              const Et = H._maxInstanceCount !== void 0 ? H._maxInstanceCount : 1 / 0, Ke = Math.min(H.instanceCount, Et);
              $t.renderInstances(Qt, Le, Ke);
            } else $t.render(Qt, Le);
          };
          function oe(E, O, H) {
            E.transparent === true && E.side === Gi && E.forceSinglePass === false ? (E.side = dn, E.needsUpdate = true, wl(E, O, H), E.side = Ia, E.needsUpdate = true, wl(E, O, H), E.side = Gi) : wl(E, O, H);
          }
          this.compile = function(E, O, H = null) {
            H === null && (H = E), u = Kt.get(H), u.init(O), g.push(u), H.traverseVisible(function(P) {
              P.isLight && P.layers.test(O.layers) && (u.pushLight(P), P.castShadow && u.pushShadow(P));
            }), E !== H && E.traverseVisible(function(P) {
              P.isLight && P.layers.test(O.layers) && (u.pushLight(P), P.castShadow && u.pushShadow(P));
            }), u.setupLights();
            const G = /* @__PURE__ */ new Set();
            return E.traverse(function(P) {
              if (!(P.isMesh || P.isPoints || P.isLine || P.isSprite)) return;
              const tt = P.material;
              if (tt) if (Array.isArray(tt)) for (let rt = 0; rt < tt.length; rt++) {
                const ft = tt[rt];
                oe(ft, H, P), G.add(ft);
              }
              else oe(tt, H, P), G.add(tt);
            }), g.pop(), u = null, G;
          }, this.compileAsync = function(E, O, H = null) {
            const G = this.compile(E, O, H);
            return new Promise((P) => {
              function tt() {
                if (G.forEach(function(rt) {
                  St.get(rt).currentProgram.isReady() && G.delete(rt);
                }), G.size === 0) {
                  P(E);
                  return;
                }
                setTimeout(tt, 10);
              }
              Wt.get("KHR_parallel_shader_compile") !== null ? tt() : setTimeout(tt, 10);
            });
          };
          let ei = null;
          function Ai(E) {
            ei && ei(E);
          }
          function hm() {
            Va.stop();
          }
          function dm() {
            Va.start();
          }
          const Va = new NS();
          Va.setAnimationLoop(Ai), typeof self < "u" && Va.setContext(self), this.setAnimationLoop = function(E) {
            ei = E, k.setAnimationLoop(E), E === null ? Va.stop() : Va.start();
          }, k.addEventListener("sessionstart", hm), k.addEventListener("sessionend", dm), this.render = function(E, O) {
            if (O !== void 0 && O.isCamera !== true) {
              console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
              return;
            }
            if (T === true) return;
            if (E.matrixWorldAutoUpdate === true && E.updateMatrixWorld(), O.parent === null && O.matrixWorldAutoUpdate === true && O.updateMatrixWorld(), k.enabled === true && k.isPresenting === true && (k.cameraAutoUpdate === true && k.updateCamera(O), O = k.getCamera()), E.isScene === true && E.onBeforeRender(v, E, O, D), u = Kt.get(E, g.length), u.init(O), g.push(u), Tt.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse), Y.setFromProjectionMatrix(Tt), _t = this.localClippingEnabled, nt = et.init(this.clippingPlanes, _t), m = ht.get(E, _.length), m.init(), _.push(m), k.enabled === true && k.isPresenting === true) {
              const tt = v.xr.getDepthSensingMesh();
              tt !== null && Yu(tt, O, -1 / 0, v.sortObjects);
            }
            Yu(E, O, 0, v.sortObjects), m.finish(), v.sortObjects === true && m.sort($, it), Zt = k.enabled === false || k.isPresenting === false || k.hasDepthSensing() === false, Zt && bt.addToRenderList(m, E), this.info.render.frame++, nt === true && et.beginShadows();
            const H = u.state.shadowsArray;
            dt.render(H, E, O), nt === true && et.endShadows(), this.info.autoReset === true && this.info.reset();
            const G = m.opaque, P = m.transmissive;
            if (u.setupLights(), O.isArrayCamera) {
              const tt = O.cameras;
              if (P.length > 0) for (let rt = 0, ft = tt.length; rt < ft; rt++) {
                const mt = tt[rt];
                mm(G, P, E, mt);
              }
              Zt && bt.render(E);
              for (let rt = 0, ft = tt.length; rt < ft; rt++) {
                const mt = tt[rt];
                pm(m, E, mt, mt.viewport);
              }
            } else P.length > 0 && mm(G, P, E, O), Zt && bt.render(E), pm(m, E, O);
            D !== null && w === 0 && (A.updateMultisampleRenderTarget(D), A.updateRenderTargetMipmap(D)), E.isScene === true && E.onAfterRender(v, E, O), de.resetDefaultState(), b = -1, x = null, g.pop(), g.length > 0 ? (u = g[g.length - 1], nt === true && et.setGlobalState(v.clippingPlanes, u.state.camera)) : u = null, _.pop(), _.length > 0 ? m = _[_.length - 1] : m = null;
          };
          function Yu(E, O, H, G) {
            if (E.visible === false) return;
            if (E.layers.test(O.layers)) {
              if (E.isGroup) H = E.renderOrder;
              else if (E.isLOD) E.autoUpdate === true && E.update(O);
              else if (E.isLight) u.pushLight(E), E.castShadow && u.pushShadow(E);
              else if (E.isSprite) {
                if (!E.frustumCulled || Y.intersectsSprite(E)) {
                  G && Vt.setFromMatrixPosition(E.matrixWorld).applyMatrix4(Tt);
                  const rt = q.update(E), ft = E.material;
                  ft.visible && m.push(E, rt, ft, H, Vt.z, null);
                }
              } else if ((E.isMesh || E.isLine || E.isPoints) && (!E.frustumCulled || Y.intersectsObject(E))) {
                const rt = q.update(E), ft = E.material;
                if (G && (E.boundingSphere !== void 0 ? (E.boundingSphere === null && E.computeBoundingSphere(), Vt.copy(E.boundingSphere.center)) : (rt.boundingSphere === null && rt.computeBoundingSphere(), Vt.copy(rt.boundingSphere.center)), Vt.applyMatrix4(E.matrixWorld).applyMatrix4(Tt)), Array.isArray(ft)) {
                  const mt = rt.groups;
                  for (let Rt = 0, Ct = mt.length; Rt < Ct; Rt++) {
                    const Mt = mt[Rt], Qt = ft[Mt.materialIndex];
                    Qt && Qt.visible && m.push(E, rt, Qt, H, Vt.z, Mt);
                  }
                } else ft.visible && m.push(E, rt, ft, H, Vt.z, null);
              }
            }
            const tt = E.children;
            for (let rt = 0, ft = tt.length; rt < ft; rt++) Yu(tt[rt], O, H, G);
          }
          function pm(E, O, H, G) {
            const P = E.opaque, tt = E.transmissive, rt = E.transparent;
            u.setupLightsView(H), nt === true && et.setGlobalState(v.clippingPlanes, H), G && xt.viewport(C.copy(G)), P.length > 0 && Rl(P, O, H), tt.length > 0 && Rl(tt, O, H), rt.length > 0 && Rl(rt, O, H), xt.buffers.depth.setTest(true), xt.buffers.depth.setMask(true), xt.buffers.color.setMask(true), xt.setPolygonOffset(false);
          }
          function mm(E, O, H, G) {
            if ((H.isScene === true ? H.overrideMaterial : null) !== null) return;
            u.state.transmissionRenderTarget[G.id] === void 0 && (u.state.transmissionRenderTarget[G.id] = new Ss(1, 1, {
              generateMipmaps: true,
              type: Wt.has("EXT_color_buffer_half_float") || Wt.has("EXT_color_buffer_float") ? Al : ea,
              minFilter: rs,
              samples: 4,
              stencilBuffer: s,
              resolveDepthBuffer: false,
              resolveStencilBuffer: false,
              colorSpace: te.workingColorSpace
            }));
            const tt = u.state.transmissionRenderTarget[G.id], rt = G.viewport || C;
            tt.setSize(rt.z * v.transmissionResolutionScale, rt.w * v.transmissionResolutionScale);
            const ft = v.getRenderTarget();
            v.setRenderTarget(tt), v.getClearColor(X), Q = v.getClearAlpha(), Q < 1 && v.setClearColor(16777215, 0.5), v.clear(), Zt && bt.render(H);
            const mt = v.toneMapping;
            v.toneMapping = Na;
            const Rt = G.viewport;
            if (G.viewport !== void 0 && (G.viewport = void 0), u.setupLightsView(G), nt === true && et.setGlobalState(v.clippingPlanes, G), Rl(E, H, G), A.updateMultisampleRenderTarget(tt), A.updateRenderTargetMipmap(tt), Wt.has("WEBGL_multisampled_render_to_texture") === false) {
              let Ct = false;
              for (let Mt = 0, Qt = O.length; Mt < Qt; Mt++) {
                const ae = O[Mt], Le = ae.object, Ae = ae.geometry, $t = ae.material, Et = ae.group;
                if ($t.side === Gi && Le.layers.test(G.layers)) {
                  const Ke = $t.side;
                  $t.side = dn, $t.needsUpdate = true, _m(Le, H, G, Ae, $t, Et), $t.side = Ke, $t.needsUpdate = true, Ct = true;
                }
              }
              Ct === true && (A.updateMultisampleRenderTarget(tt), A.updateRenderTargetMipmap(tt));
            }
            v.setRenderTarget(ft), v.setClearColor(X, Q), Rt !== void 0 && (G.viewport = Rt), v.toneMapping = mt;
          }
          function Rl(E, O, H) {
            const G = O.isScene === true ? O.overrideMaterial : null;
            for (let P = 0, tt = E.length; P < tt; P++) {
              const rt = E[P], ft = rt.object, mt = rt.geometry, Rt = G === null ? rt.material : G, Ct = rt.group;
              ft.layers.test(H.layers) && _m(ft, O, H, mt, Rt, Ct);
            }
          }
          function _m(E, O, H, G, P, tt) {
            E.onBeforeRender(v, O, H, G, P, tt), E.modelViewMatrix.multiplyMatrices(H.matrixWorldInverse, E.matrixWorld), E.normalMatrix.getNormalMatrix(E.modelViewMatrix), P.onBeforeRender(v, O, H, G, E, tt), P.transparent === true && P.side === Gi && P.forceSinglePass === false ? (P.side = dn, P.needsUpdate = true, v.renderBufferDirect(H, O, G, P, E, tt), P.side = Ia, P.needsUpdate = true, v.renderBufferDirect(H, O, G, P, E, tt), P.side = Gi) : v.renderBufferDirect(H, O, G, P, E, tt), E.onAfterRender(v, O, H, G, P, tt);
          }
          function wl(E, O, H) {
            O.isScene !== true && (O = xe);
            const G = St.get(E), P = u.state.lights, tt = u.state.shadowsArray, rt = P.state.version, ft = yt.getParameters(E, P.state, tt, O, H), mt = yt.getProgramCacheKey(ft);
            let Rt = G.programs;
            G.environment = E.isMeshStandardMaterial ? O.environment : null, G.fog = O.fog, G.envMap = (E.isMeshStandardMaterial ? F : M).get(E.envMap || G.environment), G.envMapRotation = G.environment !== null && E.envMap === null ? O.environmentRotation : E.envMapRotation, Rt === void 0 && (E.addEventListener("dispose", Nt), Rt = /* @__PURE__ */ new Map(), G.programs = Rt);
            let Ct = Rt.get(mt);
            if (Ct !== void 0) {
              if (G.currentProgram === Ct && G.lightsStateVersion === rt) return vm(E, ft), Ct;
            } else ft.uniforms = yt.getUniforms(E), E.onBeforeCompile(ft, v), Ct = yt.acquireProgram(ft, mt), Rt.set(mt, Ct), G.uniforms = ft.uniforms;
            const Mt = G.uniforms;
            return (!E.isShaderMaterial && !E.isRawShaderMaterial || E.clipping === true) && (Mt.clippingPlanes = et.uniform), vm(E, ft), G.needsLights = GS(E), G.lightsStateVersion = rt, G.needsLights && (Mt.ambientLightColor.value = P.state.ambient, Mt.lightProbe.value = P.state.probe, Mt.directionalLights.value = P.state.directional, Mt.directionalLightShadows.value = P.state.directionalShadow, Mt.spotLights.value = P.state.spot, Mt.spotLightShadows.value = P.state.spotShadow, Mt.rectAreaLights.value = P.state.rectArea, Mt.ltc_1.value = P.state.rectAreaLTC1, Mt.ltc_2.value = P.state.rectAreaLTC2, Mt.pointLights.value = P.state.point, Mt.pointLightShadows.value = P.state.pointShadow, Mt.hemisphereLights.value = P.state.hemi, Mt.directionalShadowMap.value = P.state.directionalShadowMap, Mt.directionalShadowMatrix.value = P.state.directionalShadowMatrix, Mt.spotShadowMap.value = P.state.spotShadowMap, Mt.spotLightMatrix.value = P.state.spotLightMatrix, Mt.spotLightMap.value = P.state.spotLightMap, Mt.pointShadowMap.value = P.state.pointShadowMap, Mt.pointShadowMatrix.value = P.state.pointShadowMatrix), G.currentProgram = Ct, G.uniformsList = null, Ct;
          }
          function gm(E) {
            if (E.uniformsList === null) {
              const O = E.currentProgram.getUniforms();
              E.uniformsList = Bc.seqWithValue(O.seq, E.uniforms);
            }
            return E.uniformsList;
          }
          function vm(E, O) {
            const H = St.get(E);
            H.outputColorSpace = O.outputColorSpace, H.batching = O.batching, H.batchingColor = O.batchingColor, H.instancing = O.instancing, H.instancingColor = O.instancingColor, H.instancingMorph = O.instancingMorph, H.skinning = O.skinning, H.morphTargets = O.morphTargets, H.morphNormals = O.morphNormals, H.morphColors = O.morphColors, H.morphTargetsCount = O.morphTargetsCount, H.numClippingPlanes = O.numClippingPlanes, H.numIntersection = O.numClipIntersection, H.vertexAlphas = O.vertexAlphas, H.vertexTangents = O.vertexTangents, H.toneMapping = O.toneMapping;
          }
          function IS(E, O, H, G, P) {
            O.isScene !== true && (O = xe), A.resetTextureUnits();
            const tt = O.fog, rt = G.isMeshStandardMaterial ? O.environment : null, ft = D === null ? v.outputColorSpace : D.isXRRenderTarget === true ? D.texture.colorSpace : kr, mt = (G.isMeshStandardMaterial ? F : M).get(G.envMap || rt), Rt = G.vertexColors === true && !!H.attributes.color && H.attributes.color.itemSize === 4, Ct = !!H.attributes.tangent && (!!G.normalMap || G.anisotropy > 0), Mt = !!H.morphAttributes.position, Qt = !!H.morphAttributes.normal, ae = !!H.morphAttributes.color;
            let Le = Na;
            G.toneMapped && (D === null || D.isXRRenderTarget === true) && (Le = v.toneMapping);
            const Ae = H.morphAttributes.position || H.morphAttributes.normal || H.morphAttributes.color, $t = Ae !== void 0 ? Ae.length : 0, Et = St.get(G), Ke = u.state.lights;
            if (nt === true && (_t === true || E !== x)) {
              const on = E === x && G.id === b;
              et.setState(G, E, on);
            }
            let se = false;
            G.version === Et.__version ? (Et.needsLights && Et.lightsStateVersion !== Ke.state.version || Et.outputColorSpace !== ft || P.isBatchedMesh && Et.batching === false || !P.isBatchedMesh && Et.batching === true || P.isBatchedMesh && Et.batchingColor === true && P.colorTexture === null || P.isBatchedMesh && Et.batchingColor === false && P.colorTexture !== null || P.isInstancedMesh && Et.instancing === false || !P.isInstancedMesh && Et.instancing === true || P.isSkinnedMesh && Et.skinning === false || !P.isSkinnedMesh && Et.skinning === true || P.isInstancedMesh && Et.instancingColor === true && P.instanceColor === null || P.isInstancedMesh && Et.instancingColor === false && P.instanceColor !== null || P.isInstancedMesh && Et.instancingMorph === true && P.morphTexture === null || P.isInstancedMesh && Et.instancingMorph === false && P.morphTexture !== null || Et.envMap !== mt || G.fog === true && Et.fog !== tt || Et.numClippingPlanes !== void 0 && (Et.numClippingPlanes !== et.numPlanes || Et.numIntersection !== et.numIntersection) || Et.vertexAlphas !== Rt || Et.vertexTangents !== Ct || Et.morphTargets !== Mt || Et.morphNormals !== Qt || Et.morphColors !== ae || Et.toneMapping !== Le || Et.morphTargetsCount !== $t) && (se = true) : (se = true, Et.__version = G.version);
            let ni = Et.currentProgram;
            se === true && (ni = wl(G, O, P));
            let Ds = false, xn = false, io = false;
            const ye = ni.getUniforms(), On = Et.uniforms;
            if (xt.useProgram(ni.program) && (Ds = true, xn = true, io = true), G.id !== b && (b = G.id, xn = true), Ds || x !== E) {
              xt.buffers.depth.getReversed() ? (ot.copy(E.projectionMatrix), d1(ot), p1(ot), ye.setValue(U, "projectionMatrix", ot)) : ye.setValue(U, "projectionMatrix", E.projectionMatrix), ye.setValue(U, "viewMatrix", E.matrixWorldInverse);
              const _n = ye.map.cameraPosition;
              _n !== void 0 && _n.setValue(U, wt.setFromMatrixPosition(E.matrixWorld)), Yt.logarithmicDepthBuffer && ye.setValue(U, "logDepthBufFC", 2 / (Math.log(E.far + 1) / Math.LN2)), (G.isMeshPhongMaterial || G.isMeshToonMaterial || G.isMeshLambertMaterial || G.isMeshBasicMaterial || G.isMeshStandardMaterial || G.isShaderMaterial) && ye.setValue(U, "isOrthographic", E.isOrthographicCamera === true), x !== E && (x = E, xn = true, io = true);
            }
            if (P.isSkinnedMesh) {
              ye.setOptional(U, P, "bindMatrix"), ye.setOptional(U, P, "bindMatrixInverse");
              const on = P.skeleton;
              on && (on.boneTexture === null && on.computeBoneTexture(), ye.setValue(U, "boneTexture", on.boneTexture, A));
            }
            P.isBatchedMesh && (ye.setOptional(U, P, "batchingTexture"), ye.setValue(U, "batchingTexture", P._matricesTexture, A), ye.setOptional(U, P, "batchingIdTexture"), ye.setValue(U, "batchingIdTexture", P._indirectTexture, A), ye.setOptional(U, P, "batchingColorTexture"), P._colorsTexture !== null && ye.setValue(U, "batchingColorTexture", P._colorsTexture, A));
            const Pn = H.morphAttributes;
            if ((Pn.position !== void 0 || Pn.normal !== void 0 || Pn.color !== void 0) && At.update(P, H, ni), (xn || Et.receiveShadow !== P.receiveShadow) && (Et.receiveShadow = P.receiveShadow, ye.setValue(U, "receiveShadow", P.receiveShadow)), G.isMeshGouraudMaterial && G.envMap !== null && (On.envMap.value = mt, On.flipEnvMap.value = mt.isCubeTexture && mt.isRenderTargetTexture === false ? -1 : 1), G.isMeshStandardMaterial && G.envMap === null && O.environment !== null && (On.envMapIntensity.value = O.environmentIntensity), xn && (ye.setValue(U, "toneMappingExposure", v.toneMappingExposure), Et.needsLights && HS(On, io), tt && G.fog === true && lt.refreshFogUniforms(On, tt), lt.refreshMaterialUniforms(On, G, B, W, u.state.transmissionRenderTarget[E.id]), Bc.upload(U, gm(Et), On, A)), G.isShaderMaterial && G.uniformsNeedUpdate === true && (Bc.upload(U, gm(Et), On, A), G.uniformsNeedUpdate = false), G.isSpriteMaterial && ye.setValue(U, "center", P.center), ye.setValue(U, "modelViewMatrix", P.modelViewMatrix), ye.setValue(U, "normalMatrix", P.normalMatrix), ye.setValue(U, "modelMatrix", P.matrixWorld), G.isShaderMaterial || G.isRawShaderMaterial) {
              const on = G.uniformsGroups;
              for (let _n = 0, qu = on.length; _n < qu; _n++) {
                const ka = on[_n];
                N.update(ka, ni), N.bind(ka, ni);
              }
            }
            return ni;
          }
          function HS(E, O) {
            E.ambientLightColor.needsUpdate = O, E.lightProbe.needsUpdate = O, E.directionalLights.needsUpdate = O, E.directionalLightShadows.needsUpdate = O, E.pointLights.needsUpdate = O, E.pointLightShadows.needsUpdate = O, E.spotLights.needsUpdate = O, E.spotLightShadows.needsUpdate = O, E.rectAreaLights.needsUpdate = O, E.hemisphereLights.needsUpdate = O;
          }
          function GS(E) {
            return E.isMeshLambertMaterial || E.isMeshToonMaterial || E.isMeshPhongMaterial || E.isMeshStandardMaterial || E.isShadowMaterial || E.isShaderMaterial && E.lights === true;
          }
          this.getActiveCubeFace = function() {
            return R;
          }, this.getActiveMipmapLevel = function() {
            return w;
          }, this.getRenderTarget = function() {
            return D;
          }, this.setRenderTargetTextures = function(E, O, H) {
            St.get(E.texture).__webglTexture = O, St.get(E.depthTexture).__webglTexture = H;
            const G = St.get(E);
            G.__hasExternalTextures = true, G.__autoAllocateDepthBuffer = H === void 0, G.__autoAllocateDepthBuffer || Wt.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), G.__useRenderToTexture = false);
          }, this.setRenderTargetFramebuffer = function(E, O) {
            const H = St.get(E);
            H.__webglFramebuffer = O, H.__useDefaultFramebuffer = O === void 0;
          };
          const VS = U.createFramebuffer();
          this.setRenderTarget = function(E, O = 0, H = 0) {
            D = E, R = O, w = H;
            let G = true, P = null, tt = false, rt = false;
            if (E) {
              const mt = St.get(E);
              if (mt.__useDefaultFramebuffer !== void 0) xt.bindFramebuffer(U.FRAMEBUFFER, null), G = false;
              else if (mt.__webglFramebuffer === void 0) A.setupRenderTarget(E);
              else if (mt.__hasExternalTextures) A.rebindTextures(E, St.get(E.texture).__webglTexture, St.get(E.depthTexture).__webglTexture);
              else if (E.depthBuffer) {
                const Mt = E.depthTexture;
                if (mt.__boundDepthTexture !== Mt) {
                  if (Mt !== null && St.has(Mt) && (E.width !== Mt.image.width || E.height !== Mt.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                  A.setupDepthRenderbuffer(E);
                }
              }
              const Rt = E.texture;
              (Rt.isData3DTexture || Rt.isDataArrayTexture || Rt.isCompressedArrayTexture) && (rt = true);
              const Ct = St.get(E).__webglFramebuffer;
              E.isWebGLCubeRenderTarget ? (Array.isArray(Ct[O]) ? P = Ct[O][H] : P = Ct[O], tt = true) : E.samples > 0 && A.useMultisampledRTT(E) === false ? P = St.get(E).__webglMultisampledFramebuffer : Array.isArray(Ct) ? P = Ct[H] : P = Ct, C.copy(E.viewport), V.copy(E.scissor), I = E.scissorTest;
            } else C.copy(gt).multiplyScalar(B).floor(), V.copy(Dt).multiplyScalar(B).floor(), I = ne;
            if (H !== 0 && (P = VS), xt.bindFramebuffer(U.FRAMEBUFFER, P) && G && xt.drawBuffers(E, P), xt.viewport(C), xt.scissor(V), xt.setScissorTest(I), tt) {
              const mt = St.get(E.texture);
              U.framebufferTexture2D(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_CUBE_MAP_POSITIVE_X + O, mt.__webglTexture, H);
            } else if (rt) {
              const mt = St.get(E.texture), Rt = O;
              U.framebufferTextureLayer(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, mt.__webglTexture, H, Rt);
            } else if (E !== null && H !== 0) {
              const mt = St.get(E.texture);
              U.framebufferTexture2D(U.FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_2D, mt.__webglTexture, H);
            }
            b = -1;
          }, this.readRenderTargetPixels = function(E, O, H, G, P, tt, rt) {
            if (!(E && E.isWebGLRenderTarget)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              return;
            }
            let ft = St.get(E).__webglFramebuffer;
            if (E.isWebGLCubeRenderTarget && rt !== void 0 && (ft = ft[rt]), ft) {
              xt.bindFramebuffer(U.FRAMEBUFFER, ft);
              try {
                const mt = E.texture, Rt = mt.format, Ct = mt.type;
                if (!Yt.textureFormatReadable(Rt)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  return;
                }
                if (!Yt.textureTypeReadable(Ct)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  return;
                }
                O >= 0 && O <= E.width - G && H >= 0 && H <= E.height - P && U.readPixels(O, H, G, P, zt.convert(Rt), zt.convert(Ct), tt);
              } finally {
                const mt = D !== null ? St.get(D).__webglFramebuffer : null;
                xt.bindFramebuffer(U.FRAMEBUFFER, mt);
              }
            }
          }, this.readRenderTargetPixelsAsync = async function(E, O, H, G, P, tt, rt) {
            if (!(E && E.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let ft = St.get(E).__webglFramebuffer;
            if (E.isWebGLCubeRenderTarget && rt !== void 0 && (ft = ft[rt]), ft) {
              const mt = E.texture, Rt = mt.format, Ct = mt.type;
              if (!Yt.textureFormatReadable(Rt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
              if (!Yt.textureTypeReadable(Ct)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
              if (O >= 0 && O <= E.width - G && H >= 0 && H <= E.height - P) {
                xt.bindFramebuffer(U.FRAMEBUFFER, ft);
                const Mt = U.createBuffer();
                U.bindBuffer(U.PIXEL_PACK_BUFFER, Mt), U.bufferData(U.PIXEL_PACK_BUFFER, tt.byteLength, U.STREAM_READ), U.readPixels(O, H, G, P, zt.convert(Rt), zt.convert(Ct), 0);
                const Qt = D !== null ? St.get(D).__webglFramebuffer : null;
                xt.bindFramebuffer(U.FRAMEBUFFER, Qt);
                const ae = U.fenceSync(U.SYNC_GPU_COMMANDS_COMPLETE, 0);
                return U.flush(), await h1(U, ae, 4), U.bindBuffer(U.PIXEL_PACK_BUFFER, Mt), U.getBufferSubData(U.PIXEL_PACK_BUFFER, 0, tt), U.deleteBuffer(Mt), U.deleteSync(ae), tt;
              } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
            }
          }, this.copyFramebufferToTexture = function(E, O = null, H = 0) {
            E.isTexture !== true && (tr("WebGLRenderer: copyFramebufferToTexture function signature has changed."), O = arguments[0] || null, E = arguments[1]);
            const G = Math.pow(2, -H), P = Math.floor(E.image.width * G), tt = Math.floor(E.image.height * G), rt = O !== null ? O.x : 0, ft = O !== null ? O.y : 0;
            A.setTexture2D(E, 0), U.copyTexSubImage2D(U.TEXTURE_2D, H, 0, 0, rt, ft, P, tt), xt.unbindTexture();
          };
          const kS = U.createFramebuffer(), XS = U.createFramebuffer();
          this.copyTextureToTexture = function(E, O, H = null, G = null, P = 0, tt = null) {
            E.isTexture !== true && (tr("WebGLRenderer: copyTextureToTexture function signature has changed."), G = arguments[0] || null, E = arguments[1], O = arguments[2], tt = arguments[3] || 0, H = null), tt === null && (P !== 0 ? (tr("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), tt = P, P = 0) : tt = 0);
            let rt, ft, mt, Rt, Ct, Mt, Qt, ae, Le;
            const Ae = E.isCompressedTexture ? E.mipmaps[tt] : E.image;
            if (H !== null) rt = H.max.x - H.min.x, ft = H.max.y - H.min.y, mt = H.isBox3 ? H.max.z - H.min.z : 1, Rt = H.min.x, Ct = H.min.y, Mt = H.isBox3 ? H.min.z : 0;
            else {
              const Pn = Math.pow(2, -P);
              rt = Math.floor(Ae.width * Pn), ft = Math.floor(Ae.height * Pn), E.isDataArrayTexture ? mt = Ae.depth : E.isData3DTexture ? mt = Math.floor(Ae.depth * Pn) : mt = 1, Rt = 0, Ct = 0, Mt = 0;
            }
            G !== null ? (Qt = G.x, ae = G.y, Le = G.z) : (Qt = 0, ae = 0, Le = 0);
            const $t = zt.convert(O.format), Et = zt.convert(O.type);
            let Ke;
            O.isData3DTexture ? (A.setTexture3D(O, 0), Ke = U.TEXTURE_3D) : O.isDataArrayTexture || O.isCompressedArrayTexture ? (A.setTexture2DArray(O, 0), Ke = U.TEXTURE_2D_ARRAY) : (A.setTexture2D(O, 0), Ke = U.TEXTURE_2D), U.pixelStorei(U.UNPACK_FLIP_Y_WEBGL, O.flipY), U.pixelStorei(U.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), U.pixelStorei(U.UNPACK_ALIGNMENT, O.unpackAlignment);
            const se = U.getParameter(U.UNPACK_ROW_LENGTH), ni = U.getParameter(U.UNPACK_IMAGE_HEIGHT), Ds = U.getParameter(U.UNPACK_SKIP_PIXELS), xn = U.getParameter(U.UNPACK_SKIP_ROWS), io = U.getParameter(U.UNPACK_SKIP_IMAGES);
            U.pixelStorei(U.UNPACK_ROW_LENGTH, Ae.width), U.pixelStorei(U.UNPACK_IMAGE_HEIGHT, Ae.height), U.pixelStorei(U.UNPACK_SKIP_PIXELS, Rt), U.pixelStorei(U.UNPACK_SKIP_ROWS, Ct), U.pixelStorei(U.UNPACK_SKIP_IMAGES, Mt);
            const ye = E.isDataArrayTexture || E.isData3DTexture, On = O.isDataArrayTexture || O.isData3DTexture;
            if (E.isDepthTexture) {
              const Pn = St.get(E), on = St.get(O), _n = St.get(Pn.__renderTarget), qu = St.get(on.__renderTarget);
              xt.bindFramebuffer(U.READ_FRAMEBUFFER, _n.__webglFramebuffer), xt.bindFramebuffer(U.DRAW_FRAMEBUFFER, qu.__webglFramebuffer);
              for (let ka = 0; ka < mt; ka++) ye && (U.framebufferTextureLayer(U.READ_FRAMEBUFFER, U.COLOR_ATTACHMENT0, St.get(E).__webglTexture, P, Mt + ka), U.framebufferTextureLayer(U.DRAW_FRAMEBUFFER, U.COLOR_ATTACHMENT0, St.get(O).__webglTexture, tt, Le + ka)), U.blitFramebuffer(Rt, Ct, rt, ft, Qt, ae, rt, ft, U.DEPTH_BUFFER_BIT, U.NEAREST);
              xt.bindFramebuffer(U.READ_FRAMEBUFFER, null), xt.bindFramebuffer(U.DRAW_FRAMEBUFFER, null);
            } else if (P !== 0 || E.isRenderTargetTexture || St.has(E)) {
              const Pn = St.get(E), on = St.get(O);
              xt.bindFramebuffer(U.READ_FRAMEBUFFER, kS), xt.bindFramebuffer(U.DRAW_FRAMEBUFFER, XS);
              for (let _n = 0; _n < mt; _n++) ye ? U.framebufferTextureLayer(U.READ_FRAMEBUFFER, U.COLOR_ATTACHMENT0, Pn.__webglTexture, P, Mt + _n) : U.framebufferTexture2D(U.READ_FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_2D, Pn.__webglTexture, P), On ? U.framebufferTextureLayer(U.DRAW_FRAMEBUFFER, U.COLOR_ATTACHMENT0, on.__webglTexture, tt, Le + _n) : U.framebufferTexture2D(U.DRAW_FRAMEBUFFER, U.COLOR_ATTACHMENT0, U.TEXTURE_2D, on.__webglTexture, tt), P !== 0 ? U.blitFramebuffer(Rt, Ct, rt, ft, Qt, ae, rt, ft, U.COLOR_BUFFER_BIT, U.NEAREST) : On ? U.copyTexSubImage3D(Ke, tt, Qt, ae, Le + _n, Rt, Ct, rt, ft) : U.copyTexSubImage2D(Ke, tt, Qt, ae, Rt, Ct, rt, ft);
              xt.bindFramebuffer(U.READ_FRAMEBUFFER, null), xt.bindFramebuffer(U.DRAW_FRAMEBUFFER, null);
            } else On ? E.isDataTexture || E.isData3DTexture ? U.texSubImage3D(Ke, tt, Qt, ae, Le, rt, ft, mt, $t, Et, Ae.data) : O.isCompressedArrayTexture ? U.compressedTexSubImage3D(Ke, tt, Qt, ae, Le, rt, ft, mt, $t, Ae.data) : U.texSubImage3D(Ke, tt, Qt, ae, Le, rt, ft, mt, $t, Et, Ae) : E.isDataTexture ? U.texSubImage2D(U.TEXTURE_2D, tt, Qt, ae, rt, ft, $t, Et, Ae.data) : E.isCompressedTexture ? U.compressedTexSubImage2D(U.TEXTURE_2D, tt, Qt, ae, Ae.width, Ae.height, $t, Ae.data) : U.texSubImage2D(U.TEXTURE_2D, tt, Qt, ae, rt, ft, $t, Et, Ae);
            U.pixelStorei(U.UNPACK_ROW_LENGTH, se), U.pixelStorei(U.UNPACK_IMAGE_HEIGHT, ni), U.pixelStorei(U.UNPACK_SKIP_PIXELS, Ds), U.pixelStorei(U.UNPACK_SKIP_ROWS, xn), U.pixelStorei(U.UNPACK_SKIP_IMAGES, io), tt === 0 && O.generateMipmaps && U.generateMipmap(Ke), xt.unbindTexture();
          }, this.copyTextureToTexture3D = function(E, O, H = null, G = null, P = 0) {
            return E.isTexture !== true && (tr("WebGLRenderer: copyTextureToTexture3D function signature has changed."), H = arguments[0] || null, G = arguments[1] || null, E = arguments[2], O = arguments[3], P = arguments[4] || 0), tr('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(E, O, H, G, P);
          }, this.initRenderTarget = function(E) {
            St.get(E).__webglFramebuffer === void 0 && A.setupRenderTarget(E);
          }, this.initTexture = function(E) {
            E.isCubeTexture ? A.setTextureCube(E, 0) : E.isData3DTexture ? A.setTexture3D(E, 0) : E.isDataArrayTexture || E.isCompressedArrayTexture ? A.setTexture2DArray(E, 0) : A.setTexture2D(E, 0), xt.unbindTexture();
          }, this.resetState = function() {
            R = 0, w = 0, D = null, xt.reset(), de.reset();
          }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        get coordinateSystem() {
          return qi;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(t) {
          this._outputColorSpace = t;
          const n = this.getContext();
          n.drawingBufferColorspace = te._getDrawingBufferColorSpace(t), n.unpackColorSpace = te._getUnpackColorSpace();
        }
      }
      const e0 = {
        type: "change"
      }, fm = {
        type: "start"
      }, FS = {
        type: "end"
      }, gc = new Vu(), n0 = new _a(), BC = Math.cos(70 * u1.DEG2RAD), Be = new z(), gn = 2 * Math.PI, fe = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      }, lh = 1e-6;
      class FC extends $1 {
        constructor(t, n = null) {
          super(t, n), this.state = fe.NONE, this.enabled = true, this.target = new z(), this.cursor = new z(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.zoomToCursor = false, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
          }, this.mouseButtons = {
            LEFT: Er.ROTATE,
            MIDDLE: Er.DOLLY,
            RIGHT: Er.PAN
          }, this.touches = {
            ONE: dr.ROTATE,
            TWO: dr.DOLLY_PAN
          }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new z(), this._lastQuaternion = new xs(), this._lastTargetPosition = new z(), this._quat = new xs().setFromUnitVectors(t.up, new z(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new Cg(), this._sphericalDelta = new Cg(), this._scale = 1, this._panOffset = new z(), this._rotateStart = new Ut(), this._rotateEnd = new Ut(), this._rotateDelta = new Ut(), this._panStart = new Ut(), this._panEnd = new Ut(), this._panDelta = new Ut(), this._dollyStart = new Ut(), this._dollyEnd = new Ut(), this._dollyDelta = new Ut(), this._dollyDirection = new z(), this._mouse = new Ut(), this._performCursorZoom = false, this._pointers = [], this._pointerPositions = {}, this._controlActive = false, this._onPointerMove = HC.bind(this), this._onPointerDown = IC.bind(this), this._onPointerUp = GC.bind(this), this._onContextMenu = jC.bind(this), this._onMouseWheel = XC.bind(this), this._onKeyDown = WC.bind(this), this._onTouchStart = YC.bind(this), this._onTouchMove = qC.bind(this), this._onMouseDown = VC.bind(this), this._onMouseMove = kC.bind(this), this._interceptControlDown = ZC.bind(this), this._interceptControlUp = KC.bind(this), this.domElement !== null && this.connect(), this.update();
        }
        connect() {
          this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, {
            passive: false
          }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
            passive: true,
            capture: true
          }), this.domElement.style.touchAction = "none";
        }
        disconnect() {
          this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
            capture: true
          }), this.domElement.style.touchAction = "auto";
        }
        dispose() {
          this.disconnect();
        }
        getPolarAngle() {
          return this._spherical.phi;
        }
        getAzimuthalAngle() {
          return this._spherical.theta;
        }
        getDistance() {
          return this.object.position.distanceTo(this.target);
        }
        listenToKeyEvents(t) {
          t.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = t;
        }
        stopListenToKeyEvents() {
          this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
        }
        saveState() {
          this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
        }
        reset() {
          this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(e0), this.update(), this.state = fe.NONE;
        }
        update(t = null) {
          const n = this.object.position;
          Be.copy(n).sub(this.target), Be.applyQuaternion(this._quat), this._spherical.setFromVector3(Be), this.autoRotate && this.state === fe.NONE && this._rotateLeft(this._getAutoRotationAngle(t)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
          let i = this.minAzimuthAngle, a = this.maxAzimuthAngle;
          isFinite(i) && isFinite(a) && (i < -Math.PI ? i += gn : i > Math.PI && (i -= gn), a < -Math.PI ? a += gn : a > Math.PI && (a -= gn), i <= a ? this._spherical.theta = Math.max(i, Math.min(a, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (i + a) / 2 ? Math.max(i, this._spherical.theta) : Math.min(a, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === true ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
          let s = false;
          if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) this._spherical.radius = this._clampDistance(this._spherical.radius);
          else {
            const r = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), s = r != this._spherical.radius;
          }
          if (Be.setFromSpherical(this._spherical), Be.applyQuaternion(this._quatInverse), n.copy(this.target).add(Be), this.object.lookAt(this.target), this.enableDamping === true ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
            let r = null;
            if (this.object.isPerspectiveCamera) {
              const o = Be.length();
              r = this._clampDistance(o * this._scale);
              const l = o - r;
              this.object.position.addScaledVector(this._dollyDirection, l), this.object.updateMatrixWorld(), s = !!l;
            } else if (this.object.isOrthographicCamera) {
              const o = new z(this._mouse.x, this._mouse.y, 0);
              o.unproject(this.object);
              const l = this.object.zoom;
              this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), s = l !== this.object.zoom;
              const c = new z(this._mouse.x, this._mouse.y, 0);
              c.unproject(this.object), this.object.position.sub(c).add(o), this.object.updateMatrixWorld(), r = Be.length();
            } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = false;
            r !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(r).add(this.object.position) : (gc.origin.copy(this.object.position), gc.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(gc.direction)) < BC ? this.object.lookAt(this.target) : (n0.setFromNormalAndCoplanarPoint(this.object.up, this.target), gc.intersectPlane(n0, this.target))));
          } else if (this.object.isOrthographicCamera) {
            const r = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), r !== this.object.zoom && (this.object.updateProjectionMatrix(), s = true);
          }
          return this._scale = 1, this._performCursorZoom = false, s || this._lastPosition.distanceToSquared(this.object.position) > lh || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > lh || this._lastTargetPosition.distanceToSquared(this.target) > lh ? (this.dispatchEvent(e0), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), true) : false;
        }
        _getAutoRotationAngle(t) {
          return t !== null ? gn / 60 * this.autoRotateSpeed * t : gn / 60 / 60 * this.autoRotateSpeed;
        }
        _getZoomScale(t) {
          const n = Math.abs(t * 0.01);
          return Math.pow(0.95, this.zoomSpeed * n);
        }
        _rotateLeft(t) {
          this._sphericalDelta.theta -= t;
        }
        _rotateUp(t) {
          this._sphericalDelta.phi -= t;
        }
        _panLeft(t, n) {
          Be.setFromMatrixColumn(n, 0), Be.multiplyScalar(-t), this._panOffset.add(Be);
        }
        _panUp(t, n) {
          this.screenSpacePanning === true ? Be.setFromMatrixColumn(n, 1) : (Be.setFromMatrixColumn(n, 0), Be.crossVectors(this.object.up, Be)), Be.multiplyScalar(t), this._panOffset.add(Be);
        }
        _pan(t, n) {
          const i = this.domElement;
          if (this.object.isPerspectiveCamera) {
            const a = this.object.position;
            Be.copy(a).sub(this.target);
            let s = Be.length();
            s *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * t * s / i.clientHeight, this.object.matrix), this._panUp(2 * n * s / i.clientHeight, this.object.matrix);
          } else this.object.isOrthographicCamera ? (this._panLeft(t * (this.object.right - this.object.left) / this.object.zoom / i.clientWidth, this.object.matrix), this._panUp(n * (this.object.top - this.object.bottom) / this.object.zoom / i.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = false);
        }
        _dollyOut(t) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _dollyIn(t) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _updateZoomParameters(t, n) {
          if (!this.zoomToCursor) return;
          this._performCursorZoom = true;
          const i = this.domElement.getBoundingClientRect(), a = t - i.left, s = n - i.top, r = i.width, o = i.height;
          this._mouse.x = a / r * 2 - 1, this._mouse.y = -(s / o) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
        }
        _clampDistance(t) {
          return Math.max(this.minDistance, Math.min(this.maxDistance, t));
        }
        _handleMouseDownRotate(t) {
          this._rotateStart.set(t.clientX, t.clientY);
        }
        _handleMouseDownDolly(t) {
          this._updateZoomParameters(t.clientX, t.clientX), this._dollyStart.set(t.clientX, t.clientY);
        }
        _handleMouseDownPan(t) {
          this._panStart.set(t.clientX, t.clientY);
        }
        _handleMouseMoveRotate(t) {
          this._rotateEnd.set(t.clientX, t.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const n = this.domElement;
          this._rotateLeft(gn * this._rotateDelta.x / n.clientHeight), this._rotateUp(gn * this._rotateDelta.y / n.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
        }
        _handleMouseMoveDolly(t) {
          this._dollyEnd.set(t.clientX, t.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
        }
        _handleMouseMovePan(t) {
          this._panEnd.set(t.clientX, t.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
        }
        _handleMouseWheel(t) {
          this._updateZoomParameters(t.clientX, t.clientY), t.deltaY < 0 ? this._dollyIn(this._getZoomScale(t.deltaY)) : t.deltaY > 0 && this._dollyOut(this._getZoomScale(t.deltaY)), this.update();
        }
        _handleKeyDown(t) {
          let n = false;
          switch (t.code) {
            case this.keys.UP:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateUp(gn * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), n = true;
              break;
            case this.keys.BOTTOM:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateUp(-gn * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), n = true;
              break;
            case this.keys.LEFT:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateLeft(gn * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), n = true;
              break;
            case this.keys.RIGHT:
              t.ctrlKey || t.metaKey || t.shiftKey ? this.enableRotate && this._rotateLeft(-gn * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), n = true;
              break;
          }
          n && (t.preventDefault(), this.update());
        }
        _handleTouchStartRotate(t) {
          if (this._pointers.length === 1) this._rotateStart.set(t.pageX, t.pageY);
          else {
            const n = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + n.x), a = 0.5 * (t.pageY + n.y);
            this._rotateStart.set(i, a);
          }
        }
        _handleTouchStartPan(t) {
          if (this._pointers.length === 1) this._panStart.set(t.pageX, t.pageY);
          else {
            const n = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + n.x), a = 0.5 * (t.pageY + n.y);
            this._panStart.set(i, a);
          }
        }
        _handleTouchStartDolly(t) {
          const n = this._getSecondPointerPosition(t), i = t.pageX - n.x, a = t.pageY - n.y, s = Math.sqrt(i * i + a * a);
          this._dollyStart.set(0, s);
        }
        _handleTouchStartDollyPan(t) {
          this.enableZoom && this._handleTouchStartDolly(t), this.enablePan && this._handleTouchStartPan(t);
        }
        _handleTouchStartDollyRotate(t) {
          this.enableZoom && this._handleTouchStartDolly(t), this.enableRotate && this._handleTouchStartRotate(t);
        }
        _handleTouchMoveRotate(t) {
          if (this._pointers.length == 1) this._rotateEnd.set(t.pageX, t.pageY);
          else {
            const i = this._getSecondPointerPosition(t), a = 0.5 * (t.pageX + i.x), s = 0.5 * (t.pageY + i.y);
            this._rotateEnd.set(a, s);
          }
          this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const n = this.domElement;
          this._rotateLeft(gn * this._rotateDelta.x / n.clientHeight), this._rotateUp(gn * this._rotateDelta.y / n.clientHeight), this._rotateStart.copy(this._rotateEnd);
        }
        _handleTouchMovePan(t) {
          if (this._pointers.length === 1) this._panEnd.set(t.pageX, t.pageY);
          else {
            const n = this._getSecondPointerPosition(t), i = 0.5 * (t.pageX + n.x), a = 0.5 * (t.pageY + n.y);
            this._panEnd.set(i, a);
          }
          this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
        }
        _handleTouchMoveDolly(t) {
          const n = this._getSecondPointerPosition(t), i = t.pageX - n.x, a = t.pageY - n.y, s = Math.sqrt(i * i + a * a);
          this._dollyEnd.set(0, s), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
          const r = (t.pageX + n.x) * 0.5, o = (t.pageY + n.y) * 0.5;
          this._updateZoomParameters(r, o);
        }
        _handleTouchMoveDollyPan(t) {
          this.enableZoom && this._handleTouchMoveDolly(t), this.enablePan && this._handleTouchMovePan(t);
        }
        _handleTouchMoveDollyRotate(t) {
          this.enableZoom && this._handleTouchMoveDolly(t), this.enableRotate && this._handleTouchMoveRotate(t);
        }
        _addPointer(t) {
          this._pointers.push(t.pointerId);
        }
        _removePointer(t) {
          delete this._pointerPositions[t.pointerId];
          for (let n = 0; n < this._pointers.length; n++) if (this._pointers[n] == t.pointerId) {
            this._pointers.splice(n, 1);
            return;
          }
        }
        _isTrackingPointer(t) {
          for (let n = 0; n < this._pointers.length; n++) if (this._pointers[n] == t.pointerId) return true;
          return false;
        }
        _trackPointer(t) {
          let n = this._pointerPositions[t.pointerId];
          n === void 0 && (n = new Ut(), this._pointerPositions[t.pointerId] = n), n.set(t.pageX, t.pageY);
        }
        _getSecondPointerPosition(t) {
          const n = t.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
          return this._pointerPositions[n];
        }
        _customWheelEvent(t) {
          const n = t.deltaMode, i = {
            clientX: t.clientX,
            clientY: t.clientY,
            deltaY: t.deltaY
          };
          switch (n) {
            case 1:
              i.deltaY *= 16;
              break;
            case 2:
              i.deltaY *= 100;
              break;
          }
          return t.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
        }
      }
      function IC(e) {
        this.enabled !== false && (this._pointers.length === 0 && (this.domElement.setPointerCapture(e.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(e) && (this._addPointer(e), e.pointerType === "touch" ? this._onTouchStart(e) : this._onMouseDown(e)));
      }
      function HC(e) {
        this.enabled !== false && (e.pointerType === "touch" ? this._onTouchMove(e) : this._onMouseMove(e));
      }
      function GC(e) {
        switch (this._removePointer(e), this._pointers.length) {
          case 0:
            this.domElement.releasePointerCapture(e.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(FS), this.state = fe.NONE;
            break;
          case 1:
            const t = this._pointers[0], n = this._pointerPositions[t];
            this._onTouchStart({
              pointerId: t,
              pageX: n.x,
              pageY: n.y
            });
            break;
        }
      }
      function VC(e) {
        let t;
        switch (e.button) {
          case 0:
            t = this.mouseButtons.LEFT;
            break;
          case 1:
            t = this.mouseButtons.MIDDLE;
            break;
          case 2:
            t = this.mouseButtons.RIGHT;
            break;
          default:
            t = -1;
        }
        switch (t) {
          case Er.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseDownDolly(e), this.state = fe.DOLLY;
            break;
          case Er.ROTATE:
            if (e.ctrlKey || e.metaKey || e.shiftKey) {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(e), this.state = fe.PAN;
            } else {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(e), this.state = fe.ROTATE;
            }
            break;
          case Er.PAN:
            if (e.ctrlKey || e.metaKey || e.shiftKey) {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(e), this.state = fe.ROTATE;
            } else {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(e), this.state = fe.PAN;
            }
            break;
          default:
            this.state = fe.NONE;
        }
        this.state !== fe.NONE && this.dispatchEvent(fm);
      }
      function kC(e) {
        switch (this.state) {
          case fe.ROTATE:
            if (this.enableRotate === false) return;
            this._handleMouseMoveRotate(e);
            break;
          case fe.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseMoveDolly(e);
            break;
          case fe.PAN:
            if (this.enablePan === false) return;
            this._handleMouseMovePan(e);
            break;
        }
      }
      function XC(e) {
        this.enabled === false || this.enableZoom === false || this.state !== fe.NONE || (e.preventDefault(), this.dispatchEvent(fm), this._handleMouseWheel(this._customWheelEvent(e)), this.dispatchEvent(FS));
      }
      function WC(e) {
        this.enabled !== false && this._handleKeyDown(e);
      }
      function YC(e) {
        switch (this._trackPointer(e), this._pointers.length) {
          case 1:
            switch (this.touches.ONE) {
              case dr.ROTATE:
                if (this.enableRotate === false) return;
                this._handleTouchStartRotate(e), this.state = fe.TOUCH_ROTATE;
                break;
              case dr.PAN:
                if (this.enablePan === false) return;
                this._handleTouchStartPan(e), this.state = fe.TOUCH_PAN;
                break;
              default:
                this.state = fe.NONE;
            }
            break;
          case 2:
            switch (this.touches.TWO) {
              case dr.DOLLY_PAN:
                if (this.enableZoom === false && this.enablePan === false) return;
                this._handleTouchStartDollyPan(e), this.state = fe.TOUCH_DOLLY_PAN;
                break;
              case dr.DOLLY_ROTATE:
                if (this.enableZoom === false && this.enableRotate === false) return;
                this._handleTouchStartDollyRotate(e), this.state = fe.TOUCH_DOLLY_ROTATE;
                break;
              default:
                this.state = fe.NONE;
            }
            break;
          default:
            this.state = fe.NONE;
        }
        this.state !== fe.NONE && this.dispatchEvent(fm);
      }
      function qC(e) {
        switch (this._trackPointer(e), this.state) {
          case fe.TOUCH_ROTATE:
            if (this.enableRotate === false) return;
            this._handleTouchMoveRotate(e), this.update();
            break;
          case fe.TOUCH_PAN:
            if (this.enablePan === false) return;
            this._handleTouchMovePan(e), this.update();
            break;
          case fe.TOUCH_DOLLY_PAN:
            if (this.enableZoom === false && this.enablePan === false) return;
            this._handleTouchMoveDollyPan(e), this.update();
            break;
          case fe.TOUCH_DOLLY_ROTATE:
            if (this.enableZoom === false && this.enableRotate === false) return;
            this._handleTouchMoveDollyRotate(e), this.update();
            break;
          default:
            this.state = fe.NONE;
        }
      }
      function jC(e) {
        this.enabled !== false && e.preventDefault();
      }
      function ZC(e) {
        e.key === "Control" && (this._controlActive = true, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      function KC(e) {
        e.key === "Control" && (this._controlActive = false, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      class Wu extends Qn {
        constructor() {
          const t = Wu.SkyShader, n = new na({
            name: t.name,
            uniforms: AS.clone(t.uniforms),
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader,
            side: dn,
            depthWrite: false
          });
          super(new eo(1, 1, 1), n), this.isSky = true;
        }
      }
      Wu.SkyShader = {
        name: "SkyShader",
        uniforms: {
          turbidity: {
            value: 2
          },
          rayleigh: {
            value: 1
          },
          mieCoefficient: {
            value: 5e-3
          },
          mieDirectionalG: {
            value: 0.8
          },
          sunPosition: {
            value: new z()
          },
          up: {
            value: new z(0, 1, 0)
          }
        },
        vertexShader: `
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calculation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorption + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,
        fragmentShader: `
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
      };
      function QC(e) {
        return new Worker("/StephensSausageRollSolver/assets/physicsWorker-kFA5dkdg.js", {
          name: e == null ? void 0 : e.name
        });
      }
      const er = {
        defaultColor: new It().setHex(12103586),
        selectedColor: new It().setHex(16773494),
        burntColor: new It().setHex(11012609),
        lostColor: new It().setHex(81576),
        originColor: new It().setHex(6467412),
        solvedColor: new It().setHex(1746945)
      }, i0 = (e) => e.is_initial ? er.originColor : e.status === "Lost" ? er.lostColor : e.status === "Solution" ? er.solvedColor : e.status === "Burnt" ? er.burntColor : er.defaultColor, JC = ({ solution: e }) => {
        const t = Ot.useRef(null), [n, i] = Ot.useState(() => new Ut()), [a, s] = Ot.useState(() => new zC()), [r, o] = Ot.useState(null);
        Ot.useEffect(() => (a.setSize(800, 600), () => {
          a.domElement.remove(), a.dispose();
        }), [
          a
        ]), Ot.useEffect(() => {
          a.domElement.onmousemove = (x) => {
            n.x = x.offsetX / a.domElement.width * 2 - 1, n.y = -(x.offsetY / a.domElement.height) * 2 + 1;
          };
        }, [
          a,
          n
        ]);
        const [l, c] = Ot.useState(() => new z1());
        Ot.useEffect(() => {
          const x = new Z1(16777215, 1);
          x.position.set(1, 1, 1), l.add(x);
          const C = new K1(16777215, 1);
          l.add(C);
          const V = new Wu();
          V.scale.setScalar(45e3);
          const I = new z(1, 1, 1);
          V.material.uniforms.sunPosition.value = I, l.add(V);
        }, [
          l
        ]);
        const [f, d] = Ot.useState(() => new Wn(75, 4 / 3, 0.1, 1e3));
        Ot.useEffect(() => {
          f.position.set(10, 10, 20).multiplyScalar(10);
        }, [
          f
        ]);
        const [h, p] = Ot.useState(new J1()), y = Ot.useMemo(() => {
          let x = new FC(f, a.domElement);
          return x.maxPolarAngle = Math.PI * 0.8, x.enableDamping = true, x.screenSpacePanning = false, x.update(), x;
        }, [
          a
        ]);
        Ot.useEffect(() => {
        }, [
          y
        ]);
        const [S, m] = Ot.useState(false), [u, _] = Ot.useState(0), [g, v] = Ot.useState(() => new QC());
        Ot.useEffect(() => {
          g.postMessage({
            graph: e,
            pause: false
          });
        }, [
          e
        ]), Ot.useEffect(() => {
        }, [
          g
        ]);
        const [T, R] = Ot.useState(null), [w, D] = Ot.useMemo(() => {
          let x = /* @__PURE__ */ new Map(), C = /* @__PURE__ */ new Map();
          return e.states.forEach((V, I) => {
            x.set(V.id, I), C.set(I, V.id);
          }), [
            x,
            C
          ];
        }, [
          e
        ]), b = Ot.useMemo(() => {
          const x = new cm(), C = new X1({
            color: new It().setHex(16777215)
          }), V = new I1(x, C, e.states.length);
          return V.userData.levelStates = [], e.states.forEach((I, X) => {
            V.userData.levelStates.push(I), V.setColorAt(X, i0(I));
          }), V.instanceColor !== null && (V.instanceColor.needsUpdate = true), V;
        }, [
          e
        ]);
        return Ot.useEffect(() => {
          let x = [], C = new ie(), V = new ie();
          for (const X of e.edges) {
            const Q = w.get(X.source), L = w.get(X.target);
            L === void 0 || Q === void 0 || (b.getMatrixAt(Q, C), b.getMatrixAt(L, V), x.push(new z().setFromMatrixPosition(C)), x.push(new z().setFromMatrixPosition(V)));
          }
          let I = new k1(new Ti().setFromPoints(x), new CS({
            color: 0
          }));
          return l.add(I), () => {
            l.remove(I);
          };
        }, [
          e,
          b,
          l,
          u
        ]), Ot.useEffect(() => (l.add(b), () => {
          l.remove(b);
        }), [
          b,
          l
        ]), Ot.useEffect(() => {
          const x = () => {
            y.update(), a.render(l, f);
          };
          a.setAnimationLoop(x);
        }, [
          a,
          l,
          f,
          y
        ]), Ot.useEffect(() => {
          var _a2;
          return (_a2 = t.current) == null ? void 0 : _a2.appendChild(a.domElement), () => {
            var _a3;
            (_a3 = t.current) == null ? void 0 : _a3.removeChild(a.domElement);
          };
        }, [
          t,
          a
        ]), Ot.useEffect(() => {
          g.onmessage = (x) => {
            x.data.forEach(({ id: V, position: I }) => {
              let X = w.get(V);
              X !== void 0 && b.setMatrixAt(X, new ie().makeTranslation(I.x, I.y, I.z));
            }), b.instanceMatrix.needsUpdate = true, _((V) => V + 1);
          };
        }, [
          e,
          b
        ]), Ot.useEffect(() => {
          if (T !== null) {
            let x = new ie();
            b.getMatrixAt(T, x), y.target = new z().setFromMatrixPosition(x), y.cursor = new z(), b.setColorAt(T, er.selectedColor), b.instanceColor !== null && (b.instanceColor.needsUpdate = true), o(b.userData.levelStates[T] ?? null);
          }
          return () => {
            T !== null && (b.setColorAt(T, i0(b.userData.levelStates[T])), b.instanceColor !== null && (b.instanceColor.needsUpdate = true));
          };
        }, [
          T,
          b
        ]), Ot.useEffect(() => {
          a.domElement.onmousedown = (x) => {
            var _a2;
            if (x.button !== 2) return;
            h.setFromCamera(n, f), b.computeBoundingSphere();
            const C = (_a2 = h.intersectObject(b)[0]) == null ? void 0 : _a2.instanceId;
            C !== void 0 && R(C);
          };
        }, [
          a,
          h,
          b,
          f,
          n
        ]), vt.jsxs(vt.Fragment, {
          children: [
            vt.jsx("div", {
              ref: t
            }),
            vt.jsx("button", {
              type: "button",
              defaultValue: "",
              className: `${S ? "active" : null}`,
              onClick: () => {
                g.postMessage({
                  pause: !S
                }), m(!S);
              },
              children: "Pause Physics"
            }),
            T !== null ? vt.jsx("button", {
              onClick: () => {
                let x = D.get(T);
                x !== void 0 && g.postMessage({
                  togglePin: x
                });
              },
              children: "Pin"
            }) : vt.jsx("button", {
              disabled: true,
              children: "Pin"
            }),
            r !== null && vt.jsx(eS, {
              description: e.level_description,
              state: r,
              lenX: 10,
              lenY: 10,
              lenZ: 3
            })
          ]
        });
      };
      function $C() {
        const [e, t] = Ot.useState(null);
        return vt.jsxs(vt.Fragment, {
          children: [
            vt.jsx(rT, {
              setSolution: t
            }),
            e !== null ? vt.jsx(vt.Fragment, {
              children: vt.jsx(JC, {
                solution: e
              })
            }) : ""
          ]
        });
      }
      JE();
      GE.createRoot(document.getElementById("root")).render(vt.jsx(Ot.StrictMode, {
        children: vt.jsx($C, {})
      }));
    })();
  }
});
export default require_stdin();
